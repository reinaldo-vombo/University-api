
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Users
 * 
 */
export type Users = $Result.DefaultSelection<Prisma.$UsersPayload>
/**
 * Model AcademicSemester
 * 
 */
export type AcademicSemester = $Result.DefaultSelection<Prisma.$AcademicSemesterPayload>
/**
 * Model AcademicFaculty
 * 
 */
export type AcademicFaculty = $Result.DefaultSelection<Prisma.$AcademicFacultyPayload>
/**
 * Model AcademicDepartment
 * 
 */
export type AcademicDepartment = $Result.DefaultSelection<Prisma.$AcademicDepartmentPayload>
/**
 * Model Student
 * 
 */
export type Student = $Result.DefaultSelection<Prisma.$StudentPayload>
/**
 * Model Faculty
 * 
 */
export type Faculty = $Result.DefaultSelection<Prisma.$FacultyPayload>
/**
 * Model Building
 * 
 */
export type Building = $Result.DefaultSelection<Prisma.$BuildingPayload>
/**
 * Model Room
 * 
 */
export type Room = $Result.DefaultSelection<Prisma.$RoomPayload>
/**
 * Model Course
 * 
 */
export type Course = $Result.DefaultSelection<Prisma.$CoursePayload>
/**
 * Model CourseToPreRequisite
 * 
 */
export type CourseToPreRequisite = $Result.DefaultSelection<Prisma.$CourseToPreRequisitePayload>
/**
 * Model CourseFaculty
 * 
 */
export type CourseFaculty = $Result.DefaultSelection<Prisma.$CourseFacultyPayload>
/**
 * Model SemesterRegistration
 * 
 */
export type SemesterRegistration = $Result.DefaultSelection<Prisma.$SemesterRegistrationPayload>
/**
 * Model AdmitionExameRegistration
 * 
 */
export type AdmitionExameRegistration = $Result.DefaultSelection<Prisma.$AdmitionExameRegistrationPayload>
/**
 * Model AdmitionExamePrice
 * 
 */
export type AdmitionExamePrice = $Result.DefaultSelection<Prisma.$AdmitionExamePricePayload>
/**
 * Model AdmitionExamePeriod
 * 
 */
export type AdmitionExamePeriod = $Result.DefaultSelection<Prisma.$AdmitionExamePeriodPayload>
/**
 * Model ExameFase
 * 
 */
export type ExameFase = $Result.DefaultSelection<Prisma.$ExameFasePayload>
/**
 * Model OfferedCourse
 * 
 */
export type OfferedCourse = $Result.DefaultSelection<Prisma.$OfferedCoursePayload>
/**
 * Model OfferedCourseSection
 * 
 */
export type OfferedCourseSection = $Result.DefaultSelection<Prisma.$OfferedCourseSectionPayload>
/**
 * Model OfferedCourseClassSchedule
 * 
 */
export type OfferedCourseClassSchedule = $Result.DefaultSelection<Prisma.$OfferedCourseClassSchedulePayload>
/**
 * Model StudentSemesterRegistration
 * 
 */
export type StudentSemesterRegistration = $Result.DefaultSelection<Prisma.$StudentSemesterRegistrationPayload>
/**
 * Model StudentSemesterRegistrationCourse
 * 
 */
export type StudentSemesterRegistrationCourse = $Result.DefaultSelection<Prisma.$StudentSemesterRegistrationCoursePayload>
/**
 * Model StudentEnrolledCourse
 * 
 */
export type StudentEnrolledCourse = $Result.DefaultSelection<Prisma.$StudentEnrolledCoursePayload>
/**
 * Model StudentEnrolledCourseMark
 * 
 */
export type StudentEnrolledCourseMark = $Result.DefaultSelection<Prisma.$StudentEnrolledCourseMarkPayload>
/**
 * Model CourseDiscipline
 * 
 */
export type CourseDiscipline = $Result.DefaultSelection<Prisma.$CourseDisciplinePayload>
/**
 * Model StudentCarriedCourse
 * 
 */
export type StudentCarriedCourse = $Result.DefaultSelection<Prisma.$StudentCarriedCoursePayload>
/**
 * Model CoursePricing
 * 
 */
export type CoursePricing = $Result.DefaultSelection<Prisma.$CoursePricingPayload>
/**
 * Model Discipline
 * 
 */
export type Discipline = $Result.DefaultSelection<Prisma.$DisciplinePayload>
/**
 * Model StudentSemesterPayment
 * 
 */
export type StudentSemesterPayment = $Result.DefaultSelection<Prisma.$StudentSemesterPaymentPayload>
/**
 * Model StudentAcademicInfo
 * 
 */
export type StudentAcademicInfo = $Result.DefaultSelection<Prisma.$StudentAcademicInfoPayload>
/**
 * Model Events
 * 
 */
export type Events = $Result.DefaultSelection<Prisma.$EventsPayload>
/**
 * Model Payment
 * 
 */
export type Payment = $Result.DefaultSelection<Prisma.$PaymentPayload>
/**
 * Model PaymentReference
 * 
 */
export type PaymentReference = $Result.DefaultSelection<Prisma.$PaymentReferencePayload>

/**
 * Enums
 */
export namespace $Enums {
  export const SemesterRegistrationStatus: {
  UPCOMING: 'UPCOMING',
  ONGOING: 'ONGOING',
  ENDED: 'ENDED'
};

export type SemesterRegistrationStatus = (typeof SemesterRegistrationStatus)[keyof typeof SemesterRegistrationStatus]


export const Shift: {
  MORNING: 'MORNING',
  AFTERNOON: 'AFTERNOON',
  EVENING: 'EVENING'
};

export type Shift = (typeof Shift)[keyof typeof Shift]


export const StudentType: {
  NORMAL: 'NORMAL',
  CADEIRANTE: 'CADEIRANTE',
  BOLSEIRO: 'BOLSEIRO'
};

export type StudentType = (typeof StudentType)[keyof typeof StudentType]


export const Status: {
  APROVE: 'APROVE',
  PENDING: 'PENDING',
  DENIDE: 'DENIDE'
};

export type Status = (typeof Status)[keyof typeof Status]


export const WeekDays: {
  SATURDAY: 'SATURDAY',
  SUNDAY: 'SUNDAY',
  MONDAY: 'MONDAY',
  TUESDAY: 'TUESDAY',
  WEDNESDAY: 'WEDNESDAY',
  THURSDAY: 'THURSDAY',
  FRIDAY: 'FRIDAY'
};

export type WeekDays = (typeof WeekDays)[keyof typeof WeekDays]


export const CarriedCourseStatus: {
  ACTIVE: 'ACTIVE',
  COMPLETED: 'COMPLETED',
  DROPPED: 'DROPPED'
};

export type CarriedCourseStatus = (typeof CarriedCourseStatus)[keyof typeof CarriedCourseStatus]


export const StudentEnrolledCourseStatus: {
  ONGOING: 'ONGOING',
  COMPLETED: 'COMPLETED',
  WITHDRAWN: 'WITHDRAWN'
};

export type StudentEnrolledCourseStatus = (typeof StudentEnrolledCourseStatus)[keyof typeof StudentEnrolledCourseStatus]


export const ExamType: {
  MIDTERM: 'MIDTERM',
  FINAL: 'FINAL'
};

export type ExamType = (typeof ExamType)[keyof typeof ExamType]


export const PAYMENTSTATUS: {
  PENDING: 'PENDING',
  NOT_PAID: 'NOT_PAID',
  PAID: 'PAID'
};

export type PAYMENTSTATUS = (typeof PAYMENTSTATUS)[keyof typeof PAYMENTSTATUS]


export const YearLevel: {
  FIRST: 'FIRST',
  SECOND: 'SECOND',
  THIRD: 'THIRD',
  FOURTH: 'FOURTH',
  FIFTH: 'FIFTH'
};

export type YearLevel = (typeof YearLevel)[keyof typeof YearLevel]


export const UserRole: {
  super_admin: 'super_admin',
  admin: 'admin',
  student: 'student',
  editor: 'editor',
  faculty: 'faculty',
  accountant: 'accountant',
  department_head: 'department_head',
  staff: 'staff'
};

export type UserRole = (typeof UserRole)[keyof typeof UserRole]


export const PAYMENTTYPE: {
  RECEIPT: 'RECEIPT',
  REFERENCE: 'REFERENCE'
};

export type PAYMENTTYPE = (typeof PAYMENTTYPE)[keyof typeof PAYMENTTYPE]


export const PAYMENTMETHOD: {
  INVOICE: 'INVOICE',
  EXPRESS: 'EXPRESS'
};

export type PAYMENTMETHOD = (typeof PAYMENTMETHOD)[keyof typeof PAYMENTMETHOD]

}

export type SemesterRegistrationStatus = $Enums.SemesterRegistrationStatus

export const SemesterRegistrationStatus: typeof $Enums.SemesterRegistrationStatus

export type Shift = $Enums.Shift

export const Shift: typeof $Enums.Shift

export type StudentType = $Enums.StudentType

export const StudentType: typeof $Enums.StudentType

export type Status = $Enums.Status

export const Status: typeof $Enums.Status

export type WeekDays = $Enums.WeekDays

export const WeekDays: typeof $Enums.WeekDays

export type CarriedCourseStatus = $Enums.CarriedCourseStatus

export const CarriedCourseStatus: typeof $Enums.CarriedCourseStatus

export type StudentEnrolledCourseStatus = $Enums.StudentEnrolledCourseStatus

export const StudentEnrolledCourseStatus: typeof $Enums.StudentEnrolledCourseStatus

export type ExamType = $Enums.ExamType

export const ExamType: typeof $Enums.ExamType

export type PAYMENTSTATUS = $Enums.PAYMENTSTATUS

export const PAYMENTSTATUS: typeof $Enums.PAYMENTSTATUS

export type YearLevel = $Enums.YearLevel

export const YearLevel: typeof $Enums.YearLevel

export type UserRole = $Enums.UserRole

export const UserRole: typeof $Enums.UserRole

export type PAYMENTTYPE = $Enums.PAYMENTTYPE

export const PAYMENTTYPE: typeof $Enums.PAYMENTTYPE

export type PAYMENTMETHOD = $Enums.PAYMENTMETHOD

export const PAYMENTMETHOD: typeof $Enums.PAYMENTMETHOD

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.users.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.users.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.users`: Exposes CRUD operations for the **Users** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.users.findMany()
    * ```
    */
  get users(): Prisma.UsersDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.academicSemester`: Exposes CRUD operations for the **AcademicSemester** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AcademicSemesters
    * const academicSemesters = await prisma.academicSemester.findMany()
    * ```
    */
  get academicSemester(): Prisma.AcademicSemesterDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.academicFaculty`: Exposes CRUD operations for the **AcademicFaculty** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AcademicFaculties
    * const academicFaculties = await prisma.academicFaculty.findMany()
    * ```
    */
  get academicFaculty(): Prisma.AcademicFacultyDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.academicDepartment`: Exposes CRUD operations for the **AcademicDepartment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AcademicDepartments
    * const academicDepartments = await prisma.academicDepartment.findMany()
    * ```
    */
  get academicDepartment(): Prisma.AcademicDepartmentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.student`: Exposes CRUD operations for the **Student** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Students
    * const students = await prisma.student.findMany()
    * ```
    */
  get student(): Prisma.StudentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.faculty`: Exposes CRUD operations for the **Faculty** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Faculties
    * const faculties = await prisma.faculty.findMany()
    * ```
    */
  get faculty(): Prisma.FacultyDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.building`: Exposes CRUD operations for the **Building** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Buildings
    * const buildings = await prisma.building.findMany()
    * ```
    */
  get building(): Prisma.BuildingDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.room`: Exposes CRUD operations for the **Room** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Rooms
    * const rooms = await prisma.room.findMany()
    * ```
    */
  get room(): Prisma.RoomDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.course`: Exposes CRUD operations for the **Course** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Courses
    * const courses = await prisma.course.findMany()
    * ```
    */
  get course(): Prisma.CourseDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.courseToPreRequisite`: Exposes CRUD operations for the **CourseToPreRequisite** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CourseToPreRequisites
    * const courseToPreRequisites = await prisma.courseToPreRequisite.findMany()
    * ```
    */
  get courseToPreRequisite(): Prisma.CourseToPreRequisiteDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.courseFaculty`: Exposes CRUD operations for the **CourseFaculty** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CourseFaculties
    * const courseFaculties = await prisma.courseFaculty.findMany()
    * ```
    */
  get courseFaculty(): Prisma.CourseFacultyDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.semesterRegistration`: Exposes CRUD operations for the **SemesterRegistration** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SemesterRegistrations
    * const semesterRegistrations = await prisma.semesterRegistration.findMany()
    * ```
    */
  get semesterRegistration(): Prisma.SemesterRegistrationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.admitionExameRegistration`: Exposes CRUD operations for the **AdmitionExameRegistration** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AdmitionExameRegistrations
    * const admitionExameRegistrations = await prisma.admitionExameRegistration.findMany()
    * ```
    */
  get admitionExameRegistration(): Prisma.AdmitionExameRegistrationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.admitionExamePrice`: Exposes CRUD operations for the **AdmitionExamePrice** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AdmitionExamePrices
    * const admitionExamePrices = await prisma.admitionExamePrice.findMany()
    * ```
    */
  get admitionExamePrice(): Prisma.AdmitionExamePriceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.admitionExamePeriod`: Exposes CRUD operations for the **AdmitionExamePeriod** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AdmitionExamePeriods
    * const admitionExamePeriods = await prisma.admitionExamePeriod.findMany()
    * ```
    */
  get admitionExamePeriod(): Prisma.AdmitionExamePeriodDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.exameFase`: Exposes CRUD operations for the **ExameFase** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ExameFases
    * const exameFases = await prisma.exameFase.findMany()
    * ```
    */
  get exameFase(): Prisma.ExameFaseDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.offeredCourse`: Exposes CRUD operations for the **OfferedCourse** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OfferedCourses
    * const offeredCourses = await prisma.offeredCourse.findMany()
    * ```
    */
  get offeredCourse(): Prisma.OfferedCourseDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.offeredCourseSection`: Exposes CRUD operations for the **OfferedCourseSection** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OfferedCourseSections
    * const offeredCourseSections = await prisma.offeredCourseSection.findMany()
    * ```
    */
  get offeredCourseSection(): Prisma.OfferedCourseSectionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.offeredCourseClassSchedule`: Exposes CRUD operations for the **OfferedCourseClassSchedule** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OfferedCourseClassSchedules
    * const offeredCourseClassSchedules = await prisma.offeredCourseClassSchedule.findMany()
    * ```
    */
  get offeredCourseClassSchedule(): Prisma.OfferedCourseClassScheduleDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.studentSemesterRegistration`: Exposes CRUD operations for the **StudentSemesterRegistration** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StudentSemesterRegistrations
    * const studentSemesterRegistrations = await prisma.studentSemesterRegistration.findMany()
    * ```
    */
  get studentSemesterRegistration(): Prisma.StudentSemesterRegistrationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.studentSemesterRegistrationCourse`: Exposes CRUD operations for the **StudentSemesterRegistrationCourse** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StudentSemesterRegistrationCourses
    * const studentSemesterRegistrationCourses = await prisma.studentSemesterRegistrationCourse.findMany()
    * ```
    */
  get studentSemesterRegistrationCourse(): Prisma.StudentSemesterRegistrationCourseDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.studentEnrolledCourse`: Exposes CRUD operations for the **StudentEnrolledCourse** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StudentEnrolledCourses
    * const studentEnrolledCourses = await prisma.studentEnrolledCourse.findMany()
    * ```
    */
  get studentEnrolledCourse(): Prisma.StudentEnrolledCourseDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.studentEnrolledCourseMark`: Exposes CRUD operations for the **StudentEnrolledCourseMark** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StudentEnrolledCourseMarks
    * const studentEnrolledCourseMarks = await prisma.studentEnrolledCourseMark.findMany()
    * ```
    */
  get studentEnrolledCourseMark(): Prisma.StudentEnrolledCourseMarkDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.courseDiscipline`: Exposes CRUD operations for the **CourseDiscipline** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CourseDisciplines
    * const courseDisciplines = await prisma.courseDiscipline.findMany()
    * ```
    */
  get courseDiscipline(): Prisma.CourseDisciplineDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.studentCarriedCourse`: Exposes CRUD operations for the **StudentCarriedCourse** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StudentCarriedCourses
    * const studentCarriedCourses = await prisma.studentCarriedCourse.findMany()
    * ```
    */
  get studentCarriedCourse(): Prisma.StudentCarriedCourseDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.coursePricing`: Exposes CRUD operations for the **CoursePricing** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CoursePricings
    * const coursePricings = await prisma.coursePricing.findMany()
    * ```
    */
  get coursePricing(): Prisma.CoursePricingDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.discipline`: Exposes CRUD operations for the **Discipline** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Disciplines
    * const disciplines = await prisma.discipline.findMany()
    * ```
    */
  get discipline(): Prisma.DisciplineDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.studentSemesterPayment`: Exposes CRUD operations for the **StudentSemesterPayment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StudentSemesterPayments
    * const studentSemesterPayments = await prisma.studentSemesterPayment.findMany()
    * ```
    */
  get studentSemesterPayment(): Prisma.StudentSemesterPaymentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.studentAcademicInfo`: Exposes CRUD operations for the **StudentAcademicInfo** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StudentAcademicInfos
    * const studentAcademicInfos = await prisma.studentAcademicInfo.findMany()
    * ```
    */
  get studentAcademicInfo(): Prisma.StudentAcademicInfoDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.events`: Exposes CRUD operations for the **Events** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Events
    * const events = await prisma.events.findMany()
    * ```
    */
  get events(): Prisma.EventsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.payment`: Exposes CRUD operations for the **Payment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Payments
    * const payments = await prisma.payment.findMany()
    * ```
    */
  get payment(): Prisma.PaymentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.paymentReference`: Exposes CRUD operations for the **PaymentReference** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PaymentReferences
    * const paymentReferences = await prisma.paymentReference.findMany()
    * ```
    */
  get paymentReference(): Prisma.PaymentReferenceDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.6.0
   * Query Engine version: f676762280b54cd07c770017ed3711ddde35f37a
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Users: 'Users',
    AcademicSemester: 'AcademicSemester',
    AcademicFaculty: 'AcademicFaculty',
    AcademicDepartment: 'AcademicDepartment',
    Student: 'Student',
    Faculty: 'Faculty',
    Building: 'Building',
    Room: 'Room',
    Course: 'Course',
    CourseToPreRequisite: 'CourseToPreRequisite',
    CourseFaculty: 'CourseFaculty',
    SemesterRegistration: 'SemesterRegistration',
    AdmitionExameRegistration: 'AdmitionExameRegistration',
    AdmitionExamePrice: 'AdmitionExamePrice',
    AdmitionExamePeriod: 'AdmitionExamePeriod',
    ExameFase: 'ExameFase',
    OfferedCourse: 'OfferedCourse',
    OfferedCourseSection: 'OfferedCourseSection',
    OfferedCourseClassSchedule: 'OfferedCourseClassSchedule',
    StudentSemesterRegistration: 'StudentSemesterRegistration',
    StudentSemesterRegistrationCourse: 'StudentSemesterRegistrationCourse',
    StudentEnrolledCourse: 'StudentEnrolledCourse',
    StudentEnrolledCourseMark: 'StudentEnrolledCourseMark',
    CourseDiscipline: 'CourseDiscipline',
    StudentCarriedCourse: 'StudentCarriedCourse',
    CoursePricing: 'CoursePricing',
    Discipline: 'Discipline',
    StudentSemesterPayment: 'StudentSemesterPayment',
    StudentAcademicInfo: 'StudentAcademicInfo',
    Events: 'Events',
    Payment: 'Payment',
    PaymentReference: 'PaymentReference'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "users" | "academicSemester" | "academicFaculty" | "academicDepartment" | "student" | "faculty" | "building" | "room" | "course" | "courseToPreRequisite" | "courseFaculty" | "semesterRegistration" | "admitionExameRegistration" | "admitionExamePrice" | "admitionExamePeriod" | "exameFase" | "offeredCourse" | "offeredCourseSection" | "offeredCourseClassSchedule" | "studentSemesterRegistration" | "studentSemesterRegistrationCourse" | "studentEnrolledCourse" | "studentEnrolledCourseMark" | "courseDiscipline" | "studentCarriedCourse" | "coursePricing" | "discipline" | "studentSemesterPayment" | "studentAcademicInfo" | "events" | "payment" | "paymentReference"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Users: {
        payload: Prisma.$UsersPayload<ExtArgs>
        fields: Prisma.UsersFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UsersFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsersPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UsersFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsersPayload>
          }
          findFirst: {
            args: Prisma.UsersFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsersPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UsersFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsersPayload>
          }
          findMany: {
            args: Prisma.UsersFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsersPayload>[]
          }
          create: {
            args: Prisma.UsersCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsersPayload>
          }
          createMany: {
            args: Prisma.UsersCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.UsersDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsersPayload>
          }
          update: {
            args: Prisma.UsersUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsersPayload>
          }
          deleteMany: {
            args: Prisma.UsersDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UsersUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UsersUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsersPayload>
          }
          aggregate: {
            args: Prisma.UsersAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUsers>
          }
          groupBy: {
            args: Prisma.UsersGroupByArgs<ExtArgs>
            result: $Utils.Optional<UsersGroupByOutputType>[]
          }
          count: {
            args: Prisma.UsersCountArgs<ExtArgs>
            result: $Utils.Optional<UsersCountAggregateOutputType> | number
          }
        }
      }
      AcademicSemester: {
        payload: Prisma.$AcademicSemesterPayload<ExtArgs>
        fields: Prisma.AcademicSemesterFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AcademicSemesterFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AcademicSemesterPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AcademicSemesterFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AcademicSemesterPayload>
          }
          findFirst: {
            args: Prisma.AcademicSemesterFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AcademicSemesterPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AcademicSemesterFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AcademicSemesterPayload>
          }
          findMany: {
            args: Prisma.AcademicSemesterFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AcademicSemesterPayload>[]
          }
          create: {
            args: Prisma.AcademicSemesterCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AcademicSemesterPayload>
          }
          createMany: {
            args: Prisma.AcademicSemesterCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.AcademicSemesterDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AcademicSemesterPayload>
          }
          update: {
            args: Prisma.AcademicSemesterUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AcademicSemesterPayload>
          }
          deleteMany: {
            args: Prisma.AcademicSemesterDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AcademicSemesterUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AcademicSemesterUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AcademicSemesterPayload>
          }
          aggregate: {
            args: Prisma.AcademicSemesterAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAcademicSemester>
          }
          groupBy: {
            args: Prisma.AcademicSemesterGroupByArgs<ExtArgs>
            result: $Utils.Optional<AcademicSemesterGroupByOutputType>[]
          }
          count: {
            args: Prisma.AcademicSemesterCountArgs<ExtArgs>
            result: $Utils.Optional<AcademicSemesterCountAggregateOutputType> | number
          }
        }
      }
      AcademicFaculty: {
        payload: Prisma.$AcademicFacultyPayload<ExtArgs>
        fields: Prisma.AcademicFacultyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AcademicFacultyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AcademicFacultyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AcademicFacultyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AcademicFacultyPayload>
          }
          findFirst: {
            args: Prisma.AcademicFacultyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AcademicFacultyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AcademicFacultyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AcademicFacultyPayload>
          }
          findMany: {
            args: Prisma.AcademicFacultyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AcademicFacultyPayload>[]
          }
          create: {
            args: Prisma.AcademicFacultyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AcademicFacultyPayload>
          }
          createMany: {
            args: Prisma.AcademicFacultyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.AcademicFacultyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AcademicFacultyPayload>
          }
          update: {
            args: Prisma.AcademicFacultyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AcademicFacultyPayload>
          }
          deleteMany: {
            args: Prisma.AcademicFacultyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AcademicFacultyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AcademicFacultyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AcademicFacultyPayload>
          }
          aggregate: {
            args: Prisma.AcademicFacultyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAcademicFaculty>
          }
          groupBy: {
            args: Prisma.AcademicFacultyGroupByArgs<ExtArgs>
            result: $Utils.Optional<AcademicFacultyGroupByOutputType>[]
          }
          count: {
            args: Prisma.AcademicFacultyCountArgs<ExtArgs>
            result: $Utils.Optional<AcademicFacultyCountAggregateOutputType> | number
          }
        }
      }
      AcademicDepartment: {
        payload: Prisma.$AcademicDepartmentPayload<ExtArgs>
        fields: Prisma.AcademicDepartmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AcademicDepartmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AcademicDepartmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AcademicDepartmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AcademicDepartmentPayload>
          }
          findFirst: {
            args: Prisma.AcademicDepartmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AcademicDepartmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AcademicDepartmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AcademicDepartmentPayload>
          }
          findMany: {
            args: Prisma.AcademicDepartmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AcademicDepartmentPayload>[]
          }
          create: {
            args: Prisma.AcademicDepartmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AcademicDepartmentPayload>
          }
          createMany: {
            args: Prisma.AcademicDepartmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.AcademicDepartmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AcademicDepartmentPayload>
          }
          update: {
            args: Prisma.AcademicDepartmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AcademicDepartmentPayload>
          }
          deleteMany: {
            args: Prisma.AcademicDepartmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AcademicDepartmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AcademicDepartmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AcademicDepartmentPayload>
          }
          aggregate: {
            args: Prisma.AcademicDepartmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAcademicDepartment>
          }
          groupBy: {
            args: Prisma.AcademicDepartmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<AcademicDepartmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.AcademicDepartmentCountArgs<ExtArgs>
            result: $Utils.Optional<AcademicDepartmentCountAggregateOutputType> | number
          }
        }
      }
      Student: {
        payload: Prisma.$StudentPayload<ExtArgs>
        fields: Prisma.StudentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StudentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StudentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPayload>
          }
          findFirst: {
            args: Prisma.StudentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StudentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPayload>
          }
          findMany: {
            args: Prisma.StudentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPayload>[]
          }
          create: {
            args: Prisma.StudentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPayload>
          }
          createMany: {
            args: Prisma.StudentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.StudentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPayload>
          }
          update: {
            args: Prisma.StudentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPayload>
          }
          deleteMany: {
            args: Prisma.StudentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StudentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.StudentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPayload>
          }
          aggregate: {
            args: Prisma.StudentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStudent>
          }
          groupBy: {
            args: Prisma.StudentGroupByArgs<ExtArgs>
            result: $Utils.Optional<StudentGroupByOutputType>[]
          }
          count: {
            args: Prisma.StudentCountArgs<ExtArgs>
            result: $Utils.Optional<StudentCountAggregateOutputType> | number
          }
        }
      }
      Faculty: {
        payload: Prisma.$FacultyPayload<ExtArgs>
        fields: Prisma.FacultyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FacultyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FacultyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FacultyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FacultyPayload>
          }
          findFirst: {
            args: Prisma.FacultyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FacultyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FacultyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FacultyPayload>
          }
          findMany: {
            args: Prisma.FacultyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FacultyPayload>[]
          }
          create: {
            args: Prisma.FacultyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FacultyPayload>
          }
          createMany: {
            args: Prisma.FacultyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.FacultyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FacultyPayload>
          }
          update: {
            args: Prisma.FacultyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FacultyPayload>
          }
          deleteMany: {
            args: Prisma.FacultyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FacultyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.FacultyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FacultyPayload>
          }
          aggregate: {
            args: Prisma.FacultyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFaculty>
          }
          groupBy: {
            args: Prisma.FacultyGroupByArgs<ExtArgs>
            result: $Utils.Optional<FacultyGroupByOutputType>[]
          }
          count: {
            args: Prisma.FacultyCountArgs<ExtArgs>
            result: $Utils.Optional<FacultyCountAggregateOutputType> | number
          }
        }
      }
      Building: {
        payload: Prisma.$BuildingPayload<ExtArgs>
        fields: Prisma.BuildingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BuildingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BuildingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BuildingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BuildingPayload>
          }
          findFirst: {
            args: Prisma.BuildingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BuildingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BuildingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BuildingPayload>
          }
          findMany: {
            args: Prisma.BuildingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BuildingPayload>[]
          }
          create: {
            args: Prisma.BuildingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BuildingPayload>
          }
          createMany: {
            args: Prisma.BuildingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.BuildingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BuildingPayload>
          }
          update: {
            args: Prisma.BuildingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BuildingPayload>
          }
          deleteMany: {
            args: Prisma.BuildingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BuildingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BuildingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BuildingPayload>
          }
          aggregate: {
            args: Prisma.BuildingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBuilding>
          }
          groupBy: {
            args: Prisma.BuildingGroupByArgs<ExtArgs>
            result: $Utils.Optional<BuildingGroupByOutputType>[]
          }
          count: {
            args: Prisma.BuildingCountArgs<ExtArgs>
            result: $Utils.Optional<BuildingCountAggregateOutputType> | number
          }
        }
      }
      Room: {
        payload: Prisma.$RoomPayload<ExtArgs>
        fields: Prisma.RoomFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RoomFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RoomFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomPayload>
          }
          findFirst: {
            args: Prisma.RoomFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RoomFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomPayload>
          }
          findMany: {
            args: Prisma.RoomFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomPayload>[]
          }
          create: {
            args: Prisma.RoomCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomPayload>
          }
          createMany: {
            args: Prisma.RoomCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.RoomDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomPayload>
          }
          update: {
            args: Prisma.RoomUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomPayload>
          }
          deleteMany: {
            args: Prisma.RoomDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RoomUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RoomUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomPayload>
          }
          aggregate: {
            args: Prisma.RoomAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRoom>
          }
          groupBy: {
            args: Prisma.RoomGroupByArgs<ExtArgs>
            result: $Utils.Optional<RoomGroupByOutputType>[]
          }
          count: {
            args: Prisma.RoomCountArgs<ExtArgs>
            result: $Utils.Optional<RoomCountAggregateOutputType> | number
          }
        }
      }
      Course: {
        payload: Prisma.$CoursePayload<ExtArgs>
        fields: Prisma.CourseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CourseFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CourseFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload>
          }
          findFirst: {
            args: Prisma.CourseFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CourseFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload>
          }
          findMany: {
            args: Prisma.CourseFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload>[]
          }
          create: {
            args: Prisma.CourseCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload>
          }
          createMany: {
            args: Prisma.CourseCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.CourseDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload>
          }
          update: {
            args: Prisma.CourseUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload>
          }
          deleteMany: {
            args: Prisma.CourseDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CourseUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CourseUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload>
          }
          aggregate: {
            args: Prisma.CourseAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCourse>
          }
          groupBy: {
            args: Prisma.CourseGroupByArgs<ExtArgs>
            result: $Utils.Optional<CourseGroupByOutputType>[]
          }
          count: {
            args: Prisma.CourseCountArgs<ExtArgs>
            result: $Utils.Optional<CourseCountAggregateOutputType> | number
          }
        }
      }
      CourseToPreRequisite: {
        payload: Prisma.$CourseToPreRequisitePayload<ExtArgs>
        fields: Prisma.CourseToPreRequisiteFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CourseToPreRequisiteFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseToPreRequisitePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CourseToPreRequisiteFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseToPreRequisitePayload>
          }
          findFirst: {
            args: Prisma.CourseToPreRequisiteFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseToPreRequisitePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CourseToPreRequisiteFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseToPreRequisitePayload>
          }
          findMany: {
            args: Prisma.CourseToPreRequisiteFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseToPreRequisitePayload>[]
          }
          create: {
            args: Prisma.CourseToPreRequisiteCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseToPreRequisitePayload>
          }
          createMany: {
            args: Prisma.CourseToPreRequisiteCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.CourseToPreRequisiteDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseToPreRequisitePayload>
          }
          update: {
            args: Prisma.CourseToPreRequisiteUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseToPreRequisitePayload>
          }
          deleteMany: {
            args: Prisma.CourseToPreRequisiteDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CourseToPreRequisiteUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CourseToPreRequisiteUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseToPreRequisitePayload>
          }
          aggregate: {
            args: Prisma.CourseToPreRequisiteAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCourseToPreRequisite>
          }
          groupBy: {
            args: Prisma.CourseToPreRequisiteGroupByArgs<ExtArgs>
            result: $Utils.Optional<CourseToPreRequisiteGroupByOutputType>[]
          }
          count: {
            args: Prisma.CourseToPreRequisiteCountArgs<ExtArgs>
            result: $Utils.Optional<CourseToPreRequisiteCountAggregateOutputType> | number
          }
        }
      }
      CourseFaculty: {
        payload: Prisma.$CourseFacultyPayload<ExtArgs>
        fields: Prisma.CourseFacultyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CourseFacultyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseFacultyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CourseFacultyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseFacultyPayload>
          }
          findFirst: {
            args: Prisma.CourseFacultyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseFacultyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CourseFacultyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseFacultyPayload>
          }
          findMany: {
            args: Prisma.CourseFacultyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseFacultyPayload>[]
          }
          create: {
            args: Prisma.CourseFacultyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseFacultyPayload>
          }
          createMany: {
            args: Prisma.CourseFacultyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.CourseFacultyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseFacultyPayload>
          }
          update: {
            args: Prisma.CourseFacultyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseFacultyPayload>
          }
          deleteMany: {
            args: Prisma.CourseFacultyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CourseFacultyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CourseFacultyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseFacultyPayload>
          }
          aggregate: {
            args: Prisma.CourseFacultyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCourseFaculty>
          }
          groupBy: {
            args: Prisma.CourseFacultyGroupByArgs<ExtArgs>
            result: $Utils.Optional<CourseFacultyGroupByOutputType>[]
          }
          count: {
            args: Prisma.CourseFacultyCountArgs<ExtArgs>
            result: $Utils.Optional<CourseFacultyCountAggregateOutputType> | number
          }
        }
      }
      SemesterRegistration: {
        payload: Prisma.$SemesterRegistrationPayload<ExtArgs>
        fields: Prisma.SemesterRegistrationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SemesterRegistrationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SemesterRegistrationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SemesterRegistrationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SemesterRegistrationPayload>
          }
          findFirst: {
            args: Prisma.SemesterRegistrationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SemesterRegistrationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SemesterRegistrationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SemesterRegistrationPayload>
          }
          findMany: {
            args: Prisma.SemesterRegistrationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SemesterRegistrationPayload>[]
          }
          create: {
            args: Prisma.SemesterRegistrationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SemesterRegistrationPayload>
          }
          createMany: {
            args: Prisma.SemesterRegistrationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.SemesterRegistrationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SemesterRegistrationPayload>
          }
          update: {
            args: Prisma.SemesterRegistrationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SemesterRegistrationPayload>
          }
          deleteMany: {
            args: Prisma.SemesterRegistrationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SemesterRegistrationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SemesterRegistrationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SemesterRegistrationPayload>
          }
          aggregate: {
            args: Prisma.SemesterRegistrationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSemesterRegistration>
          }
          groupBy: {
            args: Prisma.SemesterRegistrationGroupByArgs<ExtArgs>
            result: $Utils.Optional<SemesterRegistrationGroupByOutputType>[]
          }
          count: {
            args: Prisma.SemesterRegistrationCountArgs<ExtArgs>
            result: $Utils.Optional<SemesterRegistrationCountAggregateOutputType> | number
          }
        }
      }
      AdmitionExameRegistration: {
        payload: Prisma.$AdmitionExameRegistrationPayload<ExtArgs>
        fields: Prisma.AdmitionExameRegistrationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AdmitionExameRegistrationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdmitionExameRegistrationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AdmitionExameRegistrationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdmitionExameRegistrationPayload>
          }
          findFirst: {
            args: Prisma.AdmitionExameRegistrationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdmitionExameRegistrationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AdmitionExameRegistrationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdmitionExameRegistrationPayload>
          }
          findMany: {
            args: Prisma.AdmitionExameRegistrationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdmitionExameRegistrationPayload>[]
          }
          create: {
            args: Prisma.AdmitionExameRegistrationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdmitionExameRegistrationPayload>
          }
          createMany: {
            args: Prisma.AdmitionExameRegistrationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.AdmitionExameRegistrationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdmitionExameRegistrationPayload>
          }
          update: {
            args: Prisma.AdmitionExameRegistrationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdmitionExameRegistrationPayload>
          }
          deleteMany: {
            args: Prisma.AdmitionExameRegistrationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AdmitionExameRegistrationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AdmitionExameRegistrationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdmitionExameRegistrationPayload>
          }
          aggregate: {
            args: Prisma.AdmitionExameRegistrationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAdmitionExameRegistration>
          }
          groupBy: {
            args: Prisma.AdmitionExameRegistrationGroupByArgs<ExtArgs>
            result: $Utils.Optional<AdmitionExameRegistrationGroupByOutputType>[]
          }
          count: {
            args: Prisma.AdmitionExameRegistrationCountArgs<ExtArgs>
            result: $Utils.Optional<AdmitionExameRegistrationCountAggregateOutputType> | number
          }
        }
      }
      AdmitionExamePrice: {
        payload: Prisma.$AdmitionExamePricePayload<ExtArgs>
        fields: Prisma.AdmitionExamePriceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AdmitionExamePriceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdmitionExamePricePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AdmitionExamePriceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdmitionExamePricePayload>
          }
          findFirst: {
            args: Prisma.AdmitionExamePriceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdmitionExamePricePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AdmitionExamePriceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdmitionExamePricePayload>
          }
          findMany: {
            args: Prisma.AdmitionExamePriceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdmitionExamePricePayload>[]
          }
          create: {
            args: Prisma.AdmitionExamePriceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdmitionExamePricePayload>
          }
          createMany: {
            args: Prisma.AdmitionExamePriceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.AdmitionExamePriceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdmitionExamePricePayload>
          }
          update: {
            args: Prisma.AdmitionExamePriceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdmitionExamePricePayload>
          }
          deleteMany: {
            args: Prisma.AdmitionExamePriceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AdmitionExamePriceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AdmitionExamePriceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdmitionExamePricePayload>
          }
          aggregate: {
            args: Prisma.AdmitionExamePriceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAdmitionExamePrice>
          }
          groupBy: {
            args: Prisma.AdmitionExamePriceGroupByArgs<ExtArgs>
            result: $Utils.Optional<AdmitionExamePriceGroupByOutputType>[]
          }
          count: {
            args: Prisma.AdmitionExamePriceCountArgs<ExtArgs>
            result: $Utils.Optional<AdmitionExamePriceCountAggregateOutputType> | number
          }
        }
      }
      AdmitionExamePeriod: {
        payload: Prisma.$AdmitionExamePeriodPayload<ExtArgs>
        fields: Prisma.AdmitionExamePeriodFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AdmitionExamePeriodFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdmitionExamePeriodPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AdmitionExamePeriodFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdmitionExamePeriodPayload>
          }
          findFirst: {
            args: Prisma.AdmitionExamePeriodFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdmitionExamePeriodPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AdmitionExamePeriodFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdmitionExamePeriodPayload>
          }
          findMany: {
            args: Prisma.AdmitionExamePeriodFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdmitionExamePeriodPayload>[]
          }
          create: {
            args: Prisma.AdmitionExamePeriodCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdmitionExamePeriodPayload>
          }
          createMany: {
            args: Prisma.AdmitionExamePeriodCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.AdmitionExamePeriodDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdmitionExamePeriodPayload>
          }
          update: {
            args: Prisma.AdmitionExamePeriodUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdmitionExamePeriodPayload>
          }
          deleteMany: {
            args: Prisma.AdmitionExamePeriodDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AdmitionExamePeriodUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AdmitionExamePeriodUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdmitionExamePeriodPayload>
          }
          aggregate: {
            args: Prisma.AdmitionExamePeriodAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAdmitionExamePeriod>
          }
          groupBy: {
            args: Prisma.AdmitionExamePeriodGroupByArgs<ExtArgs>
            result: $Utils.Optional<AdmitionExamePeriodGroupByOutputType>[]
          }
          count: {
            args: Prisma.AdmitionExamePeriodCountArgs<ExtArgs>
            result: $Utils.Optional<AdmitionExamePeriodCountAggregateOutputType> | number
          }
        }
      }
      ExameFase: {
        payload: Prisma.$ExameFasePayload<ExtArgs>
        fields: Prisma.ExameFaseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ExameFaseFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExameFasePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ExameFaseFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExameFasePayload>
          }
          findFirst: {
            args: Prisma.ExameFaseFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExameFasePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ExameFaseFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExameFasePayload>
          }
          findMany: {
            args: Prisma.ExameFaseFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExameFasePayload>[]
          }
          create: {
            args: Prisma.ExameFaseCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExameFasePayload>
          }
          createMany: {
            args: Prisma.ExameFaseCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ExameFaseDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExameFasePayload>
          }
          update: {
            args: Prisma.ExameFaseUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExameFasePayload>
          }
          deleteMany: {
            args: Prisma.ExameFaseDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ExameFaseUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ExameFaseUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExameFasePayload>
          }
          aggregate: {
            args: Prisma.ExameFaseAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateExameFase>
          }
          groupBy: {
            args: Prisma.ExameFaseGroupByArgs<ExtArgs>
            result: $Utils.Optional<ExameFaseGroupByOutputType>[]
          }
          count: {
            args: Prisma.ExameFaseCountArgs<ExtArgs>
            result: $Utils.Optional<ExameFaseCountAggregateOutputType> | number
          }
        }
      }
      OfferedCourse: {
        payload: Prisma.$OfferedCoursePayload<ExtArgs>
        fields: Prisma.OfferedCourseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OfferedCourseFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OfferedCoursePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OfferedCourseFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OfferedCoursePayload>
          }
          findFirst: {
            args: Prisma.OfferedCourseFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OfferedCoursePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OfferedCourseFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OfferedCoursePayload>
          }
          findMany: {
            args: Prisma.OfferedCourseFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OfferedCoursePayload>[]
          }
          create: {
            args: Prisma.OfferedCourseCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OfferedCoursePayload>
          }
          createMany: {
            args: Prisma.OfferedCourseCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.OfferedCourseDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OfferedCoursePayload>
          }
          update: {
            args: Prisma.OfferedCourseUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OfferedCoursePayload>
          }
          deleteMany: {
            args: Prisma.OfferedCourseDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OfferedCourseUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.OfferedCourseUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OfferedCoursePayload>
          }
          aggregate: {
            args: Prisma.OfferedCourseAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOfferedCourse>
          }
          groupBy: {
            args: Prisma.OfferedCourseGroupByArgs<ExtArgs>
            result: $Utils.Optional<OfferedCourseGroupByOutputType>[]
          }
          count: {
            args: Prisma.OfferedCourseCountArgs<ExtArgs>
            result: $Utils.Optional<OfferedCourseCountAggregateOutputType> | number
          }
        }
      }
      OfferedCourseSection: {
        payload: Prisma.$OfferedCourseSectionPayload<ExtArgs>
        fields: Prisma.OfferedCourseSectionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OfferedCourseSectionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OfferedCourseSectionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OfferedCourseSectionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OfferedCourseSectionPayload>
          }
          findFirst: {
            args: Prisma.OfferedCourseSectionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OfferedCourseSectionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OfferedCourseSectionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OfferedCourseSectionPayload>
          }
          findMany: {
            args: Prisma.OfferedCourseSectionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OfferedCourseSectionPayload>[]
          }
          create: {
            args: Prisma.OfferedCourseSectionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OfferedCourseSectionPayload>
          }
          createMany: {
            args: Prisma.OfferedCourseSectionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.OfferedCourseSectionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OfferedCourseSectionPayload>
          }
          update: {
            args: Prisma.OfferedCourseSectionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OfferedCourseSectionPayload>
          }
          deleteMany: {
            args: Prisma.OfferedCourseSectionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OfferedCourseSectionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.OfferedCourseSectionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OfferedCourseSectionPayload>
          }
          aggregate: {
            args: Prisma.OfferedCourseSectionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOfferedCourseSection>
          }
          groupBy: {
            args: Prisma.OfferedCourseSectionGroupByArgs<ExtArgs>
            result: $Utils.Optional<OfferedCourseSectionGroupByOutputType>[]
          }
          count: {
            args: Prisma.OfferedCourseSectionCountArgs<ExtArgs>
            result: $Utils.Optional<OfferedCourseSectionCountAggregateOutputType> | number
          }
        }
      }
      OfferedCourseClassSchedule: {
        payload: Prisma.$OfferedCourseClassSchedulePayload<ExtArgs>
        fields: Prisma.OfferedCourseClassScheduleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OfferedCourseClassScheduleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OfferedCourseClassSchedulePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OfferedCourseClassScheduleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OfferedCourseClassSchedulePayload>
          }
          findFirst: {
            args: Prisma.OfferedCourseClassScheduleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OfferedCourseClassSchedulePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OfferedCourseClassScheduleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OfferedCourseClassSchedulePayload>
          }
          findMany: {
            args: Prisma.OfferedCourseClassScheduleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OfferedCourseClassSchedulePayload>[]
          }
          create: {
            args: Prisma.OfferedCourseClassScheduleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OfferedCourseClassSchedulePayload>
          }
          createMany: {
            args: Prisma.OfferedCourseClassScheduleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.OfferedCourseClassScheduleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OfferedCourseClassSchedulePayload>
          }
          update: {
            args: Prisma.OfferedCourseClassScheduleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OfferedCourseClassSchedulePayload>
          }
          deleteMany: {
            args: Prisma.OfferedCourseClassScheduleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OfferedCourseClassScheduleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.OfferedCourseClassScheduleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OfferedCourseClassSchedulePayload>
          }
          aggregate: {
            args: Prisma.OfferedCourseClassScheduleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOfferedCourseClassSchedule>
          }
          groupBy: {
            args: Prisma.OfferedCourseClassScheduleGroupByArgs<ExtArgs>
            result: $Utils.Optional<OfferedCourseClassScheduleGroupByOutputType>[]
          }
          count: {
            args: Prisma.OfferedCourseClassScheduleCountArgs<ExtArgs>
            result: $Utils.Optional<OfferedCourseClassScheduleCountAggregateOutputType> | number
          }
        }
      }
      StudentSemesterRegistration: {
        payload: Prisma.$StudentSemesterRegistrationPayload<ExtArgs>
        fields: Prisma.StudentSemesterRegistrationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StudentSemesterRegistrationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentSemesterRegistrationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StudentSemesterRegistrationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentSemesterRegistrationPayload>
          }
          findFirst: {
            args: Prisma.StudentSemesterRegistrationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentSemesterRegistrationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StudentSemesterRegistrationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentSemesterRegistrationPayload>
          }
          findMany: {
            args: Prisma.StudentSemesterRegistrationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentSemesterRegistrationPayload>[]
          }
          create: {
            args: Prisma.StudentSemesterRegistrationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentSemesterRegistrationPayload>
          }
          createMany: {
            args: Prisma.StudentSemesterRegistrationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.StudentSemesterRegistrationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentSemesterRegistrationPayload>
          }
          update: {
            args: Prisma.StudentSemesterRegistrationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentSemesterRegistrationPayload>
          }
          deleteMany: {
            args: Prisma.StudentSemesterRegistrationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StudentSemesterRegistrationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.StudentSemesterRegistrationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentSemesterRegistrationPayload>
          }
          aggregate: {
            args: Prisma.StudentSemesterRegistrationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStudentSemesterRegistration>
          }
          groupBy: {
            args: Prisma.StudentSemesterRegistrationGroupByArgs<ExtArgs>
            result: $Utils.Optional<StudentSemesterRegistrationGroupByOutputType>[]
          }
          count: {
            args: Prisma.StudentSemesterRegistrationCountArgs<ExtArgs>
            result: $Utils.Optional<StudentSemesterRegistrationCountAggregateOutputType> | number
          }
        }
      }
      StudentSemesterRegistrationCourse: {
        payload: Prisma.$StudentSemesterRegistrationCoursePayload<ExtArgs>
        fields: Prisma.StudentSemesterRegistrationCourseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StudentSemesterRegistrationCourseFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentSemesterRegistrationCoursePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StudentSemesterRegistrationCourseFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentSemesterRegistrationCoursePayload>
          }
          findFirst: {
            args: Prisma.StudentSemesterRegistrationCourseFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentSemesterRegistrationCoursePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StudentSemesterRegistrationCourseFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentSemesterRegistrationCoursePayload>
          }
          findMany: {
            args: Prisma.StudentSemesterRegistrationCourseFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentSemesterRegistrationCoursePayload>[]
          }
          create: {
            args: Prisma.StudentSemesterRegistrationCourseCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentSemesterRegistrationCoursePayload>
          }
          createMany: {
            args: Prisma.StudentSemesterRegistrationCourseCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.StudentSemesterRegistrationCourseDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentSemesterRegistrationCoursePayload>
          }
          update: {
            args: Prisma.StudentSemesterRegistrationCourseUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentSemesterRegistrationCoursePayload>
          }
          deleteMany: {
            args: Prisma.StudentSemesterRegistrationCourseDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StudentSemesterRegistrationCourseUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.StudentSemesterRegistrationCourseUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentSemesterRegistrationCoursePayload>
          }
          aggregate: {
            args: Prisma.StudentSemesterRegistrationCourseAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStudentSemesterRegistrationCourse>
          }
          groupBy: {
            args: Prisma.StudentSemesterRegistrationCourseGroupByArgs<ExtArgs>
            result: $Utils.Optional<StudentSemesterRegistrationCourseGroupByOutputType>[]
          }
          count: {
            args: Prisma.StudentSemesterRegistrationCourseCountArgs<ExtArgs>
            result: $Utils.Optional<StudentSemesterRegistrationCourseCountAggregateOutputType> | number
          }
        }
      }
      StudentEnrolledCourse: {
        payload: Prisma.$StudentEnrolledCoursePayload<ExtArgs>
        fields: Prisma.StudentEnrolledCourseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StudentEnrolledCourseFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentEnrolledCoursePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StudentEnrolledCourseFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentEnrolledCoursePayload>
          }
          findFirst: {
            args: Prisma.StudentEnrolledCourseFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentEnrolledCoursePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StudentEnrolledCourseFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentEnrolledCoursePayload>
          }
          findMany: {
            args: Prisma.StudentEnrolledCourseFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentEnrolledCoursePayload>[]
          }
          create: {
            args: Prisma.StudentEnrolledCourseCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentEnrolledCoursePayload>
          }
          createMany: {
            args: Prisma.StudentEnrolledCourseCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.StudentEnrolledCourseDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentEnrolledCoursePayload>
          }
          update: {
            args: Prisma.StudentEnrolledCourseUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentEnrolledCoursePayload>
          }
          deleteMany: {
            args: Prisma.StudentEnrolledCourseDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StudentEnrolledCourseUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.StudentEnrolledCourseUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentEnrolledCoursePayload>
          }
          aggregate: {
            args: Prisma.StudentEnrolledCourseAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStudentEnrolledCourse>
          }
          groupBy: {
            args: Prisma.StudentEnrolledCourseGroupByArgs<ExtArgs>
            result: $Utils.Optional<StudentEnrolledCourseGroupByOutputType>[]
          }
          count: {
            args: Prisma.StudentEnrolledCourseCountArgs<ExtArgs>
            result: $Utils.Optional<StudentEnrolledCourseCountAggregateOutputType> | number
          }
        }
      }
      StudentEnrolledCourseMark: {
        payload: Prisma.$StudentEnrolledCourseMarkPayload<ExtArgs>
        fields: Prisma.StudentEnrolledCourseMarkFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StudentEnrolledCourseMarkFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentEnrolledCourseMarkPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StudentEnrolledCourseMarkFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentEnrolledCourseMarkPayload>
          }
          findFirst: {
            args: Prisma.StudentEnrolledCourseMarkFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentEnrolledCourseMarkPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StudentEnrolledCourseMarkFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentEnrolledCourseMarkPayload>
          }
          findMany: {
            args: Prisma.StudentEnrolledCourseMarkFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentEnrolledCourseMarkPayload>[]
          }
          create: {
            args: Prisma.StudentEnrolledCourseMarkCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentEnrolledCourseMarkPayload>
          }
          createMany: {
            args: Prisma.StudentEnrolledCourseMarkCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.StudentEnrolledCourseMarkDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentEnrolledCourseMarkPayload>
          }
          update: {
            args: Prisma.StudentEnrolledCourseMarkUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentEnrolledCourseMarkPayload>
          }
          deleteMany: {
            args: Prisma.StudentEnrolledCourseMarkDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StudentEnrolledCourseMarkUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.StudentEnrolledCourseMarkUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentEnrolledCourseMarkPayload>
          }
          aggregate: {
            args: Prisma.StudentEnrolledCourseMarkAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStudentEnrolledCourseMark>
          }
          groupBy: {
            args: Prisma.StudentEnrolledCourseMarkGroupByArgs<ExtArgs>
            result: $Utils.Optional<StudentEnrolledCourseMarkGroupByOutputType>[]
          }
          count: {
            args: Prisma.StudentEnrolledCourseMarkCountArgs<ExtArgs>
            result: $Utils.Optional<StudentEnrolledCourseMarkCountAggregateOutputType> | number
          }
        }
      }
      CourseDiscipline: {
        payload: Prisma.$CourseDisciplinePayload<ExtArgs>
        fields: Prisma.CourseDisciplineFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CourseDisciplineFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseDisciplinePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CourseDisciplineFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseDisciplinePayload>
          }
          findFirst: {
            args: Prisma.CourseDisciplineFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseDisciplinePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CourseDisciplineFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseDisciplinePayload>
          }
          findMany: {
            args: Prisma.CourseDisciplineFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseDisciplinePayload>[]
          }
          create: {
            args: Prisma.CourseDisciplineCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseDisciplinePayload>
          }
          createMany: {
            args: Prisma.CourseDisciplineCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.CourseDisciplineDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseDisciplinePayload>
          }
          update: {
            args: Prisma.CourseDisciplineUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseDisciplinePayload>
          }
          deleteMany: {
            args: Prisma.CourseDisciplineDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CourseDisciplineUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CourseDisciplineUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseDisciplinePayload>
          }
          aggregate: {
            args: Prisma.CourseDisciplineAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCourseDiscipline>
          }
          groupBy: {
            args: Prisma.CourseDisciplineGroupByArgs<ExtArgs>
            result: $Utils.Optional<CourseDisciplineGroupByOutputType>[]
          }
          count: {
            args: Prisma.CourseDisciplineCountArgs<ExtArgs>
            result: $Utils.Optional<CourseDisciplineCountAggregateOutputType> | number
          }
        }
      }
      StudentCarriedCourse: {
        payload: Prisma.$StudentCarriedCoursePayload<ExtArgs>
        fields: Prisma.StudentCarriedCourseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StudentCarriedCourseFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentCarriedCoursePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StudentCarriedCourseFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentCarriedCoursePayload>
          }
          findFirst: {
            args: Prisma.StudentCarriedCourseFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentCarriedCoursePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StudentCarriedCourseFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentCarriedCoursePayload>
          }
          findMany: {
            args: Prisma.StudentCarriedCourseFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentCarriedCoursePayload>[]
          }
          create: {
            args: Prisma.StudentCarriedCourseCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentCarriedCoursePayload>
          }
          createMany: {
            args: Prisma.StudentCarriedCourseCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.StudentCarriedCourseDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentCarriedCoursePayload>
          }
          update: {
            args: Prisma.StudentCarriedCourseUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentCarriedCoursePayload>
          }
          deleteMany: {
            args: Prisma.StudentCarriedCourseDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StudentCarriedCourseUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.StudentCarriedCourseUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentCarriedCoursePayload>
          }
          aggregate: {
            args: Prisma.StudentCarriedCourseAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStudentCarriedCourse>
          }
          groupBy: {
            args: Prisma.StudentCarriedCourseGroupByArgs<ExtArgs>
            result: $Utils.Optional<StudentCarriedCourseGroupByOutputType>[]
          }
          count: {
            args: Prisma.StudentCarriedCourseCountArgs<ExtArgs>
            result: $Utils.Optional<StudentCarriedCourseCountAggregateOutputType> | number
          }
        }
      }
      CoursePricing: {
        payload: Prisma.$CoursePricingPayload<ExtArgs>
        fields: Prisma.CoursePricingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CoursePricingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePricingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CoursePricingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePricingPayload>
          }
          findFirst: {
            args: Prisma.CoursePricingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePricingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CoursePricingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePricingPayload>
          }
          findMany: {
            args: Prisma.CoursePricingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePricingPayload>[]
          }
          create: {
            args: Prisma.CoursePricingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePricingPayload>
          }
          createMany: {
            args: Prisma.CoursePricingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.CoursePricingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePricingPayload>
          }
          update: {
            args: Prisma.CoursePricingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePricingPayload>
          }
          deleteMany: {
            args: Prisma.CoursePricingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CoursePricingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CoursePricingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePricingPayload>
          }
          aggregate: {
            args: Prisma.CoursePricingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCoursePricing>
          }
          groupBy: {
            args: Prisma.CoursePricingGroupByArgs<ExtArgs>
            result: $Utils.Optional<CoursePricingGroupByOutputType>[]
          }
          count: {
            args: Prisma.CoursePricingCountArgs<ExtArgs>
            result: $Utils.Optional<CoursePricingCountAggregateOutputType> | number
          }
        }
      }
      Discipline: {
        payload: Prisma.$DisciplinePayload<ExtArgs>
        fields: Prisma.DisciplineFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DisciplineFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DisciplinePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DisciplineFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DisciplinePayload>
          }
          findFirst: {
            args: Prisma.DisciplineFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DisciplinePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DisciplineFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DisciplinePayload>
          }
          findMany: {
            args: Prisma.DisciplineFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DisciplinePayload>[]
          }
          create: {
            args: Prisma.DisciplineCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DisciplinePayload>
          }
          createMany: {
            args: Prisma.DisciplineCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.DisciplineDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DisciplinePayload>
          }
          update: {
            args: Prisma.DisciplineUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DisciplinePayload>
          }
          deleteMany: {
            args: Prisma.DisciplineDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DisciplineUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DisciplineUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DisciplinePayload>
          }
          aggregate: {
            args: Prisma.DisciplineAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDiscipline>
          }
          groupBy: {
            args: Prisma.DisciplineGroupByArgs<ExtArgs>
            result: $Utils.Optional<DisciplineGroupByOutputType>[]
          }
          count: {
            args: Prisma.DisciplineCountArgs<ExtArgs>
            result: $Utils.Optional<DisciplineCountAggregateOutputType> | number
          }
        }
      }
      StudentSemesterPayment: {
        payload: Prisma.$StudentSemesterPaymentPayload<ExtArgs>
        fields: Prisma.StudentSemesterPaymentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StudentSemesterPaymentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentSemesterPaymentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StudentSemesterPaymentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentSemesterPaymentPayload>
          }
          findFirst: {
            args: Prisma.StudentSemesterPaymentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentSemesterPaymentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StudentSemesterPaymentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentSemesterPaymentPayload>
          }
          findMany: {
            args: Prisma.StudentSemesterPaymentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentSemesterPaymentPayload>[]
          }
          create: {
            args: Prisma.StudentSemesterPaymentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentSemesterPaymentPayload>
          }
          createMany: {
            args: Prisma.StudentSemesterPaymentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.StudentSemesterPaymentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentSemesterPaymentPayload>
          }
          update: {
            args: Prisma.StudentSemesterPaymentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentSemesterPaymentPayload>
          }
          deleteMany: {
            args: Prisma.StudentSemesterPaymentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StudentSemesterPaymentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.StudentSemesterPaymentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentSemesterPaymentPayload>
          }
          aggregate: {
            args: Prisma.StudentSemesterPaymentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStudentSemesterPayment>
          }
          groupBy: {
            args: Prisma.StudentSemesterPaymentGroupByArgs<ExtArgs>
            result: $Utils.Optional<StudentSemesterPaymentGroupByOutputType>[]
          }
          count: {
            args: Prisma.StudentSemesterPaymentCountArgs<ExtArgs>
            result: $Utils.Optional<StudentSemesterPaymentCountAggregateOutputType> | number
          }
        }
      }
      StudentAcademicInfo: {
        payload: Prisma.$StudentAcademicInfoPayload<ExtArgs>
        fields: Prisma.StudentAcademicInfoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StudentAcademicInfoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentAcademicInfoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StudentAcademicInfoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentAcademicInfoPayload>
          }
          findFirst: {
            args: Prisma.StudentAcademicInfoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentAcademicInfoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StudentAcademicInfoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentAcademicInfoPayload>
          }
          findMany: {
            args: Prisma.StudentAcademicInfoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentAcademicInfoPayload>[]
          }
          create: {
            args: Prisma.StudentAcademicInfoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentAcademicInfoPayload>
          }
          createMany: {
            args: Prisma.StudentAcademicInfoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.StudentAcademicInfoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentAcademicInfoPayload>
          }
          update: {
            args: Prisma.StudentAcademicInfoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentAcademicInfoPayload>
          }
          deleteMany: {
            args: Prisma.StudentAcademicInfoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StudentAcademicInfoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.StudentAcademicInfoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentAcademicInfoPayload>
          }
          aggregate: {
            args: Prisma.StudentAcademicInfoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStudentAcademicInfo>
          }
          groupBy: {
            args: Prisma.StudentAcademicInfoGroupByArgs<ExtArgs>
            result: $Utils.Optional<StudentAcademicInfoGroupByOutputType>[]
          }
          count: {
            args: Prisma.StudentAcademicInfoCountArgs<ExtArgs>
            result: $Utils.Optional<StudentAcademicInfoCountAggregateOutputType> | number
          }
        }
      }
      Events: {
        payload: Prisma.$EventsPayload<ExtArgs>
        fields: Prisma.EventsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EventsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EventsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventsPayload>
          }
          findFirst: {
            args: Prisma.EventsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EventsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventsPayload>
          }
          findMany: {
            args: Prisma.EventsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventsPayload>[]
          }
          create: {
            args: Prisma.EventsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventsPayload>
          }
          createMany: {
            args: Prisma.EventsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.EventsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventsPayload>
          }
          update: {
            args: Prisma.EventsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventsPayload>
          }
          deleteMany: {
            args: Prisma.EventsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EventsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EventsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventsPayload>
          }
          aggregate: {
            args: Prisma.EventsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEvents>
          }
          groupBy: {
            args: Prisma.EventsGroupByArgs<ExtArgs>
            result: $Utils.Optional<EventsGroupByOutputType>[]
          }
          count: {
            args: Prisma.EventsCountArgs<ExtArgs>
            result: $Utils.Optional<EventsCountAggregateOutputType> | number
          }
        }
      }
      Payment: {
        payload: Prisma.$PaymentPayload<ExtArgs>
        fields: Prisma.PaymentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PaymentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PaymentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          findFirst: {
            args: Prisma.PaymentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PaymentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          findMany: {
            args: Prisma.PaymentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>[]
          }
          create: {
            args: Prisma.PaymentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          createMany: {
            args: Prisma.PaymentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.PaymentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          update: {
            args: Prisma.PaymentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          deleteMany: {
            args: Prisma.PaymentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PaymentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PaymentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          aggregate: {
            args: Prisma.PaymentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePayment>
          }
          groupBy: {
            args: Prisma.PaymentGroupByArgs<ExtArgs>
            result: $Utils.Optional<PaymentGroupByOutputType>[]
          }
          count: {
            args: Prisma.PaymentCountArgs<ExtArgs>
            result: $Utils.Optional<PaymentCountAggregateOutputType> | number
          }
        }
      }
      PaymentReference: {
        payload: Prisma.$PaymentReferencePayload<ExtArgs>
        fields: Prisma.PaymentReferenceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PaymentReferenceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentReferencePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PaymentReferenceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentReferencePayload>
          }
          findFirst: {
            args: Prisma.PaymentReferenceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentReferencePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PaymentReferenceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentReferencePayload>
          }
          findMany: {
            args: Prisma.PaymentReferenceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentReferencePayload>[]
          }
          create: {
            args: Prisma.PaymentReferenceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentReferencePayload>
          }
          createMany: {
            args: Prisma.PaymentReferenceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.PaymentReferenceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentReferencePayload>
          }
          update: {
            args: Prisma.PaymentReferenceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentReferencePayload>
          }
          deleteMany: {
            args: Prisma.PaymentReferenceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PaymentReferenceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PaymentReferenceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentReferencePayload>
          }
          aggregate: {
            args: Prisma.PaymentReferenceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePaymentReference>
          }
          groupBy: {
            args: Prisma.PaymentReferenceGroupByArgs<ExtArgs>
            result: $Utils.Optional<PaymentReferenceGroupByOutputType>[]
          }
          count: {
            args: Prisma.PaymentReferenceCountArgs<ExtArgs>
            result: $Utils.Optional<PaymentReferenceCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    users?: UsersOmit
    academicSemester?: AcademicSemesterOmit
    academicFaculty?: AcademicFacultyOmit
    academicDepartment?: AcademicDepartmentOmit
    student?: StudentOmit
    faculty?: FacultyOmit
    building?: BuildingOmit
    room?: RoomOmit
    course?: CourseOmit
    courseToPreRequisite?: CourseToPreRequisiteOmit
    courseFaculty?: CourseFacultyOmit
    semesterRegistration?: SemesterRegistrationOmit
    admitionExameRegistration?: AdmitionExameRegistrationOmit
    admitionExamePrice?: AdmitionExamePriceOmit
    admitionExamePeriod?: AdmitionExamePeriodOmit
    exameFase?: ExameFaseOmit
    offeredCourse?: OfferedCourseOmit
    offeredCourseSection?: OfferedCourseSectionOmit
    offeredCourseClassSchedule?: OfferedCourseClassScheduleOmit
    studentSemesterRegistration?: StudentSemesterRegistrationOmit
    studentSemesterRegistrationCourse?: StudentSemesterRegistrationCourseOmit
    studentEnrolledCourse?: StudentEnrolledCourseOmit
    studentEnrolledCourseMark?: StudentEnrolledCourseMarkOmit
    courseDiscipline?: CourseDisciplineOmit
    studentCarriedCourse?: StudentCarriedCourseOmit
    coursePricing?: CoursePricingOmit
    discipline?: DisciplineOmit
    studentSemesterPayment?: StudentSemesterPaymentOmit
    studentAcademicInfo?: StudentAcademicInfoOmit
    events?: EventsOmit
    payment?: PaymentOmit
    paymentReference?: PaymentReferenceOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UsersCountOutputType
   */

  export type UsersCountOutputType = {
    staffDepartments: number
  }

  export type UsersCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    staffDepartments?: boolean | UsersCountOutputTypeCountStaffDepartmentsArgs
  }

  // Custom InputTypes
  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsersCountOutputType
     */
    select?: UsersCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountStaffDepartmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AcademicDepartmentWhereInput
  }


  /**
   * Count Type AcademicSemesterCountOutputType
   */

  export type AcademicSemesterCountOutputType = {
    courseDisciplines: number
    semesterRegistrations: number
    students: number
    studentEnrolledCourses: number
    studentEnrolledCourseMarks: number
    studentSemesterPayments: number
    StudentCarriedCourse: number
  }

  export type AcademicSemesterCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    courseDisciplines?: boolean | AcademicSemesterCountOutputTypeCountCourseDisciplinesArgs
    semesterRegistrations?: boolean | AcademicSemesterCountOutputTypeCountSemesterRegistrationsArgs
    students?: boolean | AcademicSemesterCountOutputTypeCountStudentsArgs
    studentEnrolledCourses?: boolean | AcademicSemesterCountOutputTypeCountStudentEnrolledCoursesArgs
    studentEnrolledCourseMarks?: boolean | AcademicSemesterCountOutputTypeCountStudentEnrolledCourseMarksArgs
    studentSemesterPayments?: boolean | AcademicSemesterCountOutputTypeCountStudentSemesterPaymentsArgs
    StudentCarriedCourse?: boolean | AcademicSemesterCountOutputTypeCountStudentCarriedCourseArgs
  }

  // Custom InputTypes
  /**
   * AcademicSemesterCountOutputType without action
   */
  export type AcademicSemesterCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicSemesterCountOutputType
     */
    select?: AcademicSemesterCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AcademicSemesterCountOutputType without action
   */
  export type AcademicSemesterCountOutputTypeCountCourseDisciplinesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CourseDisciplineWhereInput
  }

  /**
   * AcademicSemesterCountOutputType without action
   */
  export type AcademicSemesterCountOutputTypeCountSemesterRegistrationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SemesterRegistrationWhereInput
  }

  /**
   * AcademicSemesterCountOutputType without action
   */
  export type AcademicSemesterCountOutputTypeCountStudentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentWhereInput
  }

  /**
   * AcademicSemesterCountOutputType without action
   */
  export type AcademicSemesterCountOutputTypeCountStudentEnrolledCoursesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentEnrolledCourseWhereInput
  }

  /**
   * AcademicSemesterCountOutputType without action
   */
  export type AcademicSemesterCountOutputTypeCountStudentEnrolledCourseMarksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentEnrolledCourseMarkWhereInput
  }

  /**
   * AcademicSemesterCountOutputType without action
   */
  export type AcademicSemesterCountOutputTypeCountStudentSemesterPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentSemesterPaymentWhereInput
  }

  /**
   * AcademicSemesterCountOutputType without action
   */
  export type AcademicSemesterCountOutputTypeCountStudentCarriedCourseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentCarriedCourseWhereInput
  }


  /**
   * Count Type AcademicFacultyCountOutputType
   */

  export type AcademicFacultyCountOutputType = {
    academicDepartments: number
    faculties: number
    students: number
    admitionExame: number
    AdmitionExamePrice: number
    AdmitionExamePeriod: number
  }

  export type AcademicFacultyCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    academicDepartments?: boolean | AcademicFacultyCountOutputTypeCountAcademicDepartmentsArgs
    faculties?: boolean | AcademicFacultyCountOutputTypeCountFacultiesArgs
    students?: boolean | AcademicFacultyCountOutputTypeCountStudentsArgs
    admitionExame?: boolean | AcademicFacultyCountOutputTypeCountAdmitionExameArgs
    AdmitionExamePrice?: boolean | AcademicFacultyCountOutputTypeCountAdmitionExamePriceArgs
    AdmitionExamePeriod?: boolean | AcademicFacultyCountOutputTypeCountAdmitionExamePeriodArgs
  }

  // Custom InputTypes
  /**
   * AcademicFacultyCountOutputType without action
   */
  export type AcademicFacultyCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicFacultyCountOutputType
     */
    select?: AcademicFacultyCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AcademicFacultyCountOutputType without action
   */
  export type AcademicFacultyCountOutputTypeCountAcademicDepartmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AcademicDepartmentWhereInput
  }

  /**
   * AcademicFacultyCountOutputType without action
   */
  export type AcademicFacultyCountOutputTypeCountFacultiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FacultyWhereInput
  }

  /**
   * AcademicFacultyCountOutputType without action
   */
  export type AcademicFacultyCountOutputTypeCountStudentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentWhereInput
  }

  /**
   * AcademicFacultyCountOutputType without action
   */
  export type AcademicFacultyCountOutputTypeCountAdmitionExameArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdmitionExameRegistrationWhereInput
  }

  /**
   * AcademicFacultyCountOutputType without action
   */
  export type AcademicFacultyCountOutputTypeCountAdmitionExamePriceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdmitionExamePriceWhereInput
  }

  /**
   * AcademicFacultyCountOutputType without action
   */
  export type AcademicFacultyCountOutputTypeCountAdmitionExamePeriodArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdmitionExamePeriodWhereInput
  }


  /**
   * Count Type AcademicDepartmentCountOutputType
   */

  export type AcademicDepartmentCountOutputType = {
    faculties: number
    courses: number
    students: number
    staffMembers: number
    offeredCourses: number
  }

  export type AcademicDepartmentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    faculties?: boolean | AcademicDepartmentCountOutputTypeCountFacultiesArgs
    courses?: boolean | AcademicDepartmentCountOutputTypeCountCoursesArgs
    students?: boolean | AcademicDepartmentCountOutputTypeCountStudentsArgs
    staffMembers?: boolean | AcademicDepartmentCountOutputTypeCountStaffMembersArgs
    offeredCourses?: boolean | AcademicDepartmentCountOutputTypeCountOfferedCoursesArgs
  }

  // Custom InputTypes
  /**
   * AcademicDepartmentCountOutputType without action
   */
  export type AcademicDepartmentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicDepartmentCountOutputType
     */
    select?: AcademicDepartmentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AcademicDepartmentCountOutputType without action
   */
  export type AcademicDepartmentCountOutputTypeCountFacultiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FacultyWhereInput
  }

  /**
   * AcademicDepartmentCountOutputType without action
   */
  export type AcademicDepartmentCountOutputTypeCountCoursesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CourseWhereInput
  }

  /**
   * AcademicDepartmentCountOutputType without action
   */
  export type AcademicDepartmentCountOutputTypeCountStudentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentWhereInput
  }

  /**
   * AcademicDepartmentCountOutputType without action
   */
  export type AcademicDepartmentCountOutputTypeCountStaffMembersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UsersWhereInput
  }

  /**
   * AcademicDepartmentCountOutputType without action
   */
  export type AcademicDepartmentCountOutputTypeCountOfferedCoursesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OfferedCourseWhereInput
  }


  /**
   * Count Type StudentCountOutputType
   */

  export type StudentCountOutputType = {
    studentSemesterRegistrations: number
    studentSemesterRegistrationCourses: number
    studentEnrolledCourses: number
    studentEnrolledCourseMarks: number
    studentSemesterPayments: number
    studentAcademicInfos: number
    StudentCarriedCourse: number
  }

  export type StudentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    studentSemesterRegistrations?: boolean | StudentCountOutputTypeCountStudentSemesterRegistrationsArgs
    studentSemesterRegistrationCourses?: boolean | StudentCountOutputTypeCountStudentSemesterRegistrationCoursesArgs
    studentEnrolledCourses?: boolean | StudentCountOutputTypeCountStudentEnrolledCoursesArgs
    studentEnrolledCourseMarks?: boolean | StudentCountOutputTypeCountStudentEnrolledCourseMarksArgs
    studentSemesterPayments?: boolean | StudentCountOutputTypeCountStudentSemesterPaymentsArgs
    studentAcademicInfos?: boolean | StudentCountOutputTypeCountStudentAcademicInfosArgs
    StudentCarriedCourse?: boolean | StudentCountOutputTypeCountStudentCarriedCourseArgs
  }

  // Custom InputTypes
  /**
   * StudentCountOutputType without action
   */
  export type StudentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentCountOutputType
     */
    select?: StudentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * StudentCountOutputType without action
   */
  export type StudentCountOutputTypeCountStudentSemesterRegistrationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentSemesterRegistrationWhereInput
  }

  /**
   * StudentCountOutputType without action
   */
  export type StudentCountOutputTypeCountStudentSemesterRegistrationCoursesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentSemesterRegistrationCourseWhereInput
  }

  /**
   * StudentCountOutputType without action
   */
  export type StudentCountOutputTypeCountStudentEnrolledCoursesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentEnrolledCourseWhereInput
  }

  /**
   * StudentCountOutputType without action
   */
  export type StudentCountOutputTypeCountStudentEnrolledCourseMarksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentEnrolledCourseMarkWhereInput
  }

  /**
   * StudentCountOutputType without action
   */
  export type StudentCountOutputTypeCountStudentSemesterPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentSemesterPaymentWhereInput
  }

  /**
   * StudentCountOutputType without action
   */
  export type StudentCountOutputTypeCountStudentAcademicInfosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentAcademicInfoWhereInput
  }

  /**
   * StudentCountOutputType without action
   */
  export type StudentCountOutputTypeCountStudentCarriedCourseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentCarriedCourseWhereInput
  }


  /**
   * Count Type FacultyCountOutputType
   */

  export type FacultyCountOutputType = {
    courses: number
    offeredCourseClassSchedules: number
  }

  export type FacultyCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    courses?: boolean | FacultyCountOutputTypeCountCoursesArgs
    offeredCourseClassSchedules?: boolean | FacultyCountOutputTypeCountOfferedCourseClassSchedulesArgs
  }

  // Custom InputTypes
  /**
   * FacultyCountOutputType without action
   */
  export type FacultyCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FacultyCountOutputType
     */
    select?: FacultyCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * FacultyCountOutputType without action
   */
  export type FacultyCountOutputTypeCountCoursesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CourseFacultyWhereInput
  }

  /**
   * FacultyCountOutputType without action
   */
  export type FacultyCountOutputTypeCountOfferedCourseClassSchedulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OfferedCourseClassScheduleWhereInput
  }


  /**
   * Count Type BuildingCountOutputType
   */

  export type BuildingCountOutputType = {
    rooms: number
  }

  export type BuildingCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    rooms?: boolean | BuildingCountOutputTypeCountRoomsArgs
  }

  // Custom InputTypes
  /**
   * BuildingCountOutputType without action
   */
  export type BuildingCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuildingCountOutputType
     */
    select?: BuildingCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BuildingCountOutputType without action
   */
  export type BuildingCountOutputTypeCountRoomsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoomWhereInput
  }


  /**
   * Count Type RoomCountOutputType
   */

  export type RoomCountOutputType = {
    offeredCourseClassSchedules: number
  }

  export type RoomCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    offeredCourseClassSchedules?: boolean | RoomCountOutputTypeCountOfferedCourseClassSchedulesArgs
  }

  // Custom InputTypes
  /**
   * RoomCountOutputType without action
   */
  export type RoomCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomCountOutputType
     */
    select?: RoomCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RoomCountOutputType without action
   */
  export type RoomCountOutputTypeCountOfferedCourseClassSchedulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OfferedCourseClassScheduleWhereInput
  }


  /**
   * Count Type CourseCountOutputType
   */

  export type CourseCountOutputType = {
    courseDisciplines: number
    studentCourses: number
    preRequisite: number
    preRequisiteFor: number
    faculties: number
    offeredCourses: number
  }

  export type CourseCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    courseDisciplines?: boolean | CourseCountOutputTypeCountCourseDisciplinesArgs
    studentCourses?: boolean | CourseCountOutputTypeCountStudentCoursesArgs
    preRequisite?: boolean | CourseCountOutputTypeCountPreRequisiteArgs
    preRequisiteFor?: boolean | CourseCountOutputTypeCountPreRequisiteForArgs
    faculties?: boolean | CourseCountOutputTypeCountFacultiesArgs
    offeredCourses?: boolean | CourseCountOutputTypeCountOfferedCoursesArgs
  }

  // Custom InputTypes
  /**
   * CourseCountOutputType without action
   */
  export type CourseCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseCountOutputType
     */
    select?: CourseCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CourseCountOutputType without action
   */
  export type CourseCountOutputTypeCountCourseDisciplinesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CourseDisciplineWhereInput
  }

  /**
   * CourseCountOutputType without action
   */
  export type CourseCountOutputTypeCountStudentCoursesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentEnrolledCourseWhereInput
  }

  /**
   * CourseCountOutputType without action
   */
  export type CourseCountOutputTypeCountPreRequisiteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CourseToPreRequisiteWhereInput
  }

  /**
   * CourseCountOutputType without action
   */
  export type CourseCountOutputTypeCountPreRequisiteForArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CourseToPreRequisiteWhereInput
  }

  /**
   * CourseCountOutputType without action
   */
  export type CourseCountOutputTypeCountFacultiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CourseFacultyWhereInput
  }

  /**
   * CourseCountOutputType without action
   */
  export type CourseCountOutputTypeCountOfferedCoursesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OfferedCourseWhereInput
  }


  /**
   * Count Type SemesterRegistrationCountOutputType
   */

  export type SemesterRegistrationCountOutputType = {
    offeredCourses: number
    offeredCourseSections: number
    offeredCourseClassSchedules: number
    studentSemesterRegistrations: number
    studentSemesterRegistrationCourses: number
  }

  export type SemesterRegistrationCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    offeredCourses?: boolean | SemesterRegistrationCountOutputTypeCountOfferedCoursesArgs
    offeredCourseSections?: boolean | SemesterRegistrationCountOutputTypeCountOfferedCourseSectionsArgs
    offeredCourseClassSchedules?: boolean | SemesterRegistrationCountOutputTypeCountOfferedCourseClassSchedulesArgs
    studentSemesterRegistrations?: boolean | SemesterRegistrationCountOutputTypeCountStudentSemesterRegistrationsArgs
    studentSemesterRegistrationCourses?: boolean | SemesterRegistrationCountOutputTypeCountStudentSemesterRegistrationCoursesArgs
  }

  // Custom InputTypes
  /**
   * SemesterRegistrationCountOutputType without action
   */
  export type SemesterRegistrationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SemesterRegistrationCountOutputType
     */
    select?: SemesterRegistrationCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SemesterRegistrationCountOutputType without action
   */
  export type SemesterRegistrationCountOutputTypeCountOfferedCoursesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OfferedCourseWhereInput
  }

  /**
   * SemesterRegistrationCountOutputType without action
   */
  export type SemesterRegistrationCountOutputTypeCountOfferedCourseSectionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OfferedCourseSectionWhereInput
  }

  /**
   * SemesterRegistrationCountOutputType without action
   */
  export type SemesterRegistrationCountOutputTypeCountOfferedCourseClassSchedulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OfferedCourseClassScheduleWhereInput
  }

  /**
   * SemesterRegistrationCountOutputType without action
   */
  export type SemesterRegistrationCountOutputTypeCountStudentSemesterRegistrationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentSemesterRegistrationWhereInput
  }

  /**
   * SemesterRegistrationCountOutputType without action
   */
  export type SemesterRegistrationCountOutputTypeCountStudentSemesterRegistrationCoursesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentSemesterRegistrationCourseWhereInput
  }


  /**
   * Count Type ExameFaseCountOutputType
   */

  export type ExameFaseCountOutputType = {
    registrations: number
  }

  export type ExameFaseCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    registrations?: boolean | ExameFaseCountOutputTypeCountRegistrationsArgs
  }

  // Custom InputTypes
  /**
   * ExameFaseCountOutputType without action
   */
  export type ExameFaseCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExameFaseCountOutputType
     */
    select?: ExameFaseCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ExameFaseCountOutputType without action
   */
  export type ExameFaseCountOutputTypeCountRegistrationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdmitionExameRegistrationWhereInput
  }


  /**
   * Count Type OfferedCourseCountOutputType
   */

  export type OfferedCourseCountOutputType = {
    offeredCourseSections: number
    studentSemesterRegistrationCourses: number
  }

  export type OfferedCourseCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    offeredCourseSections?: boolean | OfferedCourseCountOutputTypeCountOfferedCourseSectionsArgs
    studentSemesterRegistrationCourses?: boolean | OfferedCourseCountOutputTypeCountStudentSemesterRegistrationCoursesArgs
  }

  // Custom InputTypes
  /**
   * OfferedCourseCountOutputType without action
   */
  export type OfferedCourseCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OfferedCourseCountOutputType
     */
    select?: OfferedCourseCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * OfferedCourseCountOutputType without action
   */
  export type OfferedCourseCountOutputTypeCountOfferedCourseSectionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OfferedCourseSectionWhereInput
  }

  /**
   * OfferedCourseCountOutputType without action
   */
  export type OfferedCourseCountOutputTypeCountStudentSemesterRegistrationCoursesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentSemesterRegistrationCourseWhereInput
  }


  /**
   * Count Type OfferedCourseSectionCountOutputType
   */

  export type OfferedCourseSectionCountOutputType = {
    offeredCourseClassSchedules: number
    studentSemesterRegistrationCourses: number
  }

  export type OfferedCourseSectionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    offeredCourseClassSchedules?: boolean | OfferedCourseSectionCountOutputTypeCountOfferedCourseClassSchedulesArgs
    studentSemesterRegistrationCourses?: boolean | OfferedCourseSectionCountOutputTypeCountStudentSemesterRegistrationCoursesArgs
  }

  // Custom InputTypes
  /**
   * OfferedCourseSectionCountOutputType without action
   */
  export type OfferedCourseSectionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OfferedCourseSectionCountOutputType
     */
    select?: OfferedCourseSectionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * OfferedCourseSectionCountOutputType without action
   */
  export type OfferedCourseSectionCountOutputTypeCountOfferedCourseClassSchedulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OfferedCourseClassScheduleWhereInput
  }

  /**
   * OfferedCourseSectionCountOutputType without action
   */
  export type OfferedCourseSectionCountOutputTypeCountStudentSemesterRegistrationCoursesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentSemesterRegistrationCourseWhereInput
  }


  /**
   * Count Type StudentEnrolledCourseCountOutputType
   */

  export type StudentEnrolledCourseCountOutputType = {
    studentEnrolledCourseMarks: number
  }

  export type StudentEnrolledCourseCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    studentEnrolledCourseMarks?: boolean | StudentEnrolledCourseCountOutputTypeCountStudentEnrolledCourseMarksArgs
  }

  // Custom InputTypes
  /**
   * StudentEnrolledCourseCountOutputType without action
   */
  export type StudentEnrolledCourseCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentEnrolledCourseCountOutputType
     */
    select?: StudentEnrolledCourseCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * StudentEnrolledCourseCountOutputType without action
   */
  export type StudentEnrolledCourseCountOutputTypeCountStudentEnrolledCourseMarksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentEnrolledCourseMarkWhereInput
  }


  /**
   * Count Type DisciplineCountOutputType
   */

  export type DisciplineCountOutputType = {
    courseDisciplines: number
    StudentCarriedCourse: number
  }

  export type DisciplineCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    courseDisciplines?: boolean | DisciplineCountOutputTypeCountCourseDisciplinesArgs
    StudentCarriedCourse?: boolean | DisciplineCountOutputTypeCountStudentCarriedCourseArgs
  }

  // Custom InputTypes
  /**
   * DisciplineCountOutputType without action
   */
  export type DisciplineCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DisciplineCountOutputType
     */
    select?: DisciplineCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DisciplineCountOutputType without action
   */
  export type DisciplineCountOutputTypeCountCourseDisciplinesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CourseDisciplineWhereInput
  }

  /**
   * DisciplineCountOutputType without action
   */
  export type DisciplineCountOutputTypeCountStudentCarriedCourseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentCarriedCourseWhereInput
  }


  /**
   * Count Type PaymentCountOutputType
   */

  export type PaymentCountOutputType = {
    StudentSemesterPayment: number
    PaymentReference: number
  }

  export type PaymentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    StudentSemesterPayment?: boolean | PaymentCountOutputTypeCountStudentSemesterPaymentArgs
    PaymentReference?: boolean | PaymentCountOutputTypeCountPaymentReferenceArgs
  }

  // Custom InputTypes
  /**
   * PaymentCountOutputType without action
   */
  export type PaymentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentCountOutputType
     */
    select?: PaymentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PaymentCountOutputType without action
   */
  export type PaymentCountOutputTypeCountStudentSemesterPaymentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentSemesterPaymentWhereInput
  }

  /**
   * PaymentCountOutputType without action
   */
  export type PaymentCountOutputTypeCountPaymentReferenceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentReferenceWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Users
   */

  export type AggregateUsers = {
    _count: UsersCountAggregateOutputType | null
    _min: UsersMinAggregateOutputType | null
    _max: UsersMaxAggregateOutputType | null
  }

  export type UsersMinAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    password: string | null
    avatar: string | null
    role: $Enums.UserRole | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UsersMaxAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    password: string | null
    avatar: string | null
    role: $Enums.UserRole | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UsersCountAggregateOutputType = {
    id: number
    name: number
    email: number
    password: number
    avatar: number
    role: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UsersMinAggregateInputType = {
    id?: true
    name?: true
    email?: true
    password?: true
    avatar?: true
    role?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UsersMaxAggregateInputType = {
    id?: true
    name?: true
    email?: true
    password?: true
    avatar?: true
    role?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UsersCountAggregateInputType = {
    id?: true
    name?: true
    email?: true
    password?: true
    avatar?: true
    role?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UsersAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to aggregate.
     */
    where?: UsersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UsersOrderByWithRelationInput | UsersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UsersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UsersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UsersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UsersMaxAggregateInputType
  }

  export type GetUsersAggregateType<T extends UsersAggregateArgs> = {
        [P in keyof T & keyof AggregateUsers]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUsers[P]>
      : GetScalarType<T[P], AggregateUsers[P]>
  }




  export type UsersGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UsersWhereInput
    orderBy?: UsersOrderByWithAggregationInput | UsersOrderByWithAggregationInput[]
    by: UsersScalarFieldEnum[] | UsersScalarFieldEnum
    having?: UsersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UsersCountAggregateInputType | true
    _min?: UsersMinAggregateInputType
    _max?: UsersMaxAggregateInputType
  }

  export type UsersGroupByOutputType = {
    id: string
    name: string
    email: string
    password: string
    avatar: string | null
    role: $Enums.UserRole
    createdAt: Date
    updatedAt: Date
    _count: UsersCountAggregateOutputType | null
    _min: UsersMinAggregateOutputType | null
    _max: UsersMaxAggregateOutputType | null
  }

  type GetUsersGroupByPayload<T extends UsersGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UsersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UsersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UsersGroupByOutputType[P]>
            : GetScalarType<T[P], UsersGroupByOutputType[P]>
        }
      >
    >


  export type UsersSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    password?: boolean
    avatar?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    academicDepartment?: boolean | Users$academicDepartmentArgs<ExtArgs>
    staffDepartments?: boolean | Users$staffDepartmentsArgs<ExtArgs>
    _count?: boolean | UsersCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["users"]>



  export type UsersSelectScalar = {
    id?: boolean
    name?: boolean
    email?: boolean
    password?: boolean
    avatar?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UsersOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "email" | "password" | "avatar" | "role" | "createdAt" | "updatedAt", ExtArgs["result"]["users"]>
  export type UsersInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    academicDepartment?: boolean | Users$academicDepartmentArgs<ExtArgs>
    staffDepartments?: boolean | Users$staffDepartmentsArgs<ExtArgs>
    _count?: boolean | UsersCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $UsersPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Users"
    objects: {
      academicDepartment: Prisma.$AcademicDepartmentPayload<ExtArgs> | null
      staffDepartments: Prisma.$AcademicDepartmentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      email: string
      password: string
      avatar: string | null
      role: $Enums.UserRole
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["users"]>
    composites: {}
  }

  type UsersGetPayload<S extends boolean | null | undefined | UsersDefaultArgs> = $Result.GetResult<Prisma.$UsersPayload, S>

  type UsersCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UsersFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UsersCountAggregateInputType | true
    }

  export interface UsersDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Users'], meta: { name: 'Users' } }
    /**
     * Find zero or one Users that matches the filter.
     * @param {UsersFindUniqueArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UsersFindUniqueArgs>(args: SelectSubset<T, UsersFindUniqueArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Users that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UsersFindUniqueOrThrowArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UsersFindUniqueOrThrowArgs>(args: SelectSubset<T, UsersFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersFindFirstArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UsersFindFirstArgs>(args?: SelectSubset<T, UsersFindFirstArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Users that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersFindFirstOrThrowArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UsersFindFirstOrThrowArgs>(args?: SelectSubset<T, UsersFindFirstOrThrowArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.users.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.users.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const usersWithIdOnly = await prisma.users.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UsersFindManyArgs>(args?: SelectSubset<T, UsersFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Users.
     * @param {UsersCreateArgs} args - Arguments to create a Users.
     * @example
     * // Create one Users
     * const Users = await prisma.users.create({
     *   data: {
     *     // ... data to create a Users
     *   }
     * })
     * 
     */
    create<T extends UsersCreateArgs>(args: SelectSubset<T, UsersCreateArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UsersCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const users = await prisma.users.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UsersCreateManyArgs>(args?: SelectSubset<T, UsersCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Users.
     * @param {UsersDeleteArgs} args - Arguments to delete one Users.
     * @example
     * // Delete one Users
     * const Users = await prisma.users.delete({
     *   where: {
     *     // ... filter to delete one Users
     *   }
     * })
     * 
     */
    delete<T extends UsersDeleteArgs>(args: SelectSubset<T, UsersDeleteArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Users.
     * @param {UsersUpdateArgs} args - Arguments to update one Users.
     * @example
     * // Update one Users
     * const users = await prisma.users.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UsersUpdateArgs>(args: SelectSubset<T, UsersUpdateArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UsersDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.users.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UsersDeleteManyArgs>(args?: SelectSubset<T, UsersDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const users = await prisma.users.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UsersUpdateManyArgs>(args: SelectSubset<T, UsersUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Users.
     * @param {UsersUpsertArgs} args - Arguments to update or create a Users.
     * @example
     * // Update or create a Users
     * const users = await prisma.users.upsert({
     *   create: {
     *     // ... data to create a Users
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Users we want to update
     *   }
     * })
     */
    upsert<T extends UsersUpsertArgs>(args: SelectSubset<T, UsersUpsertArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.users.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UsersCountArgs>(
      args?: Subset<T, UsersCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UsersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UsersAggregateArgs>(args: Subset<T, UsersAggregateArgs>): Prisma.PrismaPromise<GetUsersAggregateType<T>>

    /**
     * Group by Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UsersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UsersGroupByArgs['orderBy'] }
        : { orderBy?: UsersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UsersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUsersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Users model
   */
  readonly fields: UsersFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Users.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UsersClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    academicDepartment<T extends Users$academicDepartmentArgs<ExtArgs> = {}>(args?: Subset<T, Users$academicDepartmentArgs<ExtArgs>>): Prisma__AcademicDepartmentClient<$Result.GetResult<Prisma.$AcademicDepartmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    staffDepartments<T extends Users$staffDepartmentsArgs<ExtArgs> = {}>(args?: Subset<T, Users$staffDepartmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AcademicDepartmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Users model
   */
  interface UsersFieldRefs {
    readonly id: FieldRef<"Users", 'String'>
    readonly name: FieldRef<"Users", 'String'>
    readonly email: FieldRef<"Users", 'String'>
    readonly password: FieldRef<"Users", 'String'>
    readonly avatar: FieldRef<"Users", 'String'>
    readonly role: FieldRef<"Users", 'UserRole'>
    readonly createdAt: FieldRef<"Users", 'DateTime'>
    readonly updatedAt: FieldRef<"Users", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Users findUnique
   */
  export type UsersFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Users
     */
    omit?: UsersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where: UsersWhereUniqueInput
  }

  /**
   * Users findUniqueOrThrow
   */
  export type UsersFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Users
     */
    omit?: UsersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where: UsersWhereUniqueInput
  }

  /**
   * Users findFirst
   */
  export type UsersFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Users
     */
    omit?: UsersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UsersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UsersOrderByWithRelationInput | UsersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UsersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * Users findFirstOrThrow
   */
  export type UsersFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Users
     */
    omit?: UsersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UsersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UsersOrderByWithRelationInput | UsersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UsersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * Users findMany
   */
  export type UsersFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Users
     */
    omit?: UsersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UsersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UsersOrderByWithRelationInput | UsersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UsersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * Users create
   */
  export type UsersCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Users
     */
    omit?: UsersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersInclude<ExtArgs> | null
    /**
     * The data needed to create a Users.
     */
    data: XOR<UsersCreateInput, UsersUncheckedCreateInput>
  }

  /**
   * Users createMany
   */
  export type UsersCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UsersCreateManyInput | UsersCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Users update
   */
  export type UsersUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Users
     */
    omit?: UsersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersInclude<ExtArgs> | null
    /**
     * The data needed to update a Users.
     */
    data: XOR<UsersUpdateInput, UsersUncheckedUpdateInput>
    /**
     * Choose, which Users to update.
     */
    where: UsersWhereUniqueInput
  }

  /**
   * Users updateMany
   */
  export type UsersUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UsersUpdateManyMutationInput, UsersUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UsersWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * Users upsert
   */
  export type UsersUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Users
     */
    omit?: UsersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersInclude<ExtArgs> | null
    /**
     * The filter to search for the Users to update in case it exists.
     */
    where: UsersWhereUniqueInput
    /**
     * In case the Users found by the `where` argument doesn't exist, create a new Users with this data.
     */
    create: XOR<UsersCreateInput, UsersUncheckedCreateInput>
    /**
     * In case the Users was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UsersUpdateInput, UsersUncheckedUpdateInput>
  }

  /**
   * Users delete
   */
  export type UsersDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Users
     */
    omit?: UsersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersInclude<ExtArgs> | null
    /**
     * Filter which Users to delete.
     */
    where: UsersWhereUniqueInput
  }

  /**
   * Users deleteMany
   */
  export type UsersDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UsersWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * Users.academicDepartment
   */
  export type Users$academicDepartmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicDepartment
     */
    select?: AcademicDepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AcademicDepartment
     */
    omit?: AcademicDepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicDepartmentInclude<ExtArgs> | null
    where?: AcademicDepartmentWhereInput
  }

  /**
   * Users.staffDepartments
   */
  export type Users$staffDepartmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicDepartment
     */
    select?: AcademicDepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AcademicDepartment
     */
    omit?: AcademicDepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicDepartmentInclude<ExtArgs> | null
    where?: AcademicDepartmentWhereInput
    orderBy?: AcademicDepartmentOrderByWithRelationInput | AcademicDepartmentOrderByWithRelationInput[]
    cursor?: AcademicDepartmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AcademicDepartmentScalarFieldEnum | AcademicDepartmentScalarFieldEnum[]
  }

  /**
   * Users without action
   */
  export type UsersDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Users
     */
    omit?: UsersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersInclude<ExtArgs> | null
  }


  /**
   * Model AcademicSemester
   */

  export type AggregateAcademicSemester = {
    _count: AcademicSemesterCountAggregateOutputType | null
    _min: AcademicSemesterMinAggregateOutputType | null
    _max: AcademicSemesterMaxAggregateOutputType | null
  }

  export type AcademicSemesterMinAggregateOutputType = {
    id: string | null
    title: string | null
    year: string | null
    code: string | null
    startMonth: string | null
    endMonth: string | null
    isCurrent: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AcademicSemesterMaxAggregateOutputType = {
    id: string | null
    title: string | null
    year: string | null
    code: string | null
    startMonth: string | null
    endMonth: string | null
    isCurrent: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AcademicSemesterCountAggregateOutputType = {
    id: number
    title: number
    year: number
    code: number
    startMonth: number
    endMonth: number
    isCurrent: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AcademicSemesterMinAggregateInputType = {
    id?: true
    title?: true
    year?: true
    code?: true
    startMonth?: true
    endMonth?: true
    isCurrent?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AcademicSemesterMaxAggregateInputType = {
    id?: true
    title?: true
    year?: true
    code?: true
    startMonth?: true
    endMonth?: true
    isCurrent?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AcademicSemesterCountAggregateInputType = {
    id?: true
    title?: true
    year?: true
    code?: true
    startMonth?: true
    endMonth?: true
    isCurrent?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AcademicSemesterAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AcademicSemester to aggregate.
     */
    where?: AcademicSemesterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AcademicSemesters to fetch.
     */
    orderBy?: AcademicSemesterOrderByWithRelationInput | AcademicSemesterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AcademicSemesterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AcademicSemesters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AcademicSemesters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AcademicSemesters
    **/
    _count?: true | AcademicSemesterCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AcademicSemesterMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AcademicSemesterMaxAggregateInputType
  }

  export type GetAcademicSemesterAggregateType<T extends AcademicSemesterAggregateArgs> = {
        [P in keyof T & keyof AggregateAcademicSemester]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAcademicSemester[P]>
      : GetScalarType<T[P], AggregateAcademicSemester[P]>
  }




  export type AcademicSemesterGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AcademicSemesterWhereInput
    orderBy?: AcademicSemesterOrderByWithAggregationInput | AcademicSemesterOrderByWithAggregationInput[]
    by: AcademicSemesterScalarFieldEnum[] | AcademicSemesterScalarFieldEnum
    having?: AcademicSemesterScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AcademicSemesterCountAggregateInputType | true
    _min?: AcademicSemesterMinAggregateInputType
    _max?: AcademicSemesterMaxAggregateInputType
  }

  export type AcademicSemesterGroupByOutputType = {
    id: string
    title: string
    year: string
    code: string
    startMonth: string
    endMonth: string
    isCurrent: boolean
    createdAt: Date
    updatedAt: Date
    _count: AcademicSemesterCountAggregateOutputType | null
    _min: AcademicSemesterMinAggregateOutputType | null
    _max: AcademicSemesterMaxAggregateOutputType | null
  }

  type GetAcademicSemesterGroupByPayload<T extends AcademicSemesterGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AcademicSemesterGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AcademicSemesterGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AcademicSemesterGroupByOutputType[P]>
            : GetScalarType<T[P], AcademicSemesterGroupByOutputType[P]>
        }
      >
    >


  export type AcademicSemesterSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    year?: boolean
    code?: boolean
    startMonth?: boolean
    endMonth?: boolean
    isCurrent?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    courseDisciplines?: boolean | AcademicSemester$courseDisciplinesArgs<ExtArgs>
    semesterRegistrations?: boolean | AcademicSemester$semesterRegistrationsArgs<ExtArgs>
    students?: boolean | AcademicSemester$studentsArgs<ExtArgs>
    studentEnrolledCourses?: boolean | AcademicSemester$studentEnrolledCoursesArgs<ExtArgs>
    studentEnrolledCourseMarks?: boolean | AcademicSemester$studentEnrolledCourseMarksArgs<ExtArgs>
    studentSemesterPayments?: boolean | AcademicSemester$studentSemesterPaymentsArgs<ExtArgs>
    StudentCarriedCourse?: boolean | AcademicSemester$StudentCarriedCourseArgs<ExtArgs>
    _count?: boolean | AcademicSemesterCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["academicSemester"]>



  export type AcademicSemesterSelectScalar = {
    id?: boolean
    title?: boolean
    year?: boolean
    code?: boolean
    startMonth?: boolean
    endMonth?: boolean
    isCurrent?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AcademicSemesterOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "year" | "code" | "startMonth" | "endMonth" | "isCurrent" | "createdAt" | "updatedAt", ExtArgs["result"]["academicSemester"]>
  export type AcademicSemesterInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    courseDisciplines?: boolean | AcademicSemester$courseDisciplinesArgs<ExtArgs>
    semesterRegistrations?: boolean | AcademicSemester$semesterRegistrationsArgs<ExtArgs>
    students?: boolean | AcademicSemester$studentsArgs<ExtArgs>
    studentEnrolledCourses?: boolean | AcademicSemester$studentEnrolledCoursesArgs<ExtArgs>
    studentEnrolledCourseMarks?: boolean | AcademicSemester$studentEnrolledCourseMarksArgs<ExtArgs>
    studentSemesterPayments?: boolean | AcademicSemester$studentSemesterPaymentsArgs<ExtArgs>
    StudentCarriedCourse?: boolean | AcademicSemester$StudentCarriedCourseArgs<ExtArgs>
    _count?: boolean | AcademicSemesterCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $AcademicSemesterPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AcademicSemester"
    objects: {
      courseDisciplines: Prisma.$CourseDisciplinePayload<ExtArgs>[]
      semesterRegistrations: Prisma.$SemesterRegistrationPayload<ExtArgs>[]
      students: Prisma.$StudentPayload<ExtArgs>[]
      studentEnrolledCourses: Prisma.$StudentEnrolledCoursePayload<ExtArgs>[]
      studentEnrolledCourseMarks: Prisma.$StudentEnrolledCourseMarkPayload<ExtArgs>[]
      studentSemesterPayments: Prisma.$StudentSemesterPaymentPayload<ExtArgs>[]
      StudentCarriedCourse: Prisma.$StudentCarriedCoursePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      year: string
      code: string
      startMonth: string
      endMonth: string
      isCurrent: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["academicSemester"]>
    composites: {}
  }

  type AcademicSemesterGetPayload<S extends boolean | null | undefined | AcademicSemesterDefaultArgs> = $Result.GetResult<Prisma.$AcademicSemesterPayload, S>

  type AcademicSemesterCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AcademicSemesterFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AcademicSemesterCountAggregateInputType | true
    }

  export interface AcademicSemesterDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AcademicSemester'], meta: { name: 'AcademicSemester' } }
    /**
     * Find zero or one AcademicSemester that matches the filter.
     * @param {AcademicSemesterFindUniqueArgs} args - Arguments to find a AcademicSemester
     * @example
     * // Get one AcademicSemester
     * const academicSemester = await prisma.academicSemester.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AcademicSemesterFindUniqueArgs>(args: SelectSubset<T, AcademicSemesterFindUniqueArgs<ExtArgs>>): Prisma__AcademicSemesterClient<$Result.GetResult<Prisma.$AcademicSemesterPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AcademicSemester that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AcademicSemesterFindUniqueOrThrowArgs} args - Arguments to find a AcademicSemester
     * @example
     * // Get one AcademicSemester
     * const academicSemester = await prisma.academicSemester.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AcademicSemesterFindUniqueOrThrowArgs>(args: SelectSubset<T, AcademicSemesterFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AcademicSemesterClient<$Result.GetResult<Prisma.$AcademicSemesterPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AcademicSemester that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AcademicSemesterFindFirstArgs} args - Arguments to find a AcademicSemester
     * @example
     * // Get one AcademicSemester
     * const academicSemester = await prisma.academicSemester.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AcademicSemesterFindFirstArgs>(args?: SelectSubset<T, AcademicSemesterFindFirstArgs<ExtArgs>>): Prisma__AcademicSemesterClient<$Result.GetResult<Prisma.$AcademicSemesterPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AcademicSemester that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AcademicSemesterFindFirstOrThrowArgs} args - Arguments to find a AcademicSemester
     * @example
     * // Get one AcademicSemester
     * const academicSemester = await prisma.academicSemester.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AcademicSemesterFindFirstOrThrowArgs>(args?: SelectSubset<T, AcademicSemesterFindFirstOrThrowArgs<ExtArgs>>): Prisma__AcademicSemesterClient<$Result.GetResult<Prisma.$AcademicSemesterPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AcademicSemesters that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AcademicSemesterFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AcademicSemesters
     * const academicSemesters = await prisma.academicSemester.findMany()
     * 
     * // Get first 10 AcademicSemesters
     * const academicSemesters = await prisma.academicSemester.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const academicSemesterWithIdOnly = await prisma.academicSemester.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AcademicSemesterFindManyArgs>(args?: SelectSubset<T, AcademicSemesterFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AcademicSemesterPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AcademicSemester.
     * @param {AcademicSemesterCreateArgs} args - Arguments to create a AcademicSemester.
     * @example
     * // Create one AcademicSemester
     * const AcademicSemester = await prisma.academicSemester.create({
     *   data: {
     *     // ... data to create a AcademicSemester
     *   }
     * })
     * 
     */
    create<T extends AcademicSemesterCreateArgs>(args: SelectSubset<T, AcademicSemesterCreateArgs<ExtArgs>>): Prisma__AcademicSemesterClient<$Result.GetResult<Prisma.$AcademicSemesterPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AcademicSemesters.
     * @param {AcademicSemesterCreateManyArgs} args - Arguments to create many AcademicSemesters.
     * @example
     * // Create many AcademicSemesters
     * const academicSemester = await prisma.academicSemester.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AcademicSemesterCreateManyArgs>(args?: SelectSubset<T, AcademicSemesterCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a AcademicSemester.
     * @param {AcademicSemesterDeleteArgs} args - Arguments to delete one AcademicSemester.
     * @example
     * // Delete one AcademicSemester
     * const AcademicSemester = await prisma.academicSemester.delete({
     *   where: {
     *     // ... filter to delete one AcademicSemester
     *   }
     * })
     * 
     */
    delete<T extends AcademicSemesterDeleteArgs>(args: SelectSubset<T, AcademicSemesterDeleteArgs<ExtArgs>>): Prisma__AcademicSemesterClient<$Result.GetResult<Prisma.$AcademicSemesterPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AcademicSemester.
     * @param {AcademicSemesterUpdateArgs} args - Arguments to update one AcademicSemester.
     * @example
     * // Update one AcademicSemester
     * const academicSemester = await prisma.academicSemester.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AcademicSemesterUpdateArgs>(args: SelectSubset<T, AcademicSemesterUpdateArgs<ExtArgs>>): Prisma__AcademicSemesterClient<$Result.GetResult<Prisma.$AcademicSemesterPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AcademicSemesters.
     * @param {AcademicSemesterDeleteManyArgs} args - Arguments to filter AcademicSemesters to delete.
     * @example
     * // Delete a few AcademicSemesters
     * const { count } = await prisma.academicSemester.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AcademicSemesterDeleteManyArgs>(args?: SelectSubset<T, AcademicSemesterDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AcademicSemesters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AcademicSemesterUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AcademicSemesters
     * const academicSemester = await prisma.academicSemester.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AcademicSemesterUpdateManyArgs>(args: SelectSubset<T, AcademicSemesterUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AcademicSemester.
     * @param {AcademicSemesterUpsertArgs} args - Arguments to update or create a AcademicSemester.
     * @example
     * // Update or create a AcademicSemester
     * const academicSemester = await prisma.academicSemester.upsert({
     *   create: {
     *     // ... data to create a AcademicSemester
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AcademicSemester we want to update
     *   }
     * })
     */
    upsert<T extends AcademicSemesterUpsertArgs>(args: SelectSubset<T, AcademicSemesterUpsertArgs<ExtArgs>>): Prisma__AcademicSemesterClient<$Result.GetResult<Prisma.$AcademicSemesterPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AcademicSemesters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AcademicSemesterCountArgs} args - Arguments to filter AcademicSemesters to count.
     * @example
     * // Count the number of AcademicSemesters
     * const count = await prisma.academicSemester.count({
     *   where: {
     *     // ... the filter for the AcademicSemesters we want to count
     *   }
     * })
    **/
    count<T extends AcademicSemesterCountArgs>(
      args?: Subset<T, AcademicSemesterCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AcademicSemesterCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AcademicSemester.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AcademicSemesterAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AcademicSemesterAggregateArgs>(args: Subset<T, AcademicSemesterAggregateArgs>): Prisma.PrismaPromise<GetAcademicSemesterAggregateType<T>>

    /**
     * Group by AcademicSemester.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AcademicSemesterGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AcademicSemesterGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AcademicSemesterGroupByArgs['orderBy'] }
        : { orderBy?: AcademicSemesterGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AcademicSemesterGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAcademicSemesterGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AcademicSemester model
   */
  readonly fields: AcademicSemesterFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AcademicSemester.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AcademicSemesterClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    courseDisciplines<T extends AcademicSemester$courseDisciplinesArgs<ExtArgs> = {}>(args?: Subset<T, AcademicSemester$courseDisciplinesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CourseDisciplinePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    semesterRegistrations<T extends AcademicSemester$semesterRegistrationsArgs<ExtArgs> = {}>(args?: Subset<T, AcademicSemester$semesterRegistrationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SemesterRegistrationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    students<T extends AcademicSemester$studentsArgs<ExtArgs> = {}>(args?: Subset<T, AcademicSemester$studentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    studentEnrolledCourses<T extends AcademicSemester$studentEnrolledCoursesArgs<ExtArgs> = {}>(args?: Subset<T, AcademicSemester$studentEnrolledCoursesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentEnrolledCoursePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    studentEnrolledCourseMarks<T extends AcademicSemester$studentEnrolledCourseMarksArgs<ExtArgs> = {}>(args?: Subset<T, AcademicSemester$studentEnrolledCourseMarksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentEnrolledCourseMarkPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    studentSemesterPayments<T extends AcademicSemester$studentSemesterPaymentsArgs<ExtArgs> = {}>(args?: Subset<T, AcademicSemester$studentSemesterPaymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentSemesterPaymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    StudentCarriedCourse<T extends AcademicSemester$StudentCarriedCourseArgs<ExtArgs> = {}>(args?: Subset<T, AcademicSemester$StudentCarriedCourseArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentCarriedCoursePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AcademicSemester model
   */
  interface AcademicSemesterFieldRefs {
    readonly id: FieldRef<"AcademicSemester", 'String'>
    readonly title: FieldRef<"AcademicSemester", 'String'>
    readonly year: FieldRef<"AcademicSemester", 'String'>
    readonly code: FieldRef<"AcademicSemester", 'String'>
    readonly startMonth: FieldRef<"AcademicSemester", 'String'>
    readonly endMonth: FieldRef<"AcademicSemester", 'String'>
    readonly isCurrent: FieldRef<"AcademicSemester", 'Boolean'>
    readonly createdAt: FieldRef<"AcademicSemester", 'DateTime'>
    readonly updatedAt: FieldRef<"AcademicSemester", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AcademicSemester findUnique
   */
  export type AcademicSemesterFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicSemester
     */
    select?: AcademicSemesterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AcademicSemester
     */
    omit?: AcademicSemesterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicSemesterInclude<ExtArgs> | null
    /**
     * Filter, which AcademicSemester to fetch.
     */
    where: AcademicSemesterWhereUniqueInput
  }

  /**
   * AcademicSemester findUniqueOrThrow
   */
  export type AcademicSemesterFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicSemester
     */
    select?: AcademicSemesterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AcademicSemester
     */
    omit?: AcademicSemesterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicSemesterInclude<ExtArgs> | null
    /**
     * Filter, which AcademicSemester to fetch.
     */
    where: AcademicSemesterWhereUniqueInput
  }

  /**
   * AcademicSemester findFirst
   */
  export type AcademicSemesterFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicSemester
     */
    select?: AcademicSemesterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AcademicSemester
     */
    omit?: AcademicSemesterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicSemesterInclude<ExtArgs> | null
    /**
     * Filter, which AcademicSemester to fetch.
     */
    where?: AcademicSemesterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AcademicSemesters to fetch.
     */
    orderBy?: AcademicSemesterOrderByWithRelationInput | AcademicSemesterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AcademicSemesters.
     */
    cursor?: AcademicSemesterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AcademicSemesters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AcademicSemesters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AcademicSemesters.
     */
    distinct?: AcademicSemesterScalarFieldEnum | AcademicSemesterScalarFieldEnum[]
  }

  /**
   * AcademicSemester findFirstOrThrow
   */
  export type AcademicSemesterFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicSemester
     */
    select?: AcademicSemesterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AcademicSemester
     */
    omit?: AcademicSemesterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicSemesterInclude<ExtArgs> | null
    /**
     * Filter, which AcademicSemester to fetch.
     */
    where?: AcademicSemesterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AcademicSemesters to fetch.
     */
    orderBy?: AcademicSemesterOrderByWithRelationInput | AcademicSemesterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AcademicSemesters.
     */
    cursor?: AcademicSemesterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AcademicSemesters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AcademicSemesters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AcademicSemesters.
     */
    distinct?: AcademicSemesterScalarFieldEnum | AcademicSemesterScalarFieldEnum[]
  }

  /**
   * AcademicSemester findMany
   */
  export type AcademicSemesterFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicSemester
     */
    select?: AcademicSemesterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AcademicSemester
     */
    omit?: AcademicSemesterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicSemesterInclude<ExtArgs> | null
    /**
     * Filter, which AcademicSemesters to fetch.
     */
    where?: AcademicSemesterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AcademicSemesters to fetch.
     */
    orderBy?: AcademicSemesterOrderByWithRelationInput | AcademicSemesterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AcademicSemesters.
     */
    cursor?: AcademicSemesterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AcademicSemesters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AcademicSemesters.
     */
    skip?: number
    distinct?: AcademicSemesterScalarFieldEnum | AcademicSemesterScalarFieldEnum[]
  }

  /**
   * AcademicSemester create
   */
  export type AcademicSemesterCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicSemester
     */
    select?: AcademicSemesterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AcademicSemester
     */
    omit?: AcademicSemesterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicSemesterInclude<ExtArgs> | null
    /**
     * The data needed to create a AcademicSemester.
     */
    data: XOR<AcademicSemesterCreateInput, AcademicSemesterUncheckedCreateInput>
  }

  /**
   * AcademicSemester createMany
   */
  export type AcademicSemesterCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AcademicSemesters.
     */
    data: AcademicSemesterCreateManyInput | AcademicSemesterCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AcademicSemester update
   */
  export type AcademicSemesterUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicSemester
     */
    select?: AcademicSemesterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AcademicSemester
     */
    omit?: AcademicSemesterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicSemesterInclude<ExtArgs> | null
    /**
     * The data needed to update a AcademicSemester.
     */
    data: XOR<AcademicSemesterUpdateInput, AcademicSemesterUncheckedUpdateInput>
    /**
     * Choose, which AcademicSemester to update.
     */
    where: AcademicSemesterWhereUniqueInput
  }

  /**
   * AcademicSemester updateMany
   */
  export type AcademicSemesterUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AcademicSemesters.
     */
    data: XOR<AcademicSemesterUpdateManyMutationInput, AcademicSemesterUncheckedUpdateManyInput>
    /**
     * Filter which AcademicSemesters to update
     */
    where?: AcademicSemesterWhereInput
    /**
     * Limit how many AcademicSemesters to update.
     */
    limit?: number
  }

  /**
   * AcademicSemester upsert
   */
  export type AcademicSemesterUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicSemester
     */
    select?: AcademicSemesterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AcademicSemester
     */
    omit?: AcademicSemesterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicSemesterInclude<ExtArgs> | null
    /**
     * The filter to search for the AcademicSemester to update in case it exists.
     */
    where: AcademicSemesterWhereUniqueInput
    /**
     * In case the AcademicSemester found by the `where` argument doesn't exist, create a new AcademicSemester with this data.
     */
    create: XOR<AcademicSemesterCreateInput, AcademicSemesterUncheckedCreateInput>
    /**
     * In case the AcademicSemester was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AcademicSemesterUpdateInput, AcademicSemesterUncheckedUpdateInput>
  }

  /**
   * AcademicSemester delete
   */
  export type AcademicSemesterDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicSemester
     */
    select?: AcademicSemesterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AcademicSemester
     */
    omit?: AcademicSemesterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicSemesterInclude<ExtArgs> | null
    /**
     * Filter which AcademicSemester to delete.
     */
    where: AcademicSemesterWhereUniqueInput
  }

  /**
   * AcademicSemester deleteMany
   */
  export type AcademicSemesterDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AcademicSemesters to delete
     */
    where?: AcademicSemesterWhereInput
    /**
     * Limit how many AcademicSemesters to delete.
     */
    limit?: number
  }

  /**
   * AcademicSemester.courseDisciplines
   */
  export type AcademicSemester$courseDisciplinesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseDiscipline
     */
    select?: CourseDisciplineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseDiscipline
     */
    omit?: CourseDisciplineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseDisciplineInclude<ExtArgs> | null
    where?: CourseDisciplineWhereInput
    orderBy?: CourseDisciplineOrderByWithRelationInput | CourseDisciplineOrderByWithRelationInput[]
    cursor?: CourseDisciplineWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CourseDisciplineScalarFieldEnum | CourseDisciplineScalarFieldEnum[]
  }

  /**
   * AcademicSemester.semesterRegistrations
   */
  export type AcademicSemester$semesterRegistrationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SemesterRegistration
     */
    select?: SemesterRegistrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SemesterRegistration
     */
    omit?: SemesterRegistrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SemesterRegistrationInclude<ExtArgs> | null
    where?: SemesterRegistrationWhereInput
    orderBy?: SemesterRegistrationOrderByWithRelationInput | SemesterRegistrationOrderByWithRelationInput[]
    cursor?: SemesterRegistrationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SemesterRegistrationScalarFieldEnum | SemesterRegistrationScalarFieldEnum[]
  }

  /**
   * AcademicSemester.students
   */
  export type AcademicSemester$studentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Student
     */
    omit?: StudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    where?: StudentWhereInput
    orderBy?: StudentOrderByWithRelationInput | StudentOrderByWithRelationInput[]
    cursor?: StudentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StudentScalarFieldEnum | StudentScalarFieldEnum[]
  }

  /**
   * AcademicSemester.studentEnrolledCourses
   */
  export type AcademicSemester$studentEnrolledCoursesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentEnrolledCourse
     */
    select?: StudentEnrolledCourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentEnrolledCourse
     */
    omit?: StudentEnrolledCourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentEnrolledCourseInclude<ExtArgs> | null
    where?: StudentEnrolledCourseWhereInput
    orderBy?: StudentEnrolledCourseOrderByWithRelationInput | StudentEnrolledCourseOrderByWithRelationInput[]
    cursor?: StudentEnrolledCourseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StudentEnrolledCourseScalarFieldEnum | StudentEnrolledCourseScalarFieldEnum[]
  }

  /**
   * AcademicSemester.studentEnrolledCourseMarks
   */
  export type AcademicSemester$studentEnrolledCourseMarksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentEnrolledCourseMark
     */
    select?: StudentEnrolledCourseMarkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentEnrolledCourseMark
     */
    omit?: StudentEnrolledCourseMarkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentEnrolledCourseMarkInclude<ExtArgs> | null
    where?: StudentEnrolledCourseMarkWhereInput
    orderBy?: StudentEnrolledCourseMarkOrderByWithRelationInput | StudentEnrolledCourseMarkOrderByWithRelationInput[]
    cursor?: StudentEnrolledCourseMarkWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StudentEnrolledCourseMarkScalarFieldEnum | StudentEnrolledCourseMarkScalarFieldEnum[]
  }

  /**
   * AcademicSemester.studentSemesterPayments
   */
  export type AcademicSemester$studentSemesterPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentSemesterPayment
     */
    select?: StudentSemesterPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentSemesterPayment
     */
    omit?: StudentSemesterPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentSemesterPaymentInclude<ExtArgs> | null
    where?: StudentSemesterPaymentWhereInput
    orderBy?: StudentSemesterPaymentOrderByWithRelationInput | StudentSemesterPaymentOrderByWithRelationInput[]
    cursor?: StudentSemesterPaymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StudentSemesterPaymentScalarFieldEnum | StudentSemesterPaymentScalarFieldEnum[]
  }

  /**
   * AcademicSemester.StudentCarriedCourse
   */
  export type AcademicSemester$StudentCarriedCourseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentCarriedCourse
     */
    select?: StudentCarriedCourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentCarriedCourse
     */
    omit?: StudentCarriedCourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentCarriedCourseInclude<ExtArgs> | null
    where?: StudentCarriedCourseWhereInput
    orderBy?: StudentCarriedCourseOrderByWithRelationInput | StudentCarriedCourseOrderByWithRelationInput[]
    cursor?: StudentCarriedCourseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StudentCarriedCourseScalarFieldEnum | StudentCarriedCourseScalarFieldEnum[]
  }

  /**
   * AcademicSemester without action
   */
  export type AcademicSemesterDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicSemester
     */
    select?: AcademicSemesterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AcademicSemester
     */
    omit?: AcademicSemesterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicSemesterInclude<ExtArgs> | null
  }


  /**
   * Model AcademicFaculty
   */

  export type AggregateAcademicFaculty = {
    _count: AcademicFacultyCountAggregateOutputType | null
    _min: AcademicFacultyMinAggregateOutputType | null
    _max: AcademicFacultyMaxAggregateOutputType | null
  }

  export type AcademicFacultyMinAggregateOutputType = {
    id: string | null
    title: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AcademicFacultyMaxAggregateOutputType = {
    id: string | null
    title: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AcademicFacultyCountAggregateOutputType = {
    id: number
    title: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AcademicFacultyMinAggregateInputType = {
    id?: true
    title?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AcademicFacultyMaxAggregateInputType = {
    id?: true
    title?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AcademicFacultyCountAggregateInputType = {
    id?: true
    title?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AcademicFacultyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AcademicFaculty to aggregate.
     */
    where?: AcademicFacultyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AcademicFaculties to fetch.
     */
    orderBy?: AcademicFacultyOrderByWithRelationInput | AcademicFacultyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AcademicFacultyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AcademicFaculties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AcademicFaculties.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AcademicFaculties
    **/
    _count?: true | AcademicFacultyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AcademicFacultyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AcademicFacultyMaxAggregateInputType
  }

  export type GetAcademicFacultyAggregateType<T extends AcademicFacultyAggregateArgs> = {
        [P in keyof T & keyof AggregateAcademicFaculty]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAcademicFaculty[P]>
      : GetScalarType<T[P], AggregateAcademicFaculty[P]>
  }




  export type AcademicFacultyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AcademicFacultyWhereInput
    orderBy?: AcademicFacultyOrderByWithAggregationInput | AcademicFacultyOrderByWithAggregationInput[]
    by: AcademicFacultyScalarFieldEnum[] | AcademicFacultyScalarFieldEnum
    having?: AcademicFacultyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AcademicFacultyCountAggregateInputType | true
    _min?: AcademicFacultyMinAggregateInputType
    _max?: AcademicFacultyMaxAggregateInputType
  }

  export type AcademicFacultyGroupByOutputType = {
    id: string
    title: string
    createdAt: Date
    updatedAt: Date
    _count: AcademicFacultyCountAggregateOutputType | null
    _min: AcademicFacultyMinAggregateOutputType | null
    _max: AcademicFacultyMaxAggregateOutputType | null
  }

  type GetAcademicFacultyGroupByPayload<T extends AcademicFacultyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AcademicFacultyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AcademicFacultyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AcademicFacultyGroupByOutputType[P]>
            : GetScalarType<T[P], AcademicFacultyGroupByOutputType[P]>
        }
      >
    >


  export type AcademicFacultySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    academicDepartments?: boolean | AcademicFaculty$academicDepartmentsArgs<ExtArgs>
    faculties?: boolean | AcademicFaculty$facultiesArgs<ExtArgs>
    students?: boolean | AcademicFaculty$studentsArgs<ExtArgs>
    admitionExame?: boolean | AcademicFaculty$admitionExameArgs<ExtArgs>
    AdmitionExamePrice?: boolean | AcademicFaculty$AdmitionExamePriceArgs<ExtArgs>
    AdmitionExamePeriod?: boolean | AcademicFaculty$AdmitionExamePeriodArgs<ExtArgs>
    _count?: boolean | AcademicFacultyCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["academicFaculty"]>



  export type AcademicFacultySelectScalar = {
    id?: boolean
    title?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AcademicFacultyOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "createdAt" | "updatedAt", ExtArgs["result"]["academicFaculty"]>
  export type AcademicFacultyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    academicDepartments?: boolean | AcademicFaculty$academicDepartmentsArgs<ExtArgs>
    faculties?: boolean | AcademicFaculty$facultiesArgs<ExtArgs>
    students?: boolean | AcademicFaculty$studentsArgs<ExtArgs>
    admitionExame?: boolean | AcademicFaculty$admitionExameArgs<ExtArgs>
    AdmitionExamePrice?: boolean | AcademicFaculty$AdmitionExamePriceArgs<ExtArgs>
    AdmitionExamePeriod?: boolean | AcademicFaculty$AdmitionExamePeriodArgs<ExtArgs>
    _count?: boolean | AcademicFacultyCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $AcademicFacultyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AcademicFaculty"
    objects: {
      academicDepartments: Prisma.$AcademicDepartmentPayload<ExtArgs>[]
      faculties: Prisma.$FacultyPayload<ExtArgs>[]
      students: Prisma.$StudentPayload<ExtArgs>[]
      admitionExame: Prisma.$AdmitionExameRegistrationPayload<ExtArgs>[]
      AdmitionExamePrice: Prisma.$AdmitionExamePricePayload<ExtArgs>[]
      AdmitionExamePeriod: Prisma.$AdmitionExamePeriodPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["academicFaculty"]>
    composites: {}
  }

  type AcademicFacultyGetPayload<S extends boolean | null | undefined | AcademicFacultyDefaultArgs> = $Result.GetResult<Prisma.$AcademicFacultyPayload, S>

  type AcademicFacultyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AcademicFacultyFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AcademicFacultyCountAggregateInputType | true
    }

  export interface AcademicFacultyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AcademicFaculty'], meta: { name: 'AcademicFaculty' } }
    /**
     * Find zero or one AcademicFaculty that matches the filter.
     * @param {AcademicFacultyFindUniqueArgs} args - Arguments to find a AcademicFaculty
     * @example
     * // Get one AcademicFaculty
     * const academicFaculty = await prisma.academicFaculty.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AcademicFacultyFindUniqueArgs>(args: SelectSubset<T, AcademicFacultyFindUniqueArgs<ExtArgs>>): Prisma__AcademicFacultyClient<$Result.GetResult<Prisma.$AcademicFacultyPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AcademicFaculty that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AcademicFacultyFindUniqueOrThrowArgs} args - Arguments to find a AcademicFaculty
     * @example
     * // Get one AcademicFaculty
     * const academicFaculty = await prisma.academicFaculty.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AcademicFacultyFindUniqueOrThrowArgs>(args: SelectSubset<T, AcademicFacultyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AcademicFacultyClient<$Result.GetResult<Prisma.$AcademicFacultyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AcademicFaculty that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AcademicFacultyFindFirstArgs} args - Arguments to find a AcademicFaculty
     * @example
     * // Get one AcademicFaculty
     * const academicFaculty = await prisma.academicFaculty.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AcademicFacultyFindFirstArgs>(args?: SelectSubset<T, AcademicFacultyFindFirstArgs<ExtArgs>>): Prisma__AcademicFacultyClient<$Result.GetResult<Prisma.$AcademicFacultyPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AcademicFaculty that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AcademicFacultyFindFirstOrThrowArgs} args - Arguments to find a AcademicFaculty
     * @example
     * // Get one AcademicFaculty
     * const academicFaculty = await prisma.academicFaculty.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AcademicFacultyFindFirstOrThrowArgs>(args?: SelectSubset<T, AcademicFacultyFindFirstOrThrowArgs<ExtArgs>>): Prisma__AcademicFacultyClient<$Result.GetResult<Prisma.$AcademicFacultyPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AcademicFaculties that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AcademicFacultyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AcademicFaculties
     * const academicFaculties = await prisma.academicFaculty.findMany()
     * 
     * // Get first 10 AcademicFaculties
     * const academicFaculties = await prisma.academicFaculty.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const academicFacultyWithIdOnly = await prisma.academicFaculty.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AcademicFacultyFindManyArgs>(args?: SelectSubset<T, AcademicFacultyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AcademicFacultyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AcademicFaculty.
     * @param {AcademicFacultyCreateArgs} args - Arguments to create a AcademicFaculty.
     * @example
     * // Create one AcademicFaculty
     * const AcademicFaculty = await prisma.academicFaculty.create({
     *   data: {
     *     // ... data to create a AcademicFaculty
     *   }
     * })
     * 
     */
    create<T extends AcademicFacultyCreateArgs>(args: SelectSubset<T, AcademicFacultyCreateArgs<ExtArgs>>): Prisma__AcademicFacultyClient<$Result.GetResult<Prisma.$AcademicFacultyPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AcademicFaculties.
     * @param {AcademicFacultyCreateManyArgs} args - Arguments to create many AcademicFaculties.
     * @example
     * // Create many AcademicFaculties
     * const academicFaculty = await prisma.academicFaculty.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AcademicFacultyCreateManyArgs>(args?: SelectSubset<T, AcademicFacultyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a AcademicFaculty.
     * @param {AcademicFacultyDeleteArgs} args - Arguments to delete one AcademicFaculty.
     * @example
     * // Delete one AcademicFaculty
     * const AcademicFaculty = await prisma.academicFaculty.delete({
     *   where: {
     *     // ... filter to delete one AcademicFaculty
     *   }
     * })
     * 
     */
    delete<T extends AcademicFacultyDeleteArgs>(args: SelectSubset<T, AcademicFacultyDeleteArgs<ExtArgs>>): Prisma__AcademicFacultyClient<$Result.GetResult<Prisma.$AcademicFacultyPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AcademicFaculty.
     * @param {AcademicFacultyUpdateArgs} args - Arguments to update one AcademicFaculty.
     * @example
     * // Update one AcademicFaculty
     * const academicFaculty = await prisma.academicFaculty.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AcademicFacultyUpdateArgs>(args: SelectSubset<T, AcademicFacultyUpdateArgs<ExtArgs>>): Prisma__AcademicFacultyClient<$Result.GetResult<Prisma.$AcademicFacultyPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AcademicFaculties.
     * @param {AcademicFacultyDeleteManyArgs} args - Arguments to filter AcademicFaculties to delete.
     * @example
     * // Delete a few AcademicFaculties
     * const { count } = await prisma.academicFaculty.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AcademicFacultyDeleteManyArgs>(args?: SelectSubset<T, AcademicFacultyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AcademicFaculties.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AcademicFacultyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AcademicFaculties
     * const academicFaculty = await prisma.academicFaculty.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AcademicFacultyUpdateManyArgs>(args: SelectSubset<T, AcademicFacultyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AcademicFaculty.
     * @param {AcademicFacultyUpsertArgs} args - Arguments to update or create a AcademicFaculty.
     * @example
     * // Update or create a AcademicFaculty
     * const academicFaculty = await prisma.academicFaculty.upsert({
     *   create: {
     *     // ... data to create a AcademicFaculty
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AcademicFaculty we want to update
     *   }
     * })
     */
    upsert<T extends AcademicFacultyUpsertArgs>(args: SelectSubset<T, AcademicFacultyUpsertArgs<ExtArgs>>): Prisma__AcademicFacultyClient<$Result.GetResult<Prisma.$AcademicFacultyPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AcademicFaculties.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AcademicFacultyCountArgs} args - Arguments to filter AcademicFaculties to count.
     * @example
     * // Count the number of AcademicFaculties
     * const count = await prisma.academicFaculty.count({
     *   where: {
     *     // ... the filter for the AcademicFaculties we want to count
     *   }
     * })
    **/
    count<T extends AcademicFacultyCountArgs>(
      args?: Subset<T, AcademicFacultyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AcademicFacultyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AcademicFaculty.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AcademicFacultyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AcademicFacultyAggregateArgs>(args: Subset<T, AcademicFacultyAggregateArgs>): Prisma.PrismaPromise<GetAcademicFacultyAggregateType<T>>

    /**
     * Group by AcademicFaculty.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AcademicFacultyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AcademicFacultyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AcademicFacultyGroupByArgs['orderBy'] }
        : { orderBy?: AcademicFacultyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AcademicFacultyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAcademicFacultyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AcademicFaculty model
   */
  readonly fields: AcademicFacultyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AcademicFaculty.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AcademicFacultyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    academicDepartments<T extends AcademicFaculty$academicDepartmentsArgs<ExtArgs> = {}>(args?: Subset<T, AcademicFaculty$academicDepartmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AcademicDepartmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    faculties<T extends AcademicFaculty$facultiesArgs<ExtArgs> = {}>(args?: Subset<T, AcademicFaculty$facultiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FacultyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    students<T extends AcademicFaculty$studentsArgs<ExtArgs> = {}>(args?: Subset<T, AcademicFaculty$studentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    admitionExame<T extends AcademicFaculty$admitionExameArgs<ExtArgs> = {}>(args?: Subset<T, AcademicFaculty$admitionExameArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdmitionExameRegistrationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    AdmitionExamePrice<T extends AcademicFaculty$AdmitionExamePriceArgs<ExtArgs> = {}>(args?: Subset<T, AcademicFaculty$AdmitionExamePriceArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdmitionExamePricePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    AdmitionExamePeriod<T extends AcademicFaculty$AdmitionExamePeriodArgs<ExtArgs> = {}>(args?: Subset<T, AcademicFaculty$AdmitionExamePeriodArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdmitionExamePeriodPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AcademicFaculty model
   */
  interface AcademicFacultyFieldRefs {
    readonly id: FieldRef<"AcademicFaculty", 'String'>
    readonly title: FieldRef<"AcademicFaculty", 'String'>
    readonly createdAt: FieldRef<"AcademicFaculty", 'DateTime'>
    readonly updatedAt: FieldRef<"AcademicFaculty", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AcademicFaculty findUnique
   */
  export type AcademicFacultyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicFaculty
     */
    select?: AcademicFacultySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AcademicFaculty
     */
    omit?: AcademicFacultyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicFacultyInclude<ExtArgs> | null
    /**
     * Filter, which AcademicFaculty to fetch.
     */
    where: AcademicFacultyWhereUniqueInput
  }

  /**
   * AcademicFaculty findUniqueOrThrow
   */
  export type AcademicFacultyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicFaculty
     */
    select?: AcademicFacultySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AcademicFaculty
     */
    omit?: AcademicFacultyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicFacultyInclude<ExtArgs> | null
    /**
     * Filter, which AcademicFaculty to fetch.
     */
    where: AcademicFacultyWhereUniqueInput
  }

  /**
   * AcademicFaculty findFirst
   */
  export type AcademicFacultyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicFaculty
     */
    select?: AcademicFacultySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AcademicFaculty
     */
    omit?: AcademicFacultyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicFacultyInclude<ExtArgs> | null
    /**
     * Filter, which AcademicFaculty to fetch.
     */
    where?: AcademicFacultyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AcademicFaculties to fetch.
     */
    orderBy?: AcademicFacultyOrderByWithRelationInput | AcademicFacultyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AcademicFaculties.
     */
    cursor?: AcademicFacultyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AcademicFaculties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AcademicFaculties.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AcademicFaculties.
     */
    distinct?: AcademicFacultyScalarFieldEnum | AcademicFacultyScalarFieldEnum[]
  }

  /**
   * AcademicFaculty findFirstOrThrow
   */
  export type AcademicFacultyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicFaculty
     */
    select?: AcademicFacultySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AcademicFaculty
     */
    omit?: AcademicFacultyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicFacultyInclude<ExtArgs> | null
    /**
     * Filter, which AcademicFaculty to fetch.
     */
    where?: AcademicFacultyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AcademicFaculties to fetch.
     */
    orderBy?: AcademicFacultyOrderByWithRelationInput | AcademicFacultyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AcademicFaculties.
     */
    cursor?: AcademicFacultyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AcademicFaculties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AcademicFaculties.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AcademicFaculties.
     */
    distinct?: AcademicFacultyScalarFieldEnum | AcademicFacultyScalarFieldEnum[]
  }

  /**
   * AcademicFaculty findMany
   */
  export type AcademicFacultyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicFaculty
     */
    select?: AcademicFacultySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AcademicFaculty
     */
    omit?: AcademicFacultyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicFacultyInclude<ExtArgs> | null
    /**
     * Filter, which AcademicFaculties to fetch.
     */
    where?: AcademicFacultyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AcademicFaculties to fetch.
     */
    orderBy?: AcademicFacultyOrderByWithRelationInput | AcademicFacultyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AcademicFaculties.
     */
    cursor?: AcademicFacultyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AcademicFaculties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AcademicFaculties.
     */
    skip?: number
    distinct?: AcademicFacultyScalarFieldEnum | AcademicFacultyScalarFieldEnum[]
  }

  /**
   * AcademicFaculty create
   */
  export type AcademicFacultyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicFaculty
     */
    select?: AcademicFacultySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AcademicFaculty
     */
    omit?: AcademicFacultyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicFacultyInclude<ExtArgs> | null
    /**
     * The data needed to create a AcademicFaculty.
     */
    data: XOR<AcademicFacultyCreateInput, AcademicFacultyUncheckedCreateInput>
  }

  /**
   * AcademicFaculty createMany
   */
  export type AcademicFacultyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AcademicFaculties.
     */
    data: AcademicFacultyCreateManyInput | AcademicFacultyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AcademicFaculty update
   */
  export type AcademicFacultyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicFaculty
     */
    select?: AcademicFacultySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AcademicFaculty
     */
    omit?: AcademicFacultyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicFacultyInclude<ExtArgs> | null
    /**
     * The data needed to update a AcademicFaculty.
     */
    data: XOR<AcademicFacultyUpdateInput, AcademicFacultyUncheckedUpdateInput>
    /**
     * Choose, which AcademicFaculty to update.
     */
    where: AcademicFacultyWhereUniqueInput
  }

  /**
   * AcademicFaculty updateMany
   */
  export type AcademicFacultyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AcademicFaculties.
     */
    data: XOR<AcademicFacultyUpdateManyMutationInput, AcademicFacultyUncheckedUpdateManyInput>
    /**
     * Filter which AcademicFaculties to update
     */
    where?: AcademicFacultyWhereInput
    /**
     * Limit how many AcademicFaculties to update.
     */
    limit?: number
  }

  /**
   * AcademicFaculty upsert
   */
  export type AcademicFacultyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicFaculty
     */
    select?: AcademicFacultySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AcademicFaculty
     */
    omit?: AcademicFacultyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicFacultyInclude<ExtArgs> | null
    /**
     * The filter to search for the AcademicFaculty to update in case it exists.
     */
    where: AcademicFacultyWhereUniqueInput
    /**
     * In case the AcademicFaculty found by the `where` argument doesn't exist, create a new AcademicFaculty with this data.
     */
    create: XOR<AcademicFacultyCreateInput, AcademicFacultyUncheckedCreateInput>
    /**
     * In case the AcademicFaculty was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AcademicFacultyUpdateInput, AcademicFacultyUncheckedUpdateInput>
  }

  /**
   * AcademicFaculty delete
   */
  export type AcademicFacultyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicFaculty
     */
    select?: AcademicFacultySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AcademicFaculty
     */
    omit?: AcademicFacultyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicFacultyInclude<ExtArgs> | null
    /**
     * Filter which AcademicFaculty to delete.
     */
    where: AcademicFacultyWhereUniqueInput
  }

  /**
   * AcademicFaculty deleteMany
   */
  export type AcademicFacultyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AcademicFaculties to delete
     */
    where?: AcademicFacultyWhereInput
    /**
     * Limit how many AcademicFaculties to delete.
     */
    limit?: number
  }

  /**
   * AcademicFaculty.academicDepartments
   */
  export type AcademicFaculty$academicDepartmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicDepartment
     */
    select?: AcademicDepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AcademicDepartment
     */
    omit?: AcademicDepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicDepartmentInclude<ExtArgs> | null
    where?: AcademicDepartmentWhereInput
    orderBy?: AcademicDepartmentOrderByWithRelationInput | AcademicDepartmentOrderByWithRelationInput[]
    cursor?: AcademicDepartmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AcademicDepartmentScalarFieldEnum | AcademicDepartmentScalarFieldEnum[]
  }

  /**
   * AcademicFaculty.faculties
   */
  export type AcademicFaculty$facultiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Faculty
     */
    select?: FacultySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Faculty
     */
    omit?: FacultyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacultyInclude<ExtArgs> | null
    where?: FacultyWhereInput
    orderBy?: FacultyOrderByWithRelationInput | FacultyOrderByWithRelationInput[]
    cursor?: FacultyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FacultyScalarFieldEnum | FacultyScalarFieldEnum[]
  }

  /**
   * AcademicFaculty.students
   */
  export type AcademicFaculty$studentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Student
     */
    omit?: StudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    where?: StudentWhereInput
    orderBy?: StudentOrderByWithRelationInput | StudentOrderByWithRelationInput[]
    cursor?: StudentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StudentScalarFieldEnum | StudentScalarFieldEnum[]
  }

  /**
   * AcademicFaculty.admitionExame
   */
  export type AcademicFaculty$admitionExameArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdmitionExameRegistration
     */
    select?: AdmitionExameRegistrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdmitionExameRegistration
     */
    omit?: AdmitionExameRegistrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdmitionExameRegistrationInclude<ExtArgs> | null
    where?: AdmitionExameRegistrationWhereInput
    orderBy?: AdmitionExameRegistrationOrderByWithRelationInput | AdmitionExameRegistrationOrderByWithRelationInput[]
    cursor?: AdmitionExameRegistrationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AdmitionExameRegistrationScalarFieldEnum | AdmitionExameRegistrationScalarFieldEnum[]
  }

  /**
   * AcademicFaculty.AdmitionExamePrice
   */
  export type AcademicFaculty$AdmitionExamePriceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdmitionExamePrice
     */
    select?: AdmitionExamePriceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdmitionExamePrice
     */
    omit?: AdmitionExamePriceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdmitionExamePriceInclude<ExtArgs> | null
    where?: AdmitionExamePriceWhereInput
    orderBy?: AdmitionExamePriceOrderByWithRelationInput | AdmitionExamePriceOrderByWithRelationInput[]
    cursor?: AdmitionExamePriceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AdmitionExamePriceScalarFieldEnum | AdmitionExamePriceScalarFieldEnum[]
  }

  /**
   * AcademicFaculty.AdmitionExamePeriod
   */
  export type AcademicFaculty$AdmitionExamePeriodArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdmitionExamePeriod
     */
    select?: AdmitionExamePeriodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdmitionExamePeriod
     */
    omit?: AdmitionExamePeriodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdmitionExamePeriodInclude<ExtArgs> | null
    where?: AdmitionExamePeriodWhereInput
    orderBy?: AdmitionExamePeriodOrderByWithRelationInput | AdmitionExamePeriodOrderByWithRelationInput[]
    cursor?: AdmitionExamePeriodWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AdmitionExamePeriodScalarFieldEnum | AdmitionExamePeriodScalarFieldEnum[]
  }

  /**
   * AcademicFaculty without action
   */
  export type AcademicFacultyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicFaculty
     */
    select?: AcademicFacultySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AcademicFaculty
     */
    omit?: AcademicFacultyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicFacultyInclude<ExtArgs> | null
  }


  /**
   * Model AcademicDepartment
   */

  export type AggregateAcademicDepartment = {
    _count: AcademicDepartmentCountAggregateOutputType | null
    _min: AcademicDepartmentMinAggregateOutputType | null
    _max: AcademicDepartmentMaxAggregateOutputType | null
  }

  export type AcademicDepartmentMinAggregateOutputType = {
    id: string | null
    title: string | null
    academicFacultyId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    departmentHeadId: string | null
  }

  export type AcademicDepartmentMaxAggregateOutputType = {
    id: string | null
    title: string | null
    academicFacultyId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    departmentHeadId: string | null
  }

  export type AcademicDepartmentCountAggregateOutputType = {
    id: number
    title: number
    academicFacultyId: number
    createdAt: number
    updatedAt: number
    departmentHeadId: number
    _all: number
  }


  export type AcademicDepartmentMinAggregateInputType = {
    id?: true
    title?: true
    academicFacultyId?: true
    createdAt?: true
    updatedAt?: true
    departmentHeadId?: true
  }

  export type AcademicDepartmentMaxAggregateInputType = {
    id?: true
    title?: true
    academicFacultyId?: true
    createdAt?: true
    updatedAt?: true
    departmentHeadId?: true
  }

  export type AcademicDepartmentCountAggregateInputType = {
    id?: true
    title?: true
    academicFacultyId?: true
    createdAt?: true
    updatedAt?: true
    departmentHeadId?: true
    _all?: true
  }

  export type AcademicDepartmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AcademicDepartment to aggregate.
     */
    where?: AcademicDepartmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AcademicDepartments to fetch.
     */
    orderBy?: AcademicDepartmentOrderByWithRelationInput | AcademicDepartmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AcademicDepartmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AcademicDepartments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AcademicDepartments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AcademicDepartments
    **/
    _count?: true | AcademicDepartmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AcademicDepartmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AcademicDepartmentMaxAggregateInputType
  }

  export type GetAcademicDepartmentAggregateType<T extends AcademicDepartmentAggregateArgs> = {
        [P in keyof T & keyof AggregateAcademicDepartment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAcademicDepartment[P]>
      : GetScalarType<T[P], AggregateAcademicDepartment[P]>
  }




  export type AcademicDepartmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AcademicDepartmentWhereInput
    orderBy?: AcademicDepartmentOrderByWithAggregationInput | AcademicDepartmentOrderByWithAggregationInput[]
    by: AcademicDepartmentScalarFieldEnum[] | AcademicDepartmentScalarFieldEnum
    having?: AcademicDepartmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AcademicDepartmentCountAggregateInputType | true
    _min?: AcademicDepartmentMinAggregateInputType
    _max?: AcademicDepartmentMaxAggregateInputType
  }

  export type AcademicDepartmentGroupByOutputType = {
    id: string
    title: string
    academicFacultyId: string
    createdAt: Date
    updatedAt: Date
    departmentHeadId: string | null
    _count: AcademicDepartmentCountAggregateOutputType | null
    _min: AcademicDepartmentMinAggregateOutputType | null
    _max: AcademicDepartmentMaxAggregateOutputType | null
  }

  type GetAcademicDepartmentGroupByPayload<T extends AcademicDepartmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AcademicDepartmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AcademicDepartmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AcademicDepartmentGroupByOutputType[P]>
            : GetScalarType<T[P], AcademicDepartmentGroupByOutputType[P]>
        }
      >
    >


  export type AcademicDepartmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    academicFacultyId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    departmentHeadId?: boolean
    academicFaculty?: boolean | AcademicFacultyDefaultArgs<ExtArgs>
    faculties?: boolean | AcademicDepartment$facultiesArgs<ExtArgs>
    courses?: boolean | AcademicDepartment$coursesArgs<ExtArgs>
    students?: boolean | AcademicDepartment$studentsArgs<ExtArgs>
    departmentHead?: boolean | AcademicDepartment$departmentHeadArgs<ExtArgs>
    staffMembers?: boolean | AcademicDepartment$staffMembersArgs<ExtArgs>
    offeredCourses?: boolean | AcademicDepartment$offeredCoursesArgs<ExtArgs>
    _count?: boolean | AcademicDepartmentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["academicDepartment"]>



  export type AcademicDepartmentSelectScalar = {
    id?: boolean
    title?: boolean
    academicFacultyId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    departmentHeadId?: boolean
  }

  export type AcademicDepartmentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "academicFacultyId" | "createdAt" | "updatedAt" | "departmentHeadId", ExtArgs["result"]["academicDepartment"]>
  export type AcademicDepartmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    academicFaculty?: boolean | AcademicFacultyDefaultArgs<ExtArgs>
    faculties?: boolean | AcademicDepartment$facultiesArgs<ExtArgs>
    courses?: boolean | AcademicDepartment$coursesArgs<ExtArgs>
    students?: boolean | AcademicDepartment$studentsArgs<ExtArgs>
    departmentHead?: boolean | AcademicDepartment$departmentHeadArgs<ExtArgs>
    staffMembers?: boolean | AcademicDepartment$staffMembersArgs<ExtArgs>
    offeredCourses?: boolean | AcademicDepartment$offeredCoursesArgs<ExtArgs>
    _count?: boolean | AcademicDepartmentCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $AcademicDepartmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AcademicDepartment"
    objects: {
      academicFaculty: Prisma.$AcademicFacultyPayload<ExtArgs>
      faculties: Prisma.$FacultyPayload<ExtArgs>[]
      courses: Prisma.$CoursePayload<ExtArgs>[]
      students: Prisma.$StudentPayload<ExtArgs>[]
      departmentHead: Prisma.$UsersPayload<ExtArgs> | null
      staffMembers: Prisma.$UsersPayload<ExtArgs>[]
      offeredCourses: Prisma.$OfferedCoursePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      academicFacultyId: string
      createdAt: Date
      updatedAt: Date
      departmentHeadId: string | null
    }, ExtArgs["result"]["academicDepartment"]>
    composites: {}
  }

  type AcademicDepartmentGetPayload<S extends boolean | null | undefined | AcademicDepartmentDefaultArgs> = $Result.GetResult<Prisma.$AcademicDepartmentPayload, S>

  type AcademicDepartmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AcademicDepartmentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AcademicDepartmentCountAggregateInputType | true
    }

  export interface AcademicDepartmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AcademicDepartment'], meta: { name: 'AcademicDepartment' } }
    /**
     * Find zero or one AcademicDepartment that matches the filter.
     * @param {AcademicDepartmentFindUniqueArgs} args - Arguments to find a AcademicDepartment
     * @example
     * // Get one AcademicDepartment
     * const academicDepartment = await prisma.academicDepartment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AcademicDepartmentFindUniqueArgs>(args: SelectSubset<T, AcademicDepartmentFindUniqueArgs<ExtArgs>>): Prisma__AcademicDepartmentClient<$Result.GetResult<Prisma.$AcademicDepartmentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AcademicDepartment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AcademicDepartmentFindUniqueOrThrowArgs} args - Arguments to find a AcademicDepartment
     * @example
     * // Get one AcademicDepartment
     * const academicDepartment = await prisma.academicDepartment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AcademicDepartmentFindUniqueOrThrowArgs>(args: SelectSubset<T, AcademicDepartmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AcademicDepartmentClient<$Result.GetResult<Prisma.$AcademicDepartmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AcademicDepartment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AcademicDepartmentFindFirstArgs} args - Arguments to find a AcademicDepartment
     * @example
     * // Get one AcademicDepartment
     * const academicDepartment = await prisma.academicDepartment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AcademicDepartmentFindFirstArgs>(args?: SelectSubset<T, AcademicDepartmentFindFirstArgs<ExtArgs>>): Prisma__AcademicDepartmentClient<$Result.GetResult<Prisma.$AcademicDepartmentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AcademicDepartment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AcademicDepartmentFindFirstOrThrowArgs} args - Arguments to find a AcademicDepartment
     * @example
     * // Get one AcademicDepartment
     * const academicDepartment = await prisma.academicDepartment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AcademicDepartmentFindFirstOrThrowArgs>(args?: SelectSubset<T, AcademicDepartmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__AcademicDepartmentClient<$Result.GetResult<Prisma.$AcademicDepartmentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AcademicDepartments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AcademicDepartmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AcademicDepartments
     * const academicDepartments = await prisma.academicDepartment.findMany()
     * 
     * // Get first 10 AcademicDepartments
     * const academicDepartments = await prisma.academicDepartment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const academicDepartmentWithIdOnly = await prisma.academicDepartment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AcademicDepartmentFindManyArgs>(args?: SelectSubset<T, AcademicDepartmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AcademicDepartmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AcademicDepartment.
     * @param {AcademicDepartmentCreateArgs} args - Arguments to create a AcademicDepartment.
     * @example
     * // Create one AcademicDepartment
     * const AcademicDepartment = await prisma.academicDepartment.create({
     *   data: {
     *     // ... data to create a AcademicDepartment
     *   }
     * })
     * 
     */
    create<T extends AcademicDepartmentCreateArgs>(args: SelectSubset<T, AcademicDepartmentCreateArgs<ExtArgs>>): Prisma__AcademicDepartmentClient<$Result.GetResult<Prisma.$AcademicDepartmentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AcademicDepartments.
     * @param {AcademicDepartmentCreateManyArgs} args - Arguments to create many AcademicDepartments.
     * @example
     * // Create many AcademicDepartments
     * const academicDepartment = await prisma.academicDepartment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AcademicDepartmentCreateManyArgs>(args?: SelectSubset<T, AcademicDepartmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a AcademicDepartment.
     * @param {AcademicDepartmentDeleteArgs} args - Arguments to delete one AcademicDepartment.
     * @example
     * // Delete one AcademicDepartment
     * const AcademicDepartment = await prisma.academicDepartment.delete({
     *   where: {
     *     // ... filter to delete one AcademicDepartment
     *   }
     * })
     * 
     */
    delete<T extends AcademicDepartmentDeleteArgs>(args: SelectSubset<T, AcademicDepartmentDeleteArgs<ExtArgs>>): Prisma__AcademicDepartmentClient<$Result.GetResult<Prisma.$AcademicDepartmentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AcademicDepartment.
     * @param {AcademicDepartmentUpdateArgs} args - Arguments to update one AcademicDepartment.
     * @example
     * // Update one AcademicDepartment
     * const academicDepartment = await prisma.academicDepartment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AcademicDepartmentUpdateArgs>(args: SelectSubset<T, AcademicDepartmentUpdateArgs<ExtArgs>>): Prisma__AcademicDepartmentClient<$Result.GetResult<Prisma.$AcademicDepartmentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AcademicDepartments.
     * @param {AcademicDepartmentDeleteManyArgs} args - Arguments to filter AcademicDepartments to delete.
     * @example
     * // Delete a few AcademicDepartments
     * const { count } = await prisma.academicDepartment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AcademicDepartmentDeleteManyArgs>(args?: SelectSubset<T, AcademicDepartmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AcademicDepartments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AcademicDepartmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AcademicDepartments
     * const academicDepartment = await prisma.academicDepartment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AcademicDepartmentUpdateManyArgs>(args: SelectSubset<T, AcademicDepartmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AcademicDepartment.
     * @param {AcademicDepartmentUpsertArgs} args - Arguments to update or create a AcademicDepartment.
     * @example
     * // Update or create a AcademicDepartment
     * const academicDepartment = await prisma.academicDepartment.upsert({
     *   create: {
     *     // ... data to create a AcademicDepartment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AcademicDepartment we want to update
     *   }
     * })
     */
    upsert<T extends AcademicDepartmentUpsertArgs>(args: SelectSubset<T, AcademicDepartmentUpsertArgs<ExtArgs>>): Prisma__AcademicDepartmentClient<$Result.GetResult<Prisma.$AcademicDepartmentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AcademicDepartments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AcademicDepartmentCountArgs} args - Arguments to filter AcademicDepartments to count.
     * @example
     * // Count the number of AcademicDepartments
     * const count = await prisma.academicDepartment.count({
     *   where: {
     *     // ... the filter for the AcademicDepartments we want to count
     *   }
     * })
    **/
    count<T extends AcademicDepartmentCountArgs>(
      args?: Subset<T, AcademicDepartmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AcademicDepartmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AcademicDepartment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AcademicDepartmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AcademicDepartmentAggregateArgs>(args: Subset<T, AcademicDepartmentAggregateArgs>): Prisma.PrismaPromise<GetAcademicDepartmentAggregateType<T>>

    /**
     * Group by AcademicDepartment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AcademicDepartmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AcademicDepartmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AcademicDepartmentGroupByArgs['orderBy'] }
        : { orderBy?: AcademicDepartmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AcademicDepartmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAcademicDepartmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AcademicDepartment model
   */
  readonly fields: AcademicDepartmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AcademicDepartment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AcademicDepartmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    academicFaculty<T extends AcademicFacultyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AcademicFacultyDefaultArgs<ExtArgs>>): Prisma__AcademicFacultyClient<$Result.GetResult<Prisma.$AcademicFacultyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    faculties<T extends AcademicDepartment$facultiesArgs<ExtArgs> = {}>(args?: Subset<T, AcademicDepartment$facultiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FacultyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    courses<T extends AcademicDepartment$coursesArgs<ExtArgs> = {}>(args?: Subset<T, AcademicDepartment$coursesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    students<T extends AcademicDepartment$studentsArgs<ExtArgs> = {}>(args?: Subset<T, AcademicDepartment$studentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    departmentHead<T extends AcademicDepartment$departmentHeadArgs<ExtArgs> = {}>(args?: Subset<T, AcademicDepartment$departmentHeadArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    staffMembers<T extends AcademicDepartment$staffMembersArgs<ExtArgs> = {}>(args?: Subset<T, AcademicDepartment$staffMembersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    offeredCourses<T extends AcademicDepartment$offeredCoursesArgs<ExtArgs> = {}>(args?: Subset<T, AcademicDepartment$offeredCoursesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OfferedCoursePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AcademicDepartment model
   */
  interface AcademicDepartmentFieldRefs {
    readonly id: FieldRef<"AcademicDepartment", 'String'>
    readonly title: FieldRef<"AcademicDepartment", 'String'>
    readonly academicFacultyId: FieldRef<"AcademicDepartment", 'String'>
    readonly createdAt: FieldRef<"AcademicDepartment", 'DateTime'>
    readonly updatedAt: FieldRef<"AcademicDepartment", 'DateTime'>
    readonly departmentHeadId: FieldRef<"AcademicDepartment", 'String'>
  }
    

  // Custom InputTypes
  /**
   * AcademicDepartment findUnique
   */
  export type AcademicDepartmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicDepartment
     */
    select?: AcademicDepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AcademicDepartment
     */
    omit?: AcademicDepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicDepartmentInclude<ExtArgs> | null
    /**
     * Filter, which AcademicDepartment to fetch.
     */
    where: AcademicDepartmentWhereUniqueInput
  }

  /**
   * AcademicDepartment findUniqueOrThrow
   */
  export type AcademicDepartmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicDepartment
     */
    select?: AcademicDepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AcademicDepartment
     */
    omit?: AcademicDepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicDepartmentInclude<ExtArgs> | null
    /**
     * Filter, which AcademicDepartment to fetch.
     */
    where: AcademicDepartmentWhereUniqueInput
  }

  /**
   * AcademicDepartment findFirst
   */
  export type AcademicDepartmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicDepartment
     */
    select?: AcademicDepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AcademicDepartment
     */
    omit?: AcademicDepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicDepartmentInclude<ExtArgs> | null
    /**
     * Filter, which AcademicDepartment to fetch.
     */
    where?: AcademicDepartmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AcademicDepartments to fetch.
     */
    orderBy?: AcademicDepartmentOrderByWithRelationInput | AcademicDepartmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AcademicDepartments.
     */
    cursor?: AcademicDepartmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AcademicDepartments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AcademicDepartments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AcademicDepartments.
     */
    distinct?: AcademicDepartmentScalarFieldEnum | AcademicDepartmentScalarFieldEnum[]
  }

  /**
   * AcademicDepartment findFirstOrThrow
   */
  export type AcademicDepartmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicDepartment
     */
    select?: AcademicDepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AcademicDepartment
     */
    omit?: AcademicDepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicDepartmentInclude<ExtArgs> | null
    /**
     * Filter, which AcademicDepartment to fetch.
     */
    where?: AcademicDepartmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AcademicDepartments to fetch.
     */
    orderBy?: AcademicDepartmentOrderByWithRelationInput | AcademicDepartmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AcademicDepartments.
     */
    cursor?: AcademicDepartmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AcademicDepartments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AcademicDepartments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AcademicDepartments.
     */
    distinct?: AcademicDepartmentScalarFieldEnum | AcademicDepartmentScalarFieldEnum[]
  }

  /**
   * AcademicDepartment findMany
   */
  export type AcademicDepartmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicDepartment
     */
    select?: AcademicDepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AcademicDepartment
     */
    omit?: AcademicDepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicDepartmentInclude<ExtArgs> | null
    /**
     * Filter, which AcademicDepartments to fetch.
     */
    where?: AcademicDepartmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AcademicDepartments to fetch.
     */
    orderBy?: AcademicDepartmentOrderByWithRelationInput | AcademicDepartmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AcademicDepartments.
     */
    cursor?: AcademicDepartmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AcademicDepartments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AcademicDepartments.
     */
    skip?: number
    distinct?: AcademicDepartmentScalarFieldEnum | AcademicDepartmentScalarFieldEnum[]
  }

  /**
   * AcademicDepartment create
   */
  export type AcademicDepartmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicDepartment
     */
    select?: AcademicDepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AcademicDepartment
     */
    omit?: AcademicDepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicDepartmentInclude<ExtArgs> | null
    /**
     * The data needed to create a AcademicDepartment.
     */
    data: XOR<AcademicDepartmentCreateInput, AcademicDepartmentUncheckedCreateInput>
  }

  /**
   * AcademicDepartment createMany
   */
  export type AcademicDepartmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AcademicDepartments.
     */
    data: AcademicDepartmentCreateManyInput | AcademicDepartmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AcademicDepartment update
   */
  export type AcademicDepartmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicDepartment
     */
    select?: AcademicDepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AcademicDepartment
     */
    omit?: AcademicDepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicDepartmentInclude<ExtArgs> | null
    /**
     * The data needed to update a AcademicDepartment.
     */
    data: XOR<AcademicDepartmentUpdateInput, AcademicDepartmentUncheckedUpdateInput>
    /**
     * Choose, which AcademicDepartment to update.
     */
    where: AcademicDepartmentWhereUniqueInput
  }

  /**
   * AcademicDepartment updateMany
   */
  export type AcademicDepartmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AcademicDepartments.
     */
    data: XOR<AcademicDepartmentUpdateManyMutationInput, AcademicDepartmentUncheckedUpdateManyInput>
    /**
     * Filter which AcademicDepartments to update
     */
    where?: AcademicDepartmentWhereInput
    /**
     * Limit how many AcademicDepartments to update.
     */
    limit?: number
  }

  /**
   * AcademicDepartment upsert
   */
  export type AcademicDepartmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicDepartment
     */
    select?: AcademicDepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AcademicDepartment
     */
    omit?: AcademicDepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicDepartmentInclude<ExtArgs> | null
    /**
     * The filter to search for the AcademicDepartment to update in case it exists.
     */
    where: AcademicDepartmentWhereUniqueInput
    /**
     * In case the AcademicDepartment found by the `where` argument doesn't exist, create a new AcademicDepartment with this data.
     */
    create: XOR<AcademicDepartmentCreateInput, AcademicDepartmentUncheckedCreateInput>
    /**
     * In case the AcademicDepartment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AcademicDepartmentUpdateInput, AcademicDepartmentUncheckedUpdateInput>
  }

  /**
   * AcademicDepartment delete
   */
  export type AcademicDepartmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicDepartment
     */
    select?: AcademicDepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AcademicDepartment
     */
    omit?: AcademicDepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicDepartmentInclude<ExtArgs> | null
    /**
     * Filter which AcademicDepartment to delete.
     */
    where: AcademicDepartmentWhereUniqueInput
  }

  /**
   * AcademicDepartment deleteMany
   */
  export type AcademicDepartmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AcademicDepartments to delete
     */
    where?: AcademicDepartmentWhereInput
    /**
     * Limit how many AcademicDepartments to delete.
     */
    limit?: number
  }

  /**
   * AcademicDepartment.faculties
   */
  export type AcademicDepartment$facultiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Faculty
     */
    select?: FacultySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Faculty
     */
    omit?: FacultyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacultyInclude<ExtArgs> | null
    where?: FacultyWhereInput
    orderBy?: FacultyOrderByWithRelationInput | FacultyOrderByWithRelationInput[]
    cursor?: FacultyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FacultyScalarFieldEnum | FacultyScalarFieldEnum[]
  }

  /**
   * AcademicDepartment.courses
   */
  export type AcademicDepartment$coursesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Course
     */
    omit?: CourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    where?: CourseWhereInput
    orderBy?: CourseOrderByWithRelationInput | CourseOrderByWithRelationInput[]
    cursor?: CourseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CourseScalarFieldEnum | CourseScalarFieldEnum[]
  }

  /**
   * AcademicDepartment.students
   */
  export type AcademicDepartment$studentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Student
     */
    omit?: StudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    where?: StudentWhereInput
    orderBy?: StudentOrderByWithRelationInput | StudentOrderByWithRelationInput[]
    cursor?: StudentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StudentScalarFieldEnum | StudentScalarFieldEnum[]
  }

  /**
   * AcademicDepartment.departmentHead
   */
  export type AcademicDepartment$departmentHeadArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Users
     */
    omit?: UsersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersInclude<ExtArgs> | null
    where?: UsersWhereInput
  }

  /**
   * AcademicDepartment.staffMembers
   */
  export type AcademicDepartment$staffMembersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Users
     */
    omit?: UsersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersInclude<ExtArgs> | null
    where?: UsersWhereInput
    orderBy?: UsersOrderByWithRelationInput | UsersOrderByWithRelationInput[]
    cursor?: UsersWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * AcademicDepartment.offeredCourses
   */
  export type AcademicDepartment$offeredCoursesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OfferedCourse
     */
    select?: OfferedCourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OfferedCourse
     */
    omit?: OfferedCourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OfferedCourseInclude<ExtArgs> | null
    where?: OfferedCourseWhereInput
    orderBy?: OfferedCourseOrderByWithRelationInput | OfferedCourseOrderByWithRelationInput[]
    cursor?: OfferedCourseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OfferedCourseScalarFieldEnum | OfferedCourseScalarFieldEnum[]
  }

  /**
   * AcademicDepartment without action
   */
  export type AcademicDepartmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicDepartment
     */
    select?: AcademicDepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AcademicDepartment
     */
    omit?: AcademicDepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicDepartmentInclude<ExtArgs> | null
  }


  /**
   * Model Student
   */

  export type AggregateStudent = {
    _count: StudentCountAggregateOutputType | null
    _min: StudentMinAggregateOutputType | null
    _max: StudentMaxAggregateOutputType | null
  }

  export type StudentMinAggregateOutputType = {
    id: string | null
    studentId: string | null
    studentType: $Enums.StudentType | null
    firstName: string | null
    middleName: string | null
    lastName: string | null
    profileImage: string | null
    email: string | null
    contactNo: string | null
    gender: string | null
    isWoker: boolean | null
    shift: $Enums.Shift | null
    yearLevel: $Enums.YearLevel | null
    isActive: boolean | null
    password: string | null
    gradeDeclarationFile: string | null
    biFile: string | null
    presentAddress: string | null
    permanentAddress: string | null
    academicSemesterId: string | null
    academicFacultyId: string | null
    academicDepartmentId: string | null
    admissionRegistrationId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StudentMaxAggregateOutputType = {
    id: string | null
    studentId: string | null
    studentType: $Enums.StudentType | null
    firstName: string | null
    middleName: string | null
    lastName: string | null
    profileImage: string | null
    email: string | null
    contactNo: string | null
    gender: string | null
    isWoker: boolean | null
    shift: $Enums.Shift | null
    yearLevel: $Enums.YearLevel | null
    isActive: boolean | null
    password: string | null
    gradeDeclarationFile: string | null
    biFile: string | null
    presentAddress: string | null
    permanentAddress: string | null
    academicSemesterId: string | null
    academicFacultyId: string | null
    academicDepartmentId: string | null
    admissionRegistrationId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StudentCountAggregateOutputType = {
    id: number
    studentId: number
    studentType: number
    firstName: number
    middleName: number
    lastName: number
    profileImage: number
    email: number
    contactNo: number
    gender: number
    isWoker: number
    shift: number
    yearLevel: number
    isActive: number
    password: number
    gradeDeclarationFile: number
    biFile: number
    presentAddress: number
    permanentAddress: number
    academicSemesterId: number
    academicFacultyId: number
    academicDepartmentId: number
    admissionRegistrationId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type StudentMinAggregateInputType = {
    id?: true
    studentId?: true
    studentType?: true
    firstName?: true
    middleName?: true
    lastName?: true
    profileImage?: true
    email?: true
    contactNo?: true
    gender?: true
    isWoker?: true
    shift?: true
    yearLevel?: true
    isActive?: true
    password?: true
    gradeDeclarationFile?: true
    biFile?: true
    presentAddress?: true
    permanentAddress?: true
    academicSemesterId?: true
    academicFacultyId?: true
    academicDepartmentId?: true
    admissionRegistrationId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StudentMaxAggregateInputType = {
    id?: true
    studentId?: true
    studentType?: true
    firstName?: true
    middleName?: true
    lastName?: true
    profileImage?: true
    email?: true
    contactNo?: true
    gender?: true
    isWoker?: true
    shift?: true
    yearLevel?: true
    isActive?: true
    password?: true
    gradeDeclarationFile?: true
    biFile?: true
    presentAddress?: true
    permanentAddress?: true
    academicSemesterId?: true
    academicFacultyId?: true
    academicDepartmentId?: true
    admissionRegistrationId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StudentCountAggregateInputType = {
    id?: true
    studentId?: true
    studentType?: true
    firstName?: true
    middleName?: true
    lastName?: true
    profileImage?: true
    email?: true
    contactNo?: true
    gender?: true
    isWoker?: true
    shift?: true
    yearLevel?: true
    isActive?: true
    password?: true
    gradeDeclarationFile?: true
    biFile?: true
    presentAddress?: true
    permanentAddress?: true
    academicSemesterId?: true
    academicFacultyId?: true
    academicDepartmentId?: true
    admissionRegistrationId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type StudentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Student to aggregate.
     */
    where?: StudentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Students to fetch.
     */
    orderBy?: StudentOrderByWithRelationInput | StudentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StudentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Students from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Students.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Students
    **/
    _count?: true | StudentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StudentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StudentMaxAggregateInputType
  }

  export type GetStudentAggregateType<T extends StudentAggregateArgs> = {
        [P in keyof T & keyof AggregateStudent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStudent[P]>
      : GetScalarType<T[P], AggregateStudent[P]>
  }




  export type StudentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentWhereInput
    orderBy?: StudentOrderByWithAggregationInput | StudentOrderByWithAggregationInput[]
    by: StudentScalarFieldEnum[] | StudentScalarFieldEnum
    having?: StudentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StudentCountAggregateInputType | true
    _min?: StudentMinAggregateInputType
    _max?: StudentMaxAggregateInputType
  }

  export type StudentGroupByOutputType = {
    id: string
    studentId: string
    studentType: $Enums.StudentType
    firstName: string
    middleName: string | null
    lastName: string
    profileImage: string | null
    email: string | null
    contactNo: string | null
    gender: string
    isWoker: boolean
    shift: $Enums.Shift
    yearLevel: $Enums.YearLevel
    isActive: boolean
    password: string
    gradeDeclarationFile: string
    biFile: string
    presentAddress: string
    permanentAddress: string | null
    academicSemesterId: string
    academicFacultyId: string
    academicDepartmentId: string
    admissionRegistrationId: string | null
    createdAt: Date
    updatedAt: Date
    _count: StudentCountAggregateOutputType | null
    _min: StudentMinAggregateOutputType | null
    _max: StudentMaxAggregateOutputType | null
  }

  type GetStudentGroupByPayload<T extends StudentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StudentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StudentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StudentGroupByOutputType[P]>
            : GetScalarType<T[P], StudentGroupByOutputType[P]>
        }
      >
    >


  export type StudentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    studentType?: boolean
    firstName?: boolean
    middleName?: boolean
    lastName?: boolean
    profileImage?: boolean
    email?: boolean
    contactNo?: boolean
    gender?: boolean
    isWoker?: boolean
    shift?: boolean
    yearLevel?: boolean
    isActive?: boolean
    password?: boolean
    gradeDeclarationFile?: boolean
    biFile?: boolean
    presentAddress?: boolean
    permanentAddress?: boolean
    academicSemesterId?: boolean
    academicFacultyId?: boolean
    academicDepartmentId?: boolean
    admissionRegistrationId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    academicFaculty?: boolean | AcademicFacultyDefaultArgs<ExtArgs>
    admissionRegistration?: boolean | Student$admissionRegistrationArgs<ExtArgs>
    academicDepartment?: boolean | AcademicDepartmentDefaultArgs<ExtArgs>
    academicSemester?: boolean | AcademicSemesterDefaultArgs<ExtArgs>
    studentSemesterRegistrations?: boolean | Student$studentSemesterRegistrationsArgs<ExtArgs>
    studentSemesterRegistrationCourses?: boolean | Student$studentSemesterRegistrationCoursesArgs<ExtArgs>
    studentEnrolledCourses?: boolean | Student$studentEnrolledCoursesArgs<ExtArgs>
    studentEnrolledCourseMarks?: boolean | Student$studentEnrolledCourseMarksArgs<ExtArgs>
    studentSemesterPayments?: boolean | Student$studentSemesterPaymentsArgs<ExtArgs>
    studentAcademicInfos?: boolean | Student$studentAcademicInfosArgs<ExtArgs>
    StudentCarriedCourse?: boolean | Student$StudentCarriedCourseArgs<ExtArgs>
    _count?: boolean | StudentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["student"]>



  export type StudentSelectScalar = {
    id?: boolean
    studentId?: boolean
    studentType?: boolean
    firstName?: boolean
    middleName?: boolean
    lastName?: boolean
    profileImage?: boolean
    email?: boolean
    contactNo?: boolean
    gender?: boolean
    isWoker?: boolean
    shift?: boolean
    yearLevel?: boolean
    isActive?: boolean
    password?: boolean
    gradeDeclarationFile?: boolean
    biFile?: boolean
    presentAddress?: boolean
    permanentAddress?: boolean
    academicSemesterId?: boolean
    academicFacultyId?: boolean
    academicDepartmentId?: boolean
    admissionRegistrationId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type StudentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "studentId" | "studentType" | "firstName" | "middleName" | "lastName" | "profileImage" | "email" | "contactNo" | "gender" | "isWoker" | "shift" | "yearLevel" | "isActive" | "password" | "gradeDeclarationFile" | "biFile" | "presentAddress" | "permanentAddress" | "academicSemesterId" | "academicFacultyId" | "academicDepartmentId" | "admissionRegistrationId" | "createdAt" | "updatedAt", ExtArgs["result"]["student"]>
  export type StudentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    academicFaculty?: boolean | AcademicFacultyDefaultArgs<ExtArgs>
    admissionRegistration?: boolean | Student$admissionRegistrationArgs<ExtArgs>
    academicDepartment?: boolean | AcademicDepartmentDefaultArgs<ExtArgs>
    academicSemester?: boolean | AcademicSemesterDefaultArgs<ExtArgs>
    studentSemesterRegistrations?: boolean | Student$studentSemesterRegistrationsArgs<ExtArgs>
    studentSemesterRegistrationCourses?: boolean | Student$studentSemesterRegistrationCoursesArgs<ExtArgs>
    studentEnrolledCourses?: boolean | Student$studentEnrolledCoursesArgs<ExtArgs>
    studentEnrolledCourseMarks?: boolean | Student$studentEnrolledCourseMarksArgs<ExtArgs>
    studentSemesterPayments?: boolean | Student$studentSemesterPaymentsArgs<ExtArgs>
    studentAcademicInfos?: boolean | Student$studentAcademicInfosArgs<ExtArgs>
    StudentCarriedCourse?: boolean | Student$StudentCarriedCourseArgs<ExtArgs>
    _count?: boolean | StudentCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $StudentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Student"
    objects: {
      academicFaculty: Prisma.$AcademicFacultyPayload<ExtArgs>
      admissionRegistration: Prisma.$AdmitionExameRegistrationPayload<ExtArgs> | null
      academicDepartment: Prisma.$AcademicDepartmentPayload<ExtArgs>
      academicSemester: Prisma.$AcademicSemesterPayload<ExtArgs>
      studentSemesterRegistrations: Prisma.$StudentSemesterRegistrationPayload<ExtArgs>[]
      studentSemesterRegistrationCourses: Prisma.$StudentSemesterRegistrationCoursePayload<ExtArgs>[]
      studentEnrolledCourses: Prisma.$StudentEnrolledCoursePayload<ExtArgs>[]
      studentEnrolledCourseMarks: Prisma.$StudentEnrolledCourseMarkPayload<ExtArgs>[]
      studentSemesterPayments: Prisma.$StudentSemesterPaymentPayload<ExtArgs>[]
      studentAcademicInfos: Prisma.$StudentAcademicInfoPayload<ExtArgs>[]
      StudentCarriedCourse: Prisma.$StudentCarriedCoursePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      studentId: string
      studentType: $Enums.StudentType
      firstName: string
      middleName: string | null
      lastName: string
      profileImage: string | null
      email: string | null
      contactNo: string | null
      gender: string
      isWoker: boolean
      shift: $Enums.Shift
      yearLevel: $Enums.YearLevel
      isActive: boolean
      password: string
      gradeDeclarationFile: string
      biFile: string
      presentAddress: string
      permanentAddress: string | null
      academicSemesterId: string
      academicFacultyId: string
      academicDepartmentId: string
      admissionRegistrationId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["student"]>
    composites: {}
  }

  type StudentGetPayload<S extends boolean | null | undefined | StudentDefaultArgs> = $Result.GetResult<Prisma.$StudentPayload, S>

  type StudentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<StudentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: StudentCountAggregateInputType | true
    }

  export interface StudentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Student'], meta: { name: 'Student' } }
    /**
     * Find zero or one Student that matches the filter.
     * @param {StudentFindUniqueArgs} args - Arguments to find a Student
     * @example
     * // Get one Student
     * const student = await prisma.student.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StudentFindUniqueArgs>(args: SelectSubset<T, StudentFindUniqueArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Student that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {StudentFindUniqueOrThrowArgs} args - Arguments to find a Student
     * @example
     * // Get one Student
     * const student = await prisma.student.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StudentFindUniqueOrThrowArgs>(args: SelectSubset<T, StudentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Student that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentFindFirstArgs} args - Arguments to find a Student
     * @example
     * // Get one Student
     * const student = await prisma.student.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StudentFindFirstArgs>(args?: SelectSubset<T, StudentFindFirstArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Student that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentFindFirstOrThrowArgs} args - Arguments to find a Student
     * @example
     * // Get one Student
     * const student = await prisma.student.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StudentFindFirstOrThrowArgs>(args?: SelectSubset<T, StudentFindFirstOrThrowArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Students that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Students
     * const students = await prisma.student.findMany()
     * 
     * // Get first 10 Students
     * const students = await prisma.student.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const studentWithIdOnly = await prisma.student.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StudentFindManyArgs>(args?: SelectSubset<T, StudentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Student.
     * @param {StudentCreateArgs} args - Arguments to create a Student.
     * @example
     * // Create one Student
     * const Student = await prisma.student.create({
     *   data: {
     *     // ... data to create a Student
     *   }
     * })
     * 
     */
    create<T extends StudentCreateArgs>(args: SelectSubset<T, StudentCreateArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Students.
     * @param {StudentCreateManyArgs} args - Arguments to create many Students.
     * @example
     * // Create many Students
     * const student = await prisma.student.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StudentCreateManyArgs>(args?: SelectSubset<T, StudentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Student.
     * @param {StudentDeleteArgs} args - Arguments to delete one Student.
     * @example
     * // Delete one Student
     * const Student = await prisma.student.delete({
     *   where: {
     *     // ... filter to delete one Student
     *   }
     * })
     * 
     */
    delete<T extends StudentDeleteArgs>(args: SelectSubset<T, StudentDeleteArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Student.
     * @param {StudentUpdateArgs} args - Arguments to update one Student.
     * @example
     * // Update one Student
     * const student = await prisma.student.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StudentUpdateArgs>(args: SelectSubset<T, StudentUpdateArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Students.
     * @param {StudentDeleteManyArgs} args - Arguments to filter Students to delete.
     * @example
     * // Delete a few Students
     * const { count } = await prisma.student.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StudentDeleteManyArgs>(args?: SelectSubset<T, StudentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Students.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Students
     * const student = await prisma.student.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StudentUpdateManyArgs>(args: SelectSubset<T, StudentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Student.
     * @param {StudentUpsertArgs} args - Arguments to update or create a Student.
     * @example
     * // Update or create a Student
     * const student = await prisma.student.upsert({
     *   create: {
     *     // ... data to create a Student
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Student we want to update
     *   }
     * })
     */
    upsert<T extends StudentUpsertArgs>(args: SelectSubset<T, StudentUpsertArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Students.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentCountArgs} args - Arguments to filter Students to count.
     * @example
     * // Count the number of Students
     * const count = await prisma.student.count({
     *   where: {
     *     // ... the filter for the Students we want to count
     *   }
     * })
    **/
    count<T extends StudentCountArgs>(
      args?: Subset<T, StudentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StudentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Student.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StudentAggregateArgs>(args: Subset<T, StudentAggregateArgs>): Prisma.PrismaPromise<GetStudentAggregateType<T>>

    /**
     * Group by Student.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StudentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StudentGroupByArgs['orderBy'] }
        : { orderBy?: StudentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StudentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStudentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Student model
   */
  readonly fields: StudentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Student.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StudentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    academicFaculty<T extends AcademicFacultyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AcademicFacultyDefaultArgs<ExtArgs>>): Prisma__AcademicFacultyClient<$Result.GetResult<Prisma.$AcademicFacultyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    admissionRegistration<T extends Student$admissionRegistrationArgs<ExtArgs> = {}>(args?: Subset<T, Student$admissionRegistrationArgs<ExtArgs>>): Prisma__AdmitionExameRegistrationClient<$Result.GetResult<Prisma.$AdmitionExameRegistrationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    academicDepartment<T extends AcademicDepartmentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AcademicDepartmentDefaultArgs<ExtArgs>>): Prisma__AcademicDepartmentClient<$Result.GetResult<Prisma.$AcademicDepartmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    academicSemester<T extends AcademicSemesterDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AcademicSemesterDefaultArgs<ExtArgs>>): Prisma__AcademicSemesterClient<$Result.GetResult<Prisma.$AcademicSemesterPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    studentSemesterRegistrations<T extends Student$studentSemesterRegistrationsArgs<ExtArgs> = {}>(args?: Subset<T, Student$studentSemesterRegistrationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentSemesterRegistrationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    studentSemesterRegistrationCourses<T extends Student$studentSemesterRegistrationCoursesArgs<ExtArgs> = {}>(args?: Subset<T, Student$studentSemesterRegistrationCoursesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentSemesterRegistrationCoursePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    studentEnrolledCourses<T extends Student$studentEnrolledCoursesArgs<ExtArgs> = {}>(args?: Subset<T, Student$studentEnrolledCoursesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentEnrolledCoursePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    studentEnrolledCourseMarks<T extends Student$studentEnrolledCourseMarksArgs<ExtArgs> = {}>(args?: Subset<T, Student$studentEnrolledCourseMarksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentEnrolledCourseMarkPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    studentSemesterPayments<T extends Student$studentSemesterPaymentsArgs<ExtArgs> = {}>(args?: Subset<T, Student$studentSemesterPaymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentSemesterPaymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    studentAcademicInfos<T extends Student$studentAcademicInfosArgs<ExtArgs> = {}>(args?: Subset<T, Student$studentAcademicInfosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentAcademicInfoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    StudentCarriedCourse<T extends Student$StudentCarriedCourseArgs<ExtArgs> = {}>(args?: Subset<T, Student$StudentCarriedCourseArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentCarriedCoursePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Student model
   */
  interface StudentFieldRefs {
    readonly id: FieldRef<"Student", 'String'>
    readonly studentId: FieldRef<"Student", 'String'>
    readonly studentType: FieldRef<"Student", 'StudentType'>
    readonly firstName: FieldRef<"Student", 'String'>
    readonly middleName: FieldRef<"Student", 'String'>
    readonly lastName: FieldRef<"Student", 'String'>
    readonly profileImage: FieldRef<"Student", 'String'>
    readonly email: FieldRef<"Student", 'String'>
    readonly contactNo: FieldRef<"Student", 'String'>
    readonly gender: FieldRef<"Student", 'String'>
    readonly isWoker: FieldRef<"Student", 'Boolean'>
    readonly shift: FieldRef<"Student", 'Shift'>
    readonly yearLevel: FieldRef<"Student", 'YearLevel'>
    readonly isActive: FieldRef<"Student", 'Boolean'>
    readonly password: FieldRef<"Student", 'String'>
    readonly gradeDeclarationFile: FieldRef<"Student", 'String'>
    readonly biFile: FieldRef<"Student", 'String'>
    readonly presentAddress: FieldRef<"Student", 'String'>
    readonly permanentAddress: FieldRef<"Student", 'String'>
    readonly academicSemesterId: FieldRef<"Student", 'String'>
    readonly academicFacultyId: FieldRef<"Student", 'String'>
    readonly academicDepartmentId: FieldRef<"Student", 'String'>
    readonly admissionRegistrationId: FieldRef<"Student", 'String'>
    readonly createdAt: FieldRef<"Student", 'DateTime'>
    readonly updatedAt: FieldRef<"Student", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Student findUnique
   */
  export type StudentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Student
     */
    omit?: StudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    /**
     * Filter, which Student to fetch.
     */
    where: StudentWhereUniqueInput
  }

  /**
   * Student findUniqueOrThrow
   */
  export type StudentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Student
     */
    omit?: StudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    /**
     * Filter, which Student to fetch.
     */
    where: StudentWhereUniqueInput
  }

  /**
   * Student findFirst
   */
  export type StudentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Student
     */
    omit?: StudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    /**
     * Filter, which Student to fetch.
     */
    where?: StudentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Students to fetch.
     */
    orderBy?: StudentOrderByWithRelationInput | StudentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Students.
     */
    cursor?: StudentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Students from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Students.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Students.
     */
    distinct?: StudentScalarFieldEnum | StudentScalarFieldEnum[]
  }

  /**
   * Student findFirstOrThrow
   */
  export type StudentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Student
     */
    omit?: StudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    /**
     * Filter, which Student to fetch.
     */
    where?: StudentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Students to fetch.
     */
    orderBy?: StudentOrderByWithRelationInput | StudentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Students.
     */
    cursor?: StudentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Students from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Students.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Students.
     */
    distinct?: StudentScalarFieldEnum | StudentScalarFieldEnum[]
  }

  /**
   * Student findMany
   */
  export type StudentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Student
     */
    omit?: StudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    /**
     * Filter, which Students to fetch.
     */
    where?: StudentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Students to fetch.
     */
    orderBy?: StudentOrderByWithRelationInput | StudentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Students.
     */
    cursor?: StudentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Students from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Students.
     */
    skip?: number
    distinct?: StudentScalarFieldEnum | StudentScalarFieldEnum[]
  }

  /**
   * Student create
   */
  export type StudentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Student
     */
    omit?: StudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    /**
     * The data needed to create a Student.
     */
    data: XOR<StudentCreateInput, StudentUncheckedCreateInput>
  }

  /**
   * Student createMany
   */
  export type StudentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Students.
     */
    data: StudentCreateManyInput | StudentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Student update
   */
  export type StudentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Student
     */
    omit?: StudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    /**
     * The data needed to update a Student.
     */
    data: XOR<StudentUpdateInput, StudentUncheckedUpdateInput>
    /**
     * Choose, which Student to update.
     */
    where: StudentWhereUniqueInput
  }

  /**
   * Student updateMany
   */
  export type StudentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Students.
     */
    data: XOR<StudentUpdateManyMutationInput, StudentUncheckedUpdateManyInput>
    /**
     * Filter which Students to update
     */
    where?: StudentWhereInput
    /**
     * Limit how many Students to update.
     */
    limit?: number
  }

  /**
   * Student upsert
   */
  export type StudentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Student
     */
    omit?: StudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    /**
     * The filter to search for the Student to update in case it exists.
     */
    where: StudentWhereUniqueInput
    /**
     * In case the Student found by the `where` argument doesn't exist, create a new Student with this data.
     */
    create: XOR<StudentCreateInput, StudentUncheckedCreateInput>
    /**
     * In case the Student was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StudentUpdateInput, StudentUncheckedUpdateInput>
  }

  /**
   * Student delete
   */
  export type StudentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Student
     */
    omit?: StudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    /**
     * Filter which Student to delete.
     */
    where: StudentWhereUniqueInput
  }

  /**
   * Student deleteMany
   */
  export type StudentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Students to delete
     */
    where?: StudentWhereInput
    /**
     * Limit how many Students to delete.
     */
    limit?: number
  }

  /**
   * Student.admissionRegistration
   */
  export type Student$admissionRegistrationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdmitionExameRegistration
     */
    select?: AdmitionExameRegistrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdmitionExameRegistration
     */
    omit?: AdmitionExameRegistrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdmitionExameRegistrationInclude<ExtArgs> | null
    where?: AdmitionExameRegistrationWhereInput
  }

  /**
   * Student.studentSemesterRegistrations
   */
  export type Student$studentSemesterRegistrationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentSemesterRegistration
     */
    select?: StudentSemesterRegistrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentSemesterRegistration
     */
    omit?: StudentSemesterRegistrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentSemesterRegistrationInclude<ExtArgs> | null
    where?: StudentSemesterRegistrationWhereInput
    orderBy?: StudentSemesterRegistrationOrderByWithRelationInput | StudentSemesterRegistrationOrderByWithRelationInput[]
    cursor?: StudentSemesterRegistrationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StudentSemesterRegistrationScalarFieldEnum | StudentSemesterRegistrationScalarFieldEnum[]
  }

  /**
   * Student.studentSemesterRegistrationCourses
   */
  export type Student$studentSemesterRegistrationCoursesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentSemesterRegistrationCourse
     */
    select?: StudentSemesterRegistrationCourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentSemesterRegistrationCourse
     */
    omit?: StudentSemesterRegistrationCourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentSemesterRegistrationCourseInclude<ExtArgs> | null
    where?: StudentSemesterRegistrationCourseWhereInput
    orderBy?: StudentSemesterRegistrationCourseOrderByWithRelationInput | StudentSemesterRegistrationCourseOrderByWithRelationInput[]
    cursor?: StudentSemesterRegistrationCourseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StudentSemesterRegistrationCourseScalarFieldEnum | StudentSemesterRegistrationCourseScalarFieldEnum[]
  }

  /**
   * Student.studentEnrolledCourses
   */
  export type Student$studentEnrolledCoursesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentEnrolledCourse
     */
    select?: StudentEnrolledCourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentEnrolledCourse
     */
    omit?: StudentEnrolledCourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentEnrolledCourseInclude<ExtArgs> | null
    where?: StudentEnrolledCourseWhereInput
    orderBy?: StudentEnrolledCourseOrderByWithRelationInput | StudentEnrolledCourseOrderByWithRelationInput[]
    cursor?: StudentEnrolledCourseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StudentEnrolledCourseScalarFieldEnum | StudentEnrolledCourseScalarFieldEnum[]
  }

  /**
   * Student.studentEnrolledCourseMarks
   */
  export type Student$studentEnrolledCourseMarksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentEnrolledCourseMark
     */
    select?: StudentEnrolledCourseMarkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentEnrolledCourseMark
     */
    omit?: StudentEnrolledCourseMarkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentEnrolledCourseMarkInclude<ExtArgs> | null
    where?: StudentEnrolledCourseMarkWhereInput
    orderBy?: StudentEnrolledCourseMarkOrderByWithRelationInput | StudentEnrolledCourseMarkOrderByWithRelationInput[]
    cursor?: StudentEnrolledCourseMarkWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StudentEnrolledCourseMarkScalarFieldEnum | StudentEnrolledCourseMarkScalarFieldEnum[]
  }

  /**
   * Student.studentSemesterPayments
   */
  export type Student$studentSemesterPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentSemesterPayment
     */
    select?: StudentSemesterPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentSemesterPayment
     */
    omit?: StudentSemesterPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentSemesterPaymentInclude<ExtArgs> | null
    where?: StudentSemesterPaymentWhereInput
    orderBy?: StudentSemesterPaymentOrderByWithRelationInput | StudentSemesterPaymentOrderByWithRelationInput[]
    cursor?: StudentSemesterPaymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StudentSemesterPaymentScalarFieldEnum | StudentSemesterPaymentScalarFieldEnum[]
  }

  /**
   * Student.studentAcademicInfos
   */
  export type Student$studentAcademicInfosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentAcademicInfo
     */
    select?: StudentAcademicInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentAcademicInfo
     */
    omit?: StudentAcademicInfoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentAcademicInfoInclude<ExtArgs> | null
    where?: StudentAcademicInfoWhereInput
    orderBy?: StudentAcademicInfoOrderByWithRelationInput | StudentAcademicInfoOrderByWithRelationInput[]
    cursor?: StudentAcademicInfoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StudentAcademicInfoScalarFieldEnum | StudentAcademicInfoScalarFieldEnum[]
  }

  /**
   * Student.StudentCarriedCourse
   */
  export type Student$StudentCarriedCourseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentCarriedCourse
     */
    select?: StudentCarriedCourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentCarriedCourse
     */
    omit?: StudentCarriedCourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentCarriedCourseInclude<ExtArgs> | null
    where?: StudentCarriedCourseWhereInput
    orderBy?: StudentCarriedCourseOrderByWithRelationInput | StudentCarriedCourseOrderByWithRelationInput[]
    cursor?: StudentCarriedCourseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StudentCarriedCourseScalarFieldEnum | StudentCarriedCourseScalarFieldEnum[]
  }

  /**
   * Student without action
   */
  export type StudentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Student
     */
    omit?: StudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
  }


  /**
   * Model Faculty
   */

  export type AggregateFaculty = {
    _count: FacultyCountAggregateOutputType | null
    _min: FacultyMinAggregateOutputType | null
    _max: FacultyMaxAggregateOutputType | null
  }

  export type FacultyMinAggregateOutputType = {
    id: string | null
    facultyId: string | null
    firstName: string | null
    middleName: string | null
    lastName: string | null
    profileImage: string | null
    email: string | null
    contactNo: string | null
    shift: $Enums.Shift | null
    gender: string | null
    designation: string | null
    password: string | null
    academicFacultyId: string | null
    academicDepartmentId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FacultyMaxAggregateOutputType = {
    id: string | null
    facultyId: string | null
    firstName: string | null
    middleName: string | null
    lastName: string | null
    profileImage: string | null
    email: string | null
    contactNo: string | null
    shift: $Enums.Shift | null
    gender: string | null
    designation: string | null
    password: string | null
    academicFacultyId: string | null
    academicDepartmentId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FacultyCountAggregateOutputType = {
    id: number
    facultyId: number
    firstName: number
    middleName: number
    lastName: number
    profileImage: number
    email: number
    contactNo: number
    shift: number
    gender: number
    designation: number
    password: number
    academicFacultyId: number
    academicDepartmentId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type FacultyMinAggregateInputType = {
    id?: true
    facultyId?: true
    firstName?: true
    middleName?: true
    lastName?: true
    profileImage?: true
    email?: true
    contactNo?: true
    shift?: true
    gender?: true
    designation?: true
    password?: true
    academicFacultyId?: true
    academicDepartmentId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FacultyMaxAggregateInputType = {
    id?: true
    facultyId?: true
    firstName?: true
    middleName?: true
    lastName?: true
    profileImage?: true
    email?: true
    contactNo?: true
    shift?: true
    gender?: true
    designation?: true
    password?: true
    academicFacultyId?: true
    academicDepartmentId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FacultyCountAggregateInputType = {
    id?: true
    facultyId?: true
    firstName?: true
    middleName?: true
    lastName?: true
    profileImage?: true
    email?: true
    contactNo?: true
    shift?: true
    gender?: true
    designation?: true
    password?: true
    academicFacultyId?: true
    academicDepartmentId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type FacultyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Faculty to aggregate.
     */
    where?: FacultyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Faculties to fetch.
     */
    orderBy?: FacultyOrderByWithRelationInput | FacultyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FacultyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Faculties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Faculties.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Faculties
    **/
    _count?: true | FacultyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FacultyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FacultyMaxAggregateInputType
  }

  export type GetFacultyAggregateType<T extends FacultyAggregateArgs> = {
        [P in keyof T & keyof AggregateFaculty]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFaculty[P]>
      : GetScalarType<T[P], AggregateFaculty[P]>
  }




  export type FacultyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FacultyWhereInput
    orderBy?: FacultyOrderByWithAggregationInput | FacultyOrderByWithAggregationInput[]
    by: FacultyScalarFieldEnum[] | FacultyScalarFieldEnum
    having?: FacultyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FacultyCountAggregateInputType | true
    _min?: FacultyMinAggregateInputType
    _max?: FacultyMaxAggregateInputType
  }

  export type FacultyGroupByOutputType = {
    id: string
    facultyId: string
    firstName: string
    middleName: string | null
    lastName: string
    profileImage: string | null
    email: string | null
    contactNo: string | null
    shift: $Enums.Shift
    gender: string
    designation: string
    password: string
    academicFacultyId: string
    academicDepartmentId: string
    createdAt: Date
    updatedAt: Date
    _count: FacultyCountAggregateOutputType | null
    _min: FacultyMinAggregateOutputType | null
    _max: FacultyMaxAggregateOutputType | null
  }

  type GetFacultyGroupByPayload<T extends FacultyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FacultyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FacultyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FacultyGroupByOutputType[P]>
            : GetScalarType<T[P], FacultyGroupByOutputType[P]>
        }
      >
    >


  export type FacultySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    facultyId?: boolean
    firstName?: boolean
    middleName?: boolean
    lastName?: boolean
    profileImage?: boolean
    email?: boolean
    contactNo?: boolean
    shift?: boolean
    gender?: boolean
    designation?: boolean
    password?: boolean
    academicFacultyId?: boolean
    academicDepartmentId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    courses?: boolean | Faculty$coursesArgs<ExtArgs>
    academicDepartment?: boolean | AcademicDepartmentDefaultArgs<ExtArgs>
    academicFaculty?: boolean | AcademicFacultyDefaultArgs<ExtArgs>
    offeredCourseClassSchedules?: boolean | Faculty$offeredCourseClassSchedulesArgs<ExtArgs>
    _count?: boolean | FacultyCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["faculty"]>



  export type FacultySelectScalar = {
    id?: boolean
    facultyId?: boolean
    firstName?: boolean
    middleName?: boolean
    lastName?: boolean
    profileImage?: boolean
    email?: boolean
    contactNo?: boolean
    shift?: boolean
    gender?: boolean
    designation?: boolean
    password?: boolean
    academicFacultyId?: boolean
    academicDepartmentId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type FacultyOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "facultyId" | "firstName" | "middleName" | "lastName" | "profileImage" | "email" | "contactNo" | "shift" | "gender" | "designation" | "password" | "academicFacultyId" | "academicDepartmentId" | "createdAt" | "updatedAt", ExtArgs["result"]["faculty"]>
  export type FacultyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    courses?: boolean | Faculty$coursesArgs<ExtArgs>
    academicDepartment?: boolean | AcademicDepartmentDefaultArgs<ExtArgs>
    academicFaculty?: boolean | AcademicFacultyDefaultArgs<ExtArgs>
    offeredCourseClassSchedules?: boolean | Faculty$offeredCourseClassSchedulesArgs<ExtArgs>
    _count?: boolean | FacultyCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $FacultyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Faculty"
    objects: {
      courses: Prisma.$CourseFacultyPayload<ExtArgs>[]
      academicDepartment: Prisma.$AcademicDepartmentPayload<ExtArgs>
      academicFaculty: Prisma.$AcademicFacultyPayload<ExtArgs>
      offeredCourseClassSchedules: Prisma.$OfferedCourseClassSchedulePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      facultyId: string
      firstName: string
      middleName: string | null
      lastName: string
      profileImage: string | null
      email: string | null
      contactNo: string | null
      shift: $Enums.Shift
      gender: string
      designation: string
      password: string
      academicFacultyId: string
      academicDepartmentId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["faculty"]>
    composites: {}
  }

  type FacultyGetPayload<S extends boolean | null | undefined | FacultyDefaultArgs> = $Result.GetResult<Prisma.$FacultyPayload, S>

  type FacultyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FacultyFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FacultyCountAggregateInputType | true
    }

  export interface FacultyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Faculty'], meta: { name: 'Faculty' } }
    /**
     * Find zero or one Faculty that matches the filter.
     * @param {FacultyFindUniqueArgs} args - Arguments to find a Faculty
     * @example
     * // Get one Faculty
     * const faculty = await prisma.faculty.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FacultyFindUniqueArgs>(args: SelectSubset<T, FacultyFindUniqueArgs<ExtArgs>>): Prisma__FacultyClient<$Result.GetResult<Prisma.$FacultyPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Faculty that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FacultyFindUniqueOrThrowArgs} args - Arguments to find a Faculty
     * @example
     * // Get one Faculty
     * const faculty = await prisma.faculty.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FacultyFindUniqueOrThrowArgs>(args: SelectSubset<T, FacultyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FacultyClient<$Result.GetResult<Prisma.$FacultyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Faculty that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacultyFindFirstArgs} args - Arguments to find a Faculty
     * @example
     * // Get one Faculty
     * const faculty = await prisma.faculty.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FacultyFindFirstArgs>(args?: SelectSubset<T, FacultyFindFirstArgs<ExtArgs>>): Prisma__FacultyClient<$Result.GetResult<Prisma.$FacultyPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Faculty that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacultyFindFirstOrThrowArgs} args - Arguments to find a Faculty
     * @example
     * // Get one Faculty
     * const faculty = await prisma.faculty.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FacultyFindFirstOrThrowArgs>(args?: SelectSubset<T, FacultyFindFirstOrThrowArgs<ExtArgs>>): Prisma__FacultyClient<$Result.GetResult<Prisma.$FacultyPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Faculties that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacultyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Faculties
     * const faculties = await prisma.faculty.findMany()
     * 
     * // Get first 10 Faculties
     * const faculties = await prisma.faculty.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const facultyWithIdOnly = await prisma.faculty.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FacultyFindManyArgs>(args?: SelectSubset<T, FacultyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FacultyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Faculty.
     * @param {FacultyCreateArgs} args - Arguments to create a Faculty.
     * @example
     * // Create one Faculty
     * const Faculty = await prisma.faculty.create({
     *   data: {
     *     // ... data to create a Faculty
     *   }
     * })
     * 
     */
    create<T extends FacultyCreateArgs>(args: SelectSubset<T, FacultyCreateArgs<ExtArgs>>): Prisma__FacultyClient<$Result.GetResult<Prisma.$FacultyPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Faculties.
     * @param {FacultyCreateManyArgs} args - Arguments to create many Faculties.
     * @example
     * // Create many Faculties
     * const faculty = await prisma.faculty.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FacultyCreateManyArgs>(args?: SelectSubset<T, FacultyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Faculty.
     * @param {FacultyDeleteArgs} args - Arguments to delete one Faculty.
     * @example
     * // Delete one Faculty
     * const Faculty = await prisma.faculty.delete({
     *   where: {
     *     // ... filter to delete one Faculty
     *   }
     * })
     * 
     */
    delete<T extends FacultyDeleteArgs>(args: SelectSubset<T, FacultyDeleteArgs<ExtArgs>>): Prisma__FacultyClient<$Result.GetResult<Prisma.$FacultyPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Faculty.
     * @param {FacultyUpdateArgs} args - Arguments to update one Faculty.
     * @example
     * // Update one Faculty
     * const faculty = await prisma.faculty.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FacultyUpdateArgs>(args: SelectSubset<T, FacultyUpdateArgs<ExtArgs>>): Prisma__FacultyClient<$Result.GetResult<Prisma.$FacultyPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Faculties.
     * @param {FacultyDeleteManyArgs} args - Arguments to filter Faculties to delete.
     * @example
     * // Delete a few Faculties
     * const { count } = await prisma.faculty.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FacultyDeleteManyArgs>(args?: SelectSubset<T, FacultyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Faculties.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacultyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Faculties
     * const faculty = await prisma.faculty.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FacultyUpdateManyArgs>(args: SelectSubset<T, FacultyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Faculty.
     * @param {FacultyUpsertArgs} args - Arguments to update or create a Faculty.
     * @example
     * // Update or create a Faculty
     * const faculty = await prisma.faculty.upsert({
     *   create: {
     *     // ... data to create a Faculty
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Faculty we want to update
     *   }
     * })
     */
    upsert<T extends FacultyUpsertArgs>(args: SelectSubset<T, FacultyUpsertArgs<ExtArgs>>): Prisma__FacultyClient<$Result.GetResult<Prisma.$FacultyPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Faculties.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacultyCountArgs} args - Arguments to filter Faculties to count.
     * @example
     * // Count the number of Faculties
     * const count = await prisma.faculty.count({
     *   where: {
     *     // ... the filter for the Faculties we want to count
     *   }
     * })
    **/
    count<T extends FacultyCountArgs>(
      args?: Subset<T, FacultyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FacultyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Faculty.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacultyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FacultyAggregateArgs>(args: Subset<T, FacultyAggregateArgs>): Prisma.PrismaPromise<GetFacultyAggregateType<T>>

    /**
     * Group by Faculty.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacultyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FacultyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FacultyGroupByArgs['orderBy'] }
        : { orderBy?: FacultyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FacultyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFacultyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Faculty model
   */
  readonly fields: FacultyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Faculty.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FacultyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    courses<T extends Faculty$coursesArgs<ExtArgs> = {}>(args?: Subset<T, Faculty$coursesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CourseFacultyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    academicDepartment<T extends AcademicDepartmentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AcademicDepartmentDefaultArgs<ExtArgs>>): Prisma__AcademicDepartmentClient<$Result.GetResult<Prisma.$AcademicDepartmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    academicFaculty<T extends AcademicFacultyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AcademicFacultyDefaultArgs<ExtArgs>>): Prisma__AcademicFacultyClient<$Result.GetResult<Prisma.$AcademicFacultyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    offeredCourseClassSchedules<T extends Faculty$offeredCourseClassSchedulesArgs<ExtArgs> = {}>(args?: Subset<T, Faculty$offeredCourseClassSchedulesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OfferedCourseClassSchedulePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Faculty model
   */
  interface FacultyFieldRefs {
    readonly id: FieldRef<"Faculty", 'String'>
    readonly facultyId: FieldRef<"Faculty", 'String'>
    readonly firstName: FieldRef<"Faculty", 'String'>
    readonly middleName: FieldRef<"Faculty", 'String'>
    readonly lastName: FieldRef<"Faculty", 'String'>
    readonly profileImage: FieldRef<"Faculty", 'String'>
    readonly email: FieldRef<"Faculty", 'String'>
    readonly contactNo: FieldRef<"Faculty", 'String'>
    readonly shift: FieldRef<"Faculty", 'Shift'>
    readonly gender: FieldRef<"Faculty", 'String'>
    readonly designation: FieldRef<"Faculty", 'String'>
    readonly password: FieldRef<"Faculty", 'String'>
    readonly academicFacultyId: FieldRef<"Faculty", 'String'>
    readonly academicDepartmentId: FieldRef<"Faculty", 'String'>
    readonly createdAt: FieldRef<"Faculty", 'DateTime'>
    readonly updatedAt: FieldRef<"Faculty", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Faculty findUnique
   */
  export type FacultyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Faculty
     */
    select?: FacultySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Faculty
     */
    omit?: FacultyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacultyInclude<ExtArgs> | null
    /**
     * Filter, which Faculty to fetch.
     */
    where: FacultyWhereUniqueInput
  }

  /**
   * Faculty findUniqueOrThrow
   */
  export type FacultyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Faculty
     */
    select?: FacultySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Faculty
     */
    omit?: FacultyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacultyInclude<ExtArgs> | null
    /**
     * Filter, which Faculty to fetch.
     */
    where: FacultyWhereUniqueInput
  }

  /**
   * Faculty findFirst
   */
  export type FacultyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Faculty
     */
    select?: FacultySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Faculty
     */
    omit?: FacultyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacultyInclude<ExtArgs> | null
    /**
     * Filter, which Faculty to fetch.
     */
    where?: FacultyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Faculties to fetch.
     */
    orderBy?: FacultyOrderByWithRelationInput | FacultyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Faculties.
     */
    cursor?: FacultyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Faculties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Faculties.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Faculties.
     */
    distinct?: FacultyScalarFieldEnum | FacultyScalarFieldEnum[]
  }

  /**
   * Faculty findFirstOrThrow
   */
  export type FacultyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Faculty
     */
    select?: FacultySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Faculty
     */
    omit?: FacultyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacultyInclude<ExtArgs> | null
    /**
     * Filter, which Faculty to fetch.
     */
    where?: FacultyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Faculties to fetch.
     */
    orderBy?: FacultyOrderByWithRelationInput | FacultyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Faculties.
     */
    cursor?: FacultyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Faculties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Faculties.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Faculties.
     */
    distinct?: FacultyScalarFieldEnum | FacultyScalarFieldEnum[]
  }

  /**
   * Faculty findMany
   */
  export type FacultyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Faculty
     */
    select?: FacultySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Faculty
     */
    omit?: FacultyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacultyInclude<ExtArgs> | null
    /**
     * Filter, which Faculties to fetch.
     */
    where?: FacultyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Faculties to fetch.
     */
    orderBy?: FacultyOrderByWithRelationInput | FacultyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Faculties.
     */
    cursor?: FacultyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Faculties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Faculties.
     */
    skip?: number
    distinct?: FacultyScalarFieldEnum | FacultyScalarFieldEnum[]
  }

  /**
   * Faculty create
   */
  export type FacultyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Faculty
     */
    select?: FacultySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Faculty
     */
    omit?: FacultyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacultyInclude<ExtArgs> | null
    /**
     * The data needed to create a Faculty.
     */
    data: XOR<FacultyCreateInput, FacultyUncheckedCreateInput>
  }

  /**
   * Faculty createMany
   */
  export type FacultyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Faculties.
     */
    data: FacultyCreateManyInput | FacultyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Faculty update
   */
  export type FacultyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Faculty
     */
    select?: FacultySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Faculty
     */
    omit?: FacultyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacultyInclude<ExtArgs> | null
    /**
     * The data needed to update a Faculty.
     */
    data: XOR<FacultyUpdateInput, FacultyUncheckedUpdateInput>
    /**
     * Choose, which Faculty to update.
     */
    where: FacultyWhereUniqueInput
  }

  /**
   * Faculty updateMany
   */
  export type FacultyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Faculties.
     */
    data: XOR<FacultyUpdateManyMutationInput, FacultyUncheckedUpdateManyInput>
    /**
     * Filter which Faculties to update
     */
    where?: FacultyWhereInput
    /**
     * Limit how many Faculties to update.
     */
    limit?: number
  }

  /**
   * Faculty upsert
   */
  export type FacultyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Faculty
     */
    select?: FacultySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Faculty
     */
    omit?: FacultyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacultyInclude<ExtArgs> | null
    /**
     * The filter to search for the Faculty to update in case it exists.
     */
    where: FacultyWhereUniqueInput
    /**
     * In case the Faculty found by the `where` argument doesn't exist, create a new Faculty with this data.
     */
    create: XOR<FacultyCreateInput, FacultyUncheckedCreateInput>
    /**
     * In case the Faculty was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FacultyUpdateInput, FacultyUncheckedUpdateInput>
  }

  /**
   * Faculty delete
   */
  export type FacultyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Faculty
     */
    select?: FacultySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Faculty
     */
    omit?: FacultyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacultyInclude<ExtArgs> | null
    /**
     * Filter which Faculty to delete.
     */
    where: FacultyWhereUniqueInput
  }

  /**
   * Faculty deleteMany
   */
  export type FacultyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Faculties to delete
     */
    where?: FacultyWhereInput
    /**
     * Limit how many Faculties to delete.
     */
    limit?: number
  }

  /**
   * Faculty.courses
   */
  export type Faculty$coursesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseFaculty
     */
    select?: CourseFacultySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseFaculty
     */
    omit?: CourseFacultyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseFacultyInclude<ExtArgs> | null
    where?: CourseFacultyWhereInput
    orderBy?: CourseFacultyOrderByWithRelationInput | CourseFacultyOrderByWithRelationInput[]
    cursor?: CourseFacultyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CourseFacultyScalarFieldEnum | CourseFacultyScalarFieldEnum[]
  }

  /**
   * Faculty.offeredCourseClassSchedules
   */
  export type Faculty$offeredCourseClassSchedulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OfferedCourseClassSchedule
     */
    select?: OfferedCourseClassScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OfferedCourseClassSchedule
     */
    omit?: OfferedCourseClassScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OfferedCourseClassScheduleInclude<ExtArgs> | null
    where?: OfferedCourseClassScheduleWhereInput
    orderBy?: OfferedCourseClassScheduleOrderByWithRelationInput | OfferedCourseClassScheduleOrderByWithRelationInput[]
    cursor?: OfferedCourseClassScheduleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OfferedCourseClassScheduleScalarFieldEnum | OfferedCourseClassScheduleScalarFieldEnum[]
  }

  /**
   * Faculty without action
   */
  export type FacultyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Faculty
     */
    select?: FacultySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Faculty
     */
    omit?: FacultyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacultyInclude<ExtArgs> | null
  }


  /**
   * Model Building
   */

  export type AggregateBuilding = {
    _count: BuildingCountAggregateOutputType | null
    _min: BuildingMinAggregateOutputType | null
    _max: BuildingMaxAggregateOutputType | null
  }

  export type BuildingMinAggregateOutputType = {
    id: string | null
    title: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BuildingMaxAggregateOutputType = {
    id: string | null
    title: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BuildingCountAggregateOutputType = {
    id: number
    title: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BuildingMinAggregateInputType = {
    id?: true
    title?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BuildingMaxAggregateInputType = {
    id?: true
    title?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BuildingCountAggregateInputType = {
    id?: true
    title?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BuildingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Building to aggregate.
     */
    where?: BuildingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Buildings to fetch.
     */
    orderBy?: BuildingOrderByWithRelationInput | BuildingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BuildingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Buildings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Buildings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Buildings
    **/
    _count?: true | BuildingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BuildingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BuildingMaxAggregateInputType
  }

  export type GetBuildingAggregateType<T extends BuildingAggregateArgs> = {
        [P in keyof T & keyof AggregateBuilding]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBuilding[P]>
      : GetScalarType<T[P], AggregateBuilding[P]>
  }




  export type BuildingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BuildingWhereInput
    orderBy?: BuildingOrderByWithAggregationInput | BuildingOrderByWithAggregationInput[]
    by: BuildingScalarFieldEnum[] | BuildingScalarFieldEnum
    having?: BuildingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BuildingCountAggregateInputType | true
    _min?: BuildingMinAggregateInputType
    _max?: BuildingMaxAggregateInputType
  }

  export type BuildingGroupByOutputType = {
    id: string
    title: string
    createdAt: Date
    updatedAt: Date
    _count: BuildingCountAggregateOutputType | null
    _min: BuildingMinAggregateOutputType | null
    _max: BuildingMaxAggregateOutputType | null
  }

  type GetBuildingGroupByPayload<T extends BuildingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BuildingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BuildingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BuildingGroupByOutputType[P]>
            : GetScalarType<T[P], BuildingGroupByOutputType[P]>
        }
      >
    >


  export type BuildingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    rooms?: boolean | Building$roomsArgs<ExtArgs>
    _count?: boolean | BuildingCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["building"]>



  export type BuildingSelectScalar = {
    id?: boolean
    title?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type BuildingOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "createdAt" | "updatedAt", ExtArgs["result"]["building"]>
  export type BuildingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    rooms?: boolean | Building$roomsArgs<ExtArgs>
    _count?: boolean | BuildingCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $BuildingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Building"
    objects: {
      rooms: Prisma.$RoomPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["building"]>
    composites: {}
  }

  type BuildingGetPayload<S extends boolean | null | undefined | BuildingDefaultArgs> = $Result.GetResult<Prisma.$BuildingPayload, S>

  type BuildingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BuildingFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BuildingCountAggregateInputType | true
    }

  export interface BuildingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Building'], meta: { name: 'Building' } }
    /**
     * Find zero or one Building that matches the filter.
     * @param {BuildingFindUniqueArgs} args - Arguments to find a Building
     * @example
     * // Get one Building
     * const building = await prisma.building.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BuildingFindUniqueArgs>(args: SelectSubset<T, BuildingFindUniqueArgs<ExtArgs>>): Prisma__BuildingClient<$Result.GetResult<Prisma.$BuildingPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Building that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BuildingFindUniqueOrThrowArgs} args - Arguments to find a Building
     * @example
     * // Get one Building
     * const building = await prisma.building.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BuildingFindUniqueOrThrowArgs>(args: SelectSubset<T, BuildingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BuildingClient<$Result.GetResult<Prisma.$BuildingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Building that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BuildingFindFirstArgs} args - Arguments to find a Building
     * @example
     * // Get one Building
     * const building = await prisma.building.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BuildingFindFirstArgs>(args?: SelectSubset<T, BuildingFindFirstArgs<ExtArgs>>): Prisma__BuildingClient<$Result.GetResult<Prisma.$BuildingPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Building that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BuildingFindFirstOrThrowArgs} args - Arguments to find a Building
     * @example
     * // Get one Building
     * const building = await prisma.building.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BuildingFindFirstOrThrowArgs>(args?: SelectSubset<T, BuildingFindFirstOrThrowArgs<ExtArgs>>): Prisma__BuildingClient<$Result.GetResult<Prisma.$BuildingPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Buildings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BuildingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Buildings
     * const buildings = await prisma.building.findMany()
     * 
     * // Get first 10 Buildings
     * const buildings = await prisma.building.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const buildingWithIdOnly = await prisma.building.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BuildingFindManyArgs>(args?: SelectSubset<T, BuildingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BuildingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Building.
     * @param {BuildingCreateArgs} args - Arguments to create a Building.
     * @example
     * // Create one Building
     * const Building = await prisma.building.create({
     *   data: {
     *     // ... data to create a Building
     *   }
     * })
     * 
     */
    create<T extends BuildingCreateArgs>(args: SelectSubset<T, BuildingCreateArgs<ExtArgs>>): Prisma__BuildingClient<$Result.GetResult<Prisma.$BuildingPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Buildings.
     * @param {BuildingCreateManyArgs} args - Arguments to create many Buildings.
     * @example
     * // Create many Buildings
     * const building = await prisma.building.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BuildingCreateManyArgs>(args?: SelectSubset<T, BuildingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Building.
     * @param {BuildingDeleteArgs} args - Arguments to delete one Building.
     * @example
     * // Delete one Building
     * const Building = await prisma.building.delete({
     *   where: {
     *     // ... filter to delete one Building
     *   }
     * })
     * 
     */
    delete<T extends BuildingDeleteArgs>(args: SelectSubset<T, BuildingDeleteArgs<ExtArgs>>): Prisma__BuildingClient<$Result.GetResult<Prisma.$BuildingPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Building.
     * @param {BuildingUpdateArgs} args - Arguments to update one Building.
     * @example
     * // Update one Building
     * const building = await prisma.building.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BuildingUpdateArgs>(args: SelectSubset<T, BuildingUpdateArgs<ExtArgs>>): Prisma__BuildingClient<$Result.GetResult<Prisma.$BuildingPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Buildings.
     * @param {BuildingDeleteManyArgs} args - Arguments to filter Buildings to delete.
     * @example
     * // Delete a few Buildings
     * const { count } = await prisma.building.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BuildingDeleteManyArgs>(args?: SelectSubset<T, BuildingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Buildings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BuildingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Buildings
     * const building = await prisma.building.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BuildingUpdateManyArgs>(args: SelectSubset<T, BuildingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Building.
     * @param {BuildingUpsertArgs} args - Arguments to update or create a Building.
     * @example
     * // Update or create a Building
     * const building = await prisma.building.upsert({
     *   create: {
     *     // ... data to create a Building
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Building we want to update
     *   }
     * })
     */
    upsert<T extends BuildingUpsertArgs>(args: SelectSubset<T, BuildingUpsertArgs<ExtArgs>>): Prisma__BuildingClient<$Result.GetResult<Prisma.$BuildingPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Buildings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BuildingCountArgs} args - Arguments to filter Buildings to count.
     * @example
     * // Count the number of Buildings
     * const count = await prisma.building.count({
     *   where: {
     *     // ... the filter for the Buildings we want to count
     *   }
     * })
    **/
    count<T extends BuildingCountArgs>(
      args?: Subset<T, BuildingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BuildingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Building.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BuildingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BuildingAggregateArgs>(args: Subset<T, BuildingAggregateArgs>): Prisma.PrismaPromise<GetBuildingAggregateType<T>>

    /**
     * Group by Building.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BuildingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BuildingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BuildingGroupByArgs['orderBy'] }
        : { orderBy?: BuildingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BuildingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBuildingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Building model
   */
  readonly fields: BuildingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Building.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BuildingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    rooms<T extends Building$roomsArgs<ExtArgs> = {}>(args?: Subset<T, Building$roomsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoomPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Building model
   */
  interface BuildingFieldRefs {
    readonly id: FieldRef<"Building", 'String'>
    readonly title: FieldRef<"Building", 'String'>
    readonly createdAt: FieldRef<"Building", 'DateTime'>
    readonly updatedAt: FieldRef<"Building", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Building findUnique
   */
  export type BuildingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Building
     */
    select?: BuildingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Building
     */
    omit?: BuildingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BuildingInclude<ExtArgs> | null
    /**
     * Filter, which Building to fetch.
     */
    where: BuildingWhereUniqueInput
  }

  /**
   * Building findUniqueOrThrow
   */
  export type BuildingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Building
     */
    select?: BuildingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Building
     */
    omit?: BuildingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BuildingInclude<ExtArgs> | null
    /**
     * Filter, which Building to fetch.
     */
    where: BuildingWhereUniqueInput
  }

  /**
   * Building findFirst
   */
  export type BuildingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Building
     */
    select?: BuildingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Building
     */
    omit?: BuildingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BuildingInclude<ExtArgs> | null
    /**
     * Filter, which Building to fetch.
     */
    where?: BuildingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Buildings to fetch.
     */
    orderBy?: BuildingOrderByWithRelationInput | BuildingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Buildings.
     */
    cursor?: BuildingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Buildings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Buildings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Buildings.
     */
    distinct?: BuildingScalarFieldEnum | BuildingScalarFieldEnum[]
  }

  /**
   * Building findFirstOrThrow
   */
  export type BuildingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Building
     */
    select?: BuildingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Building
     */
    omit?: BuildingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BuildingInclude<ExtArgs> | null
    /**
     * Filter, which Building to fetch.
     */
    where?: BuildingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Buildings to fetch.
     */
    orderBy?: BuildingOrderByWithRelationInput | BuildingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Buildings.
     */
    cursor?: BuildingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Buildings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Buildings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Buildings.
     */
    distinct?: BuildingScalarFieldEnum | BuildingScalarFieldEnum[]
  }

  /**
   * Building findMany
   */
  export type BuildingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Building
     */
    select?: BuildingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Building
     */
    omit?: BuildingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BuildingInclude<ExtArgs> | null
    /**
     * Filter, which Buildings to fetch.
     */
    where?: BuildingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Buildings to fetch.
     */
    orderBy?: BuildingOrderByWithRelationInput | BuildingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Buildings.
     */
    cursor?: BuildingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Buildings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Buildings.
     */
    skip?: number
    distinct?: BuildingScalarFieldEnum | BuildingScalarFieldEnum[]
  }

  /**
   * Building create
   */
  export type BuildingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Building
     */
    select?: BuildingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Building
     */
    omit?: BuildingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BuildingInclude<ExtArgs> | null
    /**
     * The data needed to create a Building.
     */
    data: XOR<BuildingCreateInput, BuildingUncheckedCreateInput>
  }

  /**
   * Building createMany
   */
  export type BuildingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Buildings.
     */
    data: BuildingCreateManyInput | BuildingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Building update
   */
  export type BuildingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Building
     */
    select?: BuildingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Building
     */
    omit?: BuildingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BuildingInclude<ExtArgs> | null
    /**
     * The data needed to update a Building.
     */
    data: XOR<BuildingUpdateInput, BuildingUncheckedUpdateInput>
    /**
     * Choose, which Building to update.
     */
    where: BuildingWhereUniqueInput
  }

  /**
   * Building updateMany
   */
  export type BuildingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Buildings.
     */
    data: XOR<BuildingUpdateManyMutationInput, BuildingUncheckedUpdateManyInput>
    /**
     * Filter which Buildings to update
     */
    where?: BuildingWhereInput
    /**
     * Limit how many Buildings to update.
     */
    limit?: number
  }

  /**
   * Building upsert
   */
  export type BuildingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Building
     */
    select?: BuildingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Building
     */
    omit?: BuildingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BuildingInclude<ExtArgs> | null
    /**
     * The filter to search for the Building to update in case it exists.
     */
    where: BuildingWhereUniqueInput
    /**
     * In case the Building found by the `where` argument doesn't exist, create a new Building with this data.
     */
    create: XOR<BuildingCreateInput, BuildingUncheckedCreateInput>
    /**
     * In case the Building was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BuildingUpdateInput, BuildingUncheckedUpdateInput>
  }

  /**
   * Building delete
   */
  export type BuildingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Building
     */
    select?: BuildingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Building
     */
    omit?: BuildingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BuildingInclude<ExtArgs> | null
    /**
     * Filter which Building to delete.
     */
    where: BuildingWhereUniqueInput
  }

  /**
   * Building deleteMany
   */
  export type BuildingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Buildings to delete
     */
    where?: BuildingWhereInput
    /**
     * Limit how many Buildings to delete.
     */
    limit?: number
  }

  /**
   * Building.rooms
   */
  export type Building$roomsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Room
     */
    select?: RoomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Room
     */
    omit?: RoomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomInclude<ExtArgs> | null
    where?: RoomWhereInput
    orderBy?: RoomOrderByWithRelationInput | RoomOrderByWithRelationInput[]
    cursor?: RoomWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RoomScalarFieldEnum | RoomScalarFieldEnum[]
  }

  /**
   * Building without action
   */
  export type BuildingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Building
     */
    select?: BuildingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Building
     */
    omit?: BuildingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BuildingInclude<ExtArgs> | null
  }


  /**
   * Model Room
   */

  export type AggregateRoom = {
    _count: RoomCountAggregateOutputType | null
    _min: RoomMinAggregateOutputType | null
    _max: RoomMaxAggregateOutputType | null
  }

  export type RoomMinAggregateOutputType = {
    id: string | null
    roomNumber: string | null
    floor: string | null
    buildingId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RoomMaxAggregateOutputType = {
    id: string | null
    roomNumber: string | null
    floor: string | null
    buildingId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RoomCountAggregateOutputType = {
    id: number
    roomNumber: number
    floor: number
    buildingId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type RoomMinAggregateInputType = {
    id?: true
    roomNumber?: true
    floor?: true
    buildingId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RoomMaxAggregateInputType = {
    id?: true
    roomNumber?: true
    floor?: true
    buildingId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RoomCountAggregateInputType = {
    id?: true
    roomNumber?: true
    floor?: true
    buildingId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type RoomAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Room to aggregate.
     */
    where?: RoomWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Rooms to fetch.
     */
    orderBy?: RoomOrderByWithRelationInput | RoomOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RoomWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Rooms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Rooms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Rooms
    **/
    _count?: true | RoomCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RoomMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RoomMaxAggregateInputType
  }

  export type GetRoomAggregateType<T extends RoomAggregateArgs> = {
        [P in keyof T & keyof AggregateRoom]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRoom[P]>
      : GetScalarType<T[P], AggregateRoom[P]>
  }




  export type RoomGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoomWhereInput
    orderBy?: RoomOrderByWithAggregationInput | RoomOrderByWithAggregationInput[]
    by: RoomScalarFieldEnum[] | RoomScalarFieldEnum
    having?: RoomScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RoomCountAggregateInputType | true
    _min?: RoomMinAggregateInputType
    _max?: RoomMaxAggregateInputType
  }

  export type RoomGroupByOutputType = {
    id: string
    roomNumber: string
    floor: string
    buildingId: string
    createdAt: Date
    updatedAt: Date
    _count: RoomCountAggregateOutputType | null
    _min: RoomMinAggregateOutputType | null
    _max: RoomMaxAggregateOutputType | null
  }

  type GetRoomGroupByPayload<T extends RoomGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RoomGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RoomGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RoomGroupByOutputType[P]>
            : GetScalarType<T[P], RoomGroupByOutputType[P]>
        }
      >
    >


  export type RoomSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    roomNumber?: boolean
    floor?: boolean
    buildingId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    building?: boolean | BuildingDefaultArgs<ExtArgs>
    offeredCourseClassSchedules?: boolean | Room$offeredCourseClassSchedulesArgs<ExtArgs>
    _count?: boolean | RoomCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["room"]>



  export type RoomSelectScalar = {
    id?: boolean
    roomNumber?: boolean
    floor?: boolean
    buildingId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type RoomOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "roomNumber" | "floor" | "buildingId" | "createdAt" | "updatedAt", ExtArgs["result"]["room"]>
  export type RoomInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    building?: boolean | BuildingDefaultArgs<ExtArgs>
    offeredCourseClassSchedules?: boolean | Room$offeredCourseClassSchedulesArgs<ExtArgs>
    _count?: boolean | RoomCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $RoomPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Room"
    objects: {
      building: Prisma.$BuildingPayload<ExtArgs>
      offeredCourseClassSchedules: Prisma.$OfferedCourseClassSchedulePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      roomNumber: string
      floor: string
      buildingId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["room"]>
    composites: {}
  }

  type RoomGetPayload<S extends boolean | null | undefined | RoomDefaultArgs> = $Result.GetResult<Prisma.$RoomPayload, S>

  type RoomCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RoomFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RoomCountAggregateInputType | true
    }

  export interface RoomDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Room'], meta: { name: 'Room' } }
    /**
     * Find zero or one Room that matches the filter.
     * @param {RoomFindUniqueArgs} args - Arguments to find a Room
     * @example
     * // Get one Room
     * const room = await prisma.room.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RoomFindUniqueArgs>(args: SelectSubset<T, RoomFindUniqueArgs<ExtArgs>>): Prisma__RoomClient<$Result.GetResult<Prisma.$RoomPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Room that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RoomFindUniqueOrThrowArgs} args - Arguments to find a Room
     * @example
     * // Get one Room
     * const room = await prisma.room.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RoomFindUniqueOrThrowArgs>(args: SelectSubset<T, RoomFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RoomClient<$Result.GetResult<Prisma.$RoomPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Room that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomFindFirstArgs} args - Arguments to find a Room
     * @example
     * // Get one Room
     * const room = await prisma.room.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RoomFindFirstArgs>(args?: SelectSubset<T, RoomFindFirstArgs<ExtArgs>>): Prisma__RoomClient<$Result.GetResult<Prisma.$RoomPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Room that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomFindFirstOrThrowArgs} args - Arguments to find a Room
     * @example
     * // Get one Room
     * const room = await prisma.room.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RoomFindFirstOrThrowArgs>(args?: SelectSubset<T, RoomFindFirstOrThrowArgs<ExtArgs>>): Prisma__RoomClient<$Result.GetResult<Prisma.$RoomPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Rooms that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Rooms
     * const rooms = await prisma.room.findMany()
     * 
     * // Get first 10 Rooms
     * const rooms = await prisma.room.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const roomWithIdOnly = await prisma.room.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RoomFindManyArgs>(args?: SelectSubset<T, RoomFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoomPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Room.
     * @param {RoomCreateArgs} args - Arguments to create a Room.
     * @example
     * // Create one Room
     * const Room = await prisma.room.create({
     *   data: {
     *     // ... data to create a Room
     *   }
     * })
     * 
     */
    create<T extends RoomCreateArgs>(args: SelectSubset<T, RoomCreateArgs<ExtArgs>>): Prisma__RoomClient<$Result.GetResult<Prisma.$RoomPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Rooms.
     * @param {RoomCreateManyArgs} args - Arguments to create many Rooms.
     * @example
     * // Create many Rooms
     * const room = await prisma.room.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RoomCreateManyArgs>(args?: SelectSubset<T, RoomCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Room.
     * @param {RoomDeleteArgs} args - Arguments to delete one Room.
     * @example
     * // Delete one Room
     * const Room = await prisma.room.delete({
     *   where: {
     *     // ... filter to delete one Room
     *   }
     * })
     * 
     */
    delete<T extends RoomDeleteArgs>(args: SelectSubset<T, RoomDeleteArgs<ExtArgs>>): Prisma__RoomClient<$Result.GetResult<Prisma.$RoomPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Room.
     * @param {RoomUpdateArgs} args - Arguments to update one Room.
     * @example
     * // Update one Room
     * const room = await prisma.room.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RoomUpdateArgs>(args: SelectSubset<T, RoomUpdateArgs<ExtArgs>>): Prisma__RoomClient<$Result.GetResult<Prisma.$RoomPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Rooms.
     * @param {RoomDeleteManyArgs} args - Arguments to filter Rooms to delete.
     * @example
     * // Delete a few Rooms
     * const { count } = await prisma.room.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RoomDeleteManyArgs>(args?: SelectSubset<T, RoomDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Rooms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Rooms
     * const room = await prisma.room.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RoomUpdateManyArgs>(args: SelectSubset<T, RoomUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Room.
     * @param {RoomUpsertArgs} args - Arguments to update or create a Room.
     * @example
     * // Update or create a Room
     * const room = await prisma.room.upsert({
     *   create: {
     *     // ... data to create a Room
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Room we want to update
     *   }
     * })
     */
    upsert<T extends RoomUpsertArgs>(args: SelectSubset<T, RoomUpsertArgs<ExtArgs>>): Prisma__RoomClient<$Result.GetResult<Prisma.$RoomPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Rooms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomCountArgs} args - Arguments to filter Rooms to count.
     * @example
     * // Count the number of Rooms
     * const count = await prisma.room.count({
     *   where: {
     *     // ... the filter for the Rooms we want to count
     *   }
     * })
    **/
    count<T extends RoomCountArgs>(
      args?: Subset<T, RoomCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RoomCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Room.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RoomAggregateArgs>(args: Subset<T, RoomAggregateArgs>): Prisma.PrismaPromise<GetRoomAggregateType<T>>

    /**
     * Group by Room.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RoomGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RoomGroupByArgs['orderBy'] }
        : { orderBy?: RoomGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RoomGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRoomGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Room model
   */
  readonly fields: RoomFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Room.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RoomClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    building<T extends BuildingDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BuildingDefaultArgs<ExtArgs>>): Prisma__BuildingClient<$Result.GetResult<Prisma.$BuildingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    offeredCourseClassSchedules<T extends Room$offeredCourseClassSchedulesArgs<ExtArgs> = {}>(args?: Subset<T, Room$offeredCourseClassSchedulesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OfferedCourseClassSchedulePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Room model
   */
  interface RoomFieldRefs {
    readonly id: FieldRef<"Room", 'String'>
    readonly roomNumber: FieldRef<"Room", 'String'>
    readonly floor: FieldRef<"Room", 'String'>
    readonly buildingId: FieldRef<"Room", 'String'>
    readonly createdAt: FieldRef<"Room", 'DateTime'>
    readonly updatedAt: FieldRef<"Room", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Room findUnique
   */
  export type RoomFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Room
     */
    select?: RoomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Room
     */
    omit?: RoomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomInclude<ExtArgs> | null
    /**
     * Filter, which Room to fetch.
     */
    where: RoomWhereUniqueInput
  }

  /**
   * Room findUniqueOrThrow
   */
  export type RoomFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Room
     */
    select?: RoomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Room
     */
    omit?: RoomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomInclude<ExtArgs> | null
    /**
     * Filter, which Room to fetch.
     */
    where: RoomWhereUniqueInput
  }

  /**
   * Room findFirst
   */
  export type RoomFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Room
     */
    select?: RoomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Room
     */
    omit?: RoomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomInclude<ExtArgs> | null
    /**
     * Filter, which Room to fetch.
     */
    where?: RoomWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Rooms to fetch.
     */
    orderBy?: RoomOrderByWithRelationInput | RoomOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Rooms.
     */
    cursor?: RoomWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Rooms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Rooms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Rooms.
     */
    distinct?: RoomScalarFieldEnum | RoomScalarFieldEnum[]
  }

  /**
   * Room findFirstOrThrow
   */
  export type RoomFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Room
     */
    select?: RoomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Room
     */
    omit?: RoomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomInclude<ExtArgs> | null
    /**
     * Filter, which Room to fetch.
     */
    where?: RoomWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Rooms to fetch.
     */
    orderBy?: RoomOrderByWithRelationInput | RoomOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Rooms.
     */
    cursor?: RoomWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Rooms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Rooms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Rooms.
     */
    distinct?: RoomScalarFieldEnum | RoomScalarFieldEnum[]
  }

  /**
   * Room findMany
   */
  export type RoomFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Room
     */
    select?: RoomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Room
     */
    omit?: RoomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomInclude<ExtArgs> | null
    /**
     * Filter, which Rooms to fetch.
     */
    where?: RoomWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Rooms to fetch.
     */
    orderBy?: RoomOrderByWithRelationInput | RoomOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Rooms.
     */
    cursor?: RoomWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Rooms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Rooms.
     */
    skip?: number
    distinct?: RoomScalarFieldEnum | RoomScalarFieldEnum[]
  }

  /**
   * Room create
   */
  export type RoomCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Room
     */
    select?: RoomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Room
     */
    omit?: RoomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomInclude<ExtArgs> | null
    /**
     * The data needed to create a Room.
     */
    data: XOR<RoomCreateInput, RoomUncheckedCreateInput>
  }

  /**
   * Room createMany
   */
  export type RoomCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Rooms.
     */
    data: RoomCreateManyInput | RoomCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Room update
   */
  export type RoomUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Room
     */
    select?: RoomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Room
     */
    omit?: RoomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomInclude<ExtArgs> | null
    /**
     * The data needed to update a Room.
     */
    data: XOR<RoomUpdateInput, RoomUncheckedUpdateInput>
    /**
     * Choose, which Room to update.
     */
    where: RoomWhereUniqueInput
  }

  /**
   * Room updateMany
   */
  export type RoomUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Rooms.
     */
    data: XOR<RoomUpdateManyMutationInput, RoomUncheckedUpdateManyInput>
    /**
     * Filter which Rooms to update
     */
    where?: RoomWhereInput
    /**
     * Limit how many Rooms to update.
     */
    limit?: number
  }

  /**
   * Room upsert
   */
  export type RoomUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Room
     */
    select?: RoomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Room
     */
    omit?: RoomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomInclude<ExtArgs> | null
    /**
     * The filter to search for the Room to update in case it exists.
     */
    where: RoomWhereUniqueInput
    /**
     * In case the Room found by the `where` argument doesn't exist, create a new Room with this data.
     */
    create: XOR<RoomCreateInput, RoomUncheckedCreateInput>
    /**
     * In case the Room was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RoomUpdateInput, RoomUncheckedUpdateInput>
  }

  /**
   * Room delete
   */
  export type RoomDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Room
     */
    select?: RoomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Room
     */
    omit?: RoomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomInclude<ExtArgs> | null
    /**
     * Filter which Room to delete.
     */
    where: RoomWhereUniqueInput
  }

  /**
   * Room deleteMany
   */
  export type RoomDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Rooms to delete
     */
    where?: RoomWhereInput
    /**
     * Limit how many Rooms to delete.
     */
    limit?: number
  }

  /**
   * Room.offeredCourseClassSchedules
   */
  export type Room$offeredCourseClassSchedulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OfferedCourseClassSchedule
     */
    select?: OfferedCourseClassScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OfferedCourseClassSchedule
     */
    omit?: OfferedCourseClassScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OfferedCourseClassScheduleInclude<ExtArgs> | null
    where?: OfferedCourseClassScheduleWhereInput
    orderBy?: OfferedCourseClassScheduleOrderByWithRelationInput | OfferedCourseClassScheduleOrderByWithRelationInput[]
    cursor?: OfferedCourseClassScheduleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OfferedCourseClassScheduleScalarFieldEnum | OfferedCourseClassScheduleScalarFieldEnum[]
  }

  /**
   * Room without action
   */
  export type RoomDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Room
     */
    select?: RoomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Room
     */
    omit?: RoomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomInclude<ExtArgs> | null
  }


  /**
   * Model Course
   */

  export type AggregateCourse = {
    _count: CourseCountAggregateOutputType | null
    _avg: CourseAvgAggregateOutputType | null
    _sum: CourseSumAggregateOutputType | null
    _min: CourseMinAggregateOutputType | null
    _max: CourseMaxAggregateOutputType | null
  }

  export type CourseAvgAggregateOutputType = {
    durationInYears: number | null
  }

  export type CourseSumAggregateOutputType = {
    durationInYears: number | null
  }

  export type CourseMinAggregateOutputType = {
    id: string | null
    title: string | null
    code: string | null
    durationInYears: number | null
    yearLevel: $Enums.YearLevel | null
    shift: $Enums.Shift | null
    academicDepartmentId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CourseMaxAggregateOutputType = {
    id: string | null
    title: string | null
    code: string | null
    durationInYears: number | null
    yearLevel: $Enums.YearLevel | null
    shift: $Enums.Shift | null
    academicDepartmentId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CourseCountAggregateOutputType = {
    id: number
    title: number
    code: number
    durationInYears: number
    yearLevel: number
    shift: number
    academicDepartmentId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CourseAvgAggregateInputType = {
    durationInYears?: true
  }

  export type CourseSumAggregateInputType = {
    durationInYears?: true
  }

  export type CourseMinAggregateInputType = {
    id?: true
    title?: true
    code?: true
    durationInYears?: true
    yearLevel?: true
    shift?: true
    academicDepartmentId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CourseMaxAggregateInputType = {
    id?: true
    title?: true
    code?: true
    durationInYears?: true
    yearLevel?: true
    shift?: true
    academicDepartmentId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CourseCountAggregateInputType = {
    id?: true
    title?: true
    code?: true
    durationInYears?: true
    yearLevel?: true
    shift?: true
    academicDepartmentId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CourseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Course to aggregate.
     */
    where?: CourseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Courses to fetch.
     */
    orderBy?: CourseOrderByWithRelationInput | CourseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CourseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Courses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Courses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Courses
    **/
    _count?: true | CourseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CourseAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CourseSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CourseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CourseMaxAggregateInputType
  }

  export type GetCourseAggregateType<T extends CourseAggregateArgs> = {
        [P in keyof T & keyof AggregateCourse]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCourse[P]>
      : GetScalarType<T[P], AggregateCourse[P]>
  }




  export type CourseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CourseWhereInput
    orderBy?: CourseOrderByWithAggregationInput | CourseOrderByWithAggregationInput[]
    by: CourseScalarFieldEnum[] | CourseScalarFieldEnum
    having?: CourseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CourseCountAggregateInputType | true
    _avg?: CourseAvgAggregateInputType
    _sum?: CourseSumAggregateInputType
    _min?: CourseMinAggregateInputType
    _max?: CourseMaxAggregateInputType
  }

  export type CourseGroupByOutputType = {
    id: string
    title: string
    code: string
    durationInYears: number
    yearLevel: $Enums.YearLevel
    shift: $Enums.Shift
    academicDepartmentId: string
    createdAt: Date
    updatedAt: Date
    _count: CourseCountAggregateOutputType | null
    _avg: CourseAvgAggregateOutputType | null
    _sum: CourseSumAggregateOutputType | null
    _min: CourseMinAggregateOutputType | null
    _max: CourseMaxAggregateOutputType | null
  }

  type GetCourseGroupByPayload<T extends CourseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CourseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CourseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CourseGroupByOutputType[P]>
            : GetScalarType<T[P], CourseGroupByOutputType[P]>
        }
      >
    >


  export type CourseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    code?: boolean
    durationInYears?: boolean
    yearLevel?: boolean
    shift?: boolean
    academicDepartmentId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    courseDisciplines?: boolean | Course$courseDisciplinesArgs<ExtArgs>
    coursePricing?: boolean | Course$coursePricingArgs<ExtArgs>
    academicDepartment?: boolean | AcademicDepartmentDefaultArgs<ExtArgs>
    studentCourses?: boolean | Course$studentCoursesArgs<ExtArgs>
    preRequisite?: boolean | Course$preRequisiteArgs<ExtArgs>
    preRequisiteFor?: boolean | Course$preRequisiteForArgs<ExtArgs>
    faculties?: boolean | Course$facultiesArgs<ExtArgs>
    offeredCourses?: boolean | Course$offeredCoursesArgs<ExtArgs>
    _count?: boolean | CourseCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["course"]>



  export type CourseSelectScalar = {
    id?: boolean
    title?: boolean
    code?: boolean
    durationInYears?: boolean
    yearLevel?: boolean
    shift?: boolean
    academicDepartmentId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CourseOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "code" | "durationInYears" | "yearLevel" | "shift" | "academicDepartmentId" | "createdAt" | "updatedAt", ExtArgs["result"]["course"]>
  export type CourseInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    courseDisciplines?: boolean | Course$courseDisciplinesArgs<ExtArgs>
    coursePricing?: boolean | Course$coursePricingArgs<ExtArgs>
    academicDepartment?: boolean | AcademicDepartmentDefaultArgs<ExtArgs>
    studentCourses?: boolean | Course$studentCoursesArgs<ExtArgs>
    preRequisite?: boolean | Course$preRequisiteArgs<ExtArgs>
    preRequisiteFor?: boolean | Course$preRequisiteForArgs<ExtArgs>
    faculties?: boolean | Course$facultiesArgs<ExtArgs>
    offeredCourses?: boolean | Course$offeredCoursesArgs<ExtArgs>
    _count?: boolean | CourseCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $CoursePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Course"
    objects: {
      courseDisciplines: Prisma.$CourseDisciplinePayload<ExtArgs>[]
      coursePricing: Prisma.$CoursePricingPayload<ExtArgs> | null
      academicDepartment: Prisma.$AcademicDepartmentPayload<ExtArgs>
      studentCourses: Prisma.$StudentEnrolledCoursePayload<ExtArgs>[]
      preRequisite: Prisma.$CourseToPreRequisitePayload<ExtArgs>[]
      preRequisiteFor: Prisma.$CourseToPreRequisitePayload<ExtArgs>[]
      faculties: Prisma.$CourseFacultyPayload<ExtArgs>[]
      offeredCourses: Prisma.$OfferedCoursePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      code: string
      durationInYears: number
      yearLevel: $Enums.YearLevel
      shift: $Enums.Shift
      academicDepartmentId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["course"]>
    composites: {}
  }

  type CourseGetPayload<S extends boolean | null | undefined | CourseDefaultArgs> = $Result.GetResult<Prisma.$CoursePayload, S>

  type CourseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CourseFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CourseCountAggregateInputType | true
    }

  export interface CourseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Course'], meta: { name: 'Course' } }
    /**
     * Find zero or one Course that matches the filter.
     * @param {CourseFindUniqueArgs} args - Arguments to find a Course
     * @example
     * // Get one Course
     * const course = await prisma.course.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CourseFindUniqueArgs>(args: SelectSubset<T, CourseFindUniqueArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Course that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CourseFindUniqueOrThrowArgs} args - Arguments to find a Course
     * @example
     * // Get one Course
     * const course = await prisma.course.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CourseFindUniqueOrThrowArgs>(args: SelectSubset<T, CourseFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Course that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseFindFirstArgs} args - Arguments to find a Course
     * @example
     * // Get one Course
     * const course = await prisma.course.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CourseFindFirstArgs>(args?: SelectSubset<T, CourseFindFirstArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Course that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseFindFirstOrThrowArgs} args - Arguments to find a Course
     * @example
     * // Get one Course
     * const course = await prisma.course.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CourseFindFirstOrThrowArgs>(args?: SelectSubset<T, CourseFindFirstOrThrowArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Courses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Courses
     * const courses = await prisma.course.findMany()
     * 
     * // Get first 10 Courses
     * const courses = await prisma.course.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const courseWithIdOnly = await prisma.course.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CourseFindManyArgs>(args?: SelectSubset<T, CourseFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Course.
     * @param {CourseCreateArgs} args - Arguments to create a Course.
     * @example
     * // Create one Course
     * const Course = await prisma.course.create({
     *   data: {
     *     // ... data to create a Course
     *   }
     * })
     * 
     */
    create<T extends CourseCreateArgs>(args: SelectSubset<T, CourseCreateArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Courses.
     * @param {CourseCreateManyArgs} args - Arguments to create many Courses.
     * @example
     * // Create many Courses
     * const course = await prisma.course.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CourseCreateManyArgs>(args?: SelectSubset<T, CourseCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Course.
     * @param {CourseDeleteArgs} args - Arguments to delete one Course.
     * @example
     * // Delete one Course
     * const Course = await prisma.course.delete({
     *   where: {
     *     // ... filter to delete one Course
     *   }
     * })
     * 
     */
    delete<T extends CourseDeleteArgs>(args: SelectSubset<T, CourseDeleteArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Course.
     * @param {CourseUpdateArgs} args - Arguments to update one Course.
     * @example
     * // Update one Course
     * const course = await prisma.course.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CourseUpdateArgs>(args: SelectSubset<T, CourseUpdateArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Courses.
     * @param {CourseDeleteManyArgs} args - Arguments to filter Courses to delete.
     * @example
     * // Delete a few Courses
     * const { count } = await prisma.course.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CourseDeleteManyArgs>(args?: SelectSubset<T, CourseDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Courses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Courses
     * const course = await prisma.course.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CourseUpdateManyArgs>(args: SelectSubset<T, CourseUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Course.
     * @param {CourseUpsertArgs} args - Arguments to update or create a Course.
     * @example
     * // Update or create a Course
     * const course = await prisma.course.upsert({
     *   create: {
     *     // ... data to create a Course
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Course we want to update
     *   }
     * })
     */
    upsert<T extends CourseUpsertArgs>(args: SelectSubset<T, CourseUpsertArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Courses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseCountArgs} args - Arguments to filter Courses to count.
     * @example
     * // Count the number of Courses
     * const count = await prisma.course.count({
     *   where: {
     *     // ... the filter for the Courses we want to count
     *   }
     * })
    **/
    count<T extends CourseCountArgs>(
      args?: Subset<T, CourseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CourseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Course.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CourseAggregateArgs>(args: Subset<T, CourseAggregateArgs>): Prisma.PrismaPromise<GetCourseAggregateType<T>>

    /**
     * Group by Course.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CourseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CourseGroupByArgs['orderBy'] }
        : { orderBy?: CourseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CourseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCourseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Course model
   */
  readonly fields: CourseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Course.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CourseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    courseDisciplines<T extends Course$courseDisciplinesArgs<ExtArgs> = {}>(args?: Subset<T, Course$courseDisciplinesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CourseDisciplinePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    coursePricing<T extends Course$coursePricingArgs<ExtArgs> = {}>(args?: Subset<T, Course$coursePricingArgs<ExtArgs>>): Prisma__CoursePricingClient<$Result.GetResult<Prisma.$CoursePricingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    academicDepartment<T extends AcademicDepartmentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AcademicDepartmentDefaultArgs<ExtArgs>>): Prisma__AcademicDepartmentClient<$Result.GetResult<Prisma.$AcademicDepartmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    studentCourses<T extends Course$studentCoursesArgs<ExtArgs> = {}>(args?: Subset<T, Course$studentCoursesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentEnrolledCoursePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    preRequisite<T extends Course$preRequisiteArgs<ExtArgs> = {}>(args?: Subset<T, Course$preRequisiteArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CourseToPreRequisitePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    preRequisiteFor<T extends Course$preRequisiteForArgs<ExtArgs> = {}>(args?: Subset<T, Course$preRequisiteForArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CourseToPreRequisitePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    faculties<T extends Course$facultiesArgs<ExtArgs> = {}>(args?: Subset<T, Course$facultiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CourseFacultyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    offeredCourses<T extends Course$offeredCoursesArgs<ExtArgs> = {}>(args?: Subset<T, Course$offeredCoursesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OfferedCoursePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Course model
   */
  interface CourseFieldRefs {
    readonly id: FieldRef<"Course", 'String'>
    readonly title: FieldRef<"Course", 'String'>
    readonly code: FieldRef<"Course", 'String'>
    readonly durationInYears: FieldRef<"Course", 'Int'>
    readonly yearLevel: FieldRef<"Course", 'YearLevel'>
    readonly shift: FieldRef<"Course", 'Shift'>
    readonly academicDepartmentId: FieldRef<"Course", 'String'>
    readonly createdAt: FieldRef<"Course", 'DateTime'>
    readonly updatedAt: FieldRef<"Course", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Course findUnique
   */
  export type CourseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Course
     */
    omit?: CourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * Filter, which Course to fetch.
     */
    where: CourseWhereUniqueInput
  }

  /**
   * Course findUniqueOrThrow
   */
  export type CourseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Course
     */
    omit?: CourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * Filter, which Course to fetch.
     */
    where: CourseWhereUniqueInput
  }

  /**
   * Course findFirst
   */
  export type CourseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Course
     */
    omit?: CourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * Filter, which Course to fetch.
     */
    where?: CourseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Courses to fetch.
     */
    orderBy?: CourseOrderByWithRelationInput | CourseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Courses.
     */
    cursor?: CourseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Courses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Courses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Courses.
     */
    distinct?: CourseScalarFieldEnum | CourseScalarFieldEnum[]
  }

  /**
   * Course findFirstOrThrow
   */
  export type CourseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Course
     */
    omit?: CourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * Filter, which Course to fetch.
     */
    where?: CourseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Courses to fetch.
     */
    orderBy?: CourseOrderByWithRelationInput | CourseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Courses.
     */
    cursor?: CourseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Courses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Courses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Courses.
     */
    distinct?: CourseScalarFieldEnum | CourseScalarFieldEnum[]
  }

  /**
   * Course findMany
   */
  export type CourseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Course
     */
    omit?: CourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * Filter, which Courses to fetch.
     */
    where?: CourseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Courses to fetch.
     */
    orderBy?: CourseOrderByWithRelationInput | CourseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Courses.
     */
    cursor?: CourseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Courses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Courses.
     */
    skip?: number
    distinct?: CourseScalarFieldEnum | CourseScalarFieldEnum[]
  }

  /**
   * Course create
   */
  export type CourseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Course
     */
    omit?: CourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * The data needed to create a Course.
     */
    data: XOR<CourseCreateInput, CourseUncheckedCreateInput>
  }

  /**
   * Course createMany
   */
  export type CourseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Courses.
     */
    data: CourseCreateManyInput | CourseCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Course update
   */
  export type CourseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Course
     */
    omit?: CourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * The data needed to update a Course.
     */
    data: XOR<CourseUpdateInput, CourseUncheckedUpdateInput>
    /**
     * Choose, which Course to update.
     */
    where: CourseWhereUniqueInput
  }

  /**
   * Course updateMany
   */
  export type CourseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Courses.
     */
    data: XOR<CourseUpdateManyMutationInput, CourseUncheckedUpdateManyInput>
    /**
     * Filter which Courses to update
     */
    where?: CourseWhereInput
    /**
     * Limit how many Courses to update.
     */
    limit?: number
  }

  /**
   * Course upsert
   */
  export type CourseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Course
     */
    omit?: CourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * The filter to search for the Course to update in case it exists.
     */
    where: CourseWhereUniqueInput
    /**
     * In case the Course found by the `where` argument doesn't exist, create a new Course with this data.
     */
    create: XOR<CourseCreateInput, CourseUncheckedCreateInput>
    /**
     * In case the Course was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CourseUpdateInput, CourseUncheckedUpdateInput>
  }

  /**
   * Course delete
   */
  export type CourseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Course
     */
    omit?: CourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * Filter which Course to delete.
     */
    where: CourseWhereUniqueInput
  }

  /**
   * Course deleteMany
   */
  export type CourseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Courses to delete
     */
    where?: CourseWhereInput
    /**
     * Limit how many Courses to delete.
     */
    limit?: number
  }

  /**
   * Course.courseDisciplines
   */
  export type Course$courseDisciplinesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseDiscipline
     */
    select?: CourseDisciplineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseDiscipline
     */
    omit?: CourseDisciplineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseDisciplineInclude<ExtArgs> | null
    where?: CourseDisciplineWhereInput
    orderBy?: CourseDisciplineOrderByWithRelationInput | CourseDisciplineOrderByWithRelationInput[]
    cursor?: CourseDisciplineWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CourseDisciplineScalarFieldEnum | CourseDisciplineScalarFieldEnum[]
  }

  /**
   * Course.coursePricing
   */
  export type Course$coursePricingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoursePricing
     */
    select?: CoursePricingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CoursePricing
     */
    omit?: CoursePricingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoursePricingInclude<ExtArgs> | null
    where?: CoursePricingWhereInput
  }

  /**
   * Course.studentCourses
   */
  export type Course$studentCoursesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentEnrolledCourse
     */
    select?: StudentEnrolledCourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentEnrolledCourse
     */
    omit?: StudentEnrolledCourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentEnrolledCourseInclude<ExtArgs> | null
    where?: StudentEnrolledCourseWhereInput
    orderBy?: StudentEnrolledCourseOrderByWithRelationInput | StudentEnrolledCourseOrderByWithRelationInput[]
    cursor?: StudentEnrolledCourseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StudentEnrolledCourseScalarFieldEnum | StudentEnrolledCourseScalarFieldEnum[]
  }

  /**
   * Course.preRequisite
   */
  export type Course$preRequisiteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseToPreRequisite
     */
    select?: CourseToPreRequisiteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseToPreRequisite
     */
    omit?: CourseToPreRequisiteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseToPreRequisiteInclude<ExtArgs> | null
    where?: CourseToPreRequisiteWhereInput
    orderBy?: CourseToPreRequisiteOrderByWithRelationInput | CourseToPreRequisiteOrderByWithRelationInput[]
    cursor?: CourseToPreRequisiteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CourseToPreRequisiteScalarFieldEnum | CourseToPreRequisiteScalarFieldEnum[]
  }

  /**
   * Course.preRequisiteFor
   */
  export type Course$preRequisiteForArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseToPreRequisite
     */
    select?: CourseToPreRequisiteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseToPreRequisite
     */
    omit?: CourseToPreRequisiteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseToPreRequisiteInclude<ExtArgs> | null
    where?: CourseToPreRequisiteWhereInput
    orderBy?: CourseToPreRequisiteOrderByWithRelationInput | CourseToPreRequisiteOrderByWithRelationInput[]
    cursor?: CourseToPreRequisiteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CourseToPreRequisiteScalarFieldEnum | CourseToPreRequisiteScalarFieldEnum[]
  }

  /**
   * Course.faculties
   */
  export type Course$facultiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseFaculty
     */
    select?: CourseFacultySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseFaculty
     */
    omit?: CourseFacultyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseFacultyInclude<ExtArgs> | null
    where?: CourseFacultyWhereInput
    orderBy?: CourseFacultyOrderByWithRelationInput | CourseFacultyOrderByWithRelationInput[]
    cursor?: CourseFacultyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CourseFacultyScalarFieldEnum | CourseFacultyScalarFieldEnum[]
  }

  /**
   * Course.offeredCourses
   */
  export type Course$offeredCoursesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OfferedCourse
     */
    select?: OfferedCourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OfferedCourse
     */
    omit?: OfferedCourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OfferedCourseInclude<ExtArgs> | null
    where?: OfferedCourseWhereInput
    orderBy?: OfferedCourseOrderByWithRelationInput | OfferedCourseOrderByWithRelationInput[]
    cursor?: OfferedCourseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OfferedCourseScalarFieldEnum | OfferedCourseScalarFieldEnum[]
  }

  /**
   * Course without action
   */
  export type CourseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Course
     */
    omit?: CourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
  }


  /**
   * Model CourseToPreRequisite
   */

  export type AggregateCourseToPreRequisite = {
    _count: CourseToPreRequisiteCountAggregateOutputType | null
    _min: CourseToPreRequisiteMinAggregateOutputType | null
    _max: CourseToPreRequisiteMaxAggregateOutputType | null
  }

  export type CourseToPreRequisiteMinAggregateOutputType = {
    courseId: string | null
    preRequisiteId: string | null
  }

  export type CourseToPreRequisiteMaxAggregateOutputType = {
    courseId: string | null
    preRequisiteId: string | null
  }

  export type CourseToPreRequisiteCountAggregateOutputType = {
    courseId: number
    preRequisiteId: number
    _all: number
  }


  export type CourseToPreRequisiteMinAggregateInputType = {
    courseId?: true
    preRequisiteId?: true
  }

  export type CourseToPreRequisiteMaxAggregateInputType = {
    courseId?: true
    preRequisiteId?: true
  }

  export type CourseToPreRequisiteCountAggregateInputType = {
    courseId?: true
    preRequisiteId?: true
    _all?: true
  }

  export type CourseToPreRequisiteAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CourseToPreRequisite to aggregate.
     */
    where?: CourseToPreRequisiteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CourseToPreRequisites to fetch.
     */
    orderBy?: CourseToPreRequisiteOrderByWithRelationInput | CourseToPreRequisiteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CourseToPreRequisiteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CourseToPreRequisites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CourseToPreRequisites.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CourseToPreRequisites
    **/
    _count?: true | CourseToPreRequisiteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CourseToPreRequisiteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CourseToPreRequisiteMaxAggregateInputType
  }

  export type GetCourseToPreRequisiteAggregateType<T extends CourseToPreRequisiteAggregateArgs> = {
        [P in keyof T & keyof AggregateCourseToPreRequisite]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCourseToPreRequisite[P]>
      : GetScalarType<T[P], AggregateCourseToPreRequisite[P]>
  }




  export type CourseToPreRequisiteGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CourseToPreRequisiteWhereInput
    orderBy?: CourseToPreRequisiteOrderByWithAggregationInput | CourseToPreRequisiteOrderByWithAggregationInput[]
    by: CourseToPreRequisiteScalarFieldEnum[] | CourseToPreRequisiteScalarFieldEnum
    having?: CourseToPreRequisiteScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CourseToPreRequisiteCountAggregateInputType | true
    _min?: CourseToPreRequisiteMinAggregateInputType
    _max?: CourseToPreRequisiteMaxAggregateInputType
  }

  export type CourseToPreRequisiteGroupByOutputType = {
    courseId: string
    preRequisiteId: string
    _count: CourseToPreRequisiteCountAggregateOutputType | null
    _min: CourseToPreRequisiteMinAggregateOutputType | null
    _max: CourseToPreRequisiteMaxAggregateOutputType | null
  }

  type GetCourseToPreRequisiteGroupByPayload<T extends CourseToPreRequisiteGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CourseToPreRequisiteGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CourseToPreRequisiteGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CourseToPreRequisiteGroupByOutputType[P]>
            : GetScalarType<T[P], CourseToPreRequisiteGroupByOutputType[P]>
        }
      >
    >


  export type CourseToPreRequisiteSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    courseId?: boolean
    preRequisiteId?: boolean
    course?: boolean | CourseDefaultArgs<ExtArgs>
    preRequisite?: boolean | CourseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["courseToPreRequisite"]>



  export type CourseToPreRequisiteSelectScalar = {
    courseId?: boolean
    preRequisiteId?: boolean
  }

  export type CourseToPreRequisiteOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"courseId" | "preRequisiteId", ExtArgs["result"]["courseToPreRequisite"]>
  export type CourseToPreRequisiteInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    course?: boolean | CourseDefaultArgs<ExtArgs>
    preRequisite?: boolean | CourseDefaultArgs<ExtArgs>
  }

  export type $CourseToPreRequisitePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CourseToPreRequisite"
    objects: {
      course: Prisma.$CoursePayload<ExtArgs>
      preRequisite: Prisma.$CoursePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      courseId: string
      preRequisiteId: string
    }, ExtArgs["result"]["courseToPreRequisite"]>
    composites: {}
  }

  type CourseToPreRequisiteGetPayload<S extends boolean | null | undefined | CourseToPreRequisiteDefaultArgs> = $Result.GetResult<Prisma.$CourseToPreRequisitePayload, S>

  type CourseToPreRequisiteCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CourseToPreRequisiteFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CourseToPreRequisiteCountAggregateInputType | true
    }

  export interface CourseToPreRequisiteDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CourseToPreRequisite'], meta: { name: 'CourseToPreRequisite' } }
    /**
     * Find zero or one CourseToPreRequisite that matches the filter.
     * @param {CourseToPreRequisiteFindUniqueArgs} args - Arguments to find a CourseToPreRequisite
     * @example
     * // Get one CourseToPreRequisite
     * const courseToPreRequisite = await prisma.courseToPreRequisite.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CourseToPreRequisiteFindUniqueArgs>(args: SelectSubset<T, CourseToPreRequisiteFindUniqueArgs<ExtArgs>>): Prisma__CourseToPreRequisiteClient<$Result.GetResult<Prisma.$CourseToPreRequisitePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CourseToPreRequisite that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CourseToPreRequisiteFindUniqueOrThrowArgs} args - Arguments to find a CourseToPreRequisite
     * @example
     * // Get one CourseToPreRequisite
     * const courseToPreRequisite = await prisma.courseToPreRequisite.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CourseToPreRequisiteFindUniqueOrThrowArgs>(args: SelectSubset<T, CourseToPreRequisiteFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CourseToPreRequisiteClient<$Result.GetResult<Prisma.$CourseToPreRequisitePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CourseToPreRequisite that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseToPreRequisiteFindFirstArgs} args - Arguments to find a CourseToPreRequisite
     * @example
     * // Get one CourseToPreRequisite
     * const courseToPreRequisite = await prisma.courseToPreRequisite.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CourseToPreRequisiteFindFirstArgs>(args?: SelectSubset<T, CourseToPreRequisiteFindFirstArgs<ExtArgs>>): Prisma__CourseToPreRequisiteClient<$Result.GetResult<Prisma.$CourseToPreRequisitePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CourseToPreRequisite that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseToPreRequisiteFindFirstOrThrowArgs} args - Arguments to find a CourseToPreRequisite
     * @example
     * // Get one CourseToPreRequisite
     * const courseToPreRequisite = await prisma.courseToPreRequisite.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CourseToPreRequisiteFindFirstOrThrowArgs>(args?: SelectSubset<T, CourseToPreRequisiteFindFirstOrThrowArgs<ExtArgs>>): Prisma__CourseToPreRequisiteClient<$Result.GetResult<Prisma.$CourseToPreRequisitePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CourseToPreRequisites that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseToPreRequisiteFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CourseToPreRequisites
     * const courseToPreRequisites = await prisma.courseToPreRequisite.findMany()
     * 
     * // Get first 10 CourseToPreRequisites
     * const courseToPreRequisites = await prisma.courseToPreRequisite.findMany({ take: 10 })
     * 
     * // Only select the `courseId`
     * const courseToPreRequisiteWithCourseIdOnly = await prisma.courseToPreRequisite.findMany({ select: { courseId: true } })
     * 
     */
    findMany<T extends CourseToPreRequisiteFindManyArgs>(args?: SelectSubset<T, CourseToPreRequisiteFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CourseToPreRequisitePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CourseToPreRequisite.
     * @param {CourseToPreRequisiteCreateArgs} args - Arguments to create a CourseToPreRequisite.
     * @example
     * // Create one CourseToPreRequisite
     * const CourseToPreRequisite = await prisma.courseToPreRequisite.create({
     *   data: {
     *     // ... data to create a CourseToPreRequisite
     *   }
     * })
     * 
     */
    create<T extends CourseToPreRequisiteCreateArgs>(args: SelectSubset<T, CourseToPreRequisiteCreateArgs<ExtArgs>>): Prisma__CourseToPreRequisiteClient<$Result.GetResult<Prisma.$CourseToPreRequisitePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CourseToPreRequisites.
     * @param {CourseToPreRequisiteCreateManyArgs} args - Arguments to create many CourseToPreRequisites.
     * @example
     * // Create many CourseToPreRequisites
     * const courseToPreRequisite = await prisma.courseToPreRequisite.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CourseToPreRequisiteCreateManyArgs>(args?: SelectSubset<T, CourseToPreRequisiteCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a CourseToPreRequisite.
     * @param {CourseToPreRequisiteDeleteArgs} args - Arguments to delete one CourseToPreRequisite.
     * @example
     * // Delete one CourseToPreRequisite
     * const CourseToPreRequisite = await prisma.courseToPreRequisite.delete({
     *   where: {
     *     // ... filter to delete one CourseToPreRequisite
     *   }
     * })
     * 
     */
    delete<T extends CourseToPreRequisiteDeleteArgs>(args: SelectSubset<T, CourseToPreRequisiteDeleteArgs<ExtArgs>>): Prisma__CourseToPreRequisiteClient<$Result.GetResult<Prisma.$CourseToPreRequisitePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CourseToPreRequisite.
     * @param {CourseToPreRequisiteUpdateArgs} args - Arguments to update one CourseToPreRequisite.
     * @example
     * // Update one CourseToPreRequisite
     * const courseToPreRequisite = await prisma.courseToPreRequisite.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CourseToPreRequisiteUpdateArgs>(args: SelectSubset<T, CourseToPreRequisiteUpdateArgs<ExtArgs>>): Prisma__CourseToPreRequisiteClient<$Result.GetResult<Prisma.$CourseToPreRequisitePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CourseToPreRequisites.
     * @param {CourseToPreRequisiteDeleteManyArgs} args - Arguments to filter CourseToPreRequisites to delete.
     * @example
     * // Delete a few CourseToPreRequisites
     * const { count } = await prisma.courseToPreRequisite.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CourseToPreRequisiteDeleteManyArgs>(args?: SelectSubset<T, CourseToPreRequisiteDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CourseToPreRequisites.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseToPreRequisiteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CourseToPreRequisites
     * const courseToPreRequisite = await prisma.courseToPreRequisite.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CourseToPreRequisiteUpdateManyArgs>(args: SelectSubset<T, CourseToPreRequisiteUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CourseToPreRequisite.
     * @param {CourseToPreRequisiteUpsertArgs} args - Arguments to update or create a CourseToPreRequisite.
     * @example
     * // Update or create a CourseToPreRequisite
     * const courseToPreRequisite = await prisma.courseToPreRequisite.upsert({
     *   create: {
     *     // ... data to create a CourseToPreRequisite
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CourseToPreRequisite we want to update
     *   }
     * })
     */
    upsert<T extends CourseToPreRequisiteUpsertArgs>(args: SelectSubset<T, CourseToPreRequisiteUpsertArgs<ExtArgs>>): Prisma__CourseToPreRequisiteClient<$Result.GetResult<Prisma.$CourseToPreRequisitePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CourseToPreRequisites.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseToPreRequisiteCountArgs} args - Arguments to filter CourseToPreRequisites to count.
     * @example
     * // Count the number of CourseToPreRequisites
     * const count = await prisma.courseToPreRequisite.count({
     *   where: {
     *     // ... the filter for the CourseToPreRequisites we want to count
     *   }
     * })
    **/
    count<T extends CourseToPreRequisiteCountArgs>(
      args?: Subset<T, CourseToPreRequisiteCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CourseToPreRequisiteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CourseToPreRequisite.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseToPreRequisiteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CourseToPreRequisiteAggregateArgs>(args: Subset<T, CourseToPreRequisiteAggregateArgs>): Prisma.PrismaPromise<GetCourseToPreRequisiteAggregateType<T>>

    /**
     * Group by CourseToPreRequisite.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseToPreRequisiteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CourseToPreRequisiteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CourseToPreRequisiteGroupByArgs['orderBy'] }
        : { orderBy?: CourseToPreRequisiteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CourseToPreRequisiteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCourseToPreRequisiteGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CourseToPreRequisite model
   */
  readonly fields: CourseToPreRequisiteFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CourseToPreRequisite.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CourseToPreRequisiteClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    course<T extends CourseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CourseDefaultArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    preRequisite<T extends CourseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CourseDefaultArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CourseToPreRequisite model
   */
  interface CourseToPreRequisiteFieldRefs {
    readonly courseId: FieldRef<"CourseToPreRequisite", 'String'>
    readonly preRequisiteId: FieldRef<"CourseToPreRequisite", 'String'>
  }
    

  // Custom InputTypes
  /**
   * CourseToPreRequisite findUnique
   */
  export type CourseToPreRequisiteFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseToPreRequisite
     */
    select?: CourseToPreRequisiteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseToPreRequisite
     */
    omit?: CourseToPreRequisiteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseToPreRequisiteInclude<ExtArgs> | null
    /**
     * Filter, which CourseToPreRequisite to fetch.
     */
    where: CourseToPreRequisiteWhereUniqueInput
  }

  /**
   * CourseToPreRequisite findUniqueOrThrow
   */
  export type CourseToPreRequisiteFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseToPreRequisite
     */
    select?: CourseToPreRequisiteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseToPreRequisite
     */
    omit?: CourseToPreRequisiteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseToPreRequisiteInclude<ExtArgs> | null
    /**
     * Filter, which CourseToPreRequisite to fetch.
     */
    where: CourseToPreRequisiteWhereUniqueInput
  }

  /**
   * CourseToPreRequisite findFirst
   */
  export type CourseToPreRequisiteFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseToPreRequisite
     */
    select?: CourseToPreRequisiteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseToPreRequisite
     */
    omit?: CourseToPreRequisiteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseToPreRequisiteInclude<ExtArgs> | null
    /**
     * Filter, which CourseToPreRequisite to fetch.
     */
    where?: CourseToPreRequisiteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CourseToPreRequisites to fetch.
     */
    orderBy?: CourseToPreRequisiteOrderByWithRelationInput | CourseToPreRequisiteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CourseToPreRequisites.
     */
    cursor?: CourseToPreRequisiteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CourseToPreRequisites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CourseToPreRequisites.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CourseToPreRequisites.
     */
    distinct?: CourseToPreRequisiteScalarFieldEnum | CourseToPreRequisiteScalarFieldEnum[]
  }

  /**
   * CourseToPreRequisite findFirstOrThrow
   */
  export type CourseToPreRequisiteFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseToPreRequisite
     */
    select?: CourseToPreRequisiteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseToPreRequisite
     */
    omit?: CourseToPreRequisiteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseToPreRequisiteInclude<ExtArgs> | null
    /**
     * Filter, which CourseToPreRequisite to fetch.
     */
    where?: CourseToPreRequisiteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CourseToPreRequisites to fetch.
     */
    orderBy?: CourseToPreRequisiteOrderByWithRelationInput | CourseToPreRequisiteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CourseToPreRequisites.
     */
    cursor?: CourseToPreRequisiteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CourseToPreRequisites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CourseToPreRequisites.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CourseToPreRequisites.
     */
    distinct?: CourseToPreRequisiteScalarFieldEnum | CourseToPreRequisiteScalarFieldEnum[]
  }

  /**
   * CourseToPreRequisite findMany
   */
  export type CourseToPreRequisiteFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseToPreRequisite
     */
    select?: CourseToPreRequisiteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseToPreRequisite
     */
    omit?: CourseToPreRequisiteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseToPreRequisiteInclude<ExtArgs> | null
    /**
     * Filter, which CourseToPreRequisites to fetch.
     */
    where?: CourseToPreRequisiteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CourseToPreRequisites to fetch.
     */
    orderBy?: CourseToPreRequisiteOrderByWithRelationInput | CourseToPreRequisiteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CourseToPreRequisites.
     */
    cursor?: CourseToPreRequisiteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CourseToPreRequisites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CourseToPreRequisites.
     */
    skip?: number
    distinct?: CourseToPreRequisiteScalarFieldEnum | CourseToPreRequisiteScalarFieldEnum[]
  }

  /**
   * CourseToPreRequisite create
   */
  export type CourseToPreRequisiteCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseToPreRequisite
     */
    select?: CourseToPreRequisiteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseToPreRequisite
     */
    omit?: CourseToPreRequisiteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseToPreRequisiteInclude<ExtArgs> | null
    /**
     * The data needed to create a CourseToPreRequisite.
     */
    data: XOR<CourseToPreRequisiteCreateInput, CourseToPreRequisiteUncheckedCreateInput>
  }

  /**
   * CourseToPreRequisite createMany
   */
  export type CourseToPreRequisiteCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CourseToPreRequisites.
     */
    data: CourseToPreRequisiteCreateManyInput | CourseToPreRequisiteCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CourseToPreRequisite update
   */
  export type CourseToPreRequisiteUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseToPreRequisite
     */
    select?: CourseToPreRequisiteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseToPreRequisite
     */
    omit?: CourseToPreRequisiteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseToPreRequisiteInclude<ExtArgs> | null
    /**
     * The data needed to update a CourseToPreRequisite.
     */
    data: XOR<CourseToPreRequisiteUpdateInput, CourseToPreRequisiteUncheckedUpdateInput>
    /**
     * Choose, which CourseToPreRequisite to update.
     */
    where: CourseToPreRequisiteWhereUniqueInput
  }

  /**
   * CourseToPreRequisite updateMany
   */
  export type CourseToPreRequisiteUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CourseToPreRequisites.
     */
    data: XOR<CourseToPreRequisiteUpdateManyMutationInput, CourseToPreRequisiteUncheckedUpdateManyInput>
    /**
     * Filter which CourseToPreRequisites to update
     */
    where?: CourseToPreRequisiteWhereInput
    /**
     * Limit how many CourseToPreRequisites to update.
     */
    limit?: number
  }

  /**
   * CourseToPreRequisite upsert
   */
  export type CourseToPreRequisiteUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseToPreRequisite
     */
    select?: CourseToPreRequisiteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseToPreRequisite
     */
    omit?: CourseToPreRequisiteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseToPreRequisiteInclude<ExtArgs> | null
    /**
     * The filter to search for the CourseToPreRequisite to update in case it exists.
     */
    where: CourseToPreRequisiteWhereUniqueInput
    /**
     * In case the CourseToPreRequisite found by the `where` argument doesn't exist, create a new CourseToPreRequisite with this data.
     */
    create: XOR<CourseToPreRequisiteCreateInput, CourseToPreRequisiteUncheckedCreateInput>
    /**
     * In case the CourseToPreRequisite was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CourseToPreRequisiteUpdateInput, CourseToPreRequisiteUncheckedUpdateInput>
  }

  /**
   * CourseToPreRequisite delete
   */
  export type CourseToPreRequisiteDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseToPreRequisite
     */
    select?: CourseToPreRequisiteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseToPreRequisite
     */
    omit?: CourseToPreRequisiteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseToPreRequisiteInclude<ExtArgs> | null
    /**
     * Filter which CourseToPreRequisite to delete.
     */
    where: CourseToPreRequisiteWhereUniqueInput
  }

  /**
   * CourseToPreRequisite deleteMany
   */
  export type CourseToPreRequisiteDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CourseToPreRequisites to delete
     */
    where?: CourseToPreRequisiteWhereInput
    /**
     * Limit how many CourseToPreRequisites to delete.
     */
    limit?: number
  }

  /**
   * CourseToPreRequisite without action
   */
  export type CourseToPreRequisiteDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseToPreRequisite
     */
    select?: CourseToPreRequisiteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseToPreRequisite
     */
    omit?: CourseToPreRequisiteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseToPreRequisiteInclude<ExtArgs> | null
  }


  /**
   * Model CourseFaculty
   */

  export type AggregateCourseFaculty = {
    _count: CourseFacultyCountAggregateOutputType | null
    _min: CourseFacultyMinAggregateOutputType | null
    _max: CourseFacultyMaxAggregateOutputType | null
  }

  export type CourseFacultyMinAggregateOutputType = {
    courseId: string | null
    facultyId: string | null
  }

  export type CourseFacultyMaxAggregateOutputType = {
    courseId: string | null
    facultyId: string | null
  }

  export type CourseFacultyCountAggregateOutputType = {
    courseId: number
    facultyId: number
    _all: number
  }


  export type CourseFacultyMinAggregateInputType = {
    courseId?: true
    facultyId?: true
  }

  export type CourseFacultyMaxAggregateInputType = {
    courseId?: true
    facultyId?: true
  }

  export type CourseFacultyCountAggregateInputType = {
    courseId?: true
    facultyId?: true
    _all?: true
  }

  export type CourseFacultyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CourseFaculty to aggregate.
     */
    where?: CourseFacultyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CourseFaculties to fetch.
     */
    orderBy?: CourseFacultyOrderByWithRelationInput | CourseFacultyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CourseFacultyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CourseFaculties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CourseFaculties.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CourseFaculties
    **/
    _count?: true | CourseFacultyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CourseFacultyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CourseFacultyMaxAggregateInputType
  }

  export type GetCourseFacultyAggregateType<T extends CourseFacultyAggregateArgs> = {
        [P in keyof T & keyof AggregateCourseFaculty]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCourseFaculty[P]>
      : GetScalarType<T[P], AggregateCourseFaculty[P]>
  }




  export type CourseFacultyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CourseFacultyWhereInput
    orderBy?: CourseFacultyOrderByWithAggregationInput | CourseFacultyOrderByWithAggregationInput[]
    by: CourseFacultyScalarFieldEnum[] | CourseFacultyScalarFieldEnum
    having?: CourseFacultyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CourseFacultyCountAggregateInputType | true
    _min?: CourseFacultyMinAggregateInputType
    _max?: CourseFacultyMaxAggregateInputType
  }

  export type CourseFacultyGroupByOutputType = {
    courseId: string
    facultyId: string
    _count: CourseFacultyCountAggregateOutputType | null
    _min: CourseFacultyMinAggregateOutputType | null
    _max: CourseFacultyMaxAggregateOutputType | null
  }

  type GetCourseFacultyGroupByPayload<T extends CourseFacultyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CourseFacultyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CourseFacultyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CourseFacultyGroupByOutputType[P]>
            : GetScalarType<T[P], CourseFacultyGroupByOutputType[P]>
        }
      >
    >


  export type CourseFacultySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    courseId?: boolean
    facultyId?: boolean
    course?: boolean | CourseDefaultArgs<ExtArgs>
    faculty?: boolean | FacultyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["courseFaculty"]>



  export type CourseFacultySelectScalar = {
    courseId?: boolean
    facultyId?: boolean
  }

  export type CourseFacultyOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"courseId" | "facultyId", ExtArgs["result"]["courseFaculty"]>
  export type CourseFacultyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    course?: boolean | CourseDefaultArgs<ExtArgs>
    faculty?: boolean | FacultyDefaultArgs<ExtArgs>
  }

  export type $CourseFacultyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CourseFaculty"
    objects: {
      course: Prisma.$CoursePayload<ExtArgs>
      faculty: Prisma.$FacultyPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      courseId: string
      facultyId: string
    }, ExtArgs["result"]["courseFaculty"]>
    composites: {}
  }

  type CourseFacultyGetPayload<S extends boolean | null | undefined | CourseFacultyDefaultArgs> = $Result.GetResult<Prisma.$CourseFacultyPayload, S>

  type CourseFacultyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CourseFacultyFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CourseFacultyCountAggregateInputType | true
    }

  export interface CourseFacultyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CourseFaculty'], meta: { name: 'CourseFaculty' } }
    /**
     * Find zero or one CourseFaculty that matches the filter.
     * @param {CourseFacultyFindUniqueArgs} args - Arguments to find a CourseFaculty
     * @example
     * // Get one CourseFaculty
     * const courseFaculty = await prisma.courseFaculty.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CourseFacultyFindUniqueArgs>(args: SelectSubset<T, CourseFacultyFindUniqueArgs<ExtArgs>>): Prisma__CourseFacultyClient<$Result.GetResult<Prisma.$CourseFacultyPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CourseFaculty that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CourseFacultyFindUniqueOrThrowArgs} args - Arguments to find a CourseFaculty
     * @example
     * // Get one CourseFaculty
     * const courseFaculty = await prisma.courseFaculty.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CourseFacultyFindUniqueOrThrowArgs>(args: SelectSubset<T, CourseFacultyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CourseFacultyClient<$Result.GetResult<Prisma.$CourseFacultyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CourseFaculty that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseFacultyFindFirstArgs} args - Arguments to find a CourseFaculty
     * @example
     * // Get one CourseFaculty
     * const courseFaculty = await prisma.courseFaculty.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CourseFacultyFindFirstArgs>(args?: SelectSubset<T, CourseFacultyFindFirstArgs<ExtArgs>>): Prisma__CourseFacultyClient<$Result.GetResult<Prisma.$CourseFacultyPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CourseFaculty that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseFacultyFindFirstOrThrowArgs} args - Arguments to find a CourseFaculty
     * @example
     * // Get one CourseFaculty
     * const courseFaculty = await prisma.courseFaculty.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CourseFacultyFindFirstOrThrowArgs>(args?: SelectSubset<T, CourseFacultyFindFirstOrThrowArgs<ExtArgs>>): Prisma__CourseFacultyClient<$Result.GetResult<Prisma.$CourseFacultyPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CourseFaculties that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseFacultyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CourseFaculties
     * const courseFaculties = await prisma.courseFaculty.findMany()
     * 
     * // Get first 10 CourseFaculties
     * const courseFaculties = await prisma.courseFaculty.findMany({ take: 10 })
     * 
     * // Only select the `courseId`
     * const courseFacultyWithCourseIdOnly = await prisma.courseFaculty.findMany({ select: { courseId: true } })
     * 
     */
    findMany<T extends CourseFacultyFindManyArgs>(args?: SelectSubset<T, CourseFacultyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CourseFacultyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CourseFaculty.
     * @param {CourseFacultyCreateArgs} args - Arguments to create a CourseFaculty.
     * @example
     * // Create one CourseFaculty
     * const CourseFaculty = await prisma.courseFaculty.create({
     *   data: {
     *     // ... data to create a CourseFaculty
     *   }
     * })
     * 
     */
    create<T extends CourseFacultyCreateArgs>(args: SelectSubset<T, CourseFacultyCreateArgs<ExtArgs>>): Prisma__CourseFacultyClient<$Result.GetResult<Prisma.$CourseFacultyPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CourseFaculties.
     * @param {CourseFacultyCreateManyArgs} args - Arguments to create many CourseFaculties.
     * @example
     * // Create many CourseFaculties
     * const courseFaculty = await prisma.courseFaculty.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CourseFacultyCreateManyArgs>(args?: SelectSubset<T, CourseFacultyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a CourseFaculty.
     * @param {CourseFacultyDeleteArgs} args - Arguments to delete one CourseFaculty.
     * @example
     * // Delete one CourseFaculty
     * const CourseFaculty = await prisma.courseFaculty.delete({
     *   where: {
     *     // ... filter to delete one CourseFaculty
     *   }
     * })
     * 
     */
    delete<T extends CourseFacultyDeleteArgs>(args: SelectSubset<T, CourseFacultyDeleteArgs<ExtArgs>>): Prisma__CourseFacultyClient<$Result.GetResult<Prisma.$CourseFacultyPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CourseFaculty.
     * @param {CourseFacultyUpdateArgs} args - Arguments to update one CourseFaculty.
     * @example
     * // Update one CourseFaculty
     * const courseFaculty = await prisma.courseFaculty.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CourseFacultyUpdateArgs>(args: SelectSubset<T, CourseFacultyUpdateArgs<ExtArgs>>): Prisma__CourseFacultyClient<$Result.GetResult<Prisma.$CourseFacultyPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CourseFaculties.
     * @param {CourseFacultyDeleteManyArgs} args - Arguments to filter CourseFaculties to delete.
     * @example
     * // Delete a few CourseFaculties
     * const { count } = await prisma.courseFaculty.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CourseFacultyDeleteManyArgs>(args?: SelectSubset<T, CourseFacultyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CourseFaculties.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseFacultyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CourseFaculties
     * const courseFaculty = await prisma.courseFaculty.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CourseFacultyUpdateManyArgs>(args: SelectSubset<T, CourseFacultyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CourseFaculty.
     * @param {CourseFacultyUpsertArgs} args - Arguments to update or create a CourseFaculty.
     * @example
     * // Update or create a CourseFaculty
     * const courseFaculty = await prisma.courseFaculty.upsert({
     *   create: {
     *     // ... data to create a CourseFaculty
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CourseFaculty we want to update
     *   }
     * })
     */
    upsert<T extends CourseFacultyUpsertArgs>(args: SelectSubset<T, CourseFacultyUpsertArgs<ExtArgs>>): Prisma__CourseFacultyClient<$Result.GetResult<Prisma.$CourseFacultyPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CourseFaculties.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseFacultyCountArgs} args - Arguments to filter CourseFaculties to count.
     * @example
     * // Count the number of CourseFaculties
     * const count = await prisma.courseFaculty.count({
     *   where: {
     *     // ... the filter for the CourseFaculties we want to count
     *   }
     * })
    **/
    count<T extends CourseFacultyCountArgs>(
      args?: Subset<T, CourseFacultyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CourseFacultyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CourseFaculty.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseFacultyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CourseFacultyAggregateArgs>(args: Subset<T, CourseFacultyAggregateArgs>): Prisma.PrismaPromise<GetCourseFacultyAggregateType<T>>

    /**
     * Group by CourseFaculty.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseFacultyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CourseFacultyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CourseFacultyGroupByArgs['orderBy'] }
        : { orderBy?: CourseFacultyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CourseFacultyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCourseFacultyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CourseFaculty model
   */
  readonly fields: CourseFacultyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CourseFaculty.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CourseFacultyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    course<T extends CourseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CourseDefaultArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    faculty<T extends FacultyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FacultyDefaultArgs<ExtArgs>>): Prisma__FacultyClient<$Result.GetResult<Prisma.$FacultyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CourseFaculty model
   */
  interface CourseFacultyFieldRefs {
    readonly courseId: FieldRef<"CourseFaculty", 'String'>
    readonly facultyId: FieldRef<"CourseFaculty", 'String'>
  }
    

  // Custom InputTypes
  /**
   * CourseFaculty findUnique
   */
  export type CourseFacultyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseFaculty
     */
    select?: CourseFacultySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseFaculty
     */
    omit?: CourseFacultyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseFacultyInclude<ExtArgs> | null
    /**
     * Filter, which CourseFaculty to fetch.
     */
    where: CourseFacultyWhereUniqueInput
  }

  /**
   * CourseFaculty findUniqueOrThrow
   */
  export type CourseFacultyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseFaculty
     */
    select?: CourseFacultySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseFaculty
     */
    omit?: CourseFacultyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseFacultyInclude<ExtArgs> | null
    /**
     * Filter, which CourseFaculty to fetch.
     */
    where: CourseFacultyWhereUniqueInput
  }

  /**
   * CourseFaculty findFirst
   */
  export type CourseFacultyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseFaculty
     */
    select?: CourseFacultySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseFaculty
     */
    omit?: CourseFacultyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseFacultyInclude<ExtArgs> | null
    /**
     * Filter, which CourseFaculty to fetch.
     */
    where?: CourseFacultyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CourseFaculties to fetch.
     */
    orderBy?: CourseFacultyOrderByWithRelationInput | CourseFacultyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CourseFaculties.
     */
    cursor?: CourseFacultyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CourseFaculties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CourseFaculties.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CourseFaculties.
     */
    distinct?: CourseFacultyScalarFieldEnum | CourseFacultyScalarFieldEnum[]
  }

  /**
   * CourseFaculty findFirstOrThrow
   */
  export type CourseFacultyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseFaculty
     */
    select?: CourseFacultySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseFaculty
     */
    omit?: CourseFacultyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseFacultyInclude<ExtArgs> | null
    /**
     * Filter, which CourseFaculty to fetch.
     */
    where?: CourseFacultyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CourseFaculties to fetch.
     */
    orderBy?: CourseFacultyOrderByWithRelationInput | CourseFacultyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CourseFaculties.
     */
    cursor?: CourseFacultyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CourseFaculties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CourseFaculties.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CourseFaculties.
     */
    distinct?: CourseFacultyScalarFieldEnum | CourseFacultyScalarFieldEnum[]
  }

  /**
   * CourseFaculty findMany
   */
  export type CourseFacultyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseFaculty
     */
    select?: CourseFacultySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseFaculty
     */
    omit?: CourseFacultyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseFacultyInclude<ExtArgs> | null
    /**
     * Filter, which CourseFaculties to fetch.
     */
    where?: CourseFacultyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CourseFaculties to fetch.
     */
    orderBy?: CourseFacultyOrderByWithRelationInput | CourseFacultyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CourseFaculties.
     */
    cursor?: CourseFacultyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CourseFaculties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CourseFaculties.
     */
    skip?: number
    distinct?: CourseFacultyScalarFieldEnum | CourseFacultyScalarFieldEnum[]
  }

  /**
   * CourseFaculty create
   */
  export type CourseFacultyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseFaculty
     */
    select?: CourseFacultySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseFaculty
     */
    omit?: CourseFacultyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseFacultyInclude<ExtArgs> | null
    /**
     * The data needed to create a CourseFaculty.
     */
    data: XOR<CourseFacultyCreateInput, CourseFacultyUncheckedCreateInput>
  }

  /**
   * CourseFaculty createMany
   */
  export type CourseFacultyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CourseFaculties.
     */
    data: CourseFacultyCreateManyInput | CourseFacultyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CourseFaculty update
   */
  export type CourseFacultyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseFaculty
     */
    select?: CourseFacultySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseFaculty
     */
    omit?: CourseFacultyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseFacultyInclude<ExtArgs> | null
    /**
     * The data needed to update a CourseFaculty.
     */
    data: XOR<CourseFacultyUpdateInput, CourseFacultyUncheckedUpdateInput>
    /**
     * Choose, which CourseFaculty to update.
     */
    where: CourseFacultyWhereUniqueInput
  }

  /**
   * CourseFaculty updateMany
   */
  export type CourseFacultyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CourseFaculties.
     */
    data: XOR<CourseFacultyUpdateManyMutationInput, CourseFacultyUncheckedUpdateManyInput>
    /**
     * Filter which CourseFaculties to update
     */
    where?: CourseFacultyWhereInput
    /**
     * Limit how many CourseFaculties to update.
     */
    limit?: number
  }

  /**
   * CourseFaculty upsert
   */
  export type CourseFacultyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseFaculty
     */
    select?: CourseFacultySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseFaculty
     */
    omit?: CourseFacultyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseFacultyInclude<ExtArgs> | null
    /**
     * The filter to search for the CourseFaculty to update in case it exists.
     */
    where: CourseFacultyWhereUniqueInput
    /**
     * In case the CourseFaculty found by the `where` argument doesn't exist, create a new CourseFaculty with this data.
     */
    create: XOR<CourseFacultyCreateInput, CourseFacultyUncheckedCreateInput>
    /**
     * In case the CourseFaculty was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CourseFacultyUpdateInput, CourseFacultyUncheckedUpdateInput>
  }

  /**
   * CourseFaculty delete
   */
  export type CourseFacultyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseFaculty
     */
    select?: CourseFacultySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseFaculty
     */
    omit?: CourseFacultyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseFacultyInclude<ExtArgs> | null
    /**
     * Filter which CourseFaculty to delete.
     */
    where: CourseFacultyWhereUniqueInput
  }

  /**
   * CourseFaculty deleteMany
   */
  export type CourseFacultyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CourseFaculties to delete
     */
    where?: CourseFacultyWhereInput
    /**
     * Limit how many CourseFaculties to delete.
     */
    limit?: number
  }

  /**
   * CourseFaculty without action
   */
  export type CourseFacultyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseFaculty
     */
    select?: CourseFacultySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseFaculty
     */
    omit?: CourseFacultyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseFacultyInclude<ExtArgs> | null
  }


  /**
   * Model SemesterRegistration
   */

  export type AggregateSemesterRegistration = {
    _count: SemesterRegistrationCountAggregateOutputType | null
    _min: SemesterRegistrationMinAggregateOutputType | null
    _max: SemesterRegistrationMaxAggregateOutputType | null
  }

  export type SemesterRegistrationMinAggregateOutputType = {
    id: string | null
    startDate: Date | null
    endDate: Date | null
    status: $Enums.SemesterRegistrationStatus | null
    createdAt: Date | null
    updateAt: Date | null
    academicSemesterId: string | null
  }

  export type SemesterRegistrationMaxAggregateOutputType = {
    id: string | null
    startDate: Date | null
    endDate: Date | null
    status: $Enums.SemesterRegistrationStatus | null
    createdAt: Date | null
    updateAt: Date | null
    academicSemesterId: string | null
  }

  export type SemesterRegistrationCountAggregateOutputType = {
    id: number
    startDate: number
    endDate: number
    status: number
    createdAt: number
    updateAt: number
    academicSemesterId: number
    _all: number
  }


  export type SemesterRegistrationMinAggregateInputType = {
    id?: true
    startDate?: true
    endDate?: true
    status?: true
    createdAt?: true
    updateAt?: true
    academicSemesterId?: true
  }

  export type SemesterRegistrationMaxAggregateInputType = {
    id?: true
    startDate?: true
    endDate?: true
    status?: true
    createdAt?: true
    updateAt?: true
    academicSemesterId?: true
  }

  export type SemesterRegistrationCountAggregateInputType = {
    id?: true
    startDate?: true
    endDate?: true
    status?: true
    createdAt?: true
    updateAt?: true
    academicSemesterId?: true
    _all?: true
  }

  export type SemesterRegistrationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SemesterRegistration to aggregate.
     */
    where?: SemesterRegistrationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SemesterRegistrations to fetch.
     */
    orderBy?: SemesterRegistrationOrderByWithRelationInput | SemesterRegistrationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SemesterRegistrationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SemesterRegistrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SemesterRegistrations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SemesterRegistrations
    **/
    _count?: true | SemesterRegistrationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SemesterRegistrationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SemesterRegistrationMaxAggregateInputType
  }

  export type GetSemesterRegistrationAggregateType<T extends SemesterRegistrationAggregateArgs> = {
        [P in keyof T & keyof AggregateSemesterRegistration]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSemesterRegistration[P]>
      : GetScalarType<T[P], AggregateSemesterRegistration[P]>
  }




  export type SemesterRegistrationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SemesterRegistrationWhereInput
    orderBy?: SemesterRegistrationOrderByWithAggregationInput | SemesterRegistrationOrderByWithAggregationInput[]
    by: SemesterRegistrationScalarFieldEnum[] | SemesterRegistrationScalarFieldEnum
    having?: SemesterRegistrationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SemesterRegistrationCountAggregateInputType | true
    _min?: SemesterRegistrationMinAggregateInputType
    _max?: SemesterRegistrationMaxAggregateInputType
  }

  export type SemesterRegistrationGroupByOutputType = {
    id: string
    startDate: Date
    endDate: Date
    status: $Enums.SemesterRegistrationStatus | null
    createdAt: Date
    updateAt: Date
    academicSemesterId: string
    _count: SemesterRegistrationCountAggregateOutputType | null
    _min: SemesterRegistrationMinAggregateOutputType | null
    _max: SemesterRegistrationMaxAggregateOutputType | null
  }

  type GetSemesterRegistrationGroupByPayload<T extends SemesterRegistrationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SemesterRegistrationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SemesterRegistrationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SemesterRegistrationGroupByOutputType[P]>
            : GetScalarType<T[P], SemesterRegistrationGroupByOutputType[P]>
        }
      >
    >


  export type SemesterRegistrationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    startDate?: boolean
    endDate?: boolean
    status?: boolean
    createdAt?: boolean
    updateAt?: boolean
    academicSemesterId?: boolean
    academicSemester?: boolean | AcademicSemesterDefaultArgs<ExtArgs>
    offeredCourses?: boolean | SemesterRegistration$offeredCoursesArgs<ExtArgs>
    offeredCourseSections?: boolean | SemesterRegistration$offeredCourseSectionsArgs<ExtArgs>
    offeredCourseClassSchedules?: boolean | SemesterRegistration$offeredCourseClassSchedulesArgs<ExtArgs>
    studentSemesterRegistrations?: boolean | SemesterRegistration$studentSemesterRegistrationsArgs<ExtArgs>
    studentSemesterRegistrationCourses?: boolean | SemesterRegistration$studentSemesterRegistrationCoursesArgs<ExtArgs>
    _count?: boolean | SemesterRegistrationCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["semesterRegistration"]>



  export type SemesterRegistrationSelectScalar = {
    id?: boolean
    startDate?: boolean
    endDate?: boolean
    status?: boolean
    createdAt?: boolean
    updateAt?: boolean
    academicSemesterId?: boolean
  }

  export type SemesterRegistrationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "startDate" | "endDate" | "status" | "createdAt" | "updateAt" | "academicSemesterId", ExtArgs["result"]["semesterRegistration"]>
  export type SemesterRegistrationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    academicSemester?: boolean | AcademicSemesterDefaultArgs<ExtArgs>
    offeredCourses?: boolean | SemesterRegistration$offeredCoursesArgs<ExtArgs>
    offeredCourseSections?: boolean | SemesterRegistration$offeredCourseSectionsArgs<ExtArgs>
    offeredCourseClassSchedules?: boolean | SemesterRegistration$offeredCourseClassSchedulesArgs<ExtArgs>
    studentSemesterRegistrations?: boolean | SemesterRegistration$studentSemesterRegistrationsArgs<ExtArgs>
    studentSemesterRegistrationCourses?: boolean | SemesterRegistration$studentSemesterRegistrationCoursesArgs<ExtArgs>
    _count?: boolean | SemesterRegistrationCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $SemesterRegistrationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SemesterRegistration"
    objects: {
      academicSemester: Prisma.$AcademicSemesterPayload<ExtArgs>
      offeredCourses: Prisma.$OfferedCoursePayload<ExtArgs>[]
      offeredCourseSections: Prisma.$OfferedCourseSectionPayload<ExtArgs>[]
      offeredCourseClassSchedules: Prisma.$OfferedCourseClassSchedulePayload<ExtArgs>[]
      studentSemesterRegistrations: Prisma.$StudentSemesterRegistrationPayload<ExtArgs>[]
      studentSemesterRegistrationCourses: Prisma.$StudentSemesterRegistrationCoursePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      startDate: Date
      endDate: Date
      status: $Enums.SemesterRegistrationStatus | null
      createdAt: Date
      updateAt: Date
      academicSemesterId: string
    }, ExtArgs["result"]["semesterRegistration"]>
    composites: {}
  }

  type SemesterRegistrationGetPayload<S extends boolean | null | undefined | SemesterRegistrationDefaultArgs> = $Result.GetResult<Prisma.$SemesterRegistrationPayload, S>

  type SemesterRegistrationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SemesterRegistrationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SemesterRegistrationCountAggregateInputType | true
    }

  export interface SemesterRegistrationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SemesterRegistration'], meta: { name: 'SemesterRegistration' } }
    /**
     * Find zero or one SemesterRegistration that matches the filter.
     * @param {SemesterRegistrationFindUniqueArgs} args - Arguments to find a SemesterRegistration
     * @example
     * // Get one SemesterRegistration
     * const semesterRegistration = await prisma.semesterRegistration.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SemesterRegistrationFindUniqueArgs>(args: SelectSubset<T, SemesterRegistrationFindUniqueArgs<ExtArgs>>): Prisma__SemesterRegistrationClient<$Result.GetResult<Prisma.$SemesterRegistrationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SemesterRegistration that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SemesterRegistrationFindUniqueOrThrowArgs} args - Arguments to find a SemesterRegistration
     * @example
     * // Get one SemesterRegistration
     * const semesterRegistration = await prisma.semesterRegistration.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SemesterRegistrationFindUniqueOrThrowArgs>(args: SelectSubset<T, SemesterRegistrationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SemesterRegistrationClient<$Result.GetResult<Prisma.$SemesterRegistrationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SemesterRegistration that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SemesterRegistrationFindFirstArgs} args - Arguments to find a SemesterRegistration
     * @example
     * // Get one SemesterRegistration
     * const semesterRegistration = await prisma.semesterRegistration.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SemesterRegistrationFindFirstArgs>(args?: SelectSubset<T, SemesterRegistrationFindFirstArgs<ExtArgs>>): Prisma__SemesterRegistrationClient<$Result.GetResult<Prisma.$SemesterRegistrationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SemesterRegistration that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SemesterRegistrationFindFirstOrThrowArgs} args - Arguments to find a SemesterRegistration
     * @example
     * // Get one SemesterRegistration
     * const semesterRegistration = await prisma.semesterRegistration.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SemesterRegistrationFindFirstOrThrowArgs>(args?: SelectSubset<T, SemesterRegistrationFindFirstOrThrowArgs<ExtArgs>>): Prisma__SemesterRegistrationClient<$Result.GetResult<Prisma.$SemesterRegistrationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SemesterRegistrations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SemesterRegistrationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SemesterRegistrations
     * const semesterRegistrations = await prisma.semesterRegistration.findMany()
     * 
     * // Get first 10 SemesterRegistrations
     * const semesterRegistrations = await prisma.semesterRegistration.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const semesterRegistrationWithIdOnly = await prisma.semesterRegistration.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SemesterRegistrationFindManyArgs>(args?: SelectSubset<T, SemesterRegistrationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SemesterRegistrationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SemesterRegistration.
     * @param {SemesterRegistrationCreateArgs} args - Arguments to create a SemesterRegistration.
     * @example
     * // Create one SemesterRegistration
     * const SemesterRegistration = await prisma.semesterRegistration.create({
     *   data: {
     *     // ... data to create a SemesterRegistration
     *   }
     * })
     * 
     */
    create<T extends SemesterRegistrationCreateArgs>(args: SelectSubset<T, SemesterRegistrationCreateArgs<ExtArgs>>): Prisma__SemesterRegistrationClient<$Result.GetResult<Prisma.$SemesterRegistrationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SemesterRegistrations.
     * @param {SemesterRegistrationCreateManyArgs} args - Arguments to create many SemesterRegistrations.
     * @example
     * // Create many SemesterRegistrations
     * const semesterRegistration = await prisma.semesterRegistration.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SemesterRegistrationCreateManyArgs>(args?: SelectSubset<T, SemesterRegistrationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a SemesterRegistration.
     * @param {SemesterRegistrationDeleteArgs} args - Arguments to delete one SemesterRegistration.
     * @example
     * // Delete one SemesterRegistration
     * const SemesterRegistration = await prisma.semesterRegistration.delete({
     *   where: {
     *     // ... filter to delete one SemesterRegistration
     *   }
     * })
     * 
     */
    delete<T extends SemesterRegistrationDeleteArgs>(args: SelectSubset<T, SemesterRegistrationDeleteArgs<ExtArgs>>): Prisma__SemesterRegistrationClient<$Result.GetResult<Prisma.$SemesterRegistrationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SemesterRegistration.
     * @param {SemesterRegistrationUpdateArgs} args - Arguments to update one SemesterRegistration.
     * @example
     * // Update one SemesterRegistration
     * const semesterRegistration = await prisma.semesterRegistration.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SemesterRegistrationUpdateArgs>(args: SelectSubset<T, SemesterRegistrationUpdateArgs<ExtArgs>>): Prisma__SemesterRegistrationClient<$Result.GetResult<Prisma.$SemesterRegistrationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SemesterRegistrations.
     * @param {SemesterRegistrationDeleteManyArgs} args - Arguments to filter SemesterRegistrations to delete.
     * @example
     * // Delete a few SemesterRegistrations
     * const { count } = await prisma.semesterRegistration.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SemesterRegistrationDeleteManyArgs>(args?: SelectSubset<T, SemesterRegistrationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SemesterRegistrations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SemesterRegistrationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SemesterRegistrations
     * const semesterRegistration = await prisma.semesterRegistration.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SemesterRegistrationUpdateManyArgs>(args: SelectSubset<T, SemesterRegistrationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SemesterRegistration.
     * @param {SemesterRegistrationUpsertArgs} args - Arguments to update or create a SemesterRegistration.
     * @example
     * // Update or create a SemesterRegistration
     * const semesterRegistration = await prisma.semesterRegistration.upsert({
     *   create: {
     *     // ... data to create a SemesterRegistration
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SemesterRegistration we want to update
     *   }
     * })
     */
    upsert<T extends SemesterRegistrationUpsertArgs>(args: SelectSubset<T, SemesterRegistrationUpsertArgs<ExtArgs>>): Prisma__SemesterRegistrationClient<$Result.GetResult<Prisma.$SemesterRegistrationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SemesterRegistrations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SemesterRegistrationCountArgs} args - Arguments to filter SemesterRegistrations to count.
     * @example
     * // Count the number of SemesterRegistrations
     * const count = await prisma.semesterRegistration.count({
     *   where: {
     *     // ... the filter for the SemesterRegistrations we want to count
     *   }
     * })
    **/
    count<T extends SemesterRegistrationCountArgs>(
      args?: Subset<T, SemesterRegistrationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SemesterRegistrationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SemesterRegistration.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SemesterRegistrationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SemesterRegistrationAggregateArgs>(args: Subset<T, SemesterRegistrationAggregateArgs>): Prisma.PrismaPromise<GetSemesterRegistrationAggregateType<T>>

    /**
     * Group by SemesterRegistration.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SemesterRegistrationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SemesterRegistrationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SemesterRegistrationGroupByArgs['orderBy'] }
        : { orderBy?: SemesterRegistrationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SemesterRegistrationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSemesterRegistrationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SemesterRegistration model
   */
  readonly fields: SemesterRegistrationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SemesterRegistration.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SemesterRegistrationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    academicSemester<T extends AcademicSemesterDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AcademicSemesterDefaultArgs<ExtArgs>>): Prisma__AcademicSemesterClient<$Result.GetResult<Prisma.$AcademicSemesterPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    offeredCourses<T extends SemesterRegistration$offeredCoursesArgs<ExtArgs> = {}>(args?: Subset<T, SemesterRegistration$offeredCoursesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OfferedCoursePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    offeredCourseSections<T extends SemesterRegistration$offeredCourseSectionsArgs<ExtArgs> = {}>(args?: Subset<T, SemesterRegistration$offeredCourseSectionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OfferedCourseSectionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    offeredCourseClassSchedules<T extends SemesterRegistration$offeredCourseClassSchedulesArgs<ExtArgs> = {}>(args?: Subset<T, SemesterRegistration$offeredCourseClassSchedulesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OfferedCourseClassSchedulePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    studentSemesterRegistrations<T extends SemesterRegistration$studentSemesterRegistrationsArgs<ExtArgs> = {}>(args?: Subset<T, SemesterRegistration$studentSemesterRegistrationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentSemesterRegistrationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    studentSemesterRegistrationCourses<T extends SemesterRegistration$studentSemesterRegistrationCoursesArgs<ExtArgs> = {}>(args?: Subset<T, SemesterRegistration$studentSemesterRegistrationCoursesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentSemesterRegistrationCoursePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SemesterRegistration model
   */
  interface SemesterRegistrationFieldRefs {
    readonly id: FieldRef<"SemesterRegistration", 'String'>
    readonly startDate: FieldRef<"SemesterRegistration", 'DateTime'>
    readonly endDate: FieldRef<"SemesterRegistration", 'DateTime'>
    readonly status: FieldRef<"SemesterRegistration", 'SemesterRegistrationStatus'>
    readonly createdAt: FieldRef<"SemesterRegistration", 'DateTime'>
    readonly updateAt: FieldRef<"SemesterRegistration", 'DateTime'>
    readonly academicSemesterId: FieldRef<"SemesterRegistration", 'String'>
  }
    

  // Custom InputTypes
  /**
   * SemesterRegistration findUnique
   */
  export type SemesterRegistrationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SemesterRegistration
     */
    select?: SemesterRegistrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SemesterRegistration
     */
    omit?: SemesterRegistrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SemesterRegistrationInclude<ExtArgs> | null
    /**
     * Filter, which SemesterRegistration to fetch.
     */
    where: SemesterRegistrationWhereUniqueInput
  }

  /**
   * SemesterRegistration findUniqueOrThrow
   */
  export type SemesterRegistrationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SemesterRegistration
     */
    select?: SemesterRegistrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SemesterRegistration
     */
    omit?: SemesterRegistrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SemesterRegistrationInclude<ExtArgs> | null
    /**
     * Filter, which SemesterRegistration to fetch.
     */
    where: SemesterRegistrationWhereUniqueInput
  }

  /**
   * SemesterRegistration findFirst
   */
  export type SemesterRegistrationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SemesterRegistration
     */
    select?: SemesterRegistrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SemesterRegistration
     */
    omit?: SemesterRegistrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SemesterRegistrationInclude<ExtArgs> | null
    /**
     * Filter, which SemesterRegistration to fetch.
     */
    where?: SemesterRegistrationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SemesterRegistrations to fetch.
     */
    orderBy?: SemesterRegistrationOrderByWithRelationInput | SemesterRegistrationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SemesterRegistrations.
     */
    cursor?: SemesterRegistrationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SemesterRegistrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SemesterRegistrations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SemesterRegistrations.
     */
    distinct?: SemesterRegistrationScalarFieldEnum | SemesterRegistrationScalarFieldEnum[]
  }

  /**
   * SemesterRegistration findFirstOrThrow
   */
  export type SemesterRegistrationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SemesterRegistration
     */
    select?: SemesterRegistrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SemesterRegistration
     */
    omit?: SemesterRegistrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SemesterRegistrationInclude<ExtArgs> | null
    /**
     * Filter, which SemesterRegistration to fetch.
     */
    where?: SemesterRegistrationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SemesterRegistrations to fetch.
     */
    orderBy?: SemesterRegistrationOrderByWithRelationInput | SemesterRegistrationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SemesterRegistrations.
     */
    cursor?: SemesterRegistrationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SemesterRegistrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SemesterRegistrations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SemesterRegistrations.
     */
    distinct?: SemesterRegistrationScalarFieldEnum | SemesterRegistrationScalarFieldEnum[]
  }

  /**
   * SemesterRegistration findMany
   */
  export type SemesterRegistrationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SemesterRegistration
     */
    select?: SemesterRegistrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SemesterRegistration
     */
    omit?: SemesterRegistrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SemesterRegistrationInclude<ExtArgs> | null
    /**
     * Filter, which SemesterRegistrations to fetch.
     */
    where?: SemesterRegistrationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SemesterRegistrations to fetch.
     */
    orderBy?: SemesterRegistrationOrderByWithRelationInput | SemesterRegistrationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SemesterRegistrations.
     */
    cursor?: SemesterRegistrationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SemesterRegistrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SemesterRegistrations.
     */
    skip?: number
    distinct?: SemesterRegistrationScalarFieldEnum | SemesterRegistrationScalarFieldEnum[]
  }

  /**
   * SemesterRegistration create
   */
  export type SemesterRegistrationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SemesterRegistration
     */
    select?: SemesterRegistrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SemesterRegistration
     */
    omit?: SemesterRegistrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SemesterRegistrationInclude<ExtArgs> | null
    /**
     * The data needed to create a SemesterRegistration.
     */
    data: XOR<SemesterRegistrationCreateInput, SemesterRegistrationUncheckedCreateInput>
  }

  /**
   * SemesterRegistration createMany
   */
  export type SemesterRegistrationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SemesterRegistrations.
     */
    data: SemesterRegistrationCreateManyInput | SemesterRegistrationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SemesterRegistration update
   */
  export type SemesterRegistrationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SemesterRegistration
     */
    select?: SemesterRegistrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SemesterRegistration
     */
    omit?: SemesterRegistrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SemesterRegistrationInclude<ExtArgs> | null
    /**
     * The data needed to update a SemesterRegistration.
     */
    data: XOR<SemesterRegistrationUpdateInput, SemesterRegistrationUncheckedUpdateInput>
    /**
     * Choose, which SemesterRegistration to update.
     */
    where: SemesterRegistrationWhereUniqueInput
  }

  /**
   * SemesterRegistration updateMany
   */
  export type SemesterRegistrationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SemesterRegistrations.
     */
    data: XOR<SemesterRegistrationUpdateManyMutationInput, SemesterRegistrationUncheckedUpdateManyInput>
    /**
     * Filter which SemesterRegistrations to update
     */
    where?: SemesterRegistrationWhereInput
    /**
     * Limit how many SemesterRegistrations to update.
     */
    limit?: number
  }

  /**
   * SemesterRegistration upsert
   */
  export type SemesterRegistrationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SemesterRegistration
     */
    select?: SemesterRegistrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SemesterRegistration
     */
    omit?: SemesterRegistrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SemesterRegistrationInclude<ExtArgs> | null
    /**
     * The filter to search for the SemesterRegistration to update in case it exists.
     */
    where: SemesterRegistrationWhereUniqueInput
    /**
     * In case the SemesterRegistration found by the `where` argument doesn't exist, create a new SemesterRegistration with this data.
     */
    create: XOR<SemesterRegistrationCreateInput, SemesterRegistrationUncheckedCreateInput>
    /**
     * In case the SemesterRegistration was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SemesterRegistrationUpdateInput, SemesterRegistrationUncheckedUpdateInput>
  }

  /**
   * SemesterRegistration delete
   */
  export type SemesterRegistrationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SemesterRegistration
     */
    select?: SemesterRegistrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SemesterRegistration
     */
    omit?: SemesterRegistrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SemesterRegistrationInclude<ExtArgs> | null
    /**
     * Filter which SemesterRegistration to delete.
     */
    where: SemesterRegistrationWhereUniqueInput
  }

  /**
   * SemesterRegistration deleteMany
   */
  export type SemesterRegistrationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SemesterRegistrations to delete
     */
    where?: SemesterRegistrationWhereInput
    /**
     * Limit how many SemesterRegistrations to delete.
     */
    limit?: number
  }

  /**
   * SemesterRegistration.offeredCourses
   */
  export type SemesterRegistration$offeredCoursesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OfferedCourse
     */
    select?: OfferedCourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OfferedCourse
     */
    omit?: OfferedCourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OfferedCourseInclude<ExtArgs> | null
    where?: OfferedCourseWhereInput
    orderBy?: OfferedCourseOrderByWithRelationInput | OfferedCourseOrderByWithRelationInput[]
    cursor?: OfferedCourseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OfferedCourseScalarFieldEnum | OfferedCourseScalarFieldEnum[]
  }

  /**
   * SemesterRegistration.offeredCourseSections
   */
  export type SemesterRegistration$offeredCourseSectionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OfferedCourseSection
     */
    select?: OfferedCourseSectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OfferedCourseSection
     */
    omit?: OfferedCourseSectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OfferedCourseSectionInclude<ExtArgs> | null
    where?: OfferedCourseSectionWhereInput
    orderBy?: OfferedCourseSectionOrderByWithRelationInput | OfferedCourseSectionOrderByWithRelationInput[]
    cursor?: OfferedCourseSectionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OfferedCourseSectionScalarFieldEnum | OfferedCourseSectionScalarFieldEnum[]
  }

  /**
   * SemesterRegistration.offeredCourseClassSchedules
   */
  export type SemesterRegistration$offeredCourseClassSchedulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OfferedCourseClassSchedule
     */
    select?: OfferedCourseClassScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OfferedCourseClassSchedule
     */
    omit?: OfferedCourseClassScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OfferedCourseClassScheduleInclude<ExtArgs> | null
    where?: OfferedCourseClassScheduleWhereInput
    orderBy?: OfferedCourseClassScheduleOrderByWithRelationInput | OfferedCourseClassScheduleOrderByWithRelationInput[]
    cursor?: OfferedCourseClassScheduleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OfferedCourseClassScheduleScalarFieldEnum | OfferedCourseClassScheduleScalarFieldEnum[]
  }

  /**
   * SemesterRegistration.studentSemesterRegistrations
   */
  export type SemesterRegistration$studentSemesterRegistrationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentSemesterRegistration
     */
    select?: StudentSemesterRegistrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentSemesterRegistration
     */
    omit?: StudentSemesterRegistrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentSemesterRegistrationInclude<ExtArgs> | null
    where?: StudentSemesterRegistrationWhereInput
    orderBy?: StudentSemesterRegistrationOrderByWithRelationInput | StudentSemesterRegistrationOrderByWithRelationInput[]
    cursor?: StudentSemesterRegistrationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StudentSemesterRegistrationScalarFieldEnum | StudentSemesterRegistrationScalarFieldEnum[]
  }

  /**
   * SemesterRegistration.studentSemesterRegistrationCourses
   */
  export type SemesterRegistration$studentSemesterRegistrationCoursesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentSemesterRegistrationCourse
     */
    select?: StudentSemesterRegistrationCourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentSemesterRegistrationCourse
     */
    omit?: StudentSemesterRegistrationCourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentSemesterRegistrationCourseInclude<ExtArgs> | null
    where?: StudentSemesterRegistrationCourseWhereInput
    orderBy?: StudentSemesterRegistrationCourseOrderByWithRelationInput | StudentSemesterRegistrationCourseOrderByWithRelationInput[]
    cursor?: StudentSemesterRegistrationCourseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StudentSemesterRegistrationCourseScalarFieldEnum | StudentSemesterRegistrationCourseScalarFieldEnum[]
  }

  /**
   * SemesterRegistration without action
   */
  export type SemesterRegistrationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SemesterRegistration
     */
    select?: SemesterRegistrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SemesterRegistration
     */
    omit?: SemesterRegistrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SemesterRegistrationInclude<ExtArgs> | null
  }


  /**
   * Model AdmitionExameRegistration
   */

  export type AggregateAdmitionExameRegistration = {
    _count: AdmitionExameRegistrationCountAggregateOutputType | null
    _avg: AdmitionExameRegistrationAvgAggregateOutputType | null
    _sum: AdmitionExameRegistrationSumAggregateOutputType | null
    _min: AdmitionExameRegistrationMinAggregateOutputType | null
    _max: AdmitionExameRegistrationMaxAggregateOutputType | null
  }

  export type AdmitionExameRegistrationAvgAggregateOutputType = {
    paymentAmoute: number | null
    exameResults: number | null
  }

  export type AdmitionExameRegistrationSumAggregateOutputType = {
    paymentAmoute: number | null
    exameResults: number | null
  }

  export type AdmitionExameRegistrationMinAggregateOutputType = {
    id: string | null
    applicantName: string | null
    paymentRecipt: string | null
    status: $Enums.Status | null
    document: string | null
    paymentAmoute: number | null
    aprovePayment: boolean | null
    exameResults: number | null
    passed: boolean | null
    faseId: string | null
    exameDate: Date | null
    rejectionReason: string | null
    phoneNumber: string | null
    email: string | null
    createdAt: Date | null
    updateAt: Date | null
    academicFalcultyId: string | null
  }

  export type AdmitionExameRegistrationMaxAggregateOutputType = {
    id: string | null
    applicantName: string | null
    paymentRecipt: string | null
    status: $Enums.Status | null
    document: string | null
    paymentAmoute: number | null
    aprovePayment: boolean | null
    exameResults: number | null
    passed: boolean | null
    faseId: string | null
    exameDate: Date | null
    rejectionReason: string | null
    phoneNumber: string | null
    email: string | null
    createdAt: Date | null
    updateAt: Date | null
    academicFalcultyId: string | null
  }

  export type AdmitionExameRegistrationCountAggregateOutputType = {
    id: number
    applicantName: number
    paymentRecipt: number
    status: number
    document: number
    paymentAmoute: number
    aprovePayment: number
    exameResults: number
    passed: number
    faseId: number
    exameDate: number
    rejectionReason: number
    phoneNumber: number
    email: number
    createdAt: number
    updateAt: number
    academicFalcultyId: number
    _all: number
  }


  export type AdmitionExameRegistrationAvgAggregateInputType = {
    paymentAmoute?: true
    exameResults?: true
  }

  export type AdmitionExameRegistrationSumAggregateInputType = {
    paymentAmoute?: true
    exameResults?: true
  }

  export type AdmitionExameRegistrationMinAggregateInputType = {
    id?: true
    applicantName?: true
    paymentRecipt?: true
    status?: true
    document?: true
    paymentAmoute?: true
    aprovePayment?: true
    exameResults?: true
    passed?: true
    faseId?: true
    exameDate?: true
    rejectionReason?: true
    phoneNumber?: true
    email?: true
    createdAt?: true
    updateAt?: true
    academicFalcultyId?: true
  }

  export type AdmitionExameRegistrationMaxAggregateInputType = {
    id?: true
    applicantName?: true
    paymentRecipt?: true
    status?: true
    document?: true
    paymentAmoute?: true
    aprovePayment?: true
    exameResults?: true
    passed?: true
    faseId?: true
    exameDate?: true
    rejectionReason?: true
    phoneNumber?: true
    email?: true
    createdAt?: true
    updateAt?: true
    academicFalcultyId?: true
  }

  export type AdmitionExameRegistrationCountAggregateInputType = {
    id?: true
    applicantName?: true
    paymentRecipt?: true
    status?: true
    document?: true
    paymentAmoute?: true
    aprovePayment?: true
    exameResults?: true
    passed?: true
    faseId?: true
    exameDate?: true
    rejectionReason?: true
    phoneNumber?: true
    email?: true
    createdAt?: true
    updateAt?: true
    academicFalcultyId?: true
    _all?: true
  }

  export type AdmitionExameRegistrationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AdmitionExameRegistration to aggregate.
     */
    where?: AdmitionExameRegistrationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdmitionExameRegistrations to fetch.
     */
    orderBy?: AdmitionExameRegistrationOrderByWithRelationInput | AdmitionExameRegistrationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AdmitionExameRegistrationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdmitionExameRegistrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdmitionExameRegistrations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AdmitionExameRegistrations
    **/
    _count?: true | AdmitionExameRegistrationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AdmitionExameRegistrationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AdmitionExameRegistrationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AdmitionExameRegistrationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AdmitionExameRegistrationMaxAggregateInputType
  }

  export type GetAdmitionExameRegistrationAggregateType<T extends AdmitionExameRegistrationAggregateArgs> = {
        [P in keyof T & keyof AggregateAdmitionExameRegistration]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAdmitionExameRegistration[P]>
      : GetScalarType<T[P], AggregateAdmitionExameRegistration[P]>
  }




  export type AdmitionExameRegistrationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdmitionExameRegistrationWhereInput
    orderBy?: AdmitionExameRegistrationOrderByWithAggregationInput | AdmitionExameRegistrationOrderByWithAggregationInput[]
    by: AdmitionExameRegistrationScalarFieldEnum[] | AdmitionExameRegistrationScalarFieldEnum
    having?: AdmitionExameRegistrationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AdmitionExameRegistrationCountAggregateInputType | true
    _avg?: AdmitionExameRegistrationAvgAggregateInputType
    _sum?: AdmitionExameRegistrationSumAggregateInputType
    _min?: AdmitionExameRegistrationMinAggregateInputType
    _max?: AdmitionExameRegistrationMaxAggregateInputType
  }

  export type AdmitionExameRegistrationGroupByOutputType = {
    id: string
    applicantName: string
    paymentRecipt: string
    status: $Enums.Status
    document: string
    paymentAmoute: number | null
    aprovePayment: boolean | null
    exameResults: number | null
    passed: boolean | null
    faseId: string
    exameDate: Date
    rejectionReason: string | null
    phoneNumber: string
    email: string
    createdAt: Date
    updateAt: Date
    academicFalcultyId: string
    _count: AdmitionExameRegistrationCountAggregateOutputType | null
    _avg: AdmitionExameRegistrationAvgAggregateOutputType | null
    _sum: AdmitionExameRegistrationSumAggregateOutputType | null
    _min: AdmitionExameRegistrationMinAggregateOutputType | null
    _max: AdmitionExameRegistrationMaxAggregateOutputType | null
  }

  type GetAdmitionExameRegistrationGroupByPayload<T extends AdmitionExameRegistrationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AdmitionExameRegistrationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AdmitionExameRegistrationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AdmitionExameRegistrationGroupByOutputType[P]>
            : GetScalarType<T[P], AdmitionExameRegistrationGroupByOutputType[P]>
        }
      >
    >


  export type AdmitionExameRegistrationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    applicantName?: boolean
    paymentRecipt?: boolean
    status?: boolean
    document?: boolean
    paymentAmoute?: boolean
    aprovePayment?: boolean
    exameResults?: boolean
    passed?: boolean
    faseId?: boolean
    exameDate?: boolean
    rejectionReason?: boolean
    phoneNumber?: boolean
    email?: boolean
    createdAt?: boolean
    updateAt?: boolean
    academicFalcultyId?: boolean
    fase?: boolean | ExameFaseDefaultArgs<ExtArgs>
    academicFalculty?: boolean | AcademicFacultyDefaultArgs<ExtArgs>
    Student?: boolean | AdmitionExameRegistration$StudentArgs<ExtArgs>
  }, ExtArgs["result"]["admitionExameRegistration"]>



  export type AdmitionExameRegistrationSelectScalar = {
    id?: boolean
    applicantName?: boolean
    paymentRecipt?: boolean
    status?: boolean
    document?: boolean
    paymentAmoute?: boolean
    aprovePayment?: boolean
    exameResults?: boolean
    passed?: boolean
    faseId?: boolean
    exameDate?: boolean
    rejectionReason?: boolean
    phoneNumber?: boolean
    email?: boolean
    createdAt?: boolean
    updateAt?: boolean
    academicFalcultyId?: boolean
  }

  export type AdmitionExameRegistrationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "applicantName" | "paymentRecipt" | "status" | "document" | "paymentAmoute" | "aprovePayment" | "exameResults" | "passed" | "faseId" | "exameDate" | "rejectionReason" | "phoneNumber" | "email" | "createdAt" | "updateAt" | "academicFalcultyId", ExtArgs["result"]["admitionExameRegistration"]>
  export type AdmitionExameRegistrationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    fase?: boolean | ExameFaseDefaultArgs<ExtArgs>
    academicFalculty?: boolean | AcademicFacultyDefaultArgs<ExtArgs>
    Student?: boolean | AdmitionExameRegistration$StudentArgs<ExtArgs>
  }

  export type $AdmitionExameRegistrationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AdmitionExameRegistration"
    objects: {
      fase: Prisma.$ExameFasePayload<ExtArgs>
      academicFalculty: Prisma.$AcademicFacultyPayload<ExtArgs>
      Student: Prisma.$StudentPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      applicantName: string
      paymentRecipt: string
      status: $Enums.Status
      document: string
      paymentAmoute: number | null
      aprovePayment: boolean | null
      exameResults: number | null
      passed: boolean | null
      faseId: string
      exameDate: Date
      rejectionReason: string | null
      phoneNumber: string
      email: string
      createdAt: Date
      updateAt: Date
      academicFalcultyId: string
    }, ExtArgs["result"]["admitionExameRegistration"]>
    composites: {}
  }

  type AdmitionExameRegistrationGetPayload<S extends boolean | null | undefined | AdmitionExameRegistrationDefaultArgs> = $Result.GetResult<Prisma.$AdmitionExameRegistrationPayload, S>

  type AdmitionExameRegistrationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AdmitionExameRegistrationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AdmitionExameRegistrationCountAggregateInputType | true
    }

  export interface AdmitionExameRegistrationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AdmitionExameRegistration'], meta: { name: 'AdmitionExameRegistration' } }
    /**
     * Find zero or one AdmitionExameRegistration that matches the filter.
     * @param {AdmitionExameRegistrationFindUniqueArgs} args - Arguments to find a AdmitionExameRegistration
     * @example
     * // Get one AdmitionExameRegistration
     * const admitionExameRegistration = await prisma.admitionExameRegistration.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AdmitionExameRegistrationFindUniqueArgs>(args: SelectSubset<T, AdmitionExameRegistrationFindUniqueArgs<ExtArgs>>): Prisma__AdmitionExameRegistrationClient<$Result.GetResult<Prisma.$AdmitionExameRegistrationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AdmitionExameRegistration that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AdmitionExameRegistrationFindUniqueOrThrowArgs} args - Arguments to find a AdmitionExameRegistration
     * @example
     * // Get one AdmitionExameRegistration
     * const admitionExameRegistration = await prisma.admitionExameRegistration.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AdmitionExameRegistrationFindUniqueOrThrowArgs>(args: SelectSubset<T, AdmitionExameRegistrationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AdmitionExameRegistrationClient<$Result.GetResult<Prisma.$AdmitionExameRegistrationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AdmitionExameRegistration that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdmitionExameRegistrationFindFirstArgs} args - Arguments to find a AdmitionExameRegistration
     * @example
     * // Get one AdmitionExameRegistration
     * const admitionExameRegistration = await prisma.admitionExameRegistration.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AdmitionExameRegistrationFindFirstArgs>(args?: SelectSubset<T, AdmitionExameRegistrationFindFirstArgs<ExtArgs>>): Prisma__AdmitionExameRegistrationClient<$Result.GetResult<Prisma.$AdmitionExameRegistrationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AdmitionExameRegistration that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdmitionExameRegistrationFindFirstOrThrowArgs} args - Arguments to find a AdmitionExameRegistration
     * @example
     * // Get one AdmitionExameRegistration
     * const admitionExameRegistration = await prisma.admitionExameRegistration.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AdmitionExameRegistrationFindFirstOrThrowArgs>(args?: SelectSubset<T, AdmitionExameRegistrationFindFirstOrThrowArgs<ExtArgs>>): Prisma__AdmitionExameRegistrationClient<$Result.GetResult<Prisma.$AdmitionExameRegistrationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AdmitionExameRegistrations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdmitionExameRegistrationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AdmitionExameRegistrations
     * const admitionExameRegistrations = await prisma.admitionExameRegistration.findMany()
     * 
     * // Get first 10 AdmitionExameRegistrations
     * const admitionExameRegistrations = await prisma.admitionExameRegistration.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const admitionExameRegistrationWithIdOnly = await prisma.admitionExameRegistration.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AdmitionExameRegistrationFindManyArgs>(args?: SelectSubset<T, AdmitionExameRegistrationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdmitionExameRegistrationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AdmitionExameRegistration.
     * @param {AdmitionExameRegistrationCreateArgs} args - Arguments to create a AdmitionExameRegistration.
     * @example
     * // Create one AdmitionExameRegistration
     * const AdmitionExameRegistration = await prisma.admitionExameRegistration.create({
     *   data: {
     *     // ... data to create a AdmitionExameRegistration
     *   }
     * })
     * 
     */
    create<T extends AdmitionExameRegistrationCreateArgs>(args: SelectSubset<T, AdmitionExameRegistrationCreateArgs<ExtArgs>>): Prisma__AdmitionExameRegistrationClient<$Result.GetResult<Prisma.$AdmitionExameRegistrationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AdmitionExameRegistrations.
     * @param {AdmitionExameRegistrationCreateManyArgs} args - Arguments to create many AdmitionExameRegistrations.
     * @example
     * // Create many AdmitionExameRegistrations
     * const admitionExameRegistration = await prisma.admitionExameRegistration.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AdmitionExameRegistrationCreateManyArgs>(args?: SelectSubset<T, AdmitionExameRegistrationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a AdmitionExameRegistration.
     * @param {AdmitionExameRegistrationDeleteArgs} args - Arguments to delete one AdmitionExameRegistration.
     * @example
     * // Delete one AdmitionExameRegistration
     * const AdmitionExameRegistration = await prisma.admitionExameRegistration.delete({
     *   where: {
     *     // ... filter to delete one AdmitionExameRegistration
     *   }
     * })
     * 
     */
    delete<T extends AdmitionExameRegistrationDeleteArgs>(args: SelectSubset<T, AdmitionExameRegistrationDeleteArgs<ExtArgs>>): Prisma__AdmitionExameRegistrationClient<$Result.GetResult<Prisma.$AdmitionExameRegistrationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AdmitionExameRegistration.
     * @param {AdmitionExameRegistrationUpdateArgs} args - Arguments to update one AdmitionExameRegistration.
     * @example
     * // Update one AdmitionExameRegistration
     * const admitionExameRegistration = await prisma.admitionExameRegistration.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AdmitionExameRegistrationUpdateArgs>(args: SelectSubset<T, AdmitionExameRegistrationUpdateArgs<ExtArgs>>): Prisma__AdmitionExameRegistrationClient<$Result.GetResult<Prisma.$AdmitionExameRegistrationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AdmitionExameRegistrations.
     * @param {AdmitionExameRegistrationDeleteManyArgs} args - Arguments to filter AdmitionExameRegistrations to delete.
     * @example
     * // Delete a few AdmitionExameRegistrations
     * const { count } = await prisma.admitionExameRegistration.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AdmitionExameRegistrationDeleteManyArgs>(args?: SelectSubset<T, AdmitionExameRegistrationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AdmitionExameRegistrations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdmitionExameRegistrationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AdmitionExameRegistrations
     * const admitionExameRegistration = await prisma.admitionExameRegistration.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AdmitionExameRegistrationUpdateManyArgs>(args: SelectSubset<T, AdmitionExameRegistrationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AdmitionExameRegistration.
     * @param {AdmitionExameRegistrationUpsertArgs} args - Arguments to update or create a AdmitionExameRegistration.
     * @example
     * // Update or create a AdmitionExameRegistration
     * const admitionExameRegistration = await prisma.admitionExameRegistration.upsert({
     *   create: {
     *     // ... data to create a AdmitionExameRegistration
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AdmitionExameRegistration we want to update
     *   }
     * })
     */
    upsert<T extends AdmitionExameRegistrationUpsertArgs>(args: SelectSubset<T, AdmitionExameRegistrationUpsertArgs<ExtArgs>>): Prisma__AdmitionExameRegistrationClient<$Result.GetResult<Prisma.$AdmitionExameRegistrationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AdmitionExameRegistrations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdmitionExameRegistrationCountArgs} args - Arguments to filter AdmitionExameRegistrations to count.
     * @example
     * // Count the number of AdmitionExameRegistrations
     * const count = await prisma.admitionExameRegistration.count({
     *   where: {
     *     // ... the filter for the AdmitionExameRegistrations we want to count
     *   }
     * })
    **/
    count<T extends AdmitionExameRegistrationCountArgs>(
      args?: Subset<T, AdmitionExameRegistrationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AdmitionExameRegistrationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AdmitionExameRegistration.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdmitionExameRegistrationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AdmitionExameRegistrationAggregateArgs>(args: Subset<T, AdmitionExameRegistrationAggregateArgs>): Prisma.PrismaPromise<GetAdmitionExameRegistrationAggregateType<T>>

    /**
     * Group by AdmitionExameRegistration.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdmitionExameRegistrationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AdmitionExameRegistrationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AdmitionExameRegistrationGroupByArgs['orderBy'] }
        : { orderBy?: AdmitionExameRegistrationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AdmitionExameRegistrationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAdmitionExameRegistrationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AdmitionExameRegistration model
   */
  readonly fields: AdmitionExameRegistrationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AdmitionExameRegistration.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AdmitionExameRegistrationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    fase<T extends ExameFaseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ExameFaseDefaultArgs<ExtArgs>>): Prisma__ExameFaseClient<$Result.GetResult<Prisma.$ExameFasePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    academicFalculty<T extends AcademicFacultyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AcademicFacultyDefaultArgs<ExtArgs>>): Prisma__AcademicFacultyClient<$Result.GetResult<Prisma.$AcademicFacultyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    Student<T extends AdmitionExameRegistration$StudentArgs<ExtArgs> = {}>(args?: Subset<T, AdmitionExameRegistration$StudentArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AdmitionExameRegistration model
   */
  interface AdmitionExameRegistrationFieldRefs {
    readonly id: FieldRef<"AdmitionExameRegistration", 'String'>
    readonly applicantName: FieldRef<"AdmitionExameRegistration", 'String'>
    readonly paymentRecipt: FieldRef<"AdmitionExameRegistration", 'String'>
    readonly status: FieldRef<"AdmitionExameRegistration", 'Status'>
    readonly document: FieldRef<"AdmitionExameRegistration", 'String'>
    readonly paymentAmoute: FieldRef<"AdmitionExameRegistration", 'Int'>
    readonly aprovePayment: FieldRef<"AdmitionExameRegistration", 'Boolean'>
    readonly exameResults: FieldRef<"AdmitionExameRegistration", 'Int'>
    readonly passed: FieldRef<"AdmitionExameRegistration", 'Boolean'>
    readonly faseId: FieldRef<"AdmitionExameRegistration", 'String'>
    readonly exameDate: FieldRef<"AdmitionExameRegistration", 'DateTime'>
    readonly rejectionReason: FieldRef<"AdmitionExameRegistration", 'String'>
    readonly phoneNumber: FieldRef<"AdmitionExameRegistration", 'String'>
    readonly email: FieldRef<"AdmitionExameRegistration", 'String'>
    readonly createdAt: FieldRef<"AdmitionExameRegistration", 'DateTime'>
    readonly updateAt: FieldRef<"AdmitionExameRegistration", 'DateTime'>
    readonly academicFalcultyId: FieldRef<"AdmitionExameRegistration", 'String'>
  }
    

  // Custom InputTypes
  /**
   * AdmitionExameRegistration findUnique
   */
  export type AdmitionExameRegistrationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdmitionExameRegistration
     */
    select?: AdmitionExameRegistrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdmitionExameRegistration
     */
    omit?: AdmitionExameRegistrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdmitionExameRegistrationInclude<ExtArgs> | null
    /**
     * Filter, which AdmitionExameRegistration to fetch.
     */
    where: AdmitionExameRegistrationWhereUniqueInput
  }

  /**
   * AdmitionExameRegistration findUniqueOrThrow
   */
  export type AdmitionExameRegistrationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdmitionExameRegistration
     */
    select?: AdmitionExameRegistrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdmitionExameRegistration
     */
    omit?: AdmitionExameRegistrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdmitionExameRegistrationInclude<ExtArgs> | null
    /**
     * Filter, which AdmitionExameRegistration to fetch.
     */
    where: AdmitionExameRegistrationWhereUniqueInput
  }

  /**
   * AdmitionExameRegistration findFirst
   */
  export type AdmitionExameRegistrationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdmitionExameRegistration
     */
    select?: AdmitionExameRegistrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdmitionExameRegistration
     */
    omit?: AdmitionExameRegistrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdmitionExameRegistrationInclude<ExtArgs> | null
    /**
     * Filter, which AdmitionExameRegistration to fetch.
     */
    where?: AdmitionExameRegistrationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdmitionExameRegistrations to fetch.
     */
    orderBy?: AdmitionExameRegistrationOrderByWithRelationInput | AdmitionExameRegistrationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AdmitionExameRegistrations.
     */
    cursor?: AdmitionExameRegistrationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdmitionExameRegistrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdmitionExameRegistrations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AdmitionExameRegistrations.
     */
    distinct?: AdmitionExameRegistrationScalarFieldEnum | AdmitionExameRegistrationScalarFieldEnum[]
  }

  /**
   * AdmitionExameRegistration findFirstOrThrow
   */
  export type AdmitionExameRegistrationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdmitionExameRegistration
     */
    select?: AdmitionExameRegistrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdmitionExameRegistration
     */
    omit?: AdmitionExameRegistrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdmitionExameRegistrationInclude<ExtArgs> | null
    /**
     * Filter, which AdmitionExameRegistration to fetch.
     */
    where?: AdmitionExameRegistrationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdmitionExameRegistrations to fetch.
     */
    orderBy?: AdmitionExameRegistrationOrderByWithRelationInput | AdmitionExameRegistrationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AdmitionExameRegistrations.
     */
    cursor?: AdmitionExameRegistrationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdmitionExameRegistrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdmitionExameRegistrations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AdmitionExameRegistrations.
     */
    distinct?: AdmitionExameRegistrationScalarFieldEnum | AdmitionExameRegistrationScalarFieldEnum[]
  }

  /**
   * AdmitionExameRegistration findMany
   */
  export type AdmitionExameRegistrationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdmitionExameRegistration
     */
    select?: AdmitionExameRegistrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdmitionExameRegistration
     */
    omit?: AdmitionExameRegistrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdmitionExameRegistrationInclude<ExtArgs> | null
    /**
     * Filter, which AdmitionExameRegistrations to fetch.
     */
    where?: AdmitionExameRegistrationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdmitionExameRegistrations to fetch.
     */
    orderBy?: AdmitionExameRegistrationOrderByWithRelationInput | AdmitionExameRegistrationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AdmitionExameRegistrations.
     */
    cursor?: AdmitionExameRegistrationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdmitionExameRegistrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdmitionExameRegistrations.
     */
    skip?: number
    distinct?: AdmitionExameRegistrationScalarFieldEnum | AdmitionExameRegistrationScalarFieldEnum[]
  }

  /**
   * AdmitionExameRegistration create
   */
  export type AdmitionExameRegistrationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdmitionExameRegistration
     */
    select?: AdmitionExameRegistrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdmitionExameRegistration
     */
    omit?: AdmitionExameRegistrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdmitionExameRegistrationInclude<ExtArgs> | null
    /**
     * The data needed to create a AdmitionExameRegistration.
     */
    data: XOR<AdmitionExameRegistrationCreateInput, AdmitionExameRegistrationUncheckedCreateInput>
  }

  /**
   * AdmitionExameRegistration createMany
   */
  export type AdmitionExameRegistrationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AdmitionExameRegistrations.
     */
    data: AdmitionExameRegistrationCreateManyInput | AdmitionExameRegistrationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AdmitionExameRegistration update
   */
  export type AdmitionExameRegistrationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdmitionExameRegistration
     */
    select?: AdmitionExameRegistrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdmitionExameRegistration
     */
    omit?: AdmitionExameRegistrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdmitionExameRegistrationInclude<ExtArgs> | null
    /**
     * The data needed to update a AdmitionExameRegistration.
     */
    data: XOR<AdmitionExameRegistrationUpdateInput, AdmitionExameRegistrationUncheckedUpdateInput>
    /**
     * Choose, which AdmitionExameRegistration to update.
     */
    where: AdmitionExameRegistrationWhereUniqueInput
  }

  /**
   * AdmitionExameRegistration updateMany
   */
  export type AdmitionExameRegistrationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AdmitionExameRegistrations.
     */
    data: XOR<AdmitionExameRegistrationUpdateManyMutationInput, AdmitionExameRegistrationUncheckedUpdateManyInput>
    /**
     * Filter which AdmitionExameRegistrations to update
     */
    where?: AdmitionExameRegistrationWhereInput
    /**
     * Limit how many AdmitionExameRegistrations to update.
     */
    limit?: number
  }

  /**
   * AdmitionExameRegistration upsert
   */
  export type AdmitionExameRegistrationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdmitionExameRegistration
     */
    select?: AdmitionExameRegistrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdmitionExameRegistration
     */
    omit?: AdmitionExameRegistrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdmitionExameRegistrationInclude<ExtArgs> | null
    /**
     * The filter to search for the AdmitionExameRegistration to update in case it exists.
     */
    where: AdmitionExameRegistrationWhereUniqueInput
    /**
     * In case the AdmitionExameRegistration found by the `where` argument doesn't exist, create a new AdmitionExameRegistration with this data.
     */
    create: XOR<AdmitionExameRegistrationCreateInput, AdmitionExameRegistrationUncheckedCreateInput>
    /**
     * In case the AdmitionExameRegistration was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AdmitionExameRegistrationUpdateInput, AdmitionExameRegistrationUncheckedUpdateInput>
  }

  /**
   * AdmitionExameRegistration delete
   */
  export type AdmitionExameRegistrationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdmitionExameRegistration
     */
    select?: AdmitionExameRegistrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdmitionExameRegistration
     */
    omit?: AdmitionExameRegistrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdmitionExameRegistrationInclude<ExtArgs> | null
    /**
     * Filter which AdmitionExameRegistration to delete.
     */
    where: AdmitionExameRegistrationWhereUniqueInput
  }

  /**
   * AdmitionExameRegistration deleteMany
   */
  export type AdmitionExameRegistrationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AdmitionExameRegistrations to delete
     */
    where?: AdmitionExameRegistrationWhereInput
    /**
     * Limit how many AdmitionExameRegistrations to delete.
     */
    limit?: number
  }

  /**
   * AdmitionExameRegistration.Student
   */
  export type AdmitionExameRegistration$StudentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Student
     */
    omit?: StudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    where?: StudentWhereInput
  }

  /**
   * AdmitionExameRegistration without action
   */
  export type AdmitionExameRegistrationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdmitionExameRegistration
     */
    select?: AdmitionExameRegistrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdmitionExameRegistration
     */
    omit?: AdmitionExameRegistrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdmitionExameRegistrationInclude<ExtArgs> | null
  }


  /**
   * Model AdmitionExamePrice
   */

  export type AggregateAdmitionExamePrice = {
    _count: AdmitionExamePriceCountAggregateOutputType | null
    _avg: AdmitionExamePriceAvgAggregateOutputType | null
    _sum: AdmitionExamePriceSumAggregateOutputType | null
    _min: AdmitionExamePriceMinAggregateOutputType | null
    _max: AdmitionExamePriceMaxAggregateOutputType | null
  }

  export type AdmitionExamePriceAvgAggregateOutputType = {
    price: number | null
  }

  export type AdmitionExamePriceSumAggregateOutputType = {
    price: number | null
  }

  export type AdmitionExamePriceMinAggregateOutputType = {
    id: string | null
    academicFacultyId: string | null
    price: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AdmitionExamePriceMaxAggregateOutputType = {
    id: string | null
    academicFacultyId: string | null
    price: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AdmitionExamePriceCountAggregateOutputType = {
    id: number
    academicFacultyId: number
    price: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AdmitionExamePriceAvgAggregateInputType = {
    price?: true
  }

  export type AdmitionExamePriceSumAggregateInputType = {
    price?: true
  }

  export type AdmitionExamePriceMinAggregateInputType = {
    id?: true
    academicFacultyId?: true
    price?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AdmitionExamePriceMaxAggregateInputType = {
    id?: true
    academicFacultyId?: true
    price?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AdmitionExamePriceCountAggregateInputType = {
    id?: true
    academicFacultyId?: true
    price?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AdmitionExamePriceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AdmitionExamePrice to aggregate.
     */
    where?: AdmitionExamePriceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdmitionExamePrices to fetch.
     */
    orderBy?: AdmitionExamePriceOrderByWithRelationInput | AdmitionExamePriceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AdmitionExamePriceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdmitionExamePrices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdmitionExamePrices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AdmitionExamePrices
    **/
    _count?: true | AdmitionExamePriceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AdmitionExamePriceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AdmitionExamePriceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AdmitionExamePriceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AdmitionExamePriceMaxAggregateInputType
  }

  export type GetAdmitionExamePriceAggregateType<T extends AdmitionExamePriceAggregateArgs> = {
        [P in keyof T & keyof AggregateAdmitionExamePrice]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAdmitionExamePrice[P]>
      : GetScalarType<T[P], AggregateAdmitionExamePrice[P]>
  }




  export type AdmitionExamePriceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdmitionExamePriceWhereInput
    orderBy?: AdmitionExamePriceOrderByWithAggregationInput | AdmitionExamePriceOrderByWithAggregationInput[]
    by: AdmitionExamePriceScalarFieldEnum[] | AdmitionExamePriceScalarFieldEnum
    having?: AdmitionExamePriceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AdmitionExamePriceCountAggregateInputType | true
    _avg?: AdmitionExamePriceAvgAggregateInputType
    _sum?: AdmitionExamePriceSumAggregateInputType
    _min?: AdmitionExamePriceMinAggregateInputType
    _max?: AdmitionExamePriceMaxAggregateInputType
  }

  export type AdmitionExamePriceGroupByOutputType = {
    id: string
    academicFacultyId: string
    price: number
    createdAt: Date
    updatedAt: Date
    _count: AdmitionExamePriceCountAggregateOutputType | null
    _avg: AdmitionExamePriceAvgAggregateOutputType | null
    _sum: AdmitionExamePriceSumAggregateOutputType | null
    _min: AdmitionExamePriceMinAggregateOutputType | null
    _max: AdmitionExamePriceMaxAggregateOutputType | null
  }

  type GetAdmitionExamePriceGroupByPayload<T extends AdmitionExamePriceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AdmitionExamePriceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AdmitionExamePriceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AdmitionExamePriceGroupByOutputType[P]>
            : GetScalarType<T[P], AdmitionExamePriceGroupByOutputType[P]>
        }
      >
    >


  export type AdmitionExamePriceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    academicFacultyId?: boolean
    price?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    academicFaculty?: boolean | AcademicFacultyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["admitionExamePrice"]>



  export type AdmitionExamePriceSelectScalar = {
    id?: boolean
    academicFacultyId?: boolean
    price?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AdmitionExamePriceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "academicFacultyId" | "price" | "createdAt" | "updatedAt", ExtArgs["result"]["admitionExamePrice"]>
  export type AdmitionExamePriceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    academicFaculty?: boolean | AcademicFacultyDefaultArgs<ExtArgs>
  }

  export type $AdmitionExamePricePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AdmitionExamePrice"
    objects: {
      academicFaculty: Prisma.$AcademicFacultyPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      academicFacultyId: string
      price: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["admitionExamePrice"]>
    composites: {}
  }

  type AdmitionExamePriceGetPayload<S extends boolean | null | undefined | AdmitionExamePriceDefaultArgs> = $Result.GetResult<Prisma.$AdmitionExamePricePayload, S>

  type AdmitionExamePriceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AdmitionExamePriceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AdmitionExamePriceCountAggregateInputType | true
    }

  export interface AdmitionExamePriceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AdmitionExamePrice'], meta: { name: 'AdmitionExamePrice' } }
    /**
     * Find zero or one AdmitionExamePrice that matches the filter.
     * @param {AdmitionExamePriceFindUniqueArgs} args - Arguments to find a AdmitionExamePrice
     * @example
     * // Get one AdmitionExamePrice
     * const admitionExamePrice = await prisma.admitionExamePrice.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AdmitionExamePriceFindUniqueArgs>(args: SelectSubset<T, AdmitionExamePriceFindUniqueArgs<ExtArgs>>): Prisma__AdmitionExamePriceClient<$Result.GetResult<Prisma.$AdmitionExamePricePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AdmitionExamePrice that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AdmitionExamePriceFindUniqueOrThrowArgs} args - Arguments to find a AdmitionExamePrice
     * @example
     * // Get one AdmitionExamePrice
     * const admitionExamePrice = await prisma.admitionExamePrice.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AdmitionExamePriceFindUniqueOrThrowArgs>(args: SelectSubset<T, AdmitionExamePriceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AdmitionExamePriceClient<$Result.GetResult<Prisma.$AdmitionExamePricePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AdmitionExamePrice that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdmitionExamePriceFindFirstArgs} args - Arguments to find a AdmitionExamePrice
     * @example
     * // Get one AdmitionExamePrice
     * const admitionExamePrice = await prisma.admitionExamePrice.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AdmitionExamePriceFindFirstArgs>(args?: SelectSubset<T, AdmitionExamePriceFindFirstArgs<ExtArgs>>): Prisma__AdmitionExamePriceClient<$Result.GetResult<Prisma.$AdmitionExamePricePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AdmitionExamePrice that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdmitionExamePriceFindFirstOrThrowArgs} args - Arguments to find a AdmitionExamePrice
     * @example
     * // Get one AdmitionExamePrice
     * const admitionExamePrice = await prisma.admitionExamePrice.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AdmitionExamePriceFindFirstOrThrowArgs>(args?: SelectSubset<T, AdmitionExamePriceFindFirstOrThrowArgs<ExtArgs>>): Prisma__AdmitionExamePriceClient<$Result.GetResult<Prisma.$AdmitionExamePricePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AdmitionExamePrices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdmitionExamePriceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AdmitionExamePrices
     * const admitionExamePrices = await prisma.admitionExamePrice.findMany()
     * 
     * // Get first 10 AdmitionExamePrices
     * const admitionExamePrices = await prisma.admitionExamePrice.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const admitionExamePriceWithIdOnly = await prisma.admitionExamePrice.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AdmitionExamePriceFindManyArgs>(args?: SelectSubset<T, AdmitionExamePriceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdmitionExamePricePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AdmitionExamePrice.
     * @param {AdmitionExamePriceCreateArgs} args - Arguments to create a AdmitionExamePrice.
     * @example
     * // Create one AdmitionExamePrice
     * const AdmitionExamePrice = await prisma.admitionExamePrice.create({
     *   data: {
     *     // ... data to create a AdmitionExamePrice
     *   }
     * })
     * 
     */
    create<T extends AdmitionExamePriceCreateArgs>(args: SelectSubset<T, AdmitionExamePriceCreateArgs<ExtArgs>>): Prisma__AdmitionExamePriceClient<$Result.GetResult<Prisma.$AdmitionExamePricePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AdmitionExamePrices.
     * @param {AdmitionExamePriceCreateManyArgs} args - Arguments to create many AdmitionExamePrices.
     * @example
     * // Create many AdmitionExamePrices
     * const admitionExamePrice = await prisma.admitionExamePrice.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AdmitionExamePriceCreateManyArgs>(args?: SelectSubset<T, AdmitionExamePriceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a AdmitionExamePrice.
     * @param {AdmitionExamePriceDeleteArgs} args - Arguments to delete one AdmitionExamePrice.
     * @example
     * // Delete one AdmitionExamePrice
     * const AdmitionExamePrice = await prisma.admitionExamePrice.delete({
     *   where: {
     *     // ... filter to delete one AdmitionExamePrice
     *   }
     * })
     * 
     */
    delete<T extends AdmitionExamePriceDeleteArgs>(args: SelectSubset<T, AdmitionExamePriceDeleteArgs<ExtArgs>>): Prisma__AdmitionExamePriceClient<$Result.GetResult<Prisma.$AdmitionExamePricePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AdmitionExamePrice.
     * @param {AdmitionExamePriceUpdateArgs} args - Arguments to update one AdmitionExamePrice.
     * @example
     * // Update one AdmitionExamePrice
     * const admitionExamePrice = await prisma.admitionExamePrice.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AdmitionExamePriceUpdateArgs>(args: SelectSubset<T, AdmitionExamePriceUpdateArgs<ExtArgs>>): Prisma__AdmitionExamePriceClient<$Result.GetResult<Prisma.$AdmitionExamePricePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AdmitionExamePrices.
     * @param {AdmitionExamePriceDeleteManyArgs} args - Arguments to filter AdmitionExamePrices to delete.
     * @example
     * // Delete a few AdmitionExamePrices
     * const { count } = await prisma.admitionExamePrice.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AdmitionExamePriceDeleteManyArgs>(args?: SelectSubset<T, AdmitionExamePriceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AdmitionExamePrices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdmitionExamePriceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AdmitionExamePrices
     * const admitionExamePrice = await prisma.admitionExamePrice.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AdmitionExamePriceUpdateManyArgs>(args: SelectSubset<T, AdmitionExamePriceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AdmitionExamePrice.
     * @param {AdmitionExamePriceUpsertArgs} args - Arguments to update or create a AdmitionExamePrice.
     * @example
     * // Update or create a AdmitionExamePrice
     * const admitionExamePrice = await prisma.admitionExamePrice.upsert({
     *   create: {
     *     // ... data to create a AdmitionExamePrice
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AdmitionExamePrice we want to update
     *   }
     * })
     */
    upsert<T extends AdmitionExamePriceUpsertArgs>(args: SelectSubset<T, AdmitionExamePriceUpsertArgs<ExtArgs>>): Prisma__AdmitionExamePriceClient<$Result.GetResult<Prisma.$AdmitionExamePricePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AdmitionExamePrices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdmitionExamePriceCountArgs} args - Arguments to filter AdmitionExamePrices to count.
     * @example
     * // Count the number of AdmitionExamePrices
     * const count = await prisma.admitionExamePrice.count({
     *   where: {
     *     // ... the filter for the AdmitionExamePrices we want to count
     *   }
     * })
    **/
    count<T extends AdmitionExamePriceCountArgs>(
      args?: Subset<T, AdmitionExamePriceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AdmitionExamePriceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AdmitionExamePrice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdmitionExamePriceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AdmitionExamePriceAggregateArgs>(args: Subset<T, AdmitionExamePriceAggregateArgs>): Prisma.PrismaPromise<GetAdmitionExamePriceAggregateType<T>>

    /**
     * Group by AdmitionExamePrice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdmitionExamePriceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AdmitionExamePriceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AdmitionExamePriceGroupByArgs['orderBy'] }
        : { orderBy?: AdmitionExamePriceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AdmitionExamePriceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAdmitionExamePriceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AdmitionExamePrice model
   */
  readonly fields: AdmitionExamePriceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AdmitionExamePrice.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AdmitionExamePriceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    academicFaculty<T extends AcademicFacultyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AcademicFacultyDefaultArgs<ExtArgs>>): Prisma__AcademicFacultyClient<$Result.GetResult<Prisma.$AcademicFacultyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AdmitionExamePrice model
   */
  interface AdmitionExamePriceFieldRefs {
    readonly id: FieldRef<"AdmitionExamePrice", 'String'>
    readonly academicFacultyId: FieldRef<"AdmitionExamePrice", 'String'>
    readonly price: FieldRef<"AdmitionExamePrice", 'Int'>
    readonly createdAt: FieldRef<"AdmitionExamePrice", 'DateTime'>
    readonly updatedAt: FieldRef<"AdmitionExamePrice", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AdmitionExamePrice findUnique
   */
  export type AdmitionExamePriceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdmitionExamePrice
     */
    select?: AdmitionExamePriceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdmitionExamePrice
     */
    omit?: AdmitionExamePriceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdmitionExamePriceInclude<ExtArgs> | null
    /**
     * Filter, which AdmitionExamePrice to fetch.
     */
    where: AdmitionExamePriceWhereUniqueInput
  }

  /**
   * AdmitionExamePrice findUniqueOrThrow
   */
  export type AdmitionExamePriceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdmitionExamePrice
     */
    select?: AdmitionExamePriceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdmitionExamePrice
     */
    omit?: AdmitionExamePriceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdmitionExamePriceInclude<ExtArgs> | null
    /**
     * Filter, which AdmitionExamePrice to fetch.
     */
    where: AdmitionExamePriceWhereUniqueInput
  }

  /**
   * AdmitionExamePrice findFirst
   */
  export type AdmitionExamePriceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdmitionExamePrice
     */
    select?: AdmitionExamePriceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdmitionExamePrice
     */
    omit?: AdmitionExamePriceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdmitionExamePriceInclude<ExtArgs> | null
    /**
     * Filter, which AdmitionExamePrice to fetch.
     */
    where?: AdmitionExamePriceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdmitionExamePrices to fetch.
     */
    orderBy?: AdmitionExamePriceOrderByWithRelationInput | AdmitionExamePriceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AdmitionExamePrices.
     */
    cursor?: AdmitionExamePriceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdmitionExamePrices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdmitionExamePrices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AdmitionExamePrices.
     */
    distinct?: AdmitionExamePriceScalarFieldEnum | AdmitionExamePriceScalarFieldEnum[]
  }

  /**
   * AdmitionExamePrice findFirstOrThrow
   */
  export type AdmitionExamePriceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdmitionExamePrice
     */
    select?: AdmitionExamePriceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdmitionExamePrice
     */
    omit?: AdmitionExamePriceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdmitionExamePriceInclude<ExtArgs> | null
    /**
     * Filter, which AdmitionExamePrice to fetch.
     */
    where?: AdmitionExamePriceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdmitionExamePrices to fetch.
     */
    orderBy?: AdmitionExamePriceOrderByWithRelationInput | AdmitionExamePriceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AdmitionExamePrices.
     */
    cursor?: AdmitionExamePriceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdmitionExamePrices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdmitionExamePrices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AdmitionExamePrices.
     */
    distinct?: AdmitionExamePriceScalarFieldEnum | AdmitionExamePriceScalarFieldEnum[]
  }

  /**
   * AdmitionExamePrice findMany
   */
  export type AdmitionExamePriceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdmitionExamePrice
     */
    select?: AdmitionExamePriceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdmitionExamePrice
     */
    omit?: AdmitionExamePriceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdmitionExamePriceInclude<ExtArgs> | null
    /**
     * Filter, which AdmitionExamePrices to fetch.
     */
    where?: AdmitionExamePriceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdmitionExamePrices to fetch.
     */
    orderBy?: AdmitionExamePriceOrderByWithRelationInput | AdmitionExamePriceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AdmitionExamePrices.
     */
    cursor?: AdmitionExamePriceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdmitionExamePrices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdmitionExamePrices.
     */
    skip?: number
    distinct?: AdmitionExamePriceScalarFieldEnum | AdmitionExamePriceScalarFieldEnum[]
  }

  /**
   * AdmitionExamePrice create
   */
  export type AdmitionExamePriceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdmitionExamePrice
     */
    select?: AdmitionExamePriceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdmitionExamePrice
     */
    omit?: AdmitionExamePriceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdmitionExamePriceInclude<ExtArgs> | null
    /**
     * The data needed to create a AdmitionExamePrice.
     */
    data: XOR<AdmitionExamePriceCreateInput, AdmitionExamePriceUncheckedCreateInput>
  }

  /**
   * AdmitionExamePrice createMany
   */
  export type AdmitionExamePriceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AdmitionExamePrices.
     */
    data: AdmitionExamePriceCreateManyInput | AdmitionExamePriceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AdmitionExamePrice update
   */
  export type AdmitionExamePriceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdmitionExamePrice
     */
    select?: AdmitionExamePriceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdmitionExamePrice
     */
    omit?: AdmitionExamePriceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdmitionExamePriceInclude<ExtArgs> | null
    /**
     * The data needed to update a AdmitionExamePrice.
     */
    data: XOR<AdmitionExamePriceUpdateInput, AdmitionExamePriceUncheckedUpdateInput>
    /**
     * Choose, which AdmitionExamePrice to update.
     */
    where: AdmitionExamePriceWhereUniqueInput
  }

  /**
   * AdmitionExamePrice updateMany
   */
  export type AdmitionExamePriceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AdmitionExamePrices.
     */
    data: XOR<AdmitionExamePriceUpdateManyMutationInput, AdmitionExamePriceUncheckedUpdateManyInput>
    /**
     * Filter which AdmitionExamePrices to update
     */
    where?: AdmitionExamePriceWhereInput
    /**
     * Limit how many AdmitionExamePrices to update.
     */
    limit?: number
  }

  /**
   * AdmitionExamePrice upsert
   */
  export type AdmitionExamePriceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdmitionExamePrice
     */
    select?: AdmitionExamePriceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdmitionExamePrice
     */
    omit?: AdmitionExamePriceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdmitionExamePriceInclude<ExtArgs> | null
    /**
     * The filter to search for the AdmitionExamePrice to update in case it exists.
     */
    where: AdmitionExamePriceWhereUniqueInput
    /**
     * In case the AdmitionExamePrice found by the `where` argument doesn't exist, create a new AdmitionExamePrice with this data.
     */
    create: XOR<AdmitionExamePriceCreateInput, AdmitionExamePriceUncheckedCreateInput>
    /**
     * In case the AdmitionExamePrice was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AdmitionExamePriceUpdateInput, AdmitionExamePriceUncheckedUpdateInput>
  }

  /**
   * AdmitionExamePrice delete
   */
  export type AdmitionExamePriceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdmitionExamePrice
     */
    select?: AdmitionExamePriceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdmitionExamePrice
     */
    omit?: AdmitionExamePriceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdmitionExamePriceInclude<ExtArgs> | null
    /**
     * Filter which AdmitionExamePrice to delete.
     */
    where: AdmitionExamePriceWhereUniqueInput
  }

  /**
   * AdmitionExamePrice deleteMany
   */
  export type AdmitionExamePriceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AdmitionExamePrices to delete
     */
    where?: AdmitionExamePriceWhereInput
    /**
     * Limit how many AdmitionExamePrices to delete.
     */
    limit?: number
  }

  /**
   * AdmitionExamePrice without action
   */
  export type AdmitionExamePriceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdmitionExamePrice
     */
    select?: AdmitionExamePriceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdmitionExamePrice
     */
    omit?: AdmitionExamePriceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdmitionExamePriceInclude<ExtArgs> | null
  }


  /**
   * Model AdmitionExamePeriod
   */

  export type AggregateAdmitionExamePeriod = {
    _count: AdmitionExamePeriodCountAggregateOutputType | null
    _min: AdmitionExamePeriodMinAggregateOutputType | null
    _max: AdmitionExamePeriodMaxAggregateOutputType | null
  }

  export type AdmitionExamePeriodMinAggregateOutputType = {
    id: string | null
    startDate: Date | null
    endDate: Date | null
    academicFacultyId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AdmitionExamePeriodMaxAggregateOutputType = {
    id: string | null
    startDate: Date | null
    endDate: Date | null
    academicFacultyId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AdmitionExamePeriodCountAggregateOutputType = {
    id: number
    startDate: number
    endDate: number
    academicFacultyId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AdmitionExamePeriodMinAggregateInputType = {
    id?: true
    startDate?: true
    endDate?: true
    academicFacultyId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AdmitionExamePeriodMaxAggregateInputType = {
    id?: true
    startDate?: true
    endDate?: true
    academicFacultyId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AdmitionExamePeriodCountAggregateInputType = {
    id?: true
    startDate?: true
    endDate?: true
    academicFacultyId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AdmitionExamePeriodAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AdmitionExamePeriod to aggregate.
     */
    where?: AdmitionExamePeriodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdmitionExamePeriods to fetch.
     */
    orderBy?: AdmitionExamePeriodOrderByWithRelationInput | AdmitionExamePeriodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AdmitionExamePeriodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdmitionExamePeriods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdmitionExamePeriods.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AdmitionExamePeriods
    **/
    _count?: true | AdmitionExamePeriodCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AdmitionExamePeriodMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AdmitionExamePeriodMaxAggregateInputType
  }

  export type GetAdmitionExamePeriodAggregateType<T extends AdmitionExamePeriodAggregateArgs> = {
        [P in keyof T & keyof AggregateAdmitionExamePeriod]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAdmitionExamePeriod[P]>
      : GetScalarType<T[P], AggregateAdmitionExamePeriod[P]>
  }




  export type AdmitionExamePeriodGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdmitionExamePeriodWhereInput
    orderBy?: AdmitionExamePeriodOrderByWithAggregationInput | AdmitionExamePeriodOrderByWithAggregationInput[]
    by: AdmitionExamePeriodScalarFieldEnum[] | AdmitionExamePeriodScalarFieldEnum
    having?: AdmitionExamePeriodScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AdmitionExamePeriodCountAggregateInputType | true
    _min?: AdmitionExamePeriodMinAggregateInputType
    _max?: AdmitionExamePeriodMaxAggregateInputType
  }

  export type AdmitionExamePeriodGroupByOutputType = {
    id: string
    startDate: Date
    endDate: Date
    academicFacultyId: string
    createdAt: Date
    updatedAt: Date
    _count: AdmitionExamePeriodCountAggregateOutputType | null
    _min: AdmitionExamePeriodMinAggregateOutputType | null
    _max: AdmitionExamePeriodMaxAggregateOutputType | null
  }

  type GetAdmitionExamePeriodGroupByPayload<T extends AdmitionExamePeriodGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AdmitionExamePeriodGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AdmitionExamePeriodGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AdmitionExamePeriodGroupByOutputType[P]>
            : GetScalarType<T[P], AdmitionExamePeriodGroupByOutputType[P]>
        }
      >
    >


  export type AdmitionExamePeriodSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    startDate?: boolean
    endDate?: boolean
    academicFacultyId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    academicFaculty?: boolean | AcademicFacultyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["admitionExamePeriod"]>



  export type AdmitionExamePeriodSelectScalar = {
    id?: boolean
    startDate?: boolean
    endDate?: boolean
    academicFacultyId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AdmitionExamePeriodOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "startDate" | "endDate" | "academicFacultyId" | "createdAt" | "updatedAt", ExtArgs["result"]["admitionExamePeriod"]>
  export type AdmitionExamePeriodInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    academicFaculty?: boolean | AcademicFacultyDefaultArgs<ExtArgs>
  }

  export type $AdmitionExamePeriodPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AdmitionExamePeriod"
    objects: {
      academicFaculty: Prisma.$AcademicFacultyPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      startDate: Date
      endDate: Date
      academicFacultyId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["admitionExamePeriod"]>
    composites: {}
  }

  type AdmitionExamePeriodGetPayload<S extends boolean | null | undefined | AdmitionExamePeriodDefaultArgs> = $Result.GetResult<Prisma.$AdmitionExamePeriodPayload, S>

  type AdmitionExamePeriodCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AdmitionExamePeriodFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AdmitionExamePeriodCountAggregateInputType | true
    }

  export interface AdmitionExamePeriodDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AdmitionExamePeriod'], meta: { name: 'AdmitionExamePeriod' } }
    /**
     * Find zero or one AdmitionExamePeriod that matches the filter.
     * @param {AdmitionExamePeriodFindUniqueArgs} args - Arguments to find a AdmitionExamePeriod
     * @example
     * // Get one AdmitionExamePeriod
     * const admitionExamePeriod = await prisma.admitionExamePeriod.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AdmitionExamePeriodFindUniqueArgs>(args: SelectSubset<T, AdmitionExamePeriodFindUniqueArgs<ExtArgs>>): Prisma__AdmitionExamePeriodClient<$Result.GetResult<Prisma.$AdmitionExamePeriodPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AdmitionExamePeriod that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AdmitionExamePeriodFindUniqueOrThrowArgs} args - Arguments to find a AdmitionExamePeriod
     * @example
     * // Get one AdmitionExamePeriod
     * const admitionExamePeriod = await prisma.admitionExamePeriod.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AdmitionExamePeriodFindUniqueOrThrowArgs>(args: SelectSubset<T, AdmitionExamePeriodFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AdmitionExamePeriodClient<$Result.GetResult<Prisma.$AdmitionExamePeriodPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AdmitionExamePeriod that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdmitionExamePeriodFindFirstArgs} args - Arguments to find a AdmitionExamePeriod
     * @example
     * // Get one AdmitionExamePeriod
     * const admitionExamePeriod = await prisma.admitionExamePeriod.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AdmitionExamePeriodFindFirstArgs>(args?: SelectSubset<T, AdmitionExamePeriodFindFirstArgs<ExtArgs>>): Prisma__AdmitionExamePeriodClient<$Result.GetResult<Prisma.$AdmitionExamePeriodPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AdmitionExamePeriod that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdmitionExamePeriodFindFirstOrThrowArgs} args - Arguments to find a AdmitionExamePeriod
     * @example
     * // Get one AdmitionExamePeriod
     * const admitionExamePeriod = await prisma.admitionExamePeriod.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AdmitionExamePeriodFindFirstOrThrowArgs>(args?: SelectSubset<T, AdmitionExamePeriodFindFirstOrThrowArgs<ExtArgs>>): Prisma__AdmitionExamePeriodClient<$Result.GetResult<Prisma.$AdmitionExamePeriodPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AdmitionExamePeriods that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdmitionExamePeriodFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AdmitionExamePeriods
     * const admitionExamePeriods = await prisma.admitionExamePeriod.findMany()
     * 
     * // Get first 10 AdmitionExamePeriods
     * const admitionExamePeriods = await prisma.admitionExamePeriod.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const admitionExamePeriodWithIdOnly = await prisma.admitionExamePeriod.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AdmitionExamePeriodFindManyArgs>(args?: SelectSubset<T, AdmitionExamePeriodFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdmitionExamePeriodPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AdmitionExamePeriod.
     * @param {AdmitionExamePeriodCreateArgs} args - Arguments to create a AdmitionExamePeriod.
     * @example
     * // Create one AdmitionExamePeriod
     * const AdmitionExamePeriod = await prisma.admitionExamePeriod.create({
     *   data: {
     *     // ... data to create a AdmitionExamePeriod
     *   }
     * })
     * 
     */
    create<T extends AdmitionExamePeriodCreateArgs>(args: SelectSubset<T, AdmitionExamePeriodCreateArgs<ExtArgs>>): Prisma__AdmitionExamePeriodClient<$Result.GetResult<Prisma.$AdmitionExamePeriodPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AdmitionExamePeriods.
     * @param {AdmitionExamePeriodCreateManyArgs} args - Arguments to create many AdmitionExamePeriods.
     * @example
     * // Create many AdmitionExamePeriods
     * const admitionExamePeriod = await prisma.admitionExamePeriod.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AdmitionExamePeriodCreateManyArgs>(args?: SelectSubset<T, AdmitionExamePeriodCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a AdmitionExamePeriod.
     * @param {AdmitionExamePeriodDeleteArgs} args - Arguments to delete one AdmitionExamePeriod.
     * @example
     * // Delete one AdmitionExamePeriod
     * const AdmitionExamePeriod = await prisma.admitionExamePeriod.delete({
     *   where: {
     *     // ... filter to delete one AdmitionExamePeriod
     *   }
     * })
     * 
     */
    delete<T extends AdmitionExamePeriodDeleteArgs>(args: SelectSubset<T, AdmitionExamePeriodDeleteArgs<ExtArgs>>): Prisma__AdmitionExamePeriodClient<$Result.GetResult<Prisma.$AdmitionExamePeriodPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AdmitionExamePeriod.
     * @param {AdmitionExamePeriodUpdateArgs} args - Arguments to update one AdmitionExamePeriod.
     * @example
     * // Update one AdmitionExamePeriod
     * const admitionExamePeriod = await prisma.admitionExamePeriod.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AdmitionExamePeriodUpdateArgs>(args: SelectSubset<T, AdmitionExamePeriodUpdateArgs<ExtArgs>>): Prisma__AdmitionExamePeriodClient<$Result.GetResult<Prisma.$AdmitionExamePeriodPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AdmitionExamePeriods.
     * @param {AdmitionExamePeriodDeleteManyArgs} args - Arguments to filter AdmitionExamePeriods to delete.
     * @example
     * // Delete a few AdmitionExamePeriods
     * const { count } = await prisma.admitionExamePeriod.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AdmitionExamePeriodDeleteManyArgs>(args?: SelectSubset<T, AdmitionExamePeriodDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AdmitionExamePeriods.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdmitionExamePeriodUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AdmitionExamePeriods
     * const admitionExamePeriod = await prisma.admitionExamePeriod.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AdmitionExamePeriodUpdateManyArgs>(args: SelectSubset<T, AdmitionExamePeriodUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AdmitionExamePeriod.
     * @param {AdmitionExamePeriodUpsertArgs} args - Arguments to update or create a AdmitionExamePeriod.
     * @example
     * // Update or create a AdmitionExamePeriod
     * const admitionExamePeriod = await prisma.admitionExamePeriod.upsert({
     *   create: {
     *     // ... data to create a AdmitionExamePeriod
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AdmitionExamePeriod we want to update
     *   }
     * })
     */
    upsert<T extends AdmitionExamePeriodUpsertArgs>(args: SelectSubset<T, AdmitionExamePeriodUpsertArgs<ExtArgs>>): Prisma__AdmitionExamePeriodClient<$Result.GetResult<Prisma.$AdmitionExamePeriodPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AdmitionExamePeriods.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdmitionExamePeriodCountArgs} args - Arguments to filter AdmitionExamePeriods to count.
     * @example
     * // Count the number of AdmitionExamePeriods
     * const count = await prisma.admitionExamePeriod.count({
     *   where: {
     *     // ... the filter for the AdmitionExamePeriods we want to count
     *   }
     * })
    **/
    count<T extends AdmitionExamePeriodCountArgs>(
      args?: Subset<T, AdmitionExamePeriodCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AdmitionExamePeriodCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AdmitionExamePeriod.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdmitionExamePeriodAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AdmitionExamePeriodAggregateArgs>(args: Subset<T, AdmitionExamePeriodAggregateArgs>): Prisma.PrismaPromise<GetAdmitionExamePeriodAggregateType<T>>

    /**
     * Group by AdmitionExamePeriod.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdmitionExamePeriodGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AdmitionExamePeriodGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AdmitionExamePeriodGroupByArgs['orderBy'] }
        : { orderBy?: AdmitionExamePeriodGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AdmitionExamePeriodGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAdmitionExamePeriodGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AdmitionExamePeriod model
   */
  readonly fields: AdmitionExamePeriodFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AdmitionExamePeriod.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AdmitionExamePeriodClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    academicFaculty<T extends AcademicFacultyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AcademicFacultyDefaultArgs<ExtArgs>>): Prisma__AcademicFacultyClient<$Result.GetResult<Prisma.$AcademicFacultyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AdmitionExamePeriod model
   */
  interface AdmitionExamePeriodFieldRefs {
    readonly id: FieldRef<"AdmitionExamePeriod", 'String'>
    readonly startDate: FieldRef<"AdmitionExamePeriod", 'DateTime'>
    readonly endDate: FieldRef<"AdmitionExamePeriod", 'DateTime'>
    readonly academicFacultyId: FieldRef<"AdmitionExamePeriod", 'String'>
    readonly createdAt: FieldRef<"AdmitionExamePeriod", 'DateTime'>
    readonly updatedAt: FieldRef<"AdmitionExamePeriod", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AdmitionExamePeriod findUnique
   */
  export type AdmitionExamePeriodFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdmitionExamePeriod
     */
    select?: AdmitionExamePeriodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdmitionExamePeriod
     */
    omit?: AdmitionExamePeriodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdmitionExamePeriodInclude<ExtArgs> | null
    /**
     * Filter, which AdmitionExamePeriod to fetch.
     */
    where: AdmitionExamePeriodWhereUniqueInput
  }

  /**
   * AdmitionExamePeriod findUniqueOrThrow
   */
  export type AdmitionExamePeriodFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdmitionExamePeriod
     */
    select?: AdmitionExamePeriodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdmitionExamePeriod
     */
    omit?: AdmitionExamePeriodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdmitionExamePeriodInclude<ExtArgs> | null
    /**
     * Filter, which AdmitionExamePeriod to fetch.
     */
    where: AdmitionExamePeriodWhereUniqueInput
  }

  /**
   * AdmitionExamePeriod findFirst
   */
  export type AdmitionExamePeriodFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdmitionExamePeriod
     */
    select?: AdmitionExamePeriodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdmitionExamePeriod
     */
    omit?: AdmitionExamePeriodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdmitionExamePeriodInclude<ExtArgs> | null
    /**
     * Filter, which AdmitionExamePeriod to fetch.
     */
    where?: AdmitionExamePeriodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdmitionExamePeriods to fetch.
     */
    orderBy?: AdmitionExamePeriodOrderByWithRelationInput | AdmitionExamePeriodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AdmitionExamePeriods.
     */
    cursor?: AdmitionExamePeriodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdmitionExamePeriods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdmitionExamePeriods.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AdmitionExamePeriods.
     */
    distinct?: AdmitionExamePeriodScalarFieldEnum | AdmitionExamePeriodScalarFieldEnum[]
  }

  /**
   * AdmitionExamePeriod findFirstOrThrow
   */
  export type AdmitionExamePeriodFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdmitionExamePeriod
     */
    select?: AdmitionExamePeriodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdmitionExamePeriod
     */
    omit?: AdmitionExamePeriodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdmitionExamePeriodInclude<ExtArgs> | null
    /**
     * Filter, which AdmitionExamePeriod to fetch.
     */
    where?: AdmitionExamePeriodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdmitionExamePeriods to fetch.
     */
    orderBy?: AdmitionExamePeriodOrderByWithRelationInput | AdmitionExamePeriodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AdmitionExamePeriods.
     */
    cursor?: AdmitionExamePeriodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdmitionExamePeriods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdmitionExamePeriods.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AdmitionExamePeriods.
     */
    distinct?: AdmitionExamePeriodScalarFieldEnum | AdmitionExamePeriodScalarFieldEnum[]
  }

  /**
   * AdmitionExamePeriod findMany
   */
  export type AdmitionExamePeriodFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdmitionExamePeriod
     */
    select?: AdmitionExamePeriodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdmitionExamePeriod
     */
    omit?: AdmitionExamePeriodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdmitionExamePeriodInclude<ExtArgs> | null
    /**
     * Filter, which AdmitionExamePeriods to fetch.
     */
    where?: AdmitionExamePeriodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdmitionExamePeriods to fetch.
     */
    orderBy?: AdmitionExamePeriodOrderByWithRelationInput | AdmitionExamePeriodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AdmitionExamePeriods.
     */
    cursor?: AdmitionExamePeriodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdmitionExamePeriods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdmitionExamePeriods.
     */
    skip?: number
    distinct?: AdmitionExamePeriodScalarFieldEnum | AdmitionExamePeriodScalarFieldEnum[]
  }

  /**
   * AdmitionExamePeriod create
   */
  export type AdmitionExamePeriodCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdmitionExamePeriod
     */
    select?: AdmitionExamePeriodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdmitionExamePeriod
     */
    omit?: AdmitionExamePeriodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdmitionExamePeriodInclude<ExtArgs> | null
    /**
     * The data needed to create a AdmitionExamePeriod.
     */
    data: XOR<AdmitionExamePeriodCreateInput, AdmitionExamePeriodUncheckedCreateInput>
  }

  /**
   * AdmitionExamePeriod createMany
   */
  export type AdmitionExamePeriodCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AdmitionExamePeriods.
     */
    data: AdmitionExamePeriodCreateManyInput | AdmitionExamePeriodCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AdmitionExamePeriod update
   */
  export type AdmitionExamePeriodUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdmitionExamePeriod
     */
    select?: AdmitionExamePeriodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdmitionExamePeriod
     */
    omit?: AdmitionExamePeriodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdmitionExamePeriodInclude<ExtArgs> | null
    /**
     * The data needed to update a AdmitionExamePeriod.
     */
    data: XOR<AdmitionExamePeriodUpdateInput, AdmitionExamePeriodUncheckedUpdateInput>
    /**
     * Choose, which AdmitionExamePeriod to update.
     */
    where: AdmitionExamePeriodWhereUniqueInput
  }

  /**
   * AdmitionExamePeriod updateMany
   */
  export type AdmitionExamePeriodUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AdmitionExamePeriods.
     */
    data: XOR<AdmitionExamePeriodUpdateManyMutationInput, AdmitionExamePeriodUncheckedUpdateManyInput>
    /**
     * Filter which AdmitionExamePeriods to update
     */
    where?: AdmitionExamePeriodWhereInput
    /**
     * Limit how many AdmitionExamePeriods to update.
     */
    limit?: number
  }

  /**
   * AdmitionExamePeriod upsert
   */
  export type AdmitionExamePeriodUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdmitionExamePeriod
     */
    select?: AdmitionExamePeriodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdmitionExamePeriod
     */
    omit?: AdmitionExamePeriodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdmitionExamePeriodInclude<ExtArgs> | null
    /**
     * The filter to search for the AdmitionExamePeriod to update in case it exists.
     */
    where: AdmitionExamePeriodWhereUniqueInput
    /**
     * In case the AdmitionExamePeriod found by the `where` argument doesn't exist, create a new AdmitionExamePeriod with this data.
     */
    create: XOR<AdmitionExamePeriodCreateInput, AdmitionExamePeriodUncheckedCreateInput>
    /**
     * In case the AdmitionExamePeriod was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AdmitionExamePeriodUpdateInput, AdmitionExamePeriodUncheckedUpdateInput>
  }

  /**
   * AdmitionExamePeriod delete
   */
  export type AdmitionExamePeriodDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdmitionExamePeriod
     */
    select?: AdmitionExamePeriodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdmitionExamePeriod
     */
    omit?: AdmitionExamePeriodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdmitionExamePeriodInclude<ExtArgs> | null
    /**
     * Filter which AdmitionExamePeriod to delete.
     */
    where: AdmitionExamePeriodWhereUniqueInput
  }

  /**
   * AdmitionExamePeriod deleteMany
   */
  export type AdmitionExamePeriodDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AdmitionExamePeriods to delete
     */
    where?: AdmitionExamePeriodWhereInput
    /**
     * Limit how many AdmitionExamePeriods to delete.
     */
    limit?: number
  }

  /**
   * AdmitionExamePeriod without action
   */
  export type AdmitionExamePeriodDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdmitionExamePeriod
     */
    select?: AdmitionExamePeriodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdmitionExamePeriod
     */
    omit?: AdmitionExamePeriodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdmitionExamePeriodInclude<ExtArgs> | null
  }


  /**
   * Model ExameFase
   */

  export type AggregateExameFase = {
    _count: ExameFaseCountAggregateOutputType | null
    _avg: ExameFaseAvgAggregateOutputType | null
    _sum: ExameFaseSumAggregateOutputType | null
    _min: ExameFaseMinAggregateOutputType | null
    _max: ExameFaseMaxAggregateOutputType | null
  }

  export type ExameFaseAvgAggregateOutputType = {
    ordem: number | null
  }

  export type ExameFaseSumAggregateOutputType = {
    ordem: number | null
  }

  export type ExameFaseMinAggregateOutputType = {
    id: string | null
    name: string | null
    ordem: number | null
    startDate: Date | null
    endDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ExameFaseMaxAggregateOutputType = {
    id: string | null
    name: string | null
    ordem: number | null
    startDate: Date | null
    endDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ExameFaseCountAggregateOutputType = {
    id: number
    name: number
    ordem: number
    startDate: number
    endDate: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ExameFaseAvgAggregateInputType = {
    ordem?: true
  }

  export type ExameFaseSumAggregateInputType = {
    ordem?: true
  }

  export type ExameFaseMinAggregateInputType = {
    id?: true
    name?: true
    ordem?: true
    startDate?: true
    endDate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ExameFaseMaxAggregateInputType = {
    id?: true
    name?: true
    ordem?: true
    startDate?: true
    endDate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ExameFaseCountAggregateInputType = {
    id?: true
    name?: true
    ordem?: true
    startDate?: true
    endDate?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ExameFaseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ExameFase to aggregate.
     */
    where?: ExameFaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExameFases to fetch.
     */
    orderBy?: ExameFaseOrderByWithRelationInput | ExameFaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ExameFaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExameFases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExameFases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ExameFases
    **/
    _count?: true | ExameFaseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ExameFaseAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ExameFaseSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ExameFaseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ExameFaseMaxAggregateInputType
  }

  export type GetExameFaseAggregateType<T extends ExameFaseAggregateArgs> = {
        [P in keyof T & keyof AggregateExameFase]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateExameFase[P]>
      : GetScalarType<T[P], AggregateExameFase[P]>
  }




  export type ExameFaseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExameFaseWhereInput
    orderBy?: ExameFaseOrderByWithAggregationInput | ExameFaseOrderByWithAggregationInput[]
    by: ExameFaseScalarFieldEnum[] | ExameFaseScalarFieldEnum
    having?: ExameFaseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ExameFaseCountAggregateInputType | true
    _avg?: ExameFaseAvgAggregateInputType
    _sum?: ExameFaseSumAggregateInputType
    _min?: ExameFaseMinAggregateInputType
    _max?: ExameFaseMaxAggregateInputType
  }

  export type ExameFaseGroupByOutputType = {
    id: string
    name: string
    ordem: number
    startDate: Date
    endDate: Date
    createdAt: Date
    updatedAt: Date
    _count: ExameFaseCountAggregateOutputType | null
    _avg: ExameFaseAvgAggregateOutputType | null
    _sum: ExameFaseSumAggregateOutputType | null
    _min: ExameFaseMinAggregateOutputType | null
    _max: ExameFaseMaxAggregateOutputType | null
  }

  type GetExameFaseGroupByPayload<T extends ExameFaseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ExameFaseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ExameFaseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ExameFaseGroupByOutputType[P]>
            : GetScalarType<T[P], ExameFaseGroupByOutputType[P]>
        }
      >
    >


  export type ExameFaseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    ordem?: boolean
    startDate?: boolean
    endDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    registrations?: boolean | ExameFase$registrationsArgs<ExtArgs>
    _count?: boolean | ExameFaseCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["exameFase"]>



  export type ExameFaseSelectScalar = {
    id?: boolean
    name?: boolean
    ordem?: boolean
    startDate?: boolean
    endDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ExameFaseOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "ordem" | "startDate" | "endDate" | "createdAt" | "updatedAt", ExtArgs["result"]["exameFase"]>
  export type ExameFaseInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    registrations?: boolean | ExameFase$registrationsArgs<ExtArgs>
    _count?: boolean | ExameFaseCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $ExameFasePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ExameFase"
    objects: {
      registrations: Prisma.$AdmitionExameRegistrationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      ordem: number
      startDate: Date
      endDate: Date
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["exameFase"]>
    composites: {}
  }

  type ExameFaseGetPayload<S extends boolean | null | undefined | ExameFaseDefaultArgs> = $Result.GetResult<Prisma.$ExameFasePayload, S>

  type ExameFaseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ExameFaseFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ExameFaseCountAggregateInputType | true
    }

  export interface ExameFaseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ExameFase'], meta: { name: 'ExameFase' } }
    /**
     * Find zero or one ExameFase that matches the filter.
     * @param {ExameFaseFindUniqueArgs} args - Arguments to find a ExameFase
     * @example
     * // Get one ExameFase
     * const exameFase = await prisma.exameFase.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ExameFaseFindUniqueArgs>(args: SelectSubset<T, ExameFaseFindUniqueArgs<ExtArgs>>): Prisma__ExameFaseClient<$Result.GetResult<Prisma.$ExameFasePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ExameFase that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ExameFaseFindUniqueOrThrowArgs} args - Arguments to find a ExameFase
     * @example
     * // Get one ExameFase
     * const exameFase = await prisma.exameFase.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ExameFaseFindUniqueOrThrowArgs>(args: SelectSubset<T, ExameFaseFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ExameFaseClient<$Result.GetResult<Prisma.$ExameFasePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ExameFase that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExameFaseFindFirstArgs} args - Arguments to find a ExameFase
     * @example
     * // Get one ExameFase
     * const exameFase = await prisma.exameFase.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ExameFaseFindFirstArgs>(args?: SelectSubset<T, ExameFaseFindFirstArgs<ExtArgs>>): Prisma__ExameFaseClient<$Result.GetResult<Prisma.$ExameFasePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ExameFase that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExameFaseFindFirstOrThrowArgs} args - Arguments to find a ExameFase
     * @example
     * // Get one ExameFase
     * const exameFase = await prisma.exameFase.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ExameFaseFindFirstOrThrowArgs>(args?: SelectSubset<T, ExameFaseFindFirstOrThrowArgs<ExtArgs>>): Prisma__ExameFaseClient<$Result.GetResult<Prisma.$ExameFasePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ExameFases that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExameFaseFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ExameFases
     * const exameFases = await prisma.exameFase.findMany()
     * 
     * // Get first 10 ExameFases
     * const exameFases = await prisma.exameFase.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const exameFaseWithIdOnly = await prisma.exameFase.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ExameFaseFindManyArgs>(args?: SelectSubset<T, ExameFaseFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExameFasePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ExameFase.
     * @param {ExameFaseCreateArgs} args - Arguments to create a ExameFase.
     * @example
     * // Create one ExameFase
     * const ExameFase = await prisma.exameFase.create({
     *   data: {
     *     // ... data to create a ExameFase
     *   }
     * })
     * 
     */
    create<T extends ExameFaseCreateArgs>(args: SelectSubset<T, ExameFaseCreateArgs<ExtArgs>>): Prisma__ExameFaseClient<$Result.GetResult<Prisma.$ExameFasePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ExameFases.
     * @param {ExameFaseCreateManyArgs} args - Arguments to create many ExameFases.
     * @example
     * // Create many ExameFases
     * const exameFase = await prisma.exameFase.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ExameFaseCreateManyArgs>(args?: SelectSubset<T, ExameFaseCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ExameFase.
     * @param {ExameFaseDeleteArgs} args - Arguments to delete one ExameFase.
     * @example
     * // Delete one ExameFase
     * const ExameFase = await prisma.exameFase.delete({
     *   where: {
     *     // ... filter to delete one ExameFase
     *   }
     * })
     * 
     */
    delete<T extends ExameFaseDeleteArgs>(args: SelectSubset<T, ExameFaseDeleteArgs<ExtArgs>>): Prisma__ExameFaseClient<$Result.GetResult<Prisma.$ExameFasePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ExameFase.
     * @param {ExameFaseUpdateArgs} args - Arguments to update one ExameFase.
     * @example
     * // Update one ExameFase
     * const exameFase = await prisma.exameFase.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ExameFaseUpdateArgs>(args: SelectSubset<T, ExameFaseUpdateArgs<ExtArgs>>): Prisma__ExameFaseClient<$Result.GetResult<Prisma.$ExameFasePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ExameFases.
     * @param {ExameFaseDeleteManyArgs} args - Arguments to filter ExameFases to delete.
     * @example
     * // Delete a few ExameFases
     * const { count } = await prisma.exameFase.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ExameFaseDeleteManyArgs>(args?: SelectSubset<T, ExameFaseDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ExameFases.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExameFaseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ExameFases
     * const exameFase = await prisma.exameFase.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ExameFaseUpdateManyArgs>(args: SelectSubset<T, ExameFaseUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ExameFase.
     * @param {ExameFaseUpsertArgs} args - Arguments to update or create a ExameFase.
     * @example
     * // Update or create a ExameFase
     * const exameFase = await prisma.exameFase.upsert({
     *   create: {
     *     // ... data to create a ExameFase
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ExameFase we want to update
     *   }
     * })
     */
    upsert<T extends ExameFaseUpsertArgs>(args: SelectSubset<T, ExameFaseUpsertArgs<ExtArgs>>): Prisma__ExameFaseClient<$Result.GetResult<Prisma.$ExameFasePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ExameFases.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExameFaseCountArgs} args - Arguments to filter ExameFases to count.
     * @example
     * // Count the number of ExameFases
     * const count = await prisma.exameFase.count({
     *   where: {
     *     // ... the filter for the ExameFases we want to count
     *   }
     * })
    **/
    count<T extends ExameFaseCountArgs>(
      args?: Subset<T, ExameFaseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ExameFaseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ExameFase.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExameFaseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ExameFaseAggregateArgs>(args: Subset<T, ExameFaseAggregateArgs>): Prisma.PrismaPromise<GetExameFaseAggregateType<T>>

    /**
     * Group by ExameFase.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExameFaseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ExameFaseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ExameFaseGroupByArgs['orderBy'] }
        : { orderBy?: ExameFaseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ExameFaseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetExameFaseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ExameFase model
   */
  readonly fields: ExameFaseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ExameFase.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ExameFaseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    registrations<T extends ExameFase$registrationsArgs<ExtArgs> = {}>(args?: Subset<T, ExameFase$registrationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdmitionExameRegistrationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ExameFase model
   */
  interface ExameFaseFieldRefs {
    readonly id: FieldRef<"ExameFase", 'String'>
    readonly name: FieldRef<"ExameFase", 'String'>
    readonly ordem: FieldRef<"ExameFase", 'Int'>
    readonly startDate: FieldRef<"ExameFase", 'DateTime'>
    readonly endDate: FieldRef<"ExameFase", 'DateTime'>
    readonly createdAt: FieldRef<"ExameFase", 'DateTime'>
    readonly updatedAt: FieldRef<"ExameFase", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ExameFase findUnique
   */
  export type ExameFaseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExameFase
     */
    select?: ExameFaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExameFase
     */
    omit?: ExameFaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExameFaseInclude<ExtArgs> | null
    /**
     * Filter, which ExameFase to fetch.
     */
    where: ExameFaseWhereUniqueInput
  }

  /**
   * ExameFase findUniqueOrThrow
   */
  export type ExameFaseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExameFase
     */
    select?: ExameFaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExameFase
     */
    omit?: ExameFaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExameFaseInclude<ExtArgs> | null
    /**
     * Filter, which ExameFase to fetch.
     */
    where: ExameFaseWhereUniqueInput
  }

  /**
   * ExameFase findFirst
   */
  export type ExameFaseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExameFase
     */
    select?: ExameFaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExameFase
     */
    omit?: ExameFaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExameFaseInclude<ExtArgs> | null
    /**
     * Filter, which ExameFase to fetch.
     */
    where?: ExameFaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExameFases to fetch.
     */
    orderBy?: ExameFaseOrderByWithRelationInput | ExameFaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ExameFases.
     */
    cursor?: ExameFaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExameFases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExameFases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ExameFases.
     */
    distinct?: ExameFaseScalarFieldEnum | ExameFaseScalarFieldEnum[]
  }

  /**
   * ExameFase findFirstOrThrow
   */
  export type ExameFaseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExameFase
     */
    select?: ExameFaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExameFase
     */
    omit?: ExameFaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExameFaseInclude<ExtArgs> | null
    /**
     * Filter, which ExameFase to fetch.
     */
    where?: ExameFaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExameFases to fetch.
     */
    orderBy?: ExameFaseOrderByWithRelationInput | ExameFaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ExameFases.
     */
    cursor?: ExameFaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExameFases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExameFases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ExameFases.
     */
    distinct?: ExameFaseScalarFieldEnum | ExameFaseScalarFieldEnum[]
  }

  /**
   * ExameFase findMany
   */
  export type ExameFaseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExameFase
     */
    select?: ExameFaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExameFase
     */
    omit?: ExameFaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExameFaseInclude<ExtArgs> | null
    /**
     * Filter, which ExameFases to fetch.
     */
    where?: ExameFaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExameFases to fetch.
     */
    orderBy?: ExameFaseOrderByWithRelationInput | ExameFaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ExameFases.
     */
    cursor?: ExameFaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExameFases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExameFases.
     */
    skip?: number
    distinct?: ExameFaseScalarFieldEnum | ExameFaseScalarFieldEnum[]
  }

  /**
   * ExameFase create
   */
  export type ExameFaseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExameFase
     */
    select?: ExameFaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExameFase
     */
    omit?: ExameFaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExameFaseInclude<ExtArgs> | null
    /**
     * The data needed to create a ExameFase.
     */
    data: XOR<ExameFaseCreateInput, ExameFaseUncheckedCreateInput>
  }

  /**
   * ExameFase createMany
   */
  export type ExameFaseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ExameFases.
     */
    data: ExameFaseCreateManyInput | ExameFaseCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ExameFase update
   */
  export type ExameFaseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExameFase
     */
    select?: ExameFaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExameFase
     */
    omit?: ExameFaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExameFaseInclude<ExtArgs> | null
    /**
     * The data needed to update a ExameFase.
     */
    data: XOR<ExameFaseUpdateInput, ExameFaseUncheckedUpdateInput>
    /**
     * Choose, which ExameFase to update.
     */
    where: ExameFaseWhereUniqueInput
  }

  /**
   * ExameFase updateMany
   */
  export type ExameFaseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ExameFases.
     */
    data: XOR<ExameFaseUpdateManyMutationInput, ExameFaseUncheckedUpdateManyInput>
    /**
     * Filter which ExameFases to update
     */
    where?: ExameFaseWhereInput
    /**
     * Limit how many ExameFases to update.
     */
    limit?: number
  }

  /**
   * ExameFase upsert
   */
  export type ExameFaseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExameFase
     */
    select?: ExameFaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExameFase
     */
    omit?: ExameFaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExameFaseInclude<ExtArgs> | null
    /**
     * The filter to search for the ExameFase to update in case it exists.
     */
    where: ExameFaseWhereUniqueInput
    /**
     * In case the ExameFase found by the `where` argument doesn't exist, create a new ExameFase with this data.
     */
    create: XOR<ExameFaseCreateInput, ExameFaseUncheckedCreateInput>
    /**
     * In case the ExameFase was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ExameFaseUpdateInput, ExameFaseUncheckedUpdateInput>
  }

  /**
   * ExameFase delete
   */
  export type ExameFaseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExameFase
     */
    select?: ExameFaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExameFase
     */
    omit?: ExameFaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExameFaseInclude<ExtArgs> | null
    /**
     * Filter which ExameFase to delete.
     */
    where: ExameFaseWhereUniqueInput
  }

  /**
   * ExameFase deleteMany
   */
  export type ExameFaseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ExameFases to delete
     */
    where?: ExameFaseWhereInput
    /**
     * Limit how many ExameFases to delete.
     */
    limit?: number
  }

  /**
   * ExameFase.registrations
   */
  export type ExameFase$registrationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdmitionExameRegistration
     */
    select?: AdmitionExameRegistrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdmitionExameRegistration
     */
    omit?: AdmitionExameRegistrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdmitionExameRegistrationInclude<ExtArgs> | null
    where?: AdmitionExameRegistrationWhereInput
    orderBy?: AdmitionExameRegistrationOrderByWithRelationInput | AdmitionExameRegistrationOrderByWithRelationInput[]
    cursor?: AdmitionExameRegistrationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AdmitionExameRegistrationScalarFieldEnum | AdmitionExameRegistrationScalarFieldEnum[]
  }

  /**
   * ExameFase without action
   */
  export type ExameFaseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExameFase
     */
    select?: ExameFaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExameFase
     */
    omit?: ExameFaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExameFaseInclude<ExtArgs> | null
  }


  /**
   * Model OfferedCourse
   */

  export type AggregateOfferedCourse = {
    _count: OfferedCourseCountAggregateOutputType | null
    _avg: OfferedCourseAvgAggregateOutputType | null
    _sum: OfferedCourseSumAggregateOutputType | null
    _min: OfferedCourseMinAggregateOutputType | null
    _max: OfferedCourseMaxAggregateOutputType | null
  }

  export type OfferedCourseAvgAggregateOutputType = {
    suspendGrade: number | null
  }

  export type OfferedCourseSumAggregateOutputType = {
    suspendGrade: number | null
  }

  export type OfferedCourseMinAggregateOutputType = {
    id: string | null
    academicDepartmentId: string | null
    courseId: string | null
    semesterRegistrationId: string | null
    suspendGrade: number | null
  }

  export type OfferedCourseMaxAggregateOutputType = {
    id: string | null
    academicDepartmentId: string | null
    courseId: string | null
    semesterRegistrationId: string | null
    suspendGrade: number | null
  }

  export type OfferedCourseCountAggregateOutputType = {
    id: number
    academicDepartmentId: number
    courseId: number
    semesterRegistrationId: number
    suspendGrade: number
    _all: number
  }


  export type OfferedCourseAvgAggregateInputType = {
    suspendGrade?: true
  }

  export type OfferedCourseSumAggregateInputType = {
    suspendGrade?: true
  }

  export type OfferedCourseMinAggregateInputType = {
    id?: true
    academicDepartmentId?: true
    courseId?: true
    semesterRegistrationId?: true
    suspendGrade?: true
  }

  export type OfferedCourseMaxAggregateInputType = {
    id?: true
    academicDepartmentId?: true
    courseId?: true
    semesterRegistrationId?: true
    suspendGrade?: true
  }

  export type OfferedCourseCountAggregateInputType = {
    id?: true
    academicDepartmentId?: true
    courseId?: true
    semesterRegistrationId?: true
    suspendGrade?: true
    _all?: true
  }

  export type OfferedCourseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OfferedCourse to aggregate.
     */
    where?: OfferedCourseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OfferedCourses to fetch.
     */
    orderBy?: OfferedCourseOrderByWithRelationInput | OfferedCourseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OfferedCourseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OfferedCourses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OfferedCourses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OfferedCourses
    **/
    _count?: true | OfferedCourseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OfferedCourseAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OfferedCourseSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OfferedCourseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OfferedCourseMaxAggregateInputType
  }

  export type GetOfferedCourseAggregateType<T extends OfferedCourseAggregateArgs> = {
        [P in keyof T & keyof AggregateOfferedCourse]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOfferedCourse[P]>
      : GetScalarType<T[P], AggregateOfferedCourse[P]>
  }




  export type OfferedCourseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OfferedCourseWhereInput
    orderBy?: OfferedCourseOrderByWithAggregationInput | OfferedCourseOrderByWithAggregationInput[]
    by: OfferedCourseScalarFieldEnum[] | OfferedCourseScalarFieldEnum
    having?: OfferedCourseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OfferedCourseCountAggregateInputType | true
    _avg?: OfferedCourseAvgAggregateInputType
    _sum?: OfferedCourseSumAggregateInputType
    _min?: OfferedCourseMinAggregateInputType
    _max?: OfferedCourseMaxAggregateInputType
  }

  export type OfferedCourseGroupByOutputType = {
    id: string
    academicDepartmentId: string
    courseId: string
    semesterRegistrationId: string
    suspendGrade: number
    _count: OfferedCourseCountAggregateOutputType | null
    _avg: OfferedCourseAvgAggregateOutputType | null
    _sum: OfferedCourseSumAggregateOutputType | null
    _min: OfferedCourseMinAggregateOutputType | null
    _max: OfferedCourseMaxAggregateOutputType | null
  }

  type GetOfferedCourseGroupByPayload<T extends OfferedCourseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OfferedCourseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OfferedCourseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OfferedCourseGroupByOutputType[P]>
            : GetScalarType<T[P], OfferedCourseGroupByOutputType[P]>
        }
      >
    >


  export type OfferedCourseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    academicDepartmentId?: boolean
    courseId?: boolean
    semesterRegistrationId?: boolean
    suspendGrade?: boolean
    academicDepartment?: boolean | AcademicDepartmentDefaultArgs<ExtArgs>
    semesterRegistration?: boolean | SemesterRegistrationDefaultArgs<ExtArgs>
    course?: boolean | CourseDefaultArgs<ExtArgs>
    offeredCourseSections?: boolean | OfferedCourse$offeredCourseSectionsArgs<ExtArgs>
    studentSemesterRegistrationCourses?: boolean | OfferedCourse$studentSemesterRegistrationCoursesArgs<ExtArgs>
    _count?: boolean | OfferedCourseCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["offeredCourse"]>



  export type OfferedCourseSelectScalar = {
    id?: boolean
    academicDepartmentId?: boolean
    courseId?: boolean
    semesterRegistrationId?: boolean
    suspendGrade?: boolean
  }

  export type OfferedCourseOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "academicDepartmentId" | "courseId" | "semesterRegistrationId" | "suspendGrade", ExtArgs["result"]["offeredCourse"]>
  export type OfferedCourseInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    academicDepartment?: boolean | AcademicDepartmentDefaultArgs<ExtArgs>
    semesterRegistration?: boolean | SemesterRegistrationDefaultArgs<ExtArgs>
    course?: boolean | CourseDefaultArgs<ExtArgs>
    offeredCourseSections?: boolean | OfferedCourse$offeredCourseSectionsArgs<ExtArgs>
    studentSemesterRegistrationCourses?: boolean | OfferedCourse$studentSemesterRegistrationCoursesArgs<ExtArgs>
    _count?: boolean | OfferedCourseCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $OfferedCoursePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "OfferedCourse"
    objects: {
      academicDepartment: Prisma.$AcademicDepartmentPayload<ExtArgs>
      semesterRegistration: Prisma.$SemesterRegistrationPayload<ExtArgs>
      course: Prisma.$CoursePayload<ExtArgs>
      offeredCourseSections: Prisma.$OfferedCourseSectionPayload<ExtArgs>[]
      studentSemesterRegistrationCourses: Prisma.$StudentSemesterRegistrationCoursePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      academicDepartmentId: string
      courseId: string
      semesterRegistrationId: string
      suspendGrade: number
    }, ExtArgs["result"]["offeredCourse"]>
    composites: {}
  }

  type OfferedCourseGetPayload<S extends boolean | null | undefined | OfferedCourseDefaultArgs> = $Result.GetResult<Prisma.$OfferedCoursePayload, S>

  type OfferedCourseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OfferedCourseFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OfferedCourseCountAggregateInputType | true
    }

  export interface OfferedCourseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OfferedCourse'], meta: { name: 'OfferedCourse' } }
    /**
     * Find zero or one OfferedCourse that matches the filter.
     * @param {OfferedCourseFindUniqueArgs} args - Arguments to find a OfferedCourse
     * @example
     * // Get one OfferedCourse
     * const offeredCourse = await prisma.offeredCourse.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OfferedCourseFindUniqueArgs>(args: SelectSubset<T, OfferedCourseFindUniqueArgs<ExtArgs>>): Prisma__OfferedCourseClient<$Result.GetResult<Prisma.$OfferedCoursePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one OfferedCourse that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OfferedCourseFindUniqueOrThrowArgs} args - Arguments to find a OfferedCourse
     * @example
     * // Get one OfferedCourse
     * const offeredCourse = await prisma.offeredCourse.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OfferedCourseFindUniqueOrThrowArgs>(args: SelectSubset<T, OfferedCourseFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OfferedCourseClient<$Result.GetResult<Prisma.$OfferedCoursePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OfferedCourse that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OfferedCourseFindFirstArgs} args - Arguments to find a OfferedCourse
     * @example
     * // Get one OfferedCourse
     * const offeredCourse = await prisma.offeredCourse.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OfferedCourseFindFirstArgs>(args?: SelectSubset<T, OfferedCourseFindFirstArgs<ExtArgs>>): Prisma__OfferedCourseClient<$Result.GetResult<Prisma.$OfferedCoursePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OfferedCourse that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OfferedCourseFindFirstOrThrowArgs} args - Arguments to find a OfferedCourse
     * @example
     * // Get one OfferedCourse
     * const offeredCourse = await prisma.offeredCourse.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OfferedCourseFindFirstOrThrowArgs>(args?: SelectSubset<T, OfferedCourseFindFirstOrThrowArgs<ExtArgs>>): Prisma__OfferedCourseClient<$Result.GetResult<Prisma.$OfferedCoursePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more OfferedCourses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OfferedCourseFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OfferedCourses
     * const offeredCourses = await prisma.offeredCourse.findMany()
     * 
     * // Get first 10 OfferedCourses
     * const offeredCourses = await prisma.offeredCourse.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const offeredCourseWithIdOnly = await prisma.offeredCourse.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OfferedCourseFindManyArgs>(args?: SelectSubset<T, OfferedCourseFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OfferedCoursePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a OfferedCourse.
     * @param {OfferedCourseCreateArgs} args - Arguments to create a OfferedCourse.
     * @example
     * // Create one OfferedCourse
     * const OfferedCourse = await prisma.offeredCourse.create({
     *   data: {
     *     // ... data to create a OfferedCourse
     *   }
     * })
     * 
     */
    create<T extends OfferedCourseCreateArgs>(args: SelectSubset<T, OfferedCourseCreateArgs<ExtArgs>>): Prisma__OfferedCourseClient<$Result.GetResult<Prisma.$OfferedCoursePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many OfferedCourses.
     * @param {OfferedCourseCreateManyArgs} args - Arguments to create many OfferedCourses.
     * @example
     * // Create many OfferedCourses
     * const offeredCourse = await prisma.offeredCourse.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OfferedCourseCreateManyArgs>(args?: SelectSubset<T, OfferedCourseCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a OfferedCourse.
     * @param {OfferedCourseDeleteArgs} args - Arguments to delete one OfferedCourse.
     * @example
     * // Delete one OfferedCourse
     * const OfferedCourse = await prisma.offeredCourse.delete({
     *   where: {
     *     // ... filter to delete one OfferedCourse
     *   }
     * })
     * 
     */
    delete<T extends OfferedCourseDeleteArgs>(args: SelectSubset<T, OfferedCourseDeleteArgs<ExtArgs>>): Prisma__OfferedCourseClient<$Result.GetResult<Prisma.$OfferedCoursePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one OfferedCourse.
     * @param {OfferedCourseUpdateArgs} args - Arguments to update one OfferedCourse.
     * @example
     * // Update one OfferedCourse
     * const offeredCourse = await prisma.offeredCourse.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OfferedCourseUpdateArgs>(args: SelectSubset<T, OfferedCourseUpdateArgs<ExtArgs>>): Prisma__OfferedCourseClient<$Result.GetResult<Prisma.$OfferedCoursePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more OfferedCourses.
     * @param {OfferedCourseDeleteManyArgs} args - Arguments to filter OfferedCourses to delete.
     * @example
     * // Delete a few OfferedCourses
     * const { count } = await prisma.offeredCourse.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OfferedCourseDeleteManyArgs>(args?: SelectSubset<T, OfferedCourseDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OfferedCourses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OfferedCourseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OfferedCourses
     * const offeredCourse = await prisma.offeredCourse.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OfferedCourseUpdateManyArgs>(args: SelectSubset<T, OfferedCourseUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one OfferedCourse.
     * @param {OfferedCourseUpsertArgs} args - Arguments to update or create a OfferedCourse.
     * @example
     * // Update or create a OfferedCourse
     * const offeredCourse = await prisma.offeredCourse.upsert({
     *   create: {
     *     // ... data to create a OfferedCourse
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OfferedCourse we want to update
     *   }
     * })
     */
    upsert<T extends OfferedCourseUpsertArgs>(args: SelectSubset<T, OfferedCourseUpsertArgs<ExtArgs>>): Prisma__OfferedCourseClient<$Result.GetResult<Prisma.$OfferedCoursePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of OfferedCourses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OfferedCourseCountArgs} args - Arguments to filter OfferedCourses to count.
     * @example
     * // Count the number of OfferedCourses
     * const count = await prisma.offeredCourse.count({
     *   where: {
     *     // ... the filter for the OfferedCourses we want to count
     *   }
     * })
    **/
    count<T extends OfferedCourseCountArgs>(
      args?: Subset<T, OfferedCourseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OfferedCourseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OfferedCourse.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OfferedCourseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OfferedCourseAggregateArgs>(args: Subset<T, OfferedCourseAggregateArgs>): Prisma.PrismaPromise<GetOfferedCourseAggregateType<T>>

    /**
     * Group by OfferedCourse.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OfferedCourseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OfferedCourseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OfferedCourseGroupByArgs['orderBy'] }
        : { orderBy?: OfferedCourseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OfferedCourseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOfferedCourseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the OfferedCourse model
   */
  readonly fields: OfferedCourseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OfferedCourse.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OfferedCourseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    academicDepartment<T extends AcademicDepartmentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AcademicDepartmentDefaultArgs<ExtArgs>>): Prisma__AcademicDepartmentClient<$Result.GetResult<Prisma.$AcademicDepartmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    semesterRegistration<T extends SemesterRegistrationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SemesterRegistrationDefaultArgs<ExtArgs>>): Prisma__SemesterRegistrationClient<$Result.GetResult<Prisma.$SemesterRegistrationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    course<T extends CourseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CourseDefaultArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    offeredCourseSections<T extends OfferedCourse$offeredCourseSectionsArgs<ExtArgs> = {}>(args?: Subset<T, OfferedCourse$offeredCourseSectionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OfferedCourseSectionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    studentSemesterRegistrationCourses<T extends OfferedCourse$studentSemesterRegistrationCoursesArgs<ExtArgs> = {}>(args?: Subset<T, OfferedCourse$studentSemesterRegistrationCoursesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentSemesterRegistrationCoursePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the OfferedCourse model
   */
  interface OfferedCourseFieldRefs {
    readonly id: FieldRef<"OfferedCourse", 'String'>
    readonly academicDepartmentId: FieldRef<"OfferedCourse", 'String'>
    readonly courseId: FieldRef<"OfferedCourse", 'String'>
    readonly semesterRegistrationId: FieldRef<"OfferedCourse", 'String'>
    readonly suspendGrade: FieldRef<"OfferedCourse", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * OfferedCourse findUnique
   */
  export type OfferedCourseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OfferedCourse
     */
    select?: OfferedCourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OfferedCourse
     */
    omit?: OfferedCourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OfferedCourseInclude<ExtArgs> | null
    /**
     * Filter, which OfferedCourse to fetch.
     */
    where: OfferedCourseWhereUniqueInput
  }

  /**
   * OfferedCourse findUniqueOrThrow
   */
  export type OfferedCourseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OfferedCourse
     */
    select?: OfferedCourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OfferedCourse
     */
    omit?: OfferedCourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OfferedCourseInclude<ExtArgs> | null
    /**
     * Filter, which OfferedCourse to fetch.
     */
    where: OfferedCourseWhereUniqueInput
  }

  /**
   * OfferedCourse findFirst
   */
  export type OfferedCourseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OfferedCourse
     */
    select?: OfferedCourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OfferedCourse
     */
    omit?: OfferedCourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OfferedCourseInclude<ExtArgs> | null
    /**
     * Filter, which OfferedCourse to fetch.
     */
    where?: OfferedCourseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OfferedCourses to fetch.
     */
    orderBy?: OfferedCourseOrderByWithRelationInput | OfferedCourseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OfferedCourses.
     */
    cursor?: OfferedCourseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OfferedCourses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OfferedCourses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OfferedCourses.
     */
    distinct?: OfferedCourseScalarFieldEnum | OfferedCourseScalarFieldEnum[]
  }

  /**
   * OfferedCourse findFirstOrThrow
   */
  export type OfferedCourseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OfferedCourse
     */
    select?: OfferedCourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OfferedCourse
     */
    omit?: OfferedCourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OfferedCourseInclude<ExtArgs> | null
    /**
     * Filter, which OfferedCourse to fetch.
     */
    where?: OfferedCourseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OfferedCourses to fetch.
     */
    orderBy?: OfferedCourseOrderByWithRelationInput | OfferedCourseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OfferedCourses.
     */
    cursor?: OfferedCourseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OfferedCourses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OfferedCourses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OfferedCourses.
     */
    distinct?: OfferedCourseScalarFieldEnum | OfferedCourseScalarFieldEnum[]
  }

  /**
   * OfferedCourse findMany
   */
  export type OfferedCourseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OfferedCourse
     */
    select?: OfferedCourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OfferedCourse
     */
    omit?: OfferedCourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OfferedCourseInclude<ExtArgs> | null
    /**
     * Filter, which OfferedCourses to fetch.
     */
    where?: OfferedCourseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OfferedCourses to fetch.
     */
    orderBy?: OfferedCourseOrderByWithRelationInput | OfferedCourseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OfferedCourses.
     */
    cursor?: OfferedCourseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OfferedCourses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OfferedCourses.
     */
    skip?: number
    distinct?: OfferedCourseScalarFieldEnum | OfferedCourseScalarFieldEnum[]
  }

  /**
   * OfferedCourse create
   */
  export type OfferedCourseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OfferedCourse
     */
    select?: OfferedCourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OfferedCourse
     */
    omit?: OfferedCourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OfferedCourseInclude<ExtArgs> | null
    /**
     * The data needed to create a OfferedCourse.
     */
    data: XOR<OfferedCourseCreateInput, OfferedCourseUncheckedCreateInput>
  }

  /**
   * OfferedCourse createMany
   */
  export type OfferedCourseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OfferedCourses.
     */
    data: OfferedCourseCreateManyInput | OfferedCourseCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * OfferedCourse update
   */
  export type OfferedCourseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OfferedCourse
     */
    select?: OfferedCourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OfferedCourse
     */
    omit?: OfferedCourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OfferedCourseInclude<ExtArgs> | null
    /**
     * The data needed to update a OfferedCourse.
     */
    data: XOR<OfferedCourseUpdateInput, OfferedCourseUncheckedUpdateInput>
    /**
     * Choose, which OfferedCourse to update.
     */
    where: OfferedCourseWhereUniqueInput
  }

  /**
   * OfferedCourse updateMany
   */
  export type OfferedCourseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OfferedCourses.
     */
    data: XOR<OfferedCourseUpdateManyMutationInput, OfferedCourseUncheckedUpdateManyInput>
    /**
     * Filter which OfferedCourses to update
     */
    where?: OfferedCourseWhereInput
    /**
     * Limit how many OfferedCourses to update.
     */
    limit?: number
  }

  /**
   * OfferedCourse upsert
   */
  export type OfferedCourseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OfferedCourse
     */
    select?: OfferedCourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OfferedCourse
     */
    omit?: OfferedCourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OfferedCourseInclude<ExtArgs> | null
    /**
     * The filter to search for the OfferedCourse to update in case it exists.
     */
    where: OfferedCourseWhereUniqueInput
    /**
     * In case the OfferedCourse found by the `where` argument doesn't exist, create a new OfferedCourse with this data.
     */
    create: XOR<OfferedCourseCreateInput, OfferedCourseUncheckedCreateInput>
    /**
     * In case the OfferedCourse was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OfferedCourseUpdateInput, OfferedCourseUncheckedUpdateInput>
  }

  /**
   * OfferedCourse delete
   */
  export type OfferedCourseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OfferedCourse
     */
    select?: OfferedCourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OfferedCourse
     */
    omit?: OfferedCourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OfferedCourseInclude<ExtArgs> | null
    /**
     * Filter which OfferedCourse to delete.
     */
    where: OfferedCourseWhereUniqueInput
  }

  /**
   * OfferedCourse deleteMany
   */
  export type OfferedCourseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OfferedCourses to delete
     */
    where?: OfferedCourseWhereInput
    /**
     * Limit how many OfferedCourses to delete.
     */
    limit?: number
  }

  /**
   * OfferedCourse.offeredCourseSections
   */
  export type OfferedCourse$offeredCourseSectionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OfferedCourseSection
     */
    select?: OfferedCourseSectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OfferedCourseSection
     */
    omit?: OfferedCourseSectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OfferedCourseSectionInclude<ExtArgs> | null
    where?: OfferedCourseSectionWhereInput
    orderBy?: OfferedCourseSectionOrderByWithRelationInput | OfferedCourseSectionOrderByWithRelationInput[]
    cursor?: OfferedCourseSectionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OfferedCourseSectionScalarFieldEnum | OfferedCourseSectionScalarFieldEnum[]
  }

  /**
   * OfferedCourse.studentSemesterRegistrationCourses
   */
  export type OfferedCourse$studentSemesterRegistrationCoursesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentSemesterRegistrationCourse
     */
    select?: StudentSemesterRegistrationCourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentSemesterRegistrationCourse
     */
    omit?: StudentSemesterRegistrationCourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentSemesterRegistrationCourseInclude<ExtArgs> | null
    where?: StudentSemesterRegistrationCourseWhereInput
    orderBy?: StudentSemesterRegistrationCourseOrderByWithRelationInput | StudentSemesterRegistrationCourseOrderByWithRelationInput[]
    cursor?: StudentSemesterRegistrationCourseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StudentSemesterRegistrationCourseScalarFieldEnum | StudentSemesterRegistrationCourseScalarFieldEnum[]
  }

  /**
   * OfferedCourse without action
   */
  export type OfferedCourseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OfferedCourse
     */
    select?: OfferedCourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OfferedCourse
     */
    omit?: OfferedCourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OfferedCourseInclude<ExtArgs> | null
  }


  /**
   * Model OfferedCourseSection
   */

  export type AggregateOfferedCourseSection = {
    _count: OfferedCourseSectionCountAggregateOutputType | null
    _avg: OfferedCourseSectionAvgAggregateOutputType | null
    _sum: OfferedCourseSectionSumAggregateOutputType | null
    _min: OfferedCourseSectionMinAggregateOutputType | null
    _max: OfferedCourseSectionMaxAggregateOutputType | null
  }

  export type OfferedCourseSectionAvgAggregateOutputType = {
    maxCapacity: number | null
    currentlyEnrolledStudent: number | null
  }

  export type OfferedCourseSectionSumAggregateOutputType = {
    maxCapacity: number | null
    currentlyEnrolledStudent: number | null
  }

  export type OfferedCourseSectionMinAggregateOutputType = {
    id: string | null
    title: string | null
    maxCapacity: number | null
    currentlyEnrolledStudent: number | null
    createdAt: Date | null
    updatedAt: Date | null
    semesterRegistrationId: string | null
    offeredCourseId: string | null
  }

  export type OfferedCourseSectionMaxAggregateOutputType = {
    id: string | null
    title: string | null
    maxCapacity: number | null
    currentlyEnrolledStudent: number | null
    createdAt: Date | null
    updatedAt: Date | null
    semesterRegistrationId: string | null
    offeredCourseId: string | null
  }

  export type OfferedCourseSectionCountAggregateOutputType = {
    id: number
    title: number
    maxCapacity: number
    currentlyEnrolledStudent: number
    createdAt: number
    updatedAt: number
    semesterRegistrationId: number
    offeredCourseId: number
    _all: number
  }


  export type OfferedCourseSectionAvgAggregateInputType = {
    maxCapacity?: true
    currentlyEnrolledStudent?: true
  }

  export type OfferedCourseSectionSumAggregateInputType = {
    maxCapacity?: true
    currentlyEnrolledStudent?: true
  }

  export type OfferedCourseSectionMinAggregateInputType = {
    id?: true
    title?: true
    maxCapacity?: true
    currentlyEnrolledStudent?: true
    createdAt?: true
    updatedAt?: true
    semesterRegistrationId?: true
    offeredCourseId?: true
  }

  export type OfferedCourseSectionMaxAggregateInputType = {
    id?: true
    title?: true
    maxCapacity?: true
    currentlyEnrolledStudent?: true
    createdAt?: true
    updatedAt?: true
    semesterRegistrationId?: true
    offeredCourseId?: true
  }

  export type OfferedCourseSectionCountAggregateInputType = {
    id?: true
    title?: true
    maxCapacity?: true
    currentlyEnrolledStudent?: true
    createdAt?: true
    updatedAt?: true
    semesterRegistrationId?: true
    offeredCourseId?: true
    _all?: true
  }

  export type OfferedCourseSectionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OfferedCourseSection to aggregate.
     */
    where?: OfferedCourseSectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OfferedCourseSections to fetch.
     */
    orderBy?: OfferedCourseSectionOrderByWithRelationInput | OfferedCourseSectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OfferedCourseSectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OfferedCourseSections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OfferedCourseSections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OfferedCourseSections
    **/
    _count?: true | OfferedCourseSectionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OfferedCourseSectionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OfferedCourseSectionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OfferedCourseSectionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OfferedCourseSectionMaxAggregateInputType
  }

  export type GetOfferedCourseSectionAggregateType<T extends OfferedCourseSectionAggregateArgs> = {
        [P in keyof T & keyof AggregateOfferedCourseSection]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOfferedCourseSection[P]>
      : GetScalarType<T[P], AggregateOfferedCourseSection[P]>
  }




  export type OfferedCourseSectionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OfferedCourseSectionWhereInput
    orderBy?: OfferedCourseSectionOrderByWithAggregationInput | OfferedCourseSectionOrderByWithAggregationInput[]
    by: OfferedCourseSectionScalarFieldEnum[] | OfferedCourseSectionScalarFieldEnum
    having?: OfferedCourseSectionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OfferedCourseSectionCountAggregateInputType | true
    _avg?: OfferedCourseSectionAvgAggregateInputType
    _sum?: OfferedCourseSectionSumAggregateInputType
    _min?: OfferedCourseSectionMinAggregateInputType
    _max?: OfferedCourseSectionMaxAggregateInputType
  }

  export type OfferedCourseSectionGroupByOutputType = {
    id: string
    title: string
    maxCapacity: number
    currentlyEnrolledStudent: number
    createdAt: Date
    updatedAt: Date
    semesterRegistrationId: string
    offeredCourseId: string
    _count: OfferedCourseSectionCountAggregateOutputType | null
    _avg: OfferedCourseSectionAvgAggregateOutputType | null
    _sum: OfferedCourseSectionSumAggregateOutputType | null
    _min: OfferedCourseSectionMinAggregateOutputType | null
    _max: OfferedCourseSectionMaxAggregateOutputType | null
  }

  type GetOfferedCourseSectionGroupByPayload<T extends OfferedCourseSectionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OfferedCourseSectionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OfferedCourseSectionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OfferedCourseSectionGroupByOutputType[P]>
            : GetScalarType<T[P], OfferedCourseSectionGroupByOutputType[P]>
        }
      >
    >


  export type OfferedCourseSectionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    maxCapacity?: boolean
    currentlyEnrolledStudent?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    semesterRegistrationId?: boolean
    offeredCourseId?: boolean
    semesterRegistration?: boolean | SemesterRegistrationDefaultArgs<ExtArgs>
    offeredCourse?: boolean | OfferedCourseDefaultArgs<ExtArgs>
    offeredCourseClassSchedules?: boolean | OfferedCourseSection$offeredCourseClassSchedulesArgs<ExtArgs>
    studentSemesterRegistrationCourses?: boolean | OfferedCourseSection$studentSemesterRegistrationCoursesArgs<ExtArgs>
    _count?: boolean | OfferedCourseSectionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["offeredCourseSection"]>



  export type OfferedCourseSectionSelectScalar = {
    id?: boolean
    title?: boolean
    maxCapacity?: boolean
    currentlyEnrolledStudent?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    semesterRegistrationId?: boolean
    offeredCourseId?: boolean
  }

  export type OfferedCourseSectionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "maxCapacity" | "currentlyEnrolledStudent" | "createdAt" | "updatedAt" | "semesterRegistrationId" | "offeredCourseId", ExtArgs["result"]["offeredCourseSection"]>
  export type OfferedCourseSectionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    semesterRegistration?: boolean | SemesterRegistrationDefaultArgs<ExtArgs>
    offeredCourse?: boolean | OfferedCourseDefaultArgs<ExtArgs>
    offeredCourseClassSchedules?: boolean | OfferedCourseSection$offeredCourseClassSchedulesArgs<ExtArgs>
    studentSemesterRegistrationCourses?: boolean | OfferedCourseSection$studentSemesterRegistrationCoursesArgs<ExtArgs>
    _count?: boolean | OfferedCourseSectionCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $OfferedCourseSectionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "OfferedCourseSection"
    objects: {
      semesterRegistration: Prisma.$SemesterRegistrationPayload<ExtArgs>
      offeredCourse: Prisma.$OfferedCoursePayload<ExtArgs>
      offeredCourseClassSchedules: Prisma.$OfferedCourseClassSchedulePayload<ExtArgs>[]
      studentSemesterRegistrationCourses: Prisma.$StudentSemesterRegistrationCoursePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      maxCapacity: number
      currentlyEnrolledStudent: number
      createdAt: Date
      updatedAt: Date
      semesterRegistrationId: string
      offeredCourseId: string
    }, ExtArgs["result"]["offeredCourseSection"]>
    composites: {}
  }

  type OfferedCourseSectionGetPayload<S extends boolean | null | undefined | OfferedCourseSectionDefaultArgs> = $Result.GetResult<Prisma.$OfferedCourseSectionPayload, S>

  type OfferedCourseSectionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OfferedCourseSectionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OfferedCourseSectionCountAggregateInputType | true
    }

  export interface OfferedCourseSectionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OfferedCourseSection'], meta: { name: 'OfferedCourseSection' } }
    /**
     * Find zero or one OfferedCourseSection that matches the filter.
     * @param {OfferedCourseSectionFindUniqueArgs} args - Arguments to find a OfferedCourseSection
     * @example
     * // Get one OfferedCourseSection
     * const offeredCourseSection = await prisma.offeredCourseSection.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OfferedCourseSectionFindUniqueArgs>(args: SelectSubset<T, OfferedCourseSectionFindUniqueArgs<ExtArgs>>): Prisma__OfferedCourseSectionClient<$Result.GetResult<Prisma.$OfferedCourseSectionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one OfferedCourseSection that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OfferedCourseSectionFindUniqueOrThrowArgs} args - Arguments to find a OfferedCourseSection
     * @example
     * // Get one OfferedCourseSection
     * const offeredCourseSection = await prisma.offeredCourseSection.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OfferedCourseSectionFindUniqueOrThrowArgs>(args: SelectSubset<T, OfferedCourseSectionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OfferedCourseSectionClient<$Result.GetResult<Prisma.$OfferedCourseSectionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OfferedCourseSection that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OfferedCourseSectionFindFirstArgs} args - Arguments to find a OfferedCourseSection
     * @example
     * // Get one OfferedCourseSection
     * const offeredCourseSection = await prisma.offeredCourseSection.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OfferedCourseSectionFindFirstArgs>(args?: SelectSubset<T, OfferedCourseSectionFindFirstArgs<ExtArgs>>): Prisma__OfferedCourseSectionClient<$Result.GetResult<Prisma.$OfferedCourseSectionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OfferedCourseSection that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OfferedCourseSectionFindFirstOrThrowArgs} args - Arguments to find a OfferedCourseSection
     * @example
     * // Get one OfferedCourseSection
     * const offeredCourseSection = await prisma.offeredCourseSection.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OfferedCourseSectionFindFirstOrThrowArgs>(args?: SelectSubset<T, OfferedCourseSectionFindFirstOrThrowArgs<ExtArgs>>): Prisma__OfferedCourseSectionClient<$Result.GetResult<Prisma.$OfferedCourseSectionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more OfferedCourseSections that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OfferedCourseSectionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OfferedCourseSections
     * const offeredCourseSections = await prisma.offeredCourseSection.findMany()
     * 
     * // Get first 10 OfferedCourseSections
     * const offeredCourseSections = await prisma.offeredCourseSection.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const offeredCourseSectionWithIdOnly = await prisma.offeredCourseSection.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OfferedCourseSectionFindManyArgs>(args?: SelectSubset<T, OfferedCourseSectionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OfferedCourseSectionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a OfferedCourseSection.
     * @param {OfferedCourseSectionCreateArgs} args - Arguments to create a OfferedCourseSection.
     * @example
     * // Create one OfferedCourseSection
     * const OfferedCourseSection = await prisma.offeredCourseSection.create({
     *   data: {
     *     // ... data to create a OfferedCourseSection
     *   }
     * })
     * 
     */
    create<T extends OfferedCourseSectionCreateArgs>(args: SelectSubset<T, OfferedCourseSectionCreateArgs<ExtArgs>>): Prisma__OfferedCourseSectionClient<$Result.GetResult<Prisma.$OfferedCourseSectionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many OfferedCourseSections.
     * @param {OfferedCourseSectionCreateManyArgs} args - Arguments to create many OfferedCourseSections.
     * @example
     * // Create many OfferedCourseSections
     * const offeredCourseSection = await prisma.offeredCourseSection.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OfferedCourseSectionCreateManyArgs>(args?: SelectSubset<T, OfferedCourseSectionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a OfferedCourseSection.
     * @param {OfferedCourseSectionDeleteArgs} args - Arguments to delete one OfferedCourseSection.
     * @example
     * // Delete one OfferedCourseSection
     * const OfferedCourseSection = await prisma.offeredCourseSection.delete({
     *   where: {
     *     // ... filter to delete one OfferedCourseSection
     *   }
     * })
     * 
     */
    delete<T extends OfferedCourseSectionDeleteArgs>(args: SelectSubset<T, OfferedCourseSectionDeleteArgs<ExtArgs>>): Prisma__OfferedCourseSectionClient<$Result.GetResult<Prisma.$OfferedCourseSectionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one OfferedCourseSection.
     * @param {OfferedCourseSectionUpdateArgs} args - Arguments to update one OfferedCourseSection.
     * @example
     * // Update one OfferedCourseSection
     * const offeredCourseSection = await prisma.offeredCourseSection.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OfferedCourseSectionUpdateArgs>(args: SelectSubset<T, OfferedCourseSectionUpdateArgs<ExtArgs>>): Prisma__OfferedCourseSectionClient<$Result.GetResult<Prisma.$OfferedCourseSectionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more OfferedCourseSections.
     * @param {OfferedCourseSectionDeleteManyArgs} args - Arguments to filter OfferedCourseSections to delete.
     * @example
     * // Delete a few OfferedCourseSections
     * const { count } = await prisma.offeredCourseSection.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OfferedCourseSectionDeleteManyArgs>(args?: SelectSubset<T, OfferedCourseSectionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OfferedCourseSections.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OfferedCourseSectionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OfferedCourseSections
     * const offeredCourseSection = await prisma.offeredCourseSection.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OfferedCourseSectionUpdateManyArgs>(args: SelectSubset<T, OfferedCourseSectionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one OfferedCourseSection.
     * @param {OfferedCourseSectionUpsertArgs} args - Arguments to update or create a OfferedCourseSection.
     * @example
     * // Update or create a OfferedCourseSection
     * const offeredCourseSection = await prisma.offeredCourseSection.upsert({
     *   create: {
     *     // ... data to create a OfferedCourseSection
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OfferedCourseSection we want to update
     *   }
     * })
     */
    upsert<T extends OfferedCourseSectionUpsertArgs>(args: SelectSubset<T, OfferedCourseSectionUpsertArgs<ExtArgs>>): Prisma__OfferedCourseSectionClient<$Result.GetResult<Prisma.$OfferedCourseSectionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of OfferedCourseSections.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OfferedCourseSectionCountArgs} args - Arguments to filter OfferedCourseSections to count.
     * @example
     * // Count the number of OfferedCourseSections
     * const count = await prisma.offeredCourseSection.count({
     *   where: {
     *     // ... the filter for the OfferedCourseSections we want to count
     *   }
     * })
    **/
    count<T extends OfferedCourseSectionCountArgs>(
      args?: Subset<T, OfferedCourseSectionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OfferedCourseSectionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OfferedCourseSection.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OfferedCourseSectionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OfferedCourseSectionAggregateArgs>(args: Subset<T, OfferedCourseSectionAggregateArgs>): Prisma.PrismaPromise<GetOfferedCourseSectionAggregateType<T>>

    /**
     * Group by OfferedCourseSection.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OfferedCourseSectionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OfferedCourseSectionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OfferedCourseSectionGroupByArgs['orderBy'] }
        : { orderBy?: OfferedCourseSectionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OfferedCourseSectionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOfferedCourseSectionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the OfferedCourseSection model
   */
  readonly fields: OfferedCourseSectionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OfferedCourseSection.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OfferedCourseSectionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    semesterRegistration<T extends SemesterRegistrationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SemesterRegistrationDefaultArgs<ExtArgs>>): Prisma__SemesterRegistrationClient<$Result.GetResult<Prisma.$SemesterRegistrationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    offeredCourse<T extends OfferedCourseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OfferedCourseDefaultArgs<ExtArgs>>): Prisma__OfferedCourseClient<$Result.GetResult<Prisma.$OfferedCoursePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    offeredCourseClassSchedules<T extends OfferedCourseSection$offeredCourseClassSchedulesArgs<ExtArgs> = {}>(args?: Subset<T, OfferedCourseSection$offeredCourseClassSchedulesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OfferedCourseClassSchedulePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    studentSemesterRegistrationCourses<T extends OfferedCourseSection$studentSemesterRegistrationCoursesArgs<ExtArgs> = {}>(args?: Subset<T, OfferedCourseSection$studentSemesterRegistrationCoursesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentSemesterRegistrationCoursePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the OfferedCourseSection model
   */
  interface OfferedCourseSectionFieldRefs {
    readonly id: FieldRef<"OfferedCourseSection", 'String'>
    readonly title: FieldRef<"OfferedCourseSection", 'String'>
    readonly maxCapacity: FieldRef<"OfferedCourseSection", 'Int'>
    readonly currentlyEnrolledStudent: FieldRef<"OfferedCourseSection", 'Int'>
    readonly createdAt: FieldRef<"OfferedCourseSection", 'DateTime'>
    readonly updatedAt: FieldRef<"OfferedCourseSection", 'DateTime'>
    readonly semesterRegistrationId: FieldRef<"OfferedCourseSection", 'String'>
    readonly offeredCourseId: FieldRef<"OfferedCourseSection", 'String'>
  }
    

  // Custom InputTypes
  /**
   * OfferedCourseSection findUnique
   */
  export type OfferedCourseSectionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OfferedCourseSection
     */
    select?: OfferedCourseSectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OfferedCourseSection
     */
    omit?: OfferedCourseSectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OfferedCourseSectionInclude<ExtArgs> | null
    /**
     * Filter, which OfferedCourseSection to fetch.
     */
    where: OfferedCourseSectionWhereUniqueInput
  }

  /**
   * OfferedCourseSection findUniqueOrThrow
   */
  export type OfferedCourseSectionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OfferedCourseSection
     */
    select?: OfferedCourseSectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OfferedCourseSection
     */
    omit?: OfferedCourseSectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OfferedCourseSectionInclude<ExtArgs> | null
    /**
     * Filter, which OfferedCourseSection to fetch.
     */
    where: OfferedCourseSectionWhereUniqueInput
  }

  /**
   * OfferedCourseSection findFirst
   */
  export type OfferedCourseSectionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OfferedCourseSection
     */
    select?: OfferedCourseSectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OfferedCourseSection
     */
    omit?: OfferedCourseSectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OfferedCourseSectionInclude<ExtArgs> | null
    /**
     * Filter, which OfferedCourseSection to fetch.
     */
    where?: OfferedCourseSectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OfferedCourseSections to fetch.
     */
    orderBy?: OfferedCourseSectionOrderByWithRelationInput | OfferedCourseSectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OfferedCourseSections.
     */
    cursor?: OfferedCourseSectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OfferedCourseSections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OfferedCourseSections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OfferedCourseSections.
     */
    distinct?: OfferedCourseSectionScalarFieldEnum | OfferedCourseSectionScalarFieldEnum[]
  }

  /**
   * OfferedCourseSection findFirstOrThrow
   */
  export type OfferedCourseSectionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OfferedCourseSection
     */
    select?: OfferedCourseSectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OfferedCourseSection
     */
    omit?: OfferedCourseSectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OfferedCourseSectionInclude<ExtArgs> | null
    /**
     * Filter, which OfferedCourseSection to fetch.
     */
    where?: OfferedCourseSectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OfferedCourseSections to fetch.
     */
    orderBy?: OfferedCourseSectionOrderByWithRelationInput | OfferedCourseSectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OfferedCourseSections.
     */
    cursor?: OfferedCourseSectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OfferedCourseSections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OfferedCourseSections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OfferedCourseSections.
     */
    distinct?: OfferedCourseSectionScalarFieldEnum | OfferedCourseSectionScalarFieldEnum[]
  }

  /**
   * OfferedCourseSection findMany
   */
  export type OfferedCourseSectionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OfferedCourseSection
     */
    select?: OfferedCourseSectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OfferedCourseSection
     */
    omit?: OfferedCourseSectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OfferedCourseSectionInclude<ExtArgs> | null
    /**
     * Filter, which OfferedCourseSections to fetch.
     */
    where?: OfferedCourseSectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OfferedCourseSections to fetch.
     */
    orderBy?: OfferedCourseSectionOrderByWithRelationInput | OfferedCourseSectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OfferedCourseSections.
     */
    cursor?: OfferedCourseSectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OfferedCourseSections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OfferedCourseSections.
     */
    skip?: number
    distinct?: OfferedCourseSectionScalarFieldEnum | OfferedCourseSectionScalarFieldEnum[]
  }

  /**
   * OfferedCourseSection create
   */
  export type OfferedCourseSectionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OfferedCourseSection
     */
    select?: OfferedCourseSectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OfferedCourseSection
     */
    omit?: OfferedCourseSectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OfferedCourseSectionInclude<ExtArgs> | null
    /**
     * The data needed to create a OfferedCourseSection.
     */
    data: XOR<OfferedCourseSectionCreateInput, OfferedCourseSectionUncheckedCreateInput>
  }

  /**
   * OfferedCourseSection createMany
   */
  export type OfferedCourseSectionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OfferedCourseSections.
     */
    data: OfferedCourseSectionCreateManyInput | OfferedCourseSectionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * OfferedCourseSection update
   */
  export type OfferedCourseSectionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OfferedCourseSection
     */
    select?: OfferedCourseSectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OfferedCourseSection
     */
    omit?: OfferedCourseSectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OfferedCourseSectionInclude<ExtArgs> | null
    /**
     * The data needed to update a OfferedCourseSection.
     */
    data: XOR<OfferedCourseSectionUpdateInput, OfferedCourseSectionUncheckedUpdateInput>
    /**
     * Choose, which OfferedCourseSection to update.
     */
    where: OfferedCourseSectionWhereUniqueInput
  }

  /**
   * OfferedCourseSection updateMany
   */
  export type OfferedCourseSectionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OfferedCourseSections.
     */
    data: XOR<OfferedCourseSectionUpdateManyMutationInput, OfferedCourseSectionUncheckedUpdateManyInput>
    /**
     * Filter which OfferedCourseSections to update
     */
    where?: OfferedCourseSectionWhereInput
    /**
     * Limit how many OfferedCourseSections to update.
     */
    limit?: number
  }

  /**
   * OfferedCourseSection upsert
   */
  export type OfferedCourseSectionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OfferedCourseSection
     */
    select?: OfferedCourseSectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OfferedCourseSection
     */
    omit?: OfferedCourseSectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OfferedCourseSectionInclude<ExtArgs> | null
    /**
     * The filter to search for the OfferedCourseSection to update in case it exists.
     */
    where: OfferedCourseSectionWhereUniqueInput
    /**
     * In case the OfferedCourseSection found by the `where` argument doesn't exist, create a new OfferedCourseSection with this data.
     */
    create: XOR<OfferedCourseSectionCreateInput, OfferedCourseSectionUncheckedCreateInput>
    /**
     * In case the OfferedCourseSection was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OfferedCourseSectionUpdateInput, OfferedCourseSectionUncheckedUpdateInput>
  }

  /**
   * OfferedCourseSection delete
   */
  export type OfferedCourseSectionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OfferedCourseSection
     */
    select?: OfferedCourseSectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OfferedCourseSection
     */
    omit?: OfferedCourseSectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OfferedCourseSectionInclude<ExtArgs> | null
    /**
     * Filter which OfferedCourseSection to delete.
     */
    where: OfferedCourseSectionWhereUniqueInput
  }

  /**
   * OfferedCourseSection deleteMany
   */
  export type OfferedCourseSectionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OfferedCourseSections to delete
     */
    where?: OfferedCourseSectionWhereInput
    /**
     * Limit how many OfferedCourseSections to delete.
     */
    limit?: number
  }

  /**
   * OfferedCourseSection.offeredCourseClassSchedules
   */
  export type OfferedCourseSection$offeredCourseClassSchedulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OfferedCourseClassSchedule
     */
    select?: OfferedCourseClassScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OfferedCourseClassSchedule
     */
    omit?: OfferedCourseClassScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OfferedCourseClassScheduleInclude<ExtArgs> | null
    where?: OfferedCourseClassScheduleWhereInput
    orderBy?: OfferedCourseClassScheduleOrderByWithRelationInput | OfferedCourseClassScheduleOrderByWithRelationInput[]
    cursor?: OfferedCourseClassScheduleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OfferedCourseClassScheduleScalarFieldEnum | OfferedCourseClassScheduleScalarFieldEnum[]
  }

  /**
   * OfferedCourseSection.studentSemesterRegistrationCourses
   */
  export type OfferedCourseSection$studentSemesterRegistrationCoursesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentSemesterRegistrationCourse
     */
    select?: StudentSemesterRegistrationCourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentSemesterRegistrationCourse
     */
    omit?: StudentSemesterRegistrationCourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentSemesterRegistrationCourseInclude<ExtArgs> | null
    where?: StudentSemesterRegistrationCourseWhereInput
    orderBy?: StudentSemesterRegistrationCourseOrderByWithRelationInput | StudentSemesterRegistrationCourseOrderByWithRelationInput[]
    cursor?: StudentSemesterRegistrationCourseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StudentSemesterRegistrationCourseScalarFieldEnum | StudentSemesterRegistrationCourseScalarFieldEnum[]
  }

  /**
   * OfferedCourseSection without action
   */
  export type OfferedCourseSectionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OfferedCourseSection
     */
    select?: OfferedCourseSectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OfferedCourseSection
     */
    omit?: OfferedCourseSectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OfferedCourseSectionInclude<ExtArgs> | null
  }


  /**
   * Model OfferedCourseClassSchedule
   */

  export type AggregateOfferedCourseClassSchedule = {
    _count: OfferedCourseClassScheduleCountAggregateOutputType | null
    _min: OfferedCourseClassScheduleMinAggregateOutputType | null
    _max: OfferedCourseClassScheduleMaxAggregateOutputType | null
  }

  export type OfferedCourseClassScheduleMinAggregateOutputType = {
    id: string | null
    startTime: string | null
    endTime: string | null
    dayOfWeek: $Enums.WeekDays | null
    createdAt: Date | null
    updatedAt: Date | null
    offeredCourseSectionId: string | null
    semesterRegistrationId: string | null
    roomId: string | null
    facultyId: string | null
  }

  export type OfferedCourseClassScheduleMaxAggregateOutputType = {
    id: string | null
    startTime: string | null
    endTime: string | null
    dayOfWeek: $Enums.WeekDays | null
    createdAt: Date | null
    updatedAt: Date | null
    offeredCourseSectionId: string | null
    semesterRegistrationId: string | null
    roomId: string | null
    facultyId: string | null
  }

  export type OfferedCourseClassScheduleCountAggregateOutputType = {
    id: number
    startTime: number
    endTime: number
    dayOfWeek: number
    createdAt: number
    updatedAt: number
    offeredCourseSectionId: number
    semesterRegistrationId: number
    roomId: number
    facultyId: number
    _all: number
  }


  export type OfferedCourseClassScheduleMinAggregateInputType = {
    id?: true
    startTime?: true
    endTime?: true
    dayOfWeek?: true
    createdAt?: true
    updatedAt?: true
    offeredCourseSectionId?: true
    semesterRegistrationId?: true
    roomId?: true
    facultyId?: true
  }

  export type OfferedCourseClassScheduleMaxAggregateInputType = {
    id?: true
    startTime?: true
    endTime?: true
    dayOfWeek?: true
    createdAt?: true
    updatedAt?: true
    offeredCourseSectionId?: true
    semesterRegistrationId?: true
    roomId?: true
    facultyId?: true
  }

  export type OfferedCourseClassScheduleCountAggregateInputType = {
    id?: true
    startTime?: true
    endTime?: true
    dayOfWeek?: true
    createdAt?: true
    updatedAt?: true
    offeredCourseSectionId?: true
    semesterRegistrationId?: true
    roomId?: true
    facultyId?: true
    _all?: true
  }

  export type OfferedCourseClassScheduleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OfferedCourseClassSchedule to aggregate.
     */
    where?: OfferedCourseClassScheduleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OfferedCourseClassSchedules to fetch.
     */
    orderBy?: OfferedCourseClassScheduleOrderByWithRelationInput | OfferedCourseClassScheduleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OfferedCourseClassScheduleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OfferedCourseClassSchedules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OfferedCourseClassSchedules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OfferedCourseClassSchedules
    **/
    _count?: true | OfferedCourseClassScheduleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OfferedCourseClassScheduleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OfferedCourseClassScheduleMaxAggregateInputType
  }

  export type GetOfferedCourseClassScheduleAggregateType<T extends OfferedCourseClassScheduleAggregateArgs> = {
        [P in keyof T & keyof AggregateOfferedCourseClassSchedule]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOfferedCourseClassSchedule[P]>
      : GetScalarType<T[P], AggregateOfferedCourseClassSchedule[P]>
  }




  export type OfferedCourseClassScheduleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OfferedCourseClassScheduleWhereInput
    orderBy?: OfferedCourseClassScheduleOrderByWithAggregationInput | OfferedCourseClassScheduleOrderByWithAggregationInput[]
    by: OfferedCourseClassScheduleScalarFieldEnum[] | OfferedCourseClassScheduleScalarFieldEnum
    having?: OfferedCourseClassScheduleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OfferedCourseClassScheduleCountAggregateInputType | true
    _min?: OfferedCourseClassScheduleMinAggregateInputType
    _max?: OfferedCourseClassScheduleMaxAggregateInputType
  }

  export type OfferedCourseClassScheduleGroupByOutputType = {
    id: string
    startTime: string
    endTime: string
    dayOfWeek: $Enums.WeekDays
    createdAt: Date
    updatedAt: Date
    offeredCourseSectionId: string
    semesterRegistrationId: string
    roomId: string
    facultyId: string
    _count: OfferedCourseClassScheduleCountAggregateOutputType | null
    _min: OfferedCourseClassScheduleMinAggregateOutputType | null
    _max: OfferedCourseClassScheduleMaxAggregateOutputType | null
  }

  type GetOfferedCourseClassScheduleGroupByPayload<T extends OfferedCourseClassScheduleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OfferedCourseClassScheduleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OfferedCourseClassScheduleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OfferedCourseClassScheduleGroupByOutputType[P]>
            : GetScalarType<T[P], OfferedCourseClassScheduleGroupByOutputType[P]>
        }
      >
    >


  export type OfferedCourseClassScheduleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    startTime?: boolean
    endTime?: boolean
    dayOfWeek?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    offeredCourseSectionId?: boolean
    semesterRegistrationId?: boolean
    roomId?: boolean
    facultyId?: boolean
    offeredCourseSection?: boolean | OfferedCourseSectionDefaultArgs<ExtArgs>
    semesterRegistration?: boolean | SemesterRegistrationDefaultArgs<ExtArgs>
    room?: boolean | RoomDefaultArgs<ExtArgs>
    faculty?: boolean | FacultyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["offeredCourseClassSchedule"]>



  export type OfferedCourseClassScheduleSelectScalar = {
    id?: boolean
    startTime?: boolean
    endTime?: boolean
    dayOfWeek?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    offeredCourseSectionId?: boolean
    semesterRegistrationId?: boolean
    roomId?: boolean
    facultyId?: boolean
  }

  export type OfferedCourseClassScheduleOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "startTime" | "endTime" | "dayOfWeek" | "createdAt" | "updatedAt" | "offeredCourseSectionId" | "semesterRegistrationId" | "roomId" | "facultyId", ExtArgs["result"]["offeredCourseClassSchedule"]>
  export type OfferedCourseClassScheduleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    offeredCourseSection?: boolean | OfferedCourseSectionDefaultArgs<ExtArgs>
    semesterRegistration?: boolean | SemesterRegistrationDefaultArgs<ExtArgs>
    room?: boolean | RoomDefaultArgs<ExtArgs>
    faculty?: boolean | FacultyDefaultArgs<ExtArgs>
  }

  export type $OfferedCourseClassSchedulePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "OfferedCourseClassSchedule"
    objects: {
      offeredCourseSection: Prisma.$OfferedCourseSectionPayload<ExtArgs>
      semesterRegistration: Prisma.$SemesterRegistrationPayload<ExtArgs>
      room: Prisma.$RoomPayload<ExtArgs>
      faculty: Prisma.$FacultyPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      startTime: string
      endTime: string
      dayOfWeek: $Enums.WeekDays
      createdAt: Date
      updatedAt: Date
      offeredCourseSectionId: string
      semesterRegistrationId: string
      roomId: string
      facultyId: string
    }, ExtArgs["result"]["offeredCourseClassSchedule"]>
    composites: {}
  }

  type OfferedCourseClassScheduleGetPayload<S extends boolean | null | undefined | OfferedCourseClassScheduleDefaultArgs> = $Result.GetResult<Prisma.$OfferedCourseClassSchedulePayload, S>

  type OfferedCourseClassScheduleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OfferedCourseClassScheduleFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OfferedCourseClassScheduleCountAggregateInputType | true
    }

  export interface OfferedCourseClassScheduleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OfferedCourseClassSchedule'], meta: { name: 'OfferedCourseClassSchedule' } }
    /**
     * Find zero or one OfferedCourseClassSchedule that matches the filter.
     * @param {OfferedCourseClassScheduleFindUniqueArgs} args - Arguments to find a OfferedCourseClassSchedule
     * @example
     * // Get one OfferedCourseClassSchedule
     * const offeredCourseClassSchedule = await prisma.offeredCourseClassSchedule.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OfferedCourseClassScheduleFindUniqueArgs>(args: SelectSubset<T, OfferedCourseClassScheduleFindUniqueArgs<ExtArgs>>): Prisma__OfferedCourseClassScheduleClient<$Result.GetResult<Prisma.$OfferedCourseClassSchedulePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one OfferedCourseClassSchedule that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OfferedCourseClassScheduleFindUniqueOrThrowArgs} args - Arguments to find a OfferedCourseClassSchedule
     * @example
     * // Get one OfferedCourseClassSchedule
     * const offeredCourseClassSchedule = await prisma.offeredCourseClassSchedule.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OfferedCourseClassScheduleFindUniqueOrThrowArgs>(args: SelectSubset<T, OfferedCourseClassScheduleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OfferedCourseClassScheduleClient<$Result.GetResult<Prisma.$OfferedCourseClassSchedulePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OfferedCourseClassSchedule that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OfferedCourseClassScheduleFindFirstArgs} args - Arguments to find a OfferedCourseClassSchedule
     * @example
     * // Get one OfferedCourseClassSchedule
     * const offeredCourseClassSchedule = await prisma.offeredCourseClassSchedule.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OfferedCourseClassScheduleFindFirstArgs>(args?: SelectSubset<T, OfferedCourseClassScheduleFindFirstArgs<ExtArgs>>): Prisma__OfferedCourseClassScheduleClient<$Result.GetResult<Prisma.$OfferedCourseClassSchedulePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OfferedCourseClassSchedule that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OfferedCourseClassScheduleFindFirstOrThrowArgs} args - Arguments to find a OfferedCourseClassSchedule
     * @example
     * // Get one OfferedCourseClassSchedule
     * const offeredCourseClassSchedule = await prisma.offeredCourseClassSchedule.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OfferedCourseClassScheduleFindFirstOrThrowArgs>(args?: SelectSubset<T, OfferedCourseClassScheduleFindFirstOrThrowArgs<ExtArgs>>): Prisma__OfferedCourseClassScheduleClient<$Result.GetResult<Prisma.$OfferedCourseClassSchedulePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more OfferedCourseClassSchedules that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OfferedCourseClassScheduleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OfferedCourseClassSchedules
     * const offeredCourseClassSchedules = await prisma.offeredCourseClassSchedule.findMany()
     * 
     * // Get first 10 OfferedCourseClassSchedules
     * const offeredCourseClassSchedules = await prisma.offeredCourseClassSchedule.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const offeredCourseClassScheduleWithIdOnly = await prisma.offeredCourseClassSchedule.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OfferedCourseClassScheduleFindManyArgs>(args?: SelectSubset<T, OfferedCourseClassScheduleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OfferedCourseClassSchedulePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a OfferedCourseClassSchedule.
     * @param {OfferedCourseClassScheduleCreateArgs} args - Arguments to create a OfferedCourseClassSchedule.
     * @example
     * // Create one OfferedCourseClassSchedule
     * const OfferedCourseClassSchedule = await prisma.offeredCourseClassSchedule.create({
     *   data: {
     *     // ... data to create a OfferedCourseClassSchedule
     *   }
     * })
     * 
     */
    create<T extends OfferedCourseClassScheduleCreateArgs>(args: SelectSubset<T, OfferedCourseClassScheduleCreateArgs<ExtArgs>>): Prisma__OfferedCourseClassScheduleClient<$Result.GetResult<Prisma.$OfferedCourseClassSchedulePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many OfferedCourseClassSchedules.
     * @param {OfferedCourseClassScheduleCreateManyArgs} args - Arguments to create many OfferedCourseClassSchedules.
     * @example
     * // Create many OfferedCourseClassSchedules
     * const offeredCourseClassSchedule = await prisma.offeredCourseClassSchedule.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OfferedCourseClassScheduleCreateManyArgs>(args?: SelectSubset<T, OfferedCourseClassScheduleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a OfferedCourseClassSchedule.
     * @param {OfferedCourseClassScheduleDeleteArgs} args - Arguments to delete one OfferedCourseClassSchedule.
     * @example
     * // Delete one OfferedCourseClassSchedule
     * const OfferedCourseClassSchedule = await prisma.offeredCourseClassSchedule.delete({
     *   where: {
     *     // ... filter to delete one OfferedCourseClassSchedule
     *   }
     * })
     * 
     */
    delete<T extends OfferedCourseClassScheduleDeleteArgs>(args: SelectSubset<T, OfferedCourseClassScheduleDeleteArgs<ExtArgs>>): Prisma__OfferedCourseClassScheduleClient<$Result.GetResult<Prisma.$OfferedCourseClassSchedulePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one OfferedCourseClassSchedule.
     * @param {OfferedCourseClassScheduleUpdateArgs} args - Arguments to update one OfferedCourseClassSchedule.
     * @example
     * // Update one OfferedCourseClassSchedule
     * const offeredCourseClassSchedule = await prisma.offeredCourseClassSchedule.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OfferedCourseClassScheduleUpdateArgs>(args: SelectSubset<T, OfferedCourseClassScheduleUpdateArgs<ExtArgs>>): Prisma__OfferedCourseClassScheduleClient<$Result.GetResult<Prisma.$OfferedCourseClassSchedulePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more OfferedCourseClassSchedules.
     * @param {OfferedCourseClassScheduleDeleteManyArgs} args - Arguments to filter OfferedCourseClassSchedules to delete.
     * @example
     * // Delete a few OfferedCourseClassSchedules
     * const { count } = await prisma.offeredCourseClassSchedule.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OfferedCourseClassScheduleDeleteManyArgs>(args?: SelectSubset<T, OfferedCourseClassScheduleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OfferedCourseClassSchedules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OfferedCourseClassScheduleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OfferedCourseClassSchedules
     * const offeredCourseClassSchedule = await prisma.offeredCourseClassSchedule.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OfferedCourseClassScheduleUpdateManyArgs>(args: SelectSubset<T, OfferedCourseClassScheduleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one OfferedCourseClassSchedule.
     * @param {OfferedCourseClassScheduleUpsertArgs} args - Arguments to update or create a OfferedCourseClassSchedule.
     * @example
     * // Update or create a OfferedCourseClassSchedule
     * const offeredCourseClassSchedule = await prisma.offeredCourseClassSchedule.upsert({
     *   create: {
     *     // ... data to create a OfferedCourseClassSchedule
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OfferedCourseClassSchedule we want to update
     *   }
     * })
     */
    upsert<T extends OfferedCourseClassScheduleUpsertArgs>(args: SelectSubset<T, OfferedCourseClassScheduleUpsertArgs<ExtArgs>>): Prisma__OfferedCourseClassScheduleClient<$Result.GetResult<Prisma.$OfferedCourseClassSchedulePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of OfferedCourseClassSchedules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OfferedCourseClassScheduleCountArgs} args - Arguments to filter OfferedCourseClassSchedules to count.
     * @example
     * // Count the number of OfferedCourseClassSchedules
     * const count = await prisma.offeredCourseClassSchedule.count({
     *   where: {
     *     // ... the filter for the OfferedCourseClassSchedules we want to count
     *   }
     * })
    **/
    count<T extends OfferedCourseClassScheduleCountArgs>(
      args?: Subset<T, OfferedCourseClassScheduleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OfferedCourseClassScheduleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OfferedCourseClassSchedule.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OfferedCourseClassScheduleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OfferedCourseClassScheduleAggregateArgs>(args: Subset<T, OfferedCourseClassScheduleAggregateArgs>): Prisma.PrismaPromise<GetOfferedCourseClassScheduleAggregateType<T>>

    /**
     * Group by OfferedCourseClassSchedule.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OfferedCourseClassScheduleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OfferedCourseClassScheduleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OfferedCourseClassScheduleGroupByArgs['orderBy'] }
        : { orderBy?: OfferedCourseClassScheduleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OfferedCourseClassScheduleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOfferedCourseClassScheduleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the OfferedCourseClassSchedule model
   */
  readonly fields: OfferedCourseClassScheduleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OfferedCourseClassSchedule.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OfferedCourseClassScheduleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    offeredCourseSection<T extends OfferedCourseSectionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OfferedCourseSectionDefaultArgs<ExtArgs>>): Prisma__OfferedCourseSectionClient<$Result.GetResult<Prisma.$OfferedCourseSectionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    semesterRegistration<T extends SemesterRegistrationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SemesterRegistrationDefaultArgs<ExtArgs>>): Prisma__SemesterRegistrationClient<$Result.GetResult<Prisma.$SemesterRegistrationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    room<T extends RoomDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RoomDefaultArgs<ExtArgs>>): Prisma__RoomClient<$Result.GetResult<Prisma.$RoomPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    faculty<T extends FacultyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FacultyDefaultArgs<ExtArgs>>): Prisma__FacultyClient<$Result.GetResult<Prisma.$FacultyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the OfferedCourseClassSchedule model
   */
  interface OfferedCourseClassScheduleFieldRefs {
    readonly id: FieldRef<"OfferedCourseClassSchedule", 'String'>
    readonly startTime: FieldRef<"OfferedCourseClassSchedule", 'String'>
    readonly endTime: FieldRef<"OfferedCourseClassSchedule", 'String'>
    readonly dayOfWeek: FieldRef<"OfferedCourseClassSchedule", 'WeekDays'>
    readonly createdAt: FieldRef<"OfferedCourseClassSchedule", 'DateTime'>
    readonly updatedAt: FieldRef<"OfferedCourseClassSchedule", 'DateTime'>
    readonly offeredCourseSectionId: FieldRef<"OfferedCourseClassSchedule", 'String'>
    readonly semesterRegistrationId: FieldRef<"OfferedCourseClassSchedule", 'String'>
    readonly roomId: FieldRef<"OfferedCourseClassSchedule", 'String'>
    readonly facultyId: FieldRef<"OfferedCourseClassSchedule", 'String'>
  }
    

  // Custom InputTypes
  /**
   * OfferedCourseClassSchedule findUnique
   */
  export type OfferedCourseClassScheduleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OfferedCourseClassSchedule
     */
    select?: OfferedCourseClassScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OfferedCourseClassSchedule
     */
    omit?: OfferedCourseClassScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OfferedCourseClassScheduleInclude<ExtArgs> | null
    /**
     * Filter, which OfferedCourseClassSchedule to fetch.
     */
    where: OfferedCourseClassScheduleWhereUniqueInput
  }

  /**
   * OfferedCourseClassSchedule findUniqueOrThrow
   */
  export type OfferedCourseClassScheduleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OfferedCourseClassSchedule
     */
    select?: OfferedCourseClassScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OfferedCourseClassSchedule
     */
    omit?: OfferedCourseClassScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OfferedCourseClassScheduleInclude<ExtArgs> | null
    /**
     * Filter, which OfferedCourseClassSchedule to fetch.
     */
    where: OfferedCourseClassScheduleWhereUniqueInput
  }

  /**
   * OfferedCourseClassSchedule findFirst
   */
  export type OfferedCourseClassScheduleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OfferedCourseClassSchedule
     */
    select?: OfferedCourseClassScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OfferedCourseClassSchedule
     */
    omit?: OfferedCourseClassScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OfferedCourseClassScheduleInclude<ExtArgs> | null
    /**
     * Filter, which OfferedCourseClassSchedule to fetch.
     */
    where?: OfferedCourseClassScheduleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OfferedCourseClassSchedules to fetch.
     */
    orderBy?: OfferedCourseClassScheduleOrderByWithRelationInput | OfferedCourseClassScheduleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OfferedCourseClassSchedules.
     */
    cursor?: OfferedCourseClassScheduleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OfferedCourseClassSchedules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OfferedCourseClassSchedules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OfferedCourseClassSchedules.
     */
    distinct?: OfferedCourseClassScheduleScalarFieldEnum | OfferedCourseClassScheduleScalarFieldEnum[]
  }

  /**
   * OfferedCourseClassSchedule findFirstOrThrow
   */
  export type OfferedCourseClassScheduleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OfferedCourseClassSchedule
     */
    select?: OfferedCourseClassScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OfferedCourseClassSchedule
     */
    omit?: OfferedCourseClassScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OfferedCourseClassScheduleInclude<ExtArgs> | null
    /**
     * Filter, which OfferedCourseClassSchedule to fetch.
     */
    where?: OfferedCourseClassScheduleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OfferedCourseClassSchedules to fetch.
     */
    orderBy?: OfferedCourseClassScheduleOrderByWithRelationInput | OfferedCourseClassScheduleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OfferedCourseClassSchedules.
     */
    cursor?: OfferedCourseClassScheduleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OfferedCourseClassSchedules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OfferedCourseClassSchedules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OfferedCourseClassSchedules.
     */
    distinct?: OfferedCourseClassScheduleScalarFieldEnum | OfferedCourseClassScheduleScalarFieldEnum[]
  }

  /**
   * OfferedCourseClassSchedule findMany
   */
  export type OfferedCourseClassScheduleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OfferedCourseClassSchedule
     */
    select?: OfferedCourseClassScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OfferedCourseClassSchedule
     */
    omit?: OfferedCourseClassScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OfferedCourseClassScheduleInclude<ExtArgs> | null
    /**
     * Filter, which OfferedCourseClassSchedules to fetch.
     */
    where?: OfferedCourseClassScheduleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OfferedCourseClassSchedules to fetch.
     */
    orderBy?: OfferedCourseClassScheduleOrderByWithRelationInput | OfferedCourseClassScheduleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OfferedCourseClassSchedules.
     */
    cursor?: OfferedCourseClassScheduleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OfferedCourseClassSchedules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OfferedCourseClassSchedules.
     */
    skip?: number
    distinct?: OfferedCourseClassScheduleScalarFieldEnum | OfferedCourseClassScheduleScalarFieldEnum[]
  }

  /**
   * OfferedCourseClassSchedule create
   */
  export type OfferedCourseClassScheduleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OfferedCourseClassSchedule
     */
    select?: OfferedCourseClassScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OfferedCourseClassSchedule
     */
    omit?: OfferedCourseClassScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OfferedCourseClassScheduleInclude<ExtArgs> | null
    /**
     * The data needed to create a OfferedCourseClassSchedule.
     */
    data: XOR<OfferedCourseClassScheduleCreateInput, OfferedCourseClassScheduleUncheckedCreateInput>
  }

  /**
   * OfferedCourseClassSchedule createMany
   */
  export type OfferedCourseClassScheduleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OfferedCourseClassSchedules.
     */
    data: OfferedCourseClassScheduleCreateManyInput | OfferedCourseClassScheduleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * OfferedCourseClassSchedule update
   */
  export type OfferedCourseClassScheduleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OfferedCourseClassSchedule
     */
    select?: OfferedCourseClassScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OfferedCourseClassSchedule
     */
    omit?: OfferedCourseClassScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OfferedCourseClassScheduleInclude<ExtArgs> | null
    /**
     * The data needed to update a OfferedCourseClassSchedule.
     */
    data: XOR<OfferedCourseClassScheduleUpdateInput, OfferedCourseClassScheduleUncheckedUpdateInput>
    /**
     * Choose, which OfferedCourseClassSchedule to update.
     */
    where: OfferedCourseClassScheduleWhereUniqueInput
  }

  /**
   * OfferedCourseClassSchedule updateMany
   */
  export type OfferedCourseClassScheduleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OfferedCourseClassSchedules.
     */
    data: XOR<OfferedCourseClassScheduleUpdateManyMutationInput, OfferedCourseClassScheduleUncheckedUpdateManyInput>
    /**
     * Filter which OfferedCourseClassSchedules to update
     */
    where?: OfferedCourseClassScheduleWhereInput
    /**
     * Limit how many OfferedCourseClassSchedules to update.
     */
    limit?: number
  }

  /**
   * OfferedCourseClassSchedule upsert
   */
  export type OfferedCourseClassScheduleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OfferedCourseClassSchedule
     */
    select?: OfferedCourseClassScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OfferedCourseClassSchedule
     */
    omit?: OfferedCourseClassScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OfferedCourseClassScheduleInclude<ExtArgs> | null
    /**
     * The filter to search for the OfferedCourseClassSchedule to update in case it exists.
     */
    where: OfferedCourseClassScheduleWhereUniqueInput
    /**
     * In case the OfferedCourseClassSchedule found by the `where` argument doesn't exist, create a new OfferedCourseClassSchedule with this data.
     */
    create: XOR<OfferedCourseClassScheduleCreateInput, OfferedCourseClassScheduleUncheckedCreateInput>
    /**
     * In case the OfferedCourseClassSchedule was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OfferedCourseClassScheduleUpdateInput, OfferedCourseClassScheduleUncheckedUpdateInput>
  }

  /**
   * OfferedCourseClassSchedule delete
   */
  export type OfferedCourseClassScheduleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OfferedCourseClassSchedule
     */
    select?: OfferedCourseClassScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OfferedCourseClassSchedule
     */
    omit?: OfferedCourseClassScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OfferedCourseClassScheduleInclude<ExtArgs> | null
    /**
     * Filter which OfferedCourseClassSchedule to delete.
     */
    where: OfferedCourseClassScheduleWhereUniqueInput
  }

  /**
   * OfferedCourseClassSchedule deleteMany
   */
  export type OfferedCourseClassScheduleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OfferedCourseClassSchedules to delete
     */
    where?: OfferedCourseClassScheduleWhereInput
    /**
     * Limit how many OfferedCourseClassSchedules to delete.
     */
    limit?: number
  }

  /**
   * OfferedCourseClassSchedule without action
   */
  export type OfferedCourseClassScheduleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OfferedCourseClassSchedule
     */
    select?: OfferedCourseClassScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OfferedCourseClassSchedule
     */
    omit?: OfferedCourseClassScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OfferedCourseClassScheduleInclude<ExtArgs> | null
  }


  /**
   * Model StudentSemesterRegistration
   */

  export type AggregateStudentSemesterRegistration = {
    _count: StudentSemesterRegistrationCountAggregateOutputType | null
    _avg: StudentSemesterRegistrationAvgAggregateOutputType | null
    _sum: StudentSemesterRegistrationSumAggregateOutputType | null
    _min: StudentSemesterRegistrationMinAggregateOutputType | null
    _max: StudentSemesterRegistrationMaxAggregateOutputType | null
  }

  export type StudentSemesterRegistrationAvgAggregateOutputType = {
    totalCreditsTaken: number | null
  }

  export type StudentSemesterRegistrationSumAggregateOutputType = {
    totalCreditsTaken: number | null
  }

  export type StudentSemesterRegistrationMinAggregateOutputType = {
    id: string | null
    isConfirmed: boolean | null
    totalCreditsTaken: number | null
    paymentRecipt: string | null
    createdAt: Date | null
    updatedAt: Date | null
    studentId: string | null
    semesterRegistrationId: string | null
  }

  export type StudentSemesterRegistrationMaxAggregateOutputType = {
    id: string | null
    isConfirmed: boolean | null
    totalCreditsTaken: number | null
    paymentRecipt: string | null
    createdAt: Date | null
    updatedAt: Date | null
    studentId: string | null
    semesterRegistrationId: string | null
  }

  export type StudentSemesterRegistrationCountAggregateOutputType = {
    id: number
    isConfirmed: number
    totalCreditsTaken: number
    paymentRecipt: number
    createdAt: number
    updatedAt: number
    studentId: number
    semesterRegistrationId: number
    _all: number
  }


  export type StudentSemesterRegistrationAvgAggregateInputType = {
    totalCreditsTaken?: true
  }

  export type StudentSemesterRegistrationSumAggregateInputType = {
    totalCreditsTaken?: true
  }

  export type StudentSemesterRegistrationMinAggregateInputType = {
    id?: true
    isConfirmed?: true
    totalCreditsTaken?: true
    paymentRecipt?: true
    createdAt?: true
    updatedAt?: true
    studentId?: true
    semesterRegistrationId?: true
  }

  export type StudentSemesterRegistrationMaxAggregateInputType = {
    id?: true
    isConfirmed?: true
    totalCreditsTaken?: true
    paymentRecipt?: true
    createdAt?: true
    updatedAt?: true
    studentId?: true
    semesterRegistrationId?: true
  }

  export type StudentSemesterRegistrationCountAggregateInputType = {
    id?: true
    isConfirmed?: true
    totalCreditsTaken?: true
    paymentRecipt?: true
    createdAt?: true
    updatedAt?: true
    studentId?: true
    semesterRegistrationId?: true
    _all?: true
  }

  export type StudentSemesterRegistrationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StudentSemesterRegistration to aggregate.
     */
    where?: StudentSemesterRegistrationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentSemesterRegistrations to fetch.
     */
    orderBy?: StudentSemesterRegistrationOrderByWithRelationInput | StudentSemesterRegistrationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StudentSemesterRegistrationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentSemesterRegistrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentSemesterRegistrations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StudentSemesterRegistrations
    **/
    _count?: true | StudentSemesterRegistrationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StudentSemesterRegistrationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StudentSemesterRegistrationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StudentSemesterRegistrationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StudentSemesterRegistrationMaxAggregateInputType
  }

  export type GetStudentSemesterRegistrationAggregateType<T extends StudentSemesterRegistrationAggregateArgs> = {
        [P in keyof T & keyof AggregateStudentSemesterRegistration]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStudentSemesterRegistration[P]>
      : GetScalarType<T[P], AggregateStudentSemesterRegistration[P]>
  }




  export type StudentSemesterRegistrationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentSemesterRegistrationWhereInput
    orderBy?: StudentSemesterRegistrationOrderByWithAggregationInput | StudentSemesterRegistrationOrderByWithAggregationInput[]
    by: StudentSemesterRegistrationScalarFieldEnum[] | StudentSemesterRegistrationScalarFieldEnum
    having?: StudentSemesterRegistrationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StudentSemesterRegistrationCountAggregateInputType | true
    _avg?: StudentSemesterRegistrationAvgAggregateInputType
    _sum?: StudentSemesterRegistrationSumAggregateInputType
    _min?: StudentSemesterRegistrationMinAggregateInputType
    _max?: StudentSemesterRegistrationMaxAggregateInputType
  }

  export type StudentSemesterRegistrationGroupByOutputType = {
    id: string
    isConfirmed: boolean | null
    totalCreditsTaken: number | null
    paymentRecipt: string | null
    createdAt: Date
    updatedAt: Date
    studentId: string
    semesterRegistrationId: string
    _count: StudentSemesterRegistrationCountAggregateOutputType | null
    _avg: StudentSemesterRegistrationAvgAggregateOutputType | null
    _sum: StudentSemesterRegistrationSumAggregateOutputType | null
    _min: StudentSemesterRegistrationMinAggregateOutputType | null
    _max: StudentSemesterRegistrationMaxAggregateOutputType | null
  }

  type GetStudentSemesterRegistrationGroupByPayload<T extends StudentSemesterRegistrationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StudentSemesterRegistrationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StudentSemesterRegistrationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StudentSemesterRegistrationGroupByOutputType[P]>
            : GetScalarType<T[P], StudentSemesterRegistrationGroupByOutputType[P]>
        }
      >
    >


  export type StudentSemesterRegistrationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    isConfirmed?: boolean
    totalCreditsTaken?: boolean
    paymentRecipt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    studentId?: boolean
    semesterRegistrationId?: boolean
    student?: boolean | StudentDefaultArgs<ExtArgs>
    semesterRegistration?: boolean | SemesterRegistrationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["studentSemesterRegistration"]>



  export type StudentSemesterRegistrationSelectScalar = {
    id?: boolean
    isConfirmed?: boolean
    totalCreditsTaken?: boolean
    paymentRecipt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    studentId?: boolean
    semesterRegistrationId?: boolean
  }

  export type StudentSemesterRegistrationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "isConfirmed" | "totalCreditsTaken" | "paymentRecipt" | "createdAt" | "updatedAt" | "studentId" | "semesterRegistrationId", ExtArgs["result"]["studentSemesterRegistration"]>
  export type StudentSemesterRegistrationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentDefaultArgs<ExtArgs>
    semesterRegistration?: boolean | SemesterRegistrationDefaultArgs<ExtArgs>
  }

  export type $StudentSemesterRegistrationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "StudentSemesterRegistration"
    objects: {
      student: Prisma.$StudentPayload<ExtArgs>
      semesterRegistration: Prisma.$SemesterRegistrationPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      isConfirmed: boolean | null
      totalCreditsTaken: number | null
      paymentRecipt: string | null
      createdAt: Date
      updatedAt: Date
      studentId: string
      semesterRegistrationId: string
    }, ExtArgs["result"]["studentSemesterRegistration"]>
    composites: {}
  }

  type StudentSemesterRegistrationGetPayload<S extends boolean | null | undefined | StudentSemesterRegistrationDefaultArgs> = $Result.GetResult<Prisma.$StudentSemesterRegistrationPayload, S>

  type StudentSemesterRegistrationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<StudentSemesterRegistrationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: StudentSemesterRegistrationCountAggregateInputType | true
    }

  export interface StudentSemesterRegistrationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['StudentSemesterRegistration'], meta: { name: 'StudentSemesterRegistration' } }
    /**
     * Find zero or one StudentSemesterRegistration that matches the filter.
     * @param {StudentSemesterRegistrationFindUniqueArgs} args - Arguments to find a StudentSemesterRegistration
     * @example
     * // Get one StudentSemesterRegistration
     * const studentSemesterRegistration = await prisma.studentSemesterRegistration.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StudentSemesterRegistrationFindUniqueArgs>(args: SelectSubset<T, StudentSemesterRegistrationFindUniqueArgs<ExtArgs>>): Prisma__StudentSemesterRegistrationClient<$Result.GetResult<Prisma.$StudentSemesterRegistrationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one StudentSemesterRegistration that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {StudentSemesterRegistrationFindUniqueOrThrowArgs} args - Arguments to find a StudentSemesterRegistration
     * @example
     * // Get one StudentSemesterRegistration
     * const studentSemesterRegistration = await prisma.studentSemesterRegistration.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StudentSemesterRegistrationFindUniqueOrThrowArgs>(args: SelectSubset<T, StudentSemesterRegistrationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StudentSemesterRegistrationClient<$Result.GetResult<Prisma.$StudentSemesterRegistrationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StudentSemesterRegistration that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentSemesterRegistrationFindFirstArgs} args - Arguments to find a StudentSemesterRegistration
     * @example
     * // Get one StudentSemesterRegistration
     * const studentSemesterRegistration = await prisma.studentSemesterRegistration.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StudentSemesterRegistrationFindFirstArgs>(args?: SelectSubset<T, StudentSemesterRegistrationFindFirstArgs<ExtArgs>>): Prisma__StudentSemesterRegistrationClient<$Result.GetResult<Prisma.$StudentSemesterRegistrationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StudentSemesterRegistration that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentSemesterRegistrationFindFirstOrThrowArgs} args - Arguments to find a StudentSemesterRegistration
     * @example
     * // Get one StudentSemesterRegistration
     * const studentSemesterRegistration = await prisma.studentSemesterRegistration.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StudentSemesterRegistrationFindFirstOrThrowArgs>(args?: SelectSubset<T, StudentSemesterRegistrationFindFirstOrThrowArgs<ExtArgs>>): Prisma__StudentSemesterRegistrationClient<$Result.GetResult<Prisma.$StudentSemesterRegistrationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more StudentSemesterRegistrations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentSemesterRegistrationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StudentSemesterRegistrations
     * const studentSemesterRegistrations = await prisma.studentSemesterRegistration.findMany()
     * 
     * // Get first 10 StudentSemesterRegistrations
     * const studentSemesterRegistrations = await prisma.studentSemesterRegistration.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const studentSemesterRegistrationWithIdOnly = await prisma.studentSemesterRegistration.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StudentSemesterRegistrationFindManyArgs>(args?: SelectSubset<T, StudentSemesterRegistrationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentSemesterRegistrationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a StudentSemesterRegistration.
     * @param {StudentSemesterRegistrationCreateArgs} args - Arguments to create a StudentSemesterRegistration.
     * @example
     * // Create one StudentSemesterRegistration
     * const StudentSemesterRegistration = await prisma.studentSemesterRegistration.create({
     *   data: {
     *     // ... data to create a StudentSemesterRegistration
     *   }
     * })
     * 
     */
    create<T extends StudentSemesterRegistrationCreateArgs>(args: SelectSubset<T, StudentSemesterRegistrationCreateArgs<ExtArgs>>): Prisma__StudentSemesterRegistrationClient<$Result.GetResult<Prisma.$StudentSemesterRegistrationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many StudentSemesterRegistrations.
     * @param {StudentSemesterRegistrationCreateManyArgs} args - Arguments to create many StudentSemesterRegistrations.
     * @example
     * // Create many StudentSemesterRegistrations
     * const studentSemesterRegistration = await prisma.studentSemesterRegistration.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StudentSemesterRegistrationCreateManyArgs>(args?: SelectSubset<T, StudentSemesterRegistrationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a StudentSemesterRegistration.
     * @param {StudentSemesterRegistrationDeleteArgs} args - Arguments to delete one StudentSemesterRegistration.
     * @example
     * // Delete one StudentSemesterRegistration
     * const StudentSemesterRegistration = await prisma.studentSemesterRegistration.delete({
     *   where: {
     *     // ... filter to delete one StudentSemesterRegistration
     *   }
     * })
     * 
     */
    delete<T extends StudentSemesterRegistrationDeleteArgs>(args: SelectSubset<T, StudentSemesterRegistrationDeleteArgs<ExtArgs>>): Prisma__StudentSemesterRegistrationClient<$Result.GetResult<Prisma.$StudentSemesterRegistrationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one StudentSemesterRegistration.
     * @param {StudentSemesterRegistrationUpdateArgs} args - Arguments to update one StudentSemesterRegistration.
     * @example
     * // Update one StudentSemesterRegistration
     * const studentSemesterRegistration = await prisma.studentSemesterRegistration.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StudentSemesterRegistrationUpdateArgs>(args: SelectSubset<T, StudentSemesterRegistrationUpdateArgs<ExtArgs>>): Prisma__StudentSemesterRegistrationClient<$Result.GetResult<Prisma.$StudentSemesterRegistrationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more StudentSemesterRegistrations.
     * @param {StudentSemesterRegistrationDeleteManyArgs} args - Arguments to filter StudentSemesterRegistrations to delete.
     * @example
     * // Delete a few StudentSemesterRegistrations
     * const { count } = await prisma.studentSemesterRegistration.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StudentSemesterRegistrationDeleteManyArgs>(args?: SelectSubset<T, StudentSemesterRegistrationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StudentSemesterRegistrations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentSemesterRegistrationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StudentSemesterRegistrations
     * const studentSemesterRegistration = await prisma.studentSemesterRegistration.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StudentSemesterRegistrationUpdateManyArgs>(args: SelectSubset<T, StudentSemesterRegistrationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one StudentSemesterRegistration.
     * @param {StudentSemesterRegistrationUpsertArgs} args - Arguments to update or create a StudentSemesterRegistration.
     * @example
     * // Update or create a StudentSemesterRegistration
     * const studentSemesterRegistration = await prisma.studentSemesterRegistration.upsert({
     *   create: {
     *     // ... data to create a StudentSemesterRegistration
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StudentSemesterRegistration we want to update
     *   }
     * })
     */
    upsert<T extends StudentSemesterRegistrationUpsertArgs>(args: SelectSubset<T, StudentSemesterRegistrationUpsertArgs<ExtArgs>>): Prisma__StudentSemesterRegistrationClient<$Result.GetResult<Prisma.$StudentSemesterRegistrationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of StudentSemesterRegistrations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentSemesterRegistrationCountArgs} args - Arguments to filter StudentSemesterRegistrations to count.
     * @example
     * // Count the number of StudentSemesterRegistrations
     * const count = await prisma.studentSemesterRegistration.count({
     *   where: {
     *     // ... the filter for the StudentSemesterRegistrations we want to count
     *   }
     * })
    **/
    count<T extends StudentSemesterRegistrationCountArgs>(
      args?: Subset<T, StudentSemesterRegistrationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StudentSemesterRegistrationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StudentSemesterRegistration.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentSemesterRegistrationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StudentSemesterRegistrationAggregateArgs>(args: Subset<T, StudentSemesterRegistrationAggregateArgs>): Prisma.PrismaPromise<GetStudentSemesterRegistrationAggregateType<T>>

    /**
     * Group by StudentSemesterRegistration.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentSemesterRegistrationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StudentSemesterRegistrationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StudentSemesterRegistrationGroupByArgs['orderBy'] }
        : { orderBy?: StudentSemesterRegistrationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StudentSemesterRegistrationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStudentSemesterRegistrationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the StudentSemesterRegistration model
   */
  readonly fields: StudentSemesterRegistrationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for StudentSemesterRegistration.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StudentSemesterRegistrationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    student<T extends StudentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StudentDefaultArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    semesterRegistration<T extends SemesterRegistrationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SemesterRegistrationDefaultArgs<ExtArgs>>): Prisma__SemesterRegistrationClient<$Result.GetResult<Prisma.$SemesterRegistrationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the StudentSemesterRegistration model
   */
  interface StudentSemesterRegistrationFieldRefs {
    readonly id: FieldRef<"StudentSemesterRegistration", 'String'>
    readonly isConfirmed: FieldRef<"StudentSemesterRegistration", 'Boolean'>
    readonly totalCreditsTaken: FieldRef<"StudentSemesterRegistration", 'Int'>
    readonly paymentRecipt: FieldRef<"StudentSemesterRegistration", 'String'>
    readonly createdAt: FieldRef<"StudentSemesterRegistration", 'DateTime'>
    readonly updatedAt: FieldRef<"StudentSemesterRegistration", 'DateTime'>
    readonly studentId: FieldRef<"StudentSemesterRegistration", 'String'>
    readonly semesterRegistrationId: FieldRef<"StudentSemesterRegistration", 'String'>
  }
    

  // Custom InputTypes
  /**
   * StudentSemesterRegistration findUnique
   */
  export type StudentSemesterRegistrationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentSemesterRegistration
     */
    select?: StudentSemesterRegistrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentSemesterRegistration
     */
    omit?: StudentSemesterRegistrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentSemesterRegistrationInclude<ExtArgs> | null
    /**
     * Filter, which StudentSemesterRegistration to fetch.
     */
    where: StudentSemesterRegistrationWhereUniqueInput
  }

  /**
   * StudentSemesterRegistration findUniqueOrThrow
   */
  export type StudentSemesterRegistrationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentSemesterRegistration
     */
    select?: StudentSemesterRegistrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentSemesterRegistration
     */
    omit?: StudentSemesterRegistrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentSemesterRegistrationInclude<ExtArgs> | null
    /**
     * Filter, which StudentSemesterRegistration to fetch.
     */
    where: StudentSemesterRegistrationWhereUniqueInput
  }

  /**
   * StudentSemesterRegistration findFirst
   */
  export type StudentSemesterRegistrationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentSemesterRegistration
     */
    select?: StudentSemesterRegistrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentSemesterRegistration
     */
    omit?: StudentSemesterRegistrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentSemesterRegistrationInclude<ExtArgs> | null
    /**
     * Filter, which StudentSemesterRegistration to fetch.
     */
    where?: StudentSemesterRegistrationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentSemesterRegistrations to fetch.
     */
    orderBy?: StudentSemesterRegistrationOrderByWithRelationInput | StudentSemesterRegistrationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StudentSemesterRegistrations.
     */
    cursor?: StudentSemesterRegistrationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentSemesterRegistrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentSemesterRegistrations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StudentSemesterRegistrations.
     */
    distinct?: StudentSemesterRegistrationScalarFieldEnum | StudentSemesterRegistrationScalarFieldEnum[]
  }

  /**
   * StudentSemesterRegistration findFirstOrThrow
   */
  export type StudentSemesterRegistrationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentSemesterRegistration
     */
    select?: StudentSemesterRegistrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentSemesterRegistration
     */
    omit?: StudentSemesterRegistrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentSemesterRegistrationInclude<ExtArgs> | null
    /**
     * Filter, which StudentSemesterRegistration to fetch.
     */
    where?: StudentSemesterRegistrationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentSemesterRegistrations to fetch.
     */
    orderBy?: StudentSemesterRegistrationOrderByWithRelationInput | StudentSemesterRegistrationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StudentSemesterRegistrations.
     */
    cursor?: StudentSemesterRegistrationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentSemesterRegistrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentSemesterRegistrations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StudentSemesterRegistrations.
     */
    distinct?: StudentSemesterRegistrationScalarFieldEnum | StudentSemesterRegistrationScalarFieldEnum[]
  }

  /**
   * StudentSemesterRegistration findMany
   */
  export type StudentSemesterRegistrationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentSemesterRegistration
     */
    select?: StudentSemesterRegistrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentSemesterRegistration
     */
    omit?: StudentSemesterRegistrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentSemesterRegistrationInclude<ExtArgs> | null
    /**
     * Filter, which StudentSemesterRegistrations to fetch.
     */
    where?: StudentSemesterRegistrationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentSemesterRegistrations to fetch.
     */
    orderBy?: StudentSemesterRegistrationOrderByWithRelationInput | StudentSemesterRegistrationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StudentSemesterRegistrations.
     */
    cursor?: StudentSemesterRegistrationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentSemesterRegistrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentSemesterRegistrations.
     */
    skip?: number
    distinct?: StudentSemesterRegistrationScalarFieldEnum | StudentSemesterRegistrationScalarFieldEnum[]
  }

  /**
   * StudentSemesterRegistration create
   */
  export type StudentSemesterRegistrationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentSemesterRegistration
     */
    select?: StudentSemesterRegistrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentSemesterRegistration
     */
    omit?: StudentSemesterRegistrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentSemesterRegistrationInclude<ExtArgs> | null
    /**
     * The data needed to create a StudentSemesterRegistration.
     */
    data: XOR<StudentSemesterRegistrationCreateInput, StudentSemesterRegistrationUncheckedCreateInput>
  }

  /**
   * StudentSemesterRegistration createMany
   */
  export type StudentSemesterRegistrationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many StudentSemesterRegistrations.
     */
    data: StudentSemesterRegistrationCreateManyInput | StudentSemesterRegistrationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * StudentSemesterRegistration update
   */
  export type StudentSemesterRegistrationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentSemesterRegistration
     */
    select?: StudentSemesterRegistrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentSemesterRegistration
     */
    omit?: StudentSemesterRegistrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentSemesterRegistrationInclude<ExtArgs> | null
    /**
     * The data needed to update a StudentSemesterRegistration.
     */
    data: XOR<StudentSemesterRegistrationUpdateInput, StudentSemesterRegistrationUncheckedUpdateInput>
    /**
     * Choose, which StudentSemesterRegistration to update.
     */
    where: StudentSemesterRegistrationWhereUniqueInput
  }

  /**
   * StudentSemesterRegistration updateMany
   */
  export type StudentSemesterRegistrationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update StudentSemesterRegistrations.
     */
    data: XOR<StudentSemesterRegistrationUpdateManyMutationInput, StudentSemesterRegistrationUncheckedUpdateManyInput>
    /**
     * Filter which StudentSemesterRegistrations to update
     */
    where?: StudentSemesterRegistrationWhereInput
    /**
     * Limit how many StudentSemesterRegistrations to update.
     */
    limit?: number
  }

  /**
   * StudentSemesterRegistration upsert
   */
  export type StudentSemesterRegistrationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentSemesterRegistration
     */
    select?: StudentSemesterRegistrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentSemesterRegistration
     */
    omit?: StudentSemesterRegistrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentSemesterRegistrationInclude<ExtArgs> | null
    /**
     * The filter to search for the StudentSemesterRegistration to update in case it exists.
     */
    where: StudentSemesterRegistrationWhereUniqueInput
    /**
     * In case the StudentSemesterRegistration found by the `where` argument doesn't exist, create a new StudentSemesterRegistration with this data.
     */
    create: XOR<StudentSemesterRegistrationCreateInput, StudentSemesterRegistrationUncheckedCreateInput>
    /**
     * In case the StudentSemesterRegistration was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StudentSemesterRegistrationUpdateInput, StudentSemesterRegistrationUncheckedUpdateInput>
  }

  /**
   * StudentSemesterRegistration delete
   */
  export type StudentSemesterRegistrationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentSemesterRegistration
     */
    select?: StudentSemesterRegistrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentSemesterRegistration
     */
    omit?: StudentSemesterRegistrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentSemesterRegistrationInclude<ExtArgs> | null
    /**
     * Filter which StudentSemesterRegistration to delete.
     */
    where: StudentSemesterRegistrationWhereUniqueInput
  }

  /**
   * StudentSemesterRegistration deleteMany
   */
  export type StudentSemesterRegistrationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StudentSemesterRegistrations to delete
     */
    where?: StudentSemesterRegistrationWhereInput
    /**
     * Limit how many StudentSemesterRegistrations to delete.
     */
    limit?: number
  }

  /**
   * StudentSemesterRegistration without action
   */
  export type StudentSemesterRegistrationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentSemesterRegistration
     */
    select?: StudentSemesterRegistrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentSemesterRegistration
     */
    omit?: StudentSemesterRegistrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentSemesterRegistrationInclude<ExtArgs> | null
  }


  /**
   * Model StudentSemesterRegistrationCourse
   */

  export type AggregateStudentSemesterRegistrationCourse = {
    _count: StudentSemesterRegistrationCourseCountAggregateOutputType | null
    _min: StudentSemesterRegistrationCourseMinAggregateOutputType | null
    _max: StudentSemesterRegistrationCourseMaxAggregateOutputType | null
  }

  export type StudentSemesterRegistrationCourseMinAggregateOutputType = {
    semesterRegistrationId: string | null
    studentId: string | null
    offeredCourseId: string | null
    offeredCourseSectionId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StudentSemesterRegistrationCourseMaxAggregateOutputType = {
    semesterRegistrationId: string | null
    studentId: string | null
    offeredCourseId: string | null
    offeredCourseSectionId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StudentSemesterRegistrationCourseCountAggregateOutputType = {
    semesterRegistrationId: number
    studentId: number
    offeredCourseId: number
    offeredCourseSectionId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type StudentSemesterRegistrationCourseMinAggregateInputType = {
    semesterRegistrationId?: true
    studentId?: true
    offeredCourseId?: true
    offeredCourseSectionId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StudentSemesterRegistrationCourseMaxAggregateInputType = {
    semesterRegistrationId?: true
    studentId?: true
    offeredCourseId?: true
    offeredCourseSectionId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StudentSemesterRegistrationCourseCountAggregateInputType = {
    semesterRegistrationId?: true
    studentId?: true
    offeredCourseId?: true
    offeredCourseSectionId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type StudentSemesterRegistrationCourseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StudentSemesterRegistrationCourse to aggregate.
     */
    where?: StudentSemesterRegistrationCourseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentSemesterRegistrationCourses to fetch.
     */
    orderBy?: StudentSemesterRegistrationCourseOrderByWithRelationInput | StudentSemesterRegistrationCourseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StudentSemesterRegistrationCourseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentSemesterRegistrationCourses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentSemesterRegistrationCourses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StudentSemesterRegistrationCourses
    **/
    _count?: true | StudentSemesterRegistrationCourseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StudentSemesterRegistrationCourseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StudentSemesterRegistrationCourseMaxAggregateInputType
  }

  export type GetStudentSemesterRegistrationCourseAggregateType<T extends StudentSemesterRegistrationCourseAggregateArgs> = {
        [P in keyof T & keyof AggregateStudentSemesterRegistrationCourse]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStudentSemesterRegistrationCourse[P]>
      : GetScalarType<T[P], AggregateStudentSemesterRegistrationCourse[P]>
  }




  export type StudentSemesterRegistrationCourseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentSemesterRegistrationCourseWhereInput
    orderBy?: StudentSemesterRegistrationCourseOrderByWithAggregationInput | StudentSemesterRegistrationCourseOrderByWithAggregationInput[]
    by: StudentSemesterRegistrationCourseScalarFieldEnum[] | StudentSemesterRegistrationCourseScalarFieldEnum
    having?: StudentSemesterRegistrationCourseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StudentSemesterRegistrationCourseCountAggregateInputType | true
    _min?: StudentSemesterRegistrationCourseMinAggregateInputType
    _max?: StudentSemesterRegistrationCourseMaxAggregateInputType
  }

  export type StudentSemesterRegistrationCourseGroupByOutputType = {
    semesterRegistrationId: string
    studentId: string
    offeredCourseId: string
    offeredCourseSectionId: string
    createdAt: Date
    updatedAt: Date
    _count: StudentSemesterRegistrationCourseCountAggregateOutputType | null
    _min: StudentSemesterRegistrationCourseMinAggregateOutputType | null
    _max: StudentSemesterRegistrationCourseMaxAggregateOutputType | null
  }

  type GetStudentSemesterRegistrationCourseGroupByPayload<T extends StudentSemesterRegistrationCourseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StudentSemesterRegistrationCourseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StudentSemesterRegistrationCourseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StudentSemesterRegistrationCourseGroupByOutputType[P]>
            : GetScalarType<T[P], StudentSemesterRegistrationCourseGroupByOutputType[P]>
        }
      >
    >


  export type StudentSemesterRegistrationCourseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    semesterRegistrationId?: boolean
    studentId?: boolean
    offeredCourseId?: boolean
    offeredCourseSectionId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    semesterRegistration?: boolean | SemesterRegistrationDefaultArgs<ExtArgs>
    student?: boolean | StudentDefaultArgs<ExtArgs>
    offeredCourse?: boolean | OfferedCourseDefaultArgs<ExtArgs>
    offeredCourseSection?: boolean | OfferedCourseSectionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["studentSemesterRegistrationCourse"]>



  export type StudentSemesterRegistrationCourseSelectScalar = {
    semesterRegistrationId?: boolean
    studentId?: boolean
    offeredCourseId?: boolean
    offeredCourseSectionId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type StudentSemesterRegistrationCourseOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"semesterRegistrationId" | "studentId" | "offeredCourseId" | "offeredCourseSectionId" | "createdAt" | "updatedAt", ExtArgs["result"]["studentSemesterRegistrationCourse"]>
  export type StudentSemesterRegistrationCourseInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    semesterRegistration?: boolean | SemesterRegistrationDefaultArgs<ExtArgs>
    student?: boolean | StudentDefaultArgs<ExtArgs>
    offeredCourse?: boolean | OfferedCourseDefaultArgs<ExtArgs>
    offeredCourseSection?: boolean | OfferedCourseSectionDefaultArgs<ExtArgs>
  }

  export type $StudentSemesterRegistrationCoursePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "StudentSemesterRegistrationCourse"
    objects: {
      semesterRegistration: Prisma.$SemesterRegistrationPayload<ExtArgs>
      student: Prisma.$StudentPayload<ExtArgs>
      offeredCourse: Prisma.$OfferedCoursePayload<ExtArgs>
      offeredCourseSection: Prisma.$OfferedCourseSectionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      semesterRegistrationId: string
      studentId: string
      offeredCourseId: string
      offeredCourseSectionId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["studentSemesterRegistrationCourse"]>
    composites: {}
  }

  type StudentSemesterRegistrationCourseGetPayload<S extends boolean | null | undefined | StudentSemesterRegistrationCourseDefaultArgs> = $Result.GetResult<Prisma.$StudentSemesterRegistrationCoursePayload, S>

  type StudentSemesterRegistrationCourseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<StudentSemesterRegistrationCourseFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: StudentSemesterRegistrationCourseCountAggregateInputType | true
    }

  export interface StudentSemesterRegistrationCourseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['StudentSemesterRegistrationCourse'], meta: { name: 'StudentSemesterRegistrationCourse' } }
    /**
     * Find zero or one StudentSemesterRegistrationCourse that matches the filter.
     * @param {StudentSemesterRegistrationCourseFindUniqueArgs} args - Arguments to find a StudentSemesterRegistrationCourse
     * @example
     * // Get one StudentSemesterRegistrationCourse
     * const studentSemesterRegistrationCourse = await prisma.studentSemesterRegistrationCourse.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StudentSemesterRegistrationCourseFindUniqueArgs>(args: SelectSubset<T, StudentSemesterRegistrationCourseFindUniqueArgs<ExtArgs>>): Prisma__StudentSemesterRegistrationCourseClient<$Result.GetResult<Prisma.$StudentSemesterRegistrationCoursePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one StudentSemesterRegistrationCourse that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {StudentSemesterRegistrationCourseFindUniqueOrThrowArgs} args - Arguments to find a StudentSemesterRegistrationCourse
     * @example
     * // Get one StudentSemesterRegistrationCourse
     * const studentSemesterRegistrationCourse = await prisma.studentSemesterRegistrationCourse.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StudentSemesterRegistrationCourseFindUniqueOrThrowArgs>(args: SelectSubset<T, StudentSemesterRegistrationCourseFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StudentSemesterRegistrationCourseClient<$Result.GetResult<Prisma.$StudentSemesterRegistrationCoursePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StudentSemesterRegistrationCourse that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentSemesterRegistrationCourseFindFirstArgs} args - Arguments to find a StudentSemesterRegistrationCourse
     * @example
     * // Get one StudentSemesterRegistrationCourse
     * const studentSemesterRegistrationCourse = await prisma.studentSemesterRegistrationCourse.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StudentSemesterRegistrationCourseFindFirstArgs>(args?: SelectSubset<T, StudentSemesterRegistrationCourseFindFirstArgs<ExtArgs>>): Prisma__StudentSemesterRegistrationCourseClient<$Result.GetResult<Prisma.$StudentSemesterRegistrationCoursePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StudentSemesterRegistrationCourse that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentSemesterRegistrationCourseFindFirstOrThrowArgs} args - Arguments to find a StudentSemesterRegistrationCourse
     * @example
     * // Get one StudentSemesterRegistrationCourse
     * const studentSemesterRegistrationCourse = await prisma.studentSemesterRegistrationCourse.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StudentSemesterRegistrationCourseFindFirstOrThrowArgs>(args?: SelectSubset<T, StudentSemesterRegistrationCourseFindFirstOrThrowArgs<ExtArgs>>): Prisma__StudentSemesterRegistrationCourseClient<$Result.GetResult<Prisma.$StudentSemesterRegistrationCoursePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more StudentSemesterRegistrationCourses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentSemesterRegistrationCourseFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StudentSemesterRegistrationCourses
     * const studentSemesterRegistrationCourses = await prisma.studentSemesterRegistrationCourse.findMany()
     * 
     * // Get first 10 StudentSemesterRegistrationCourses
     * const studentSemesterRegistrationCourses = await prisma.studentSemesterRegistrationCourse.findMany({ take: 10 })
     * 
     * // Only select the `semesterRegistrationId`
     * const studentSemesterRegistrationCourseWithSemesterRegistrationIdOnly = await prisma.studentSemesterRegistrationCourse.findMany({ select: { semesterRegistrationId: true } })
     * 
     */
    findMany<T extends StudentSemesterRegistrationCourseFindManyArgs>(args?: SelectSubset<T, StudentSemesterRegistrationCourseFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentSemesterRegistrationCoursePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a StudentSemesterRegistrationCourse.
     * @param {StudentSemesterRegistrationCourseCreateArgs} args - Arguments to create a StudentSemesterRegistrationCourse.
     * @example
     * // Create one StudentSemesterRegistrationCourse
     * const StudentSemesterRegistrationCourse = await prisma.studentSemesterRegistrationCourse.create({
     *   data: {
     *     // ... data to create a StudentSemesterRegistrationCourse
     *   }
     * })
     * 
     */
    create<T extends StudentSemesterRegistrationCourseCreateArgs>(args: SelectSubset<T, StudentSemesterRegistrationCourseCreateArgs<ExtArgs>>): Prisma__StudentSemesterRegistrationCourseClient<$Result.GetResult<Prisma.$StudentSemesterRegistrationCoursePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many StudentSemesterRegistrationCourses.
     * @param {StudentSemesterRegistrationCourseCreateManyArgs} args - Arguments to create many StudentSemesterRegistrationCourses.
     * @example
     * // Create many StudentSemesterRegistrationCourses
     * const studentSemesterRegistrationCourse = await prisma.studentSemesterRegistrationCourse.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StudentSemesterRegistrationCourseCreateManyArgs>(args?: SelectSubset<T, StudentSemesterRegistrationCourseCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a StudentSemesterRegistrationCourse.
     * @param {StudentSemesterRegistrationCourseDeleteArgs} args - Arguments to delete one StudentSemesterRegistrationCourse.
     * @example
     * // Delete one StudentSemesterRegistrationCourse
     * const StudentSemesterRegistrationCourse = await prisma.studentSemesterRegistrationCourse.delete({
     *   where: {
     *     // ... filter to delete one StudentSemesterRegistrationCourse
     *   }
     * })
     * 
     */
    delete<T extends StudentSemesterRegistrationCourseDeleteArgs>(args: SelectSubset<T, StudentSemesterRegistrationCourseDeleteArgs<ExtArgs>>): Prisma__StudentSemesterRegistrationCourseClient<$Result.GetResult<Prisma.$StudentSemesterRegistrationCoursePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one StudentSemesterRegistrationCourse.
     * @param {StudentSemesterRegistrationCourseUpdateArgs} args - Arguments to update one StudentSemesterRegistrationCourse.
     * @example
     * // Update one StudentSemesterRegistrationCourse
     * const studentSemesterRegistrationCourse = await prisma.studentSemesterRegistrationCourse.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StudentSemesterRegistrationCourseUpdateArgs>(args: SelectSubset<T, StudentSemesterRegistrationCourseUpdateArgs<ExtArgs>>): Prisma__StudentSemesterRegistrationCourseClient<$Result.GetResult<Prisma.$StudentSemesterRegistrationCoursePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more StudentSemesterRegistrationCourses.
     * @param {StudentSemesterRegistrationCourseDeleteManyArgs} args - Arguments to filter StudentSemesterRegistrationCourses to delete.
     * @example
     * // Delete a few StudentSemesterRegistrationCourses
     * const { count } = await prisma.studentSemesterRegistrationCourse.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StudentSemesterRegistrationCourseDeleteManyArgs>(args?: SelectSubset<T, StudentSemesterRegistrationCourseDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StudentSemesterRegistrationCourses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentSemesterRegistrationCourseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StudentSemesterRegistrationCourses
     * const studentSemesterRegistrationCourse = await prisma.studentSemesterRegistrationCourse.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StudentSemesterRegistrationCourseUpdateManyArgs>(args: SelectSubset<T, StudentSemesterRegistrationCourseUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one StudentSemesterRegistrationCourse.
     * @param {StudentSemesterRegistrationCourseUpsertArgs} args - Arguments to update or create a StudentSemesterRegistrationCourse.
     * @example
     * // Update or create a StudentSemesterRegistrationCourse
     * const studentSemesterRegistrationCourse = await prisma.studentSemesterRegistrationCourse.upsert({
     *   create: {
     *     // ... data to create a StudentSemesterRegistrationCourse
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StudentSemesterRegistrationCourse we want to update
     *   }
     * })
     */
    upsert<T extends StudentSemesterRegistrationCourseUpsertArgs>(args: SelectSubset<T, StudentSemesterRegistrationCourseUpsertArgs<ExtArgs>>): Prisma__StudentSemesterRegistrationCourseClient<$Result.GetResult<Prisma.$StudentSemesterRegistrationCoursePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of StudentSemesterRegistrationCourses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentSemesterRegistrationCourseCountArgs} args - Arguments to filter StudentSemesterRegistrationCourses to count.
     * @example
     * // Count the number of StudentSemesterRegistrationCourses
     * const count = await prisma.studentSemesterRegistrationCourse.count({
     *   where: {
     *     // ... the filter for the StudentSemesterRegistrationCourses we want to count
     *   }
     * })
    **/
    count<T extends StudentSemesterRegistrationCourseCountArgs>(
      args?: Subset<T, StudentSemesterRegistrationCourseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StudentSemesterRegistrationCourseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StudentSemesterRegistrationCourse.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentSemesterRegistrationCourseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StudentSemesterRegistrationCourseAggregateArgs>(args: Subset<T, StudentSemesterRegistrationCourseAggregateArgs>): Prisma.PrismaPromise<GetStudentSemesterRegistrationCourseAggregateType<T>>

    /**
     * Group by StudentSemesterRegistrationCourse.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentSemesterRegistrationCourseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StudentSemesterRegistrationCourseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StudentSemesterRegistrationCourseGroupByArgs['orderBy'] }
        : { orderBy?: StudentSemesterRegistrationCourseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StudentSemesterRegistrationCourseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStudentSemesterRegistrationCourseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the StudentSemesterRegistrationCourse model
   */
  readonly fields: StudentSemesterRegistrationCourseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for StudentSemesterRegistrationCourse.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StudentSemesterRegistrationCourseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    semesterRegistration<T extends SemesterRegistrationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SemesterRegistrationDefaultArgs<ExtArgs>>): Prisma__SemesterRegistrationClient<$Result.GetResult<Prisma.$SemesterRegistrationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    student<T extends StudentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StudentDefaultArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    offeredCourse<T extends OfferedCourseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OfferedCourseDefaultArgs<ExtArgs>>): Prisma__OfferedCourseClient<$Result.GetResult<Prisma.$OfferedCoursePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    offeredCourseSection<T extends OfferedCourseSectionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OfferedCourseSectionDefaultArgs<ExtArgs>>): Prisma__OfferedCourseSectionClient<$Result.GetResult<Prisma.$OfferedCourseSectionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the StudentSemesterRegistrationCourse model
   */
  interface StudentSemesterRegistrationCourseFieldRefs {
    readonly semesterRegistrationId: FieldRef<"StudentSemesterRegistrationCourse", 'String'>
    readonly studentId: FieldRef<"StudentSemesterRegistrationCourse", 'String'>
    readonly offeredCourseId: FieldRef<"StudentSemesterRegistrationCourse", 'String'>
    readonly offeredCourseSectionId: FieldRef<"StudentSemesterRegistrationCourse", 'String'>
    readonly createdAt: FieldRef<"StudentSemesterRegistrationCourse", 'DateTime'>
    readonly updatedAt: FieldRef<"StudentSemesterRegistrationCourse", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * StudentSemesterRegistrationCourse findUnique
   */
  export type StudentSemesterRegistrationCourseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentSemesterRegistrationCourse
     */
    select?: StudentSemesterRegistrationCourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentSemesterRegistrationCourse
     */
    omit?: StudentSemesterRegistrationCourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentSemesterRegistrationCourseInclude<ExtArgs> | null
    /**
     * Filter, which StudentSemesterRegistrationCourse to fetch.
     */
    where: StudentSemesterRegistrationCourseWhereUniqueInput
  }

  /**
   * StudentSemesterRegistrationCourse findUniqueOrThrow
   */
  export type StudentSemesterRegistrationCourseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentSemesterRegistrationCourse
     */
    select?: StudentSemesterRegistrationCourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentSemesterRegistrationCourse
     */
    omit?: StudentSemesterRegistrationCourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentSemesterRegistrationCourseInclude<ExtArgs> | null
    /**
     * Filter, which StudentSemesterRegistrationCourse to fetch.
     */
    where: StudentSemesterRegistrationCourseWhereUniqueInput
  }

  /**
   * StudentSemesterRegistrationCourse findFirst
   */
  export type StudentSemesterRegistrationCourseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentSemesterRegistrationCourse
     */
    select?: StudentSemesterRegistrationCourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentSemesterRegistrationCourse
     */
    omit?: StudentSemesterRegistrationCourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentSemesterRegistrationCourseInclude<ExtArgs> | null
    /**
     * Filter, which StudentSemesterRegistrationCourse to fetch.
     */
    where?: StudentSemesterRegistrationCourseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentSemesterRegistrationCourses to fetch.
     */
    orderBy?: StudentSemesterRegistrationCourseOrderByWithRelationInput | StudentSemesterRegistrationCourseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StudentSemesterRegistrationCourses.
     */
    cursor?: StudentSemesterRegistrationCourseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentSemesterRegistrationCourses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentSemesterRegistrationCourses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StudentSemesterRegistrationCourses.
     */
    distinct?: StudentSemesterRegistrationCourseScalarFieldEnum | StudentSemesterRegistrationCourseScalarFieldEnum[]
  }

  /**
   * StudentSemesterRegistrationCourse findFirstOrThrow
   */
  export type StudentSemesterRegistrationCourseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentSemesterRegistrationCourse
     */
    select?: StudentSemesterRegistrationCourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentSemesterRegistrationCourse
     */
    omit?: StudentSemesterRegistrationCourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentSemesterRegistrationCourseInclude<ExtArgs> | null
    /**
     * Filter, which StudentSemesterRegistrationCourse to fetch.
     */
    where?: StudentSemesterRegistrationCourseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentSemesterRegistrationCourses to fetch.
     */
    orderBy?: StudentSemesterRegistrationCourseOrderByWithRelationInput | StudentSemesterRegistrationCourseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StudentSemesterRegistrationCourses.
     */
    cursor?: StudentSemesterRegistrationCourseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentSemesterRegistrationCourses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentSemesterRegistrationCourses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StudentSemesterRegistrationCourses.
     */
    distinct?: StudentSemesterRegistrationCourseScalarFieldEnum | StudentSemesterRegistrationCourseScalarFieldEnum[]
  }

  /**
   * StudentSemesterRegistrationCourse findMany
   */
  export type StudentSemesterRegistrationCourseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentSemesterRegistrationCourse
     */
    select?: StudentSemesterRegistrationCourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentSemesterRegistrationCourse
     */
    omit?: StudentSemesterRegistrationCourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentSemesterRegistrationCourseInclude<ExtArgs> | null
    /**
     * Filter, which StudentSemesterRegistrationCourses to fetch.
     */
    where?: StudentSemesterRegistrationCourseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentSemesterRegistrationCourses to fetch.
     */
    orderBy?: StudentSemesterRegistrationCourseOrderByWithRelationInput | StudentSemesterRegistrationCourseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StudentSemesterRegistrationCourses.
     */
    cursor?: StudentSemesterRegistrationCourseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentSemesterRegistrationCourses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentSemesterRegistrationCourses.
     */
    skip?: number
    distinct?: StudentSemesterRegistrationCourseScalarFieldEnum | StudentSemesterRegistrationCourseScalarFieldEnum[]
  }

  /**
   * StudentSemesterRegistrationCourse create
   */
  export type StudentSemesterRegistrationCourseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentSemesterRegistrationCourse
     */
    select?: StudentSemesterRegistrationCourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentSemesterRegistrationCourse
     */
    omit?: StudentSemesterRegistrationCourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentSemesterRegistrationCourseInclude<ExtArgs> | null
    /**
     * The data needed to create a StudentSemesterRegistrationCourse.
     */
    data: XOR<StudentSemesterRegistrationCourseCreateInput, StudentSemesterRegistrationCourseUncheckedCreateInput>
  }

  /**
   * StudentSemesterRegistrationCourse createMany
   */
  export type StudentSemesterRegistrationCourseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many StudentSemesterRegistrationCourses.
     */
    data: StudentSemesterRegistrationCourseCreateManyInput | StudentSemesterRegistrationCourseCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * StudentSemesterRegistrationCourse update
   */
  export type StudentSemesterRegistrationCourseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentSemesterRegistrationCourse
     */
    select?: StudentSemesterRegistrationCourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentSemesterRegistrationCourse
     */
    omit?: StudentSemesterRegistrationCourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentSemesterRegistrationCourseInclude<ExtArgs> | null
    /**
     * The data needed to update a StudentSemesterRegistrationCourse.
     */
    data: XOR<StudentSemesterRegistrationCourseUpdateInput, StudentSemesterRegistrationCourseUncheckedUpdateInput>
    /**
     * Choose, which StudentSemesterRegistrationCourse to update.
     */
    where: StudentSemesterRegistrationCourseWhereUniqueInput
  }

  /**
   * StudentSemesterRegistrationCourse updateMany
   */
  export type StudentSemesterRegistrationCourseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update StudentSemesterRegistrationCourses.
     */
    data: XOR<StudentSemesterRegistrationCourseUpdateManyMutationInput, StudentSemesterRegistrationCourseUncheckedUpdateManyInput>
    /**
     * Filter which StudentSemesterRegistrationCourses to update
     */
    where?: StudentSemesterRegistrationCourseWhereInput
    /**
     * Limit how many StudentSemesterRegistrationCourses to update.
     */
    limit?: number
  }

  /**
   * StudentSemesterRegistrationCourse upsert
   */
  export type StudentSemesterRegistrationCourseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentSemesterRegistrationCourse
     */
    select?: StudentSemesterRegistrationCourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentSemesterRegistrationCourse
     */
    omit?: StudentSemesterRegistrationCourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentSemesterRegistrationCourseInclude<ExtArgs> | null
    /**
     * The filter to search for the StudentSemesterRegistrationCourse to update in case it exists.
     */
    where: StudentSemesterRegistrationCourseWhereUniqueInput
    /**
     * In case the StudentSemesterRegistrationCourse found by the `where` argument doesn't exist, create a new StudentSemesterRegistrationCourse with this data.
     */
    create: XOR<StudentSemesterRegistrationCourseCreateInput, StudentSemesterRegistrationCourseUncheckedCreateInput>
    /**
     * In case the StudentSemesterRegistrationCourse was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StudentSemesterRegistrationCourseUpdateInput, StudentSemesterRegistrationCourseUncheckedUpdateInput>
  }

  /**
   * StudentSemesterRegistrationCourse delete
   */
  export type StudentSemesterRegistrationCourseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentSemesterRegistrationCourse
     */
    select?: StudentSemesterRegistrationCourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentSemesterRegistrationCourse
     */
    omit?: StudentSemesterRegistrationCourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentSemesterRegistrationCourseInclude<ExtArgs> | null
    /**
     * Filter which StudentSemesterRegistrationCourse to delete.
     */
    where: StudentSemesterRegistrationCourseWhereUniqueInput
  }

  /**
   * StudentSemesterRegistrationCourse deleteMany
   */
  export type StudentSemesterRegistrationCourseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StudentSemesterRegistrationCourses to delete
     */
    where?: StudentSemesterRegistrationCourseWhereInput
    /**
     * Limit how many StudentSemesterRegistrationCourses to delete.
     */
    limit?: number
  }

  /**
   * StudentSemesterRegistrationCourse without action
   */
  export type StudentSemesterRegistrationCourseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentSemesterRegistrationCourse
     */
    select?: StudentSemesterRegistrationCourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentSemesterRegistrationCourse
     */
    omit?: StudentSemesterRegistrationCourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentSemesterRegistrationCourseInclude<ExtArgs> | null
  }


  /**
   * Model StudentEnrolledCourse
   */

  export type AggregateStudentEnrolledCourse = {
    _count: StudentEnrolledCourseCountAggregateOutputType | null
    _avg: StudentEnrolledCourseAvgAggregateOutputType | null
    _sum: StudentEnrolledCourseSumAggregateOutputType | null
    _min: StudentEnrolledCourseMinAggregateOutputType | null
    _max: StudentEnrolledCourseMaxAggregateOutputType | null
  }

  export type StudentEnrolledCourseAvgAggregateOutputType = {
    point: number | null
    totalMarks: number | null
  }

  export type StudentEnrolledCourseSumAggregateOutputType = {
    point: number | null
    totalMarks: number | null
  }

  export type StudentEnrolledCourseMinAggregateOutputType = {
    id: string | null
    grade: string | null
    point: number | null
    totalMarks: number | null
    status: $Enums.StudentEnrolledCourseStatus | null
    createdAt: Date | null
    updatedAt: Date | null
    studentId: string | null
    academicSemesterId: string | null
    courseId: string | null
  }

  export type StudentEnrolledCourseMaxAggregateOutputType = {
    id: string | null
    grade: string | null
    point: number | null
    totalMarks: number | null
    status: $Enums.StudentEnrolledCourseStatus | null
    createdAt: Date | null
    updatedAt: Date | null
    studentId: string | null
    academicSemesterId: string | null
    courseId: string | null
  }

  export type StudentEnrolledCourseCountAggregateOutputType = {
    id: number
    grade: number
    point: number
    totalMarks: number
    status: number
    createdAt: number
    updatedAt: number
    studentId: number
    academicSemesterId: number
    courseId: number
    _all: number
  }


  export type StudentEnrolledCourseAvgAggregateInputType = {
    point?: true
    totalMarks?: true
  }

  export type StudentEnrolledCourseSumAggregateInputType = {
    point?: true
    totalMarks?: true
  }

  export type StudentEnrolledCourseMinAggregateInputType = {
    id?: true
    grade?: true
    point?: true
    totalMarks?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    studentId?: true
    academicSemesterId?: true
    courseId?: true
  }

  export type StudentEnrolledCourseMaxAggregateInputType = {
    id?: true
    grade?: true
    point?: true
    totalMarks?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    studentId?: true
    academicSemesterId?: true
    courseId?: true
  }

  export type StudentEnrolledCourseCountAggregateInputType = {
    id?: true
    grade?: true
    point?: true
    totalMarks?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    studentId?: true
    academicSemesterId?: true
    courseId?: true
    _all?: true
  }

  export type StudentEnrolledCourseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StudentEnrolledCourse to aggregate.
     */
    where?: StudentEnrolledCourseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentEnrolledCourses to fetch.
     */
    orderBy?: StudentEnrolledCourseOrderByWithRelationInput | StudentEnrolledCourseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StudentEnrolledCourseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentEnrolledCourses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentEnrolledCourses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StudentEnrolledCourses
    **/
    _count?: true | StudentEnrolledCourseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StudentEnrolledCourseAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StudentEnrolledCourseSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StudentEnrolledCourseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StudentEnrolledCourseMaxAggregateInputType
  }

  export type GetStudentEnrolledCourseAggregateType<T extends StudentEnrolledCourseAggregateArgs> = {
        [P in keyof T & keyof AggregateStudentEnrolledCourse]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStudentEnrolledCourse[P]>
      : GetScalarType<T[P], AggregateStudentEnrolledCourse[P]>
  }




  export type StudentEnrolledCourseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentEnrolledCourseWhereInput
    orderBy?: StudentEnrolledCourseOrderByWithAggregationInput | StudentEnrolledCourseOrderByWithAggregationInput[]
    by: StudentEnrolledCourseScalarFieldEnum[] | StudentEnrolledCourseScalarFieldEnum
    having?: StudentEnrolledCourseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StudentEnrolledCourseCountAggregateInputType | true
    _avg?: StudentEnrolledCourseAvgAggregateInputType
    _sum?: StudentEnrolledCourseSumAggregateInputType
    _min?: StudentEnrolledCourseMinAggregateInputType
    _max?: StudentEnrolledCourseMaxAggregateInputType
  }

  export type StudentEnrolledCourseGroupByOutputType = {
    id: string
    grade: string | null
    point: number | null
    totalMarks: number | null
    status: $Enums.StudentEnrolledCourseStatus | null
    createdAt: Date
    updatedAt: Date
    studentId: string
    academicSemesterId: string
    courseId: string
    _count: StudentEnrolledCourseCountAggregateOutputType | null
    _avg: StudentEnrolledCourseAvgAggregateOutputType | null
    _sum: StudentEnrolledCourseSumAggregateOutputType | null
    _min: StudentEnrolledCourseMinAggregateOutputType | null
    _max: StudentEnrolledCourseMaxAggregateOutputType | null
  }

  type GetStudentEnrolledCourseGroupByPayload<T extends StudentEnrolledCourseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StudentEnrolledCourseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StudentEnrolledCourseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StudentEnrolledCourseGroupByOutputType[P]>
            : GetScalarType<T[P], StudentEnrolledCourseGroupByOutputType[P]>
        }
      >
    >


  export type StudentEnrolledCourseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    grade?: boolean
    point?: boolean
    totalMarks?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    studentId?: boolean
    academicSemesterId?: boolean
    courseId?: boolean
    student?: boolean | StudentDefaultArgs<ExtArgs>
    course?: boolean | CourseDefaultArgs<ExtArgs>
    studentEnrolledCourseMarks?: boolean | StudentEnrolledCourse$studentEnrolledCourseMarksArgs<ExtArgs>
    academicSemester?: boolean | AcademicSemesterDefaultArgs<ExtArgs>
    _count?: boolean | StudentEnrolledCourseCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["studentEnrolledCourse"]>



  export type StudentEnrolledCourseSelectScalar = {
    id?: boolean
    grade?: boolean
    point?: boolean
    totalMarks?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    studentId?: boolean
    academicSemesterId?: boolean
    courseId?: boolean
  }

  export type StudentEnrolledCourseOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "grade" | "point" | "totalMarks" | "status" | "createdAt" | "updatedAt" | "studentId" | "academicSemesterId" | "courseId", ExtArgs["result"]["studentEnrolledCourse"]>
  export type StudentEnrolledCourseInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentDefaultArgs<ExtArgs>
    course?: boolean | CourseDefaultArgs<ExtArgs>
    studentEnrolledCourseMarks?: boolean | StudentEnrolledCourse$studentEnrolledCourseMarksArgs<ExtArgs>
    academicSemester?: boolean | AcademicSemesterDefaultArgs<ExtArgs>
    _count?: boolean | StudentEnrolledCourseCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $StudentEnrolledCoursePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "StudentEnrolledCourse"
    objects: {
      student: Prisma.$StudentPayload<ExtArgs>
      course: Prisma.$CoursePayload<ExtArgs>
      studentEnrolledCourseMarks: Prisma.$StudentEnrolledCourseMarkPayload<ExtArgs>[]
      academicSemester: Prisma.$AcademicSemesterPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      grade: string | null
      point: number | null
      totalMarks: number | null
      status: $Enums.StudentEnrolledCourseStatus | null
      createdAt: Date
      updatedAt: Date
      studentId: string
      academicSemesterId: string
      courseId: string
    }, ExtArgs["result"]["studentEnrolledCourse"]>
    composites: {}
  }

  type StudentEnrolledCourseGetPayload<S extends boolean | null | undefined | StudentEnrolledCourseDefaultArgs> = $Result.GetResult<Prisma.$StudentEnrolledCoursePayload, S>

  type StudentEnrolledCourseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<StudentEnrolledCourseFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: StudentEnrolledCourseCountAggregateInputType | true
    }

  export interface StudentEnrolledCourseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['StudentEnrolledCourse'], meta: { name: 'StudentEnrolledCourse' } }
    /**
     * Find zero or one StudentEnrolledCourse that matches the filter.
     * @param {StudentEnrolledCourseFindUniqueArgs} args - Arguments to find a StudentEnrolledCourse
     * @example
     * // Get one StudentEnrolledCourse
     * const studentEnrolledCourse = await prisma.studentEnrolledCourse.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StudentEnrolledCourseFindUniqueArgs>(args: SelectSubset<T, StudentEnrolledCourseFindUniqueArgs<ExtArgs>>): Prisma__StudentEnrolledCourseClient<$Result.GetResult<Prisma.$StudentEnrolledCoursePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one StudentEnrolledCourse that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {StudentEnrolledCourseFindUniqueOrThrowArgs} args - Arguments to find a StudentEnrolledCourse
     * @example
     * // Get one StudentEnrolledCourse
     * const studentEnrolledCourse = await prisma.studentEnrolledCourse.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StudentEnrolledCourseFindUniqueOrThrowArgs>(args: SelectSubset<T, StudentEnrolledCourseFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StudentEnrolledCourseClient<$Result.GetResult<Prisma.$StudentEnrolledCoursePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StudentEnrolledCourse that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentEnrolledCourseFindFirstArgs} args - Arguments to find a StudentEnrolledCourse
     * @example
     * // Get one StudentEnrolledCourse
     * const studentEnrolledCourse = await prisma.studentEnrolledCourse.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StudentEnrolledCourseFindFirstArgs>(args?: SelectSubset<T, StudentEnrolledCourseFindFirstArgs<ExtArgs>>): Prisma__StudentEnrolledCourseClient<$Result.GetResult<Prisma.$StudentEnrolledCoursePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StudentEnrolledCourse that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentEnrolledCourseFindFirstOrThrowArgs} args - Arguments to find a StudentEnrolledCourse
     * @example
     * // Get one StudentEnrolledCourse
     * const studentEnrolledCourse = await prisma.studentEnrolledCourse.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StudentEnrolledCourseFindFirstOrThrowArgs>(args?: SelectSubset<T, StudentEnrolledCourseFindFirstOrThrowArgs<ExtArgs>>): Prisma__StudentEnrolledCourseClient<$Result.GetResult<Prisma.$StudentEnrolledCoursePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more StudentEnrolledCourses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentEnrolledCourseFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StudentEnrolledCourses
     * const studentEnrolledCourses = await prisma.studentEnrolledCourse.findMany()
     * 
     * // Get first 10 StudentEnrolledCourses
     * const studentEnrolledCourses = await prisma.studentEnrolledCourse.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const studentEnrolledCourseWithIdOnly = await prisma.studentEnrolledCourse.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StudentEnrolledCourseFindManyArgs>(args?: SelectSubset<T, StudentEnrolledCourseFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentEnrolledCoursePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a StudentEnrolledCourse.
     * @param {StudentEnrolledCourseCreateArgs} args - Arguments to create a StudentEnrolledCourse.
     * @example
     * // Create one StudentEnrolledCourse
     * const StudentEnrolledCourse = await prisma.studentEnrolledCourse.create({
     *   data: {
     *     // ... data to create a StudentEnrolledCourse
     *   }
     * })
     * 
     */
    create<T extends StudentEnrolledCourseCreateArgs>(args: SelectSubset<T, StudentEnrolledCourseCreateArgs<ExtArgs>>): Prisma__StudentEnrolledCourseClient<$Result.GetResult<Prisma.$StudentEnrolledCoursePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many StudentEnrolledCourses.
     * @param {StudentEnrolledCourseCreateManyArgs} args - Arguments to create many StudentEnrolledCourses.
     * @example
     * // Create many StudentEnrolledCourses
     * const studentEnrolledCourse = await prisma.studentEnrolledCourse.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StudentEnrolledCourseCreateManyArgs>(args?: SelectSubset<T, StudentEnrolledCourseCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a StudentEnrolledCourse.
     * @param {StudentEnrolledCourseDeleteArgs} args - Arguments to delete one StudentEnrolledCourse.
     * @example
     * // Delete one StudentEnrolledCourse
     * const StudentEnrolledCourse = await prisma.studentEnrolledCourse.delete({
     *   where: {
     *     // ... filter to delete one StudentEnrolledCourse
     *   }
     * })
     * 
     */
    delete<T extends StudentEnrolledCourseDeleteArgs>(args: SelectSubset<T, StudentEnrolledCourseDeleteArgs<ExtArgs>>): Prisma__StudentEnrolledCourseClient<$Result.GetResult<Prisma.$StudentEnrolledCoursePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one StudentEnrolledCourse.
     * @param {StudentEnrolledCourseUpdateArgs} args - Arguments to update one StudentEnrolledCourse.
     * @example
     * // Update one StudentEnrolledCourse
     * const studentEnrolledCourse = await prisma.studentEnrolledCourse.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StudentEnrolledCourseUpdateArgs>(args: SelectSubset<T, StudentEnrolledCourseUpdateArgs<ExtArgs>>): Prisma__StudentEnrolledCourseClient<$Result.GetResult<Prisma.$StudentEnrolledCoursePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more StudentEnrolledCourses.
     * @param {StudentEnrolledCourseDeleteManyArgs} args - Arguments to filter StudentEnrolledCourses to delete.
     * @example
     * // Delete a few StudentEnrolledCourses
     * const { count } = await prisma.studentEnrolledCourse.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StudentEnrolledCourseDeleteManyArgs>(args?: SelectSubset<T, StudentEnrolledCourseDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StudentEnrolledCourses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentEnrolledCourseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StudentEnrolledCourses
     * const studentEnrolledCourse = await prisma.studentEnrolledCourse.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StudentEnrolledCourseUpdateManyArgs>(args: SelectSubset<T, StudentEnrolledCourseUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one StudentEnrolledCourse.
     * @param {StudentEnrolledCourseUpsertArgs} args - Arguments to update or create a StudentEnrolledCourse.
     * @example
     * // Update or create a StudentEnrolledCourse
     * const studentEnrolledCourse = await prisma.studentEnrolledCourse.upsert({
     *   create: {
     *     // ... data to create a StudentEnrolledCourse
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StudentEnrolledCourse we want to update
     *   }
     * })
     */
    upsert<T extends StudentEnrolledCourseUpsertArgs>(args: SelectSubset<T, StudentEnrolledCourseUpsertArgs<ExtArgs>>): Prisma__StudentEnrolledCourseClient<$Result.GetResult<Prisma.$StudentEnrolledCoursePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of StudentEnrolledCourses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentEnrolledCourseCountArgs} args - Arguments to filter StudentEnrolledCourses to count.
     * @example
     * // Count the number of StudentEnrolledCourses
     * const count = await prisma.studentEnrolledCourse.count({
     *   where: {
     *     // ... the filter for the StudentEnrolledCourses we want to count
     *   }
     * })
    **/
    count<T extends StudentEnrolledCourseCountArgs>(
      args?: Subset<T, StudentEnrolledCourseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StudentEnrolledCourseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StudentEnrolledCourse.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentEnrolledCourseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StudentEnrolledCourseAggregateArgs>(args: Subset<T, StudentEnrolledCourseAggregateArgs>): Prisma.PrismaPromise<GetStudentEnrolledCourseAggregateType<T>>

    /**
     * Group by StudentEnrolledCourse.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentEnrolledCourseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StudentEnrolledCourseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StudentEnrolledCourseGroupByArgs['orderBy'] }
        : { orderBy?: StudentEnrolledCourseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StudentEnrolledCourseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStudentEnrolledCourseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the StudentEnrolledCourse model
   */
  readonly fields: StudentEnrolledCourseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for StudentEnrolledCourse.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StudentEnrolledCourseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    student<T extends StudentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StudentDefaultArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    course<T extends CourseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CourseDefaultArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    studentEnrolledCourseMarks<T extends StudentEnrolledCourse$studentEnrolledCourseMarksArgs<ExtArgs> = {}>(args?: Subset<T, StudentEnrolledCourse$studentEnrolledCourseMarksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentEnrolledCourseMarkPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    academicSemester<T extends AcademicSemesterDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AcademicSemesterDefaultArgs<ExtArgs>>): Prisma__AcademicSemesterClient<$Result.GetResult<Prisma.$AcademicSemesterPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the StudentEnrolledCourse model
   */
  interface StudentEnrolledCourseFieldRefs {
    readonly id: FieldRef<"StudentEnrolledCourse", 'String'>
    readonly grade: FieldRef<"StudentEnrolledCourse", 'String'>
    readonly point: FieldRef<"StudentEnrolledCourse", 'Float'>
    readonly totalMarks: FieldRef<"StudentEnrolledCourse", 'Int'>
    readonly status: FieldRef<"StudentEnrolledCourse", 'StudentEnrolledCourseStatus'>
    readonly createdAt: FieldRef<"StudentEnrolledCourse", 'DateTime'>
    readonly updatedAt: FieldRef<"StudentEnrolledCourse", 'DateTime'>
    readonly studentId: FieldRef<"StudentEnrolledCourse", 'String'>
    readonly academicSemesterId: FieldRef<"StudentEnrolledCourse", 'String'>
    readonly courseId: FieldRef<"StudentEnrolledCourse", 'String'>
  }
    

  // Custom InputTypes
  /**
   * StudentEnrolledCourse findUnique
   */
  export type StudentEnrolledCourseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentEnrolledCourse
     */
    select?: StudentEnrolledCourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentEnrolledCourse
     */
    omit?: StudentEnrolledCourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentEnrolledCourseInclude<ExtArgs> | null
    /**
     * Filter, which StudentEnrolledCourse to fetch.
     */
    where: StudentEnrolledCourseWhereUniqueInput
  }

  /**
   * StudentEnrolledCourse findUniqueOrThrow
   */
  export type StudentEnrolledCourseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentEnrolledCourse
     */
    select?: StudentEnrolledCourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentEnrolledCourse
     */
    omit?: StudentEnrolledCourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentEnrolledCourseInclude<ExtArgs> | null
    /**
     * Filter, which StudentEnrolledCourse to fetch.
     */
    where: StudentEnrolledCourseWhereUniqueInput
  }

  /**
   * StudentEnrolledCourse findFirst
   */
  export type StudentEnrolledCourseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentEnrolledCourse
     */
    select?: StudentEnrolledCourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentEnrolledCourse
     */
    omit?: StudentEnrolledCourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentEnrolledCourseInclude<ExtArgs> | null
    /**
     * Filter, which StudentEnrolledCourse to fetch.
     */
    where?: StudentEnrolledCourseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentEnrolledCourses to fetch.
     */
    orderBy?: StudentEnrolledCourseOrderByWithRelationInput | StudentEnrolledCourseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StudentEnrolledCourses.
     */
    cursor?: StudentEnrolledCourseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentEnrolledCourses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentEnrolledCourses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StudentEnrolledCourses.
     */
    distinct?: StudentEnrolledCourseScalarFieldEnum | StudentEnrolledCourseScalarFieldEnum[]
  }

  /**
   * StudentEnrolledCourse findFirstOrThrow
   */
  export type StudentEnrolledCourseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentEnrolledCourse
     */
    select?: StudentEnrolledCourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentEnrolledCourse
     */
    omit?: StudentEnrolledCourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentEnrolledCourseInclude<ExtArgs> | null
    /**
     * Filter, which StudentEnrolledCourse to fetch.
     */
    where?: StudentEnrolledCourseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentEnrolledCourses to fetch.
     */
    orderBy?: StudentEnrolledCourseOrderByWithRelationInput | StudentEnrolledCourseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StudentEnrolledCourses.
     */
    cursor?: StudentEnrolledCourseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentEnrolledCourses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentEnrolledCourses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StudentEnrolledCourses.
     */
    distinct?: StudentEnrolledCourseScalarFieldEnum | StudentEnrolledCourseScalarFieldEnum[]
  }

  /**
   * StudentEnrolledCourse findMany
   */
  export type StudentEnrolledCourseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentEnrolledCourse
     */
    select?: StudentEnrolledCourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentEnrolledCourse
     */
    omit?: StudentEnrolledCourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentEnrolledCourseInclude<ExtArgs> | null
    /**
     * Filter, which StudentEnrolledCourses to fetch.
     */
    where?: StudentEnrolledCourseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentEnrolledCourses to fetch.
     */
    orderBy?: StudentEnrolledCourseOrderByWithRelationInput | StudentEnrolledCourseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StudentEnrolledCourses.
     */
    cursor?: StudentEnrolledCourseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentEnrolledCourses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentEnrolledCourses.
     */
    skip?: number
    distinct?: StudentEnrolledCourseScalarFieldEnum | StudentEnrolledCourseScalarFieldEnum[]
  }

  /**
   * StudentEnrolledCourse create
   */
  export type StudentEnrolledCourseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentEnrolledCourse
     */
    select?: StudentEnrolledCourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentEnrolledCourse
     */
    omit?: StudentEnrolledCourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentEnrolledCourseInclude<ExtArgs> | null
    /**
     * The data needed to create a StudentEnrolledCourse.
     */
    data: XOR<StudentEnrolledCourseCreateInput, StudentEnrolledCourseUncheckedCreateInput>
  }

  /**
   * StudentEnrolledCourse createMany
   */
  export type StudentEnrolledCourseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many StudentEnrolledCourses.
     */
    data: StudentEnrolledCourseCreateManyInput | StudentEnrolledCourseCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * StudentEnrolledCourse update
   */
  export type StudentEnrolledCourseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentEnrolledCourse
     */
    select?: StudentEnrolledCourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentEnrolledCourse
     */
    omit?: StudentEnrolledCourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentEnrolledCourseInclude<ExtArgs> | null
    /**
     * The data needed to update a StudentEnrolledCourse.
     */
    data: XOR<StudentEnrolledCourseUpdateInput, StudentEnrolledCourseUncheckedUpdateInput>
    /**
     * Choose, which StudentEnrolledCourse to update.
     */
    where: StudentEnrolledCourseWhereUniqueInput
  }

  /**
   * StudentEnrolledCourse updateMany
   */
  export type StudentEnrolledCourseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update StudentEnrolledCourses.
     */
    data: XOR<StudentEnrolledCourseUpdateManyMutationInput, StudentEnrolledCourseUncheckedUpdateManyInput>
    /**
     * Filter which StudentEnrolledCourses to update
     */
    where?: StudentEnrolledCourseWhereInput
    /**
     * Limit how many StudentEnrolledCourses to update.
     */
    limit?: number
  }

  /**
   * StudentEnrolledCourse upsert
   */
  export type StudentEnrolledCourseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentEnrolledCourse
     */
    select?: StudentEnrolledCourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentEnrolledCourse
     */
    omit?: StudentEnrolledCourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentEnrolledCourseInclude<ExtArgs> | null
    /**
     * The filter to search for the StudentEnrolledCourse to update in case it exists.
     */
    where: StudentEnrolledCourseWhereUniqueInput
    /**
     * In case the StudentEnrolledCourse found by the `where` argument doesn't exist, create a new StudentEnrolledCourse with this data.
     */
    create: XOR<StudentEnrolledCourseCreateInput, StudentEnrolledCourseUncheckedCreateInput>
    /**
     * In case the StudentEnrolledCourse was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StudentEnrolledCourseUpdateInput, StudentEnrolledCourseUncheckedUpdateInput>
  }

  /**
   * StudentEnrolledCourse delete
   */
  export type StudentEnrolledCourseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentEnrolledCourse
     */
    select?: StudentEnrolledCourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentEnrolledCourse
     */
    omit?: StudentEnrolledCourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentEnrolledCourseInclude<ExtArgs> | null
    /**
     * Filter which StudentEnrolledCourse to delete.
     */
    where: StudentEnrolledCourseWhereUniqueInput
  }

  /**
   * StudentEnrolledCourse deleteMany
   */
  export type StudentEnrolledCourseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StudentEnrolledCourses to delete
     */
    where?: StudentEnrolledCourseWhereInput
    /**
     * Limit how many StudentEnrolledCourses to delete.
     */
    limit?: number
  }

  /**
   * StudentEnrolledCourse.studentEnrolledCourseMarks
   */
  export type StudentEnrolledCourse$studentEnrolledCourseMarksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentEnrolledCourseMark
     */
    select?: StudentEnrolledCourseMarkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentEnrolledCourseMark
     */
    omit?: StudentEnrolledCourseMarkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentEnrolledCourseMarkInclude<ExtArgs> | null
    where?: StudentEnrolledCourseMarkWhereInput
    orderBy?: StudentEnrolledCourseMarkOrderByWithRelationInput | StudentEnrolledCourseMarkOrderByWithRelationInput[]
    cursor?: StudentEnrolledCourseMarkWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StudentEnrolledCourseMarkScalarFieldEnum | StudentEnrolledCourseMarkScalarFieldEnum[]
  }

  /**
   * StudentEnrolledCourse without action
   */
  export type StudentEnrolledCourseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentEnrolledCourse
     */
    select?: StudentEnrolledCourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentEnrolledCourse
     */
    omit?: StudentEnrolledCourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentEnrolledCourseInclude<ExtArgs> | null
  }


  /**
   * Model StudentEnrolledCourseMark
   */

  export type AggregateStudentEnrolledCourseMark = {
    _count: StudentEnrolledCourseMarkCountAggregateOutputType | null
    _avg: StudentEnrolledCourseMarkAvgAggregateOutputType | null
    _sum: StudentEnrolledCourseMarkSumAggregateOutputType | null
    _min: StudentEnrolledCourseMarkMinAggregateOutputType | null
    _max: StudentEnrolledCourseMarkMaxAggregateOutputType | null
  }

  export type StudentEnrolledCourseMarkAvgAggregateOutputType = {
    frequencyExam: number | null
    finalExam: number | null
    resourceExam: number | null
    specialExam: number | null
    recoveryExam: number | null
    totalMarks: number | null
    grade: number | null
  }

  export type StudentEnrolledCourseMarkSumAggregateOutputType = {
    frequencyExam: number | null
    finalExam: number | null
    resourceExam: number | null
    specialExam: number | null
    recoveryExam: number | null
    totalMarks: number | null
    grade: number | null
  }

  export type StudentEnrolledCourseMarkMinAggregateOutputType = {
    id: string | null
    examType: $Enums.ExamType | null
    createdAt: Date | null
    updatedAt: Date | null
    studentId: string | null
    studentEnrolledCourseId: string | null
    academicSemesterId: string | null
    frequencyExam: number | null
    finalExam: number | null
    resourceExam: number | null
    specialExam: number | null
    recoveryExam: number | null
    totalMarks: number | null
    grade: number | null
  }

  export type StudentEnrolledCourseMarkMaxAggregateOutputType = {
    id: string | null
    examType: $Enums.ExamType | null
    createdAt: Date | null
    updatedAt: Date | null
    studentId: string | null
    studentEnrolledCourseId: string | null
    academicSemesterId: string | null
    frequencyExam: number | null
    finalExam: number | null
    resourceExam: number | null
    specialExam: number | null
    recoveryExam: number | null
    totalMarks: number | null
    grade: number | null
  }

  export type StudentEnrolledCourseMarkCountAggregateOutputType = {
    id: number
    examType: number
    createdAt: number
    updatedAt: number
    studentId: number
    studentEnrolledCourseId: number
    academicSemesterId: number
    continuousAssessments: number
    frequencyExam: number
    finalExam: number
    resourceExam: number
    specialExam: number
    recoveryExam: number
    totalMarks: number
    grade: number
    _all: number
  }


  export type StudentEnrolledCourseMarkAvgAggregateInputType = {
    frequencyExam?: true
    finalExam?: true
    resourceExam?: true
    specialExam?: true
    recoveryExam?: true
    totalMarks?: true
    grade?: true
  }

  export type StudentEnrolledCourseMarkSumAggregateInputType = {
    frequencyExam?: true
    finalExam?: true
    resourceExam?: true
    specialExam?: true
    recoveryExam?: true
    totalMarks?: true
    grade?: true
  }

  export type StudentEnrolledCourseMarkMinAggregateInputType = {
    id?: true
    examType?: true
    createdAt?: true
    updatedAt?: true
    studentId?: true
    studentEnrolledCourseId?: true
    academicSemesterId?: true
    frequencyExam?: true
    finalExam?: true
    resourceExam?: true
    specialExam?: true
    recoveryExam?: true
    totalMarks?: true
    grade?: true
  }

  export type StudentEnrolledCourseMarkMaxAggregateInputType = {
    id?: true
    examType?: true
    createdAt?: true
    updatedAt?: true
    studentId?: true
    studentEnrolledCourseId?: true
    academicSemesterId?: true
    frequencyExam?: true
    finalExam?: true
    resourceExam?: true
    specialExam?: true
    recoveryExam?: true
    totalMarks?: true
    grade?: true
  }

  export type StudentEnrolledCourseMarkCountAggregateInputType = {
    id?: true
    examType?: true
    createdAt?: true
    updatedAt?: true
    studentId?: true
    studentEnrolledCourseId?: true
    academicSemesterId?: true
    continuousAssessments?: true
    frequencyExam?: true
    finalExam?: true
    resourceExam?: true
    specialExam?: true
    recoveryExam?: true
    totalMarks?: true
    grade?: true
    _all?: true
  }

  export type StudentEnrolledCourseMarkAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StudentEnrolledCourseMark to aggregate.
     */
    where?: StudentEnrolledCourseMarkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentEnrolledCourseMarks to fetch.
     */
    orderBy?: StudentEnrolledCourseMarkOrderByWithRelationInput | StudentEnrolledCourseMarkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StudentEnrolledCourseMarkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentEnrolledCourseMarks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentEnrolledCourseMarks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StudentEnrolledCourseMarks
    **/
    _count?: true | StudentEnrolledCourseMarkCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StudentEnrolledCourseMarkAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StudentEnrolledCourseMarkSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StudentEnrolledCourseMarkMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StudentEnrolledCourseMarkMaxAggregateInputType
  }

  export type GetStudentEnrolledCourseMarkAggregateType<T extends StudentEnrolledCourseMarkAggregateArgs> = {
        [P in keyof T & keyof AggregateStudentEnrolledCourseMark]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStudentEnrolledCourseMark[P]>
      : GetScalarType<T[P], AggregateStudentEnrolledCourseMark[P]>
  }




  export type StudentEnrolledCourseMarkGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentEnrolledCourseMarkWhereInput
    orderBy?: StudentEnrolledCourseMarkOrderByWithAggregationInput | StudentEnrolledCourseMarkOrderByWithAggregationInput[]
    by: StudentEnrolledCourseMarkScalarFieldEnum[] | StudentEnrolledCourseMarkScalarFieldEnum
    having?: StudentEnrolledCourseMarkScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StudentEnrolledCourseMarkCountAggregateInputType | true
    _avg?: StudentEnrolledCourseMarkAvgAggregateInputType
    _sum?: StudentEnrolledCourseMarkSumAggregateInputType
    _min?: StudentEnrolledCourseMarkMinAggregateInputType
    _max?: StudentEnrolledCourseMarkMaxAggregateInputType
  }

  export type StudentEnrolledCourseMarkGroupByOutputType = {
    id: string
    examType: $Enums.ExamType | null
    createdAt: Date
    updatedAt: Date
    studentId: string
    studentEnrolledCourseId: string
    academicSemesterId: string
    continuousAssessments: JsonValue
    frequencyExam: number | null
    finalExam: number | null
    resourceExam: number | null
    specialExam: number | null
    recoveryExam: number | null
    totalMarks: number
    grade: number
    _count: StudentEnrolledCourseMarkCountAggregateOutputType | null
    _avg: StudentEnrolledCourseMarkAvgAggregateOutputType | null
    _sum: StudentEnrolledCourseMarkSumAggregateOutputType | null
    _min: StudentEnrolledCourseMarkMinAggregateOutputType | null
    _max: StudentEnrolledCourseMarkMaxAggregateOutputType | null
  }

  type GetStudentEnrolledCourseMarkGroupByPayload<T extends StudentEnrolledCourseMarkGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StudentEnrolledCourseMarkGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StudentEnrolledCourseMarkGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StudentEnrolledCourseMarkGroupByOutputType[P]>
            : GetScalarType<T[P], StudentEnrolledCourseMarkGroupByOutputType[P]>
        }
      >
    >


  export type StudentEnrolledCourseMarkSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    examType?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    studentId?: boolean
    studentEnrolledCourseId?: boolean
    academicSemesterId?: boolean
    continuousAssessments?: boolean
    frequencyExam?: boolean
    finalExam?: boolean
    resourceExam?: boolean
    specialExam?: boolean
    recoveryExam?: boolean
    totalMarks?: boolean
    grade?: boolean
    student?: boolean | StudentDefaultArgs<ExtArgs>
    studentEnrolledCourse?: boolean | StudentEnrolledCourseDefaultArgs<ExtArgs>
    academicSemester?: boolean | AcademicSemesterDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["studentEnrolledCourseMark"]>



  export type StudentEnrolledCourseMarkSelectScalar = {
    id?: boolean
    examType?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    studentId?: boolean
    studentEnrolledCourseId?: boolean
    academicSemesterId?: boolean
    continuousAssessments?: boolean
    frequencyExam?: boolean
    finalExam?: boolean
    resourceExam?: boolean
    specialExam?: boolean
    recoveryExam?: boolean
    totalMarks?: boolean
    grade?: boolean
  }

  export type StudentEnrolledCourseMarkOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "examType" | "createdAt" | "updatedAt" | "studentId" | "studentEnrolledCourseId" | "academicSemesterId" | "continuousAssessments" | "frequencyExam" | "finalExam" | "resourceExam" | "specialExam" | "recoveryExam" | "totalMarks" | "grade", ExtArgs["result"]["studentEnrolledCourseMark"]>
  export type StudentEnrolledCourseMarkInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentDefaultArgs<ExtArgs>
    studentEnrolledCourse?: boolean | StudentEnrolledCourseDefaultArgs<ExtArgs>
    academicSemester?: boolean | AcademicSemesterDefaultArgs<ExtArgs>
  }

  export type $StudentEnrolledCourseMarkPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "StudentEnrolledCourseMark"
    objects: {
      student: Prisma.$StudentPayload<ExtArgs>
      studentEnrolledCourse: Prisma.$StudentEnrolledCoursePayload<ExtArgs>
      academicSemester: Prisma.$AcademicSemesterPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      examType: $Enums.ExamType | null
      createdAt: Date
      updatedAt: Date
      studentId: string
      studentEnrolledCourseId: string
      academicSemesterId: string
      continuousAssessments: Prisma.JsonValue
      frequencyExam: number | null
      finalExam: number | null
      resourceExam: number | null
      specialExam: number | null
      recoveryExam: number | null
      totalMarks: number
      grade: number
    }, ExtArgs["result"]["studentEnrolledCourseMark"]>
    composites: {}
  }

  type StudentEnrolledCourseMarkGetPayload<S extends boolean | null | undefined | StudentEnrolledCourseMarkDefaultArgs> = $Result.GetResult<Prisma.$StudentEnrolledCourseMarkPayload, S>

  type StudentEnrolledCourseMarkCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<StudentEnrolledCourseMarkFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: StudentEnrolledCourseMarkCountAggregateInputType | true
    }

  export interface StudentEnrolledCourseMarkDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['StudentEnrolledCourseMark'], meta: { name: 'StudentEnrolledCourseMark' } }
    /**
     * Find zero or one StudentEnrolledCourseMark that matches the filter.
     * @param {StudentEnrolledCourseMarkFindUniqueArgs} args - Arguments to find a StudentEnrolledCourseMark
     * @example
     * // Get one StudentEnrolledCourseMark
     * const studentEnrolledCourseMark = await prisma.studentEnrolledCourseMark.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StudentEnrolledCourseMarkFindUniqueArgs>(args: SelectSubset<T, StudentEnrolledCourseMarkFindUniqueArgs<ExtArgs>>): Prisma__StudentEnrolledCourseMarkClient<$Result.GetResult<Prisma.$StudentEnrolledCourseMarkPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one StudentEnrolledCourseMark that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {StudentEnrolledCourseMarkFindUniqueOrThrowArgs} args - Arguments to find a StudentEnrolledCourseMark
     * @example
     * // Get one StudentEnrolledCourseMark
     * const studentEnrolledCourseMark = await prisma.studentEnrolledCourseMark.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StudentEnrolledCourseMarkFindUniqueOrThrowArgs>(args: SelectSubset<T, StudentEnrolledCourseMarkFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StudentEnrolledCourseMarkClient<$Result.GetResult<Prisma.$StudentEnrolledCourseMarkPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StudentEnrolledCourseMark that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentEnrolledCourseMarkFindFirstArgs} args - Arguments to find a StudentEnrolledCourseMark
     * @example
     * // Get one StudentEnrolledCourseMark
     * const studentEnrolledCourseMark = await prisma.studentEnrolledCourseMark.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StudentEnrolledCourseMarkFindFirstArgs>(args?: SelectSubset<T, StudentEnrolledCourseMarkFindFirstArgs<ExtArgs>>): Prisma__StudentEnrolledCourseMarkClient<$Result.GetResult<Prisma.$StudentEnrolledCourseMarkPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StudentEnrolledCourseMark that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentEnrolledCourseMarkFindFirstOrThrowArgs} args - Arguments to find a StudentEnrolledCourseMark
     * @example
     * // Get one StudentEnrolledCourseMark
     * const studentEnrolledCourseMark = await prisma.studentEnrolledCourseMark.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StudentEnrolledCourseMarkFindFirstOrThrowArgs>(args?: SelectSubset<T, StudentEnrolledCourseMarkFindFirstOrThrowArgs<ExtArgs>>): Prisma__StudentEnrolledCourseMarkClient<$Result.GetResult<Prisma.$StudentEnrolledCourseMarkPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more StudentEnrolledCourseMarks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentEnrolledCourseMarkFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StudentEnrolledCourseMarks
     * const studentEnrolledCourseMarks = await prisma.studentEnrolledCourseMark.findMany()
     * 
     * // Get first 10 StudentEnrolledCourseMarks
     * const studentEnrolledCourseMarks = await prisma.studentEnrolledCourseMark.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const studentEnrolledCourseMarkWithIdOnly = await prisma.studentEnrolledCourseMark.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StudentEnrolledCourseMarkFindManyArgs>(args?: SelectSubset<T, StudentEnrolledCourseMarkFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentEnrolledCourseMarkPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a StudentEnrolledCourseMark.
     * @param {StudentEnrolledCourseMarkCreateArgs} args - Arguments to create a StudentEnrolledCourseMark.
     * @example
     * // Create one StudentEnrolledCourseMark
     * const StudentEnrolledCourseMark = await prisma.studentEnrolledCourseMark.create({
     *   data: {
     *     // ... data to create a StudentEnrolledCourseMark
     *   }
     * })
     * 
     */
    create<T extends StudentEnrolledCourseMarkCreateArgs>(args: SelectSubset<T, StudentEnrolledCourseMarkCreateArgs<ExtArgs>>): Prisma__StudentEnrolledCourseMarkClient<$Result.GetResult<Prisma.$StudentEnrolledCourseMarkPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many StudentEnrolledCourseMarks.
     * @param {StudentEnrolledCourseMarkCreateManyArgs} args - Arguments to create many StudentEnrolledCourseMarks.
     * @example
     * // Create many StudentEnrolledCourseMarks
     * const studentEnrolledCourseMark = await prisma.studentEnrolledCourseMark.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StudentEnrolledCourseMarkCreateManyArgs>(args?: SelectSubset<T, StudentEnrolledCourseMarkCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a StudentEnrolledCourseMark.
     * @param {StudentEnrolledCourseMarkDeleteArgs} args - Arguments to delete one StudentEnrolledCourseMark.
     * @example
     * // Delete one StudentEnrolledCourseMark
     * const StudentEnrolledCourseMark = await prisma.studentEnrolledCourseMark.delete({
     *   where: {
     *     // ... filter to delete one StudentEnrolledCourseMark
     *   }
     * })
     * 
     */
    delete<T extends StudentEnrolledCourseMarkDeleteArgs>(args: SelectSubset<T, StudentEnrolledCourseMarkDeleteArgs<ExtArgs>>): Prisma__StudentEnrolledCourseMarkClient<$Result.GetResult<Prisma.$StudentEnrolledCourseMarkPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one StudentEnrolledCourseMark.
     * @param {StudentEnrolledCourseMarkUpdateArgs} args - Arguments to update one StudentEnrolledCourseMark.
     * @example
     * // Update one StudentEnrolledCourseMark
     * const studentEnrolledCourseMark = await prisma.studentEnrolledCourseMark.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StudentEnrolledCourseMarkUpdateArgs>(args: SelectSubset<T, StudentEnrolledCourseMarkUpdateArgs<ExtArgs>>): Prisma__StudentEnrolledCourseMarkClient<$Result.GetResult<Prisma.$StudentEnrolledCourseMarkPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more StudentEnrolledCourseMarks.
     * @param {StudentEnrolledCourseMarkDeleteManyArgs} args - Arguments to filter StudentEnrolledCourseMarks to delete.
     * @example
     * // Delete a few StudentEnrolledCourseMarks
     * const { count } = await prisma.studentEnrolledCourseMark.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StudentEnrolledCourseMarkDeleteManyArgs>(args?: SelectSubset<T, StudentEnrolledCourseMarkDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StudentEnrolledCourseMarks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentEnrolledCourseMarkUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StudentEnrolledCourseMarks
     * const studentEnrolledCourseMark = await prisma.studentEnrolledCourseMark.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StudentEnrolledCourseMarkUpdateManyArgs>(args: SelectSubset<T, StudentEnrolledCourseMarkUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one StudentEnrolledCourseMark.
     * @param {StudentEnrolledCourseMarkUpsertArgs} args - Arguments to update or create a StudentEnrolledCourseMark.
     * @example
     * // Update or create a StudentEnrolledCourseMark
     * const studentEnrolledCourseMark = await prisma.studentEnrolledCourseMark.upsert({
     *   create: {
     *     // ... data to create a StudentEnrolledCourseMark
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StudentEnrolledCourseMark we want to update
     *   }
     * })
     */
    upsert<T extends StudentEnrolledCourseMarkUpsertArgs>(args: SelectSubset<T, StudentEnrolledCourseMarkUpsertArgs<ExtArgs>>): Prisma__StudentEnrolledCourseMarkClient<$Result.GetResult<Prisma.$StudentEnrolledCourseMarkPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of StudentEnrolledCourseMarks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentEnrolledCourseMarkCountArgs} args - Arguments to filter StudentEnrolledCourseMarks to count.
     * @example
     * // Count the number of StudentEnrolledCourseMarks
     * const count = await prisma.studentEnrolledCourseMark.count({
     *   where: {
     *     // ... the filter for the StudentEnrolledCourseMarks we want to count
     *   }
     * })
    **/
    count<T extends StudentEnrolledCourseMarkCountArgs>(
      args?: Subset<T, StudentEnrolledCourseMarkCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StudentEnrolledCourseMarkCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StudentEnrolledCourseMark.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentEnrolledCourseMarkAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StudentEnrolledCourseMarkAggregateArgs>(args: Subset<T, StudentEnrolledCourseMarkAggregateArgs>): Prisma.PrismaPromise<GetStudentEnrolledCourseMarkAggregateType<T>>

    /**
     * Group by StudentEnrolledCourseMark.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentEnrolledCourseMarkGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StudentEnrolledCourseMarkGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StudentEnrolledCourseMarkGroupByArgs['orderBy'] }
        : { orderBy?: StudentEnrolledCourseMarkGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StudentEnrolledCourseMarkGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStudentEnrolledCourseMarkGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the StudentEnrolledCourseMark model
   */
  readonly fields: StudentEnrolledCourseMarkFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for StudentEnrolledCourseMark.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StudentEnrolledCourseMarkClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    student<T extends StudentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StudentDefaultArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    studentEnrolledCourse<T extends StudentEnrolledCourseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StudentEnrolledCourseDefaultArgs<ExtArgs>>): Prisma__StudentEnrolledCourseClient<$Result.GetResult<Prisma.$StudentEnrolledCoursePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    academicSemester<T extends AcademicSemesterDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AcademicSemesterDefaultArgs<ExtArgs>>): Prisma__AcademicSemesterClient<$Result.GetResult<Prisma.$AcademicSemesterPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the StudentEnrolledCourseMark model
   */
  interface StudentEnrolledCourseMarkFieldRefs {
    readonly id: FieldRef<"StudentEnrolledCourseMark", 'String'>
    readonly examType: FieldRef<"StudentEnrolledCourseMark", 'ExamType'>
    readonly createdAt: FieldRef<"StudentEnrolledCourseMark", 'DateTime'>
    readonly updatedAt: FieldRef<"StudentEnrolledCourseMark", 'DateTime'>
    readonly studentId: FieldRef<"StudentEnrolledCourseMark", 'String'>
    readonly studentEnrolledCourseId: FieldRef<"StudentEnrolledCourseMark", 'String'>
    readonly academicSemesterId: FieldRef<"StudentEnrolledCourseMark", 'String'>
    readonly continuousAssessments: FieldRef<"StudentEnrolledCourseMark", 'Json'>
    readonly frequencyExam: FieldRef<"StudentEnrolledCourseMark", 'Float'>
    readonly finalExam: FieldRef<"StudentEnrolledCourseMark", 'Float'>
    readonly resourceExam: FieldRef<"StudentEnrolledCourseMark", 'Float'>
    readonly specialExam: FieldRef<"StudentEnrolledCourseMark", 'Float'>
    readonly recoveryExam: FieldRef<"StudentEnrolledCourseMark", 'Float'>
    readonly totalMarks: FieldRef<"StudentEnrolledCourseMark", 'Float'>
    readonly grade: FieldRef<"StudentEnrolledCourseMark", 'Float'>
  }
    

  // Custom InputTypes
  /**
   * StudentEnrolledCourseMark findUnique
   */
  export type StudentEnrolledCourseMarkFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentEnrolledCourseMark
     */
    select?: StudentEnrolledCourseMarkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentEnrolledCourseMark
     */
    omit?: StudentEnrolledCourseMarkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentEnrolledCourseMarkInclude<ExtArgs> | null
    /**
     * Filter, which StudentEnrolledCourseMark to fetch.
     */
    where: StudentEnrolledCourseMarkWhereUniqueInput
  }

  /**
   * StudentEnrolledCourseMark findUniqueOrThrow
   */
  export type StudentEnrolledCourseMarkFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentEnrolledCourseMark
     */
    select?: StudentEnrolledCourseMarkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentEnrolledCourseMark
     */
    omit?: StudentEnrolledCourseMarkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentEnrolledCourseMarkInclude<ExtArgs> | null
    /**
     * Filter, which StudentEnrolledCourseMark to fetch.
     */
    where: StudentEnrolledCourseMarkWhereUniqueInput
  }

  /**
   * StudentEnrolledCourseMark findFirst
   */
  export type StudentEnrolledCourseMarkFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentEnrolledCourseMark
     */
    select?: StudentEnrolledCourseMarkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentEnrolledCourseMark
     */
    omit?: StudentEnrolledCourseMarkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentEnrolledCourseMarkInclude<ExtArgs> | null
    /**
     * Filter, which StudentEnrolledCourseMark to fetch.
     */
    where?: StudentEnrolledCourseMarkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentEnrolledCourseMarks to fetch.
     */
    orderBy?: StudentEnrolledCourseMarkOrderByWithRelationInput | StudentEnrolledCourseMarkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StudentEnrolledCourseMarks.
     */
    cursor?: StudentEnrolledCourseMarkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentEnrolledCourseMarks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentEnrolledCourseMarks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StudentEnrolledCourseMarks.
     */
    distinct?: StudentEnrolledCourseMarkScalarFieldEnum | StudentEnrolledCourseMarkScalarFieldEnum[]
  }

  /**
   * StudentEnrolledCourseMark findFirstOrThrow
   */
  export type StudentEnrolledCourseMarkFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentEnrolledCourseMark
     */
    select?: StudentEnrolledCourseMarkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentEnrolledCourseMark
     */
    omit?: StudentEnrolledCourseMarkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentEnrolledCourseMarkInclude<ExtArgs> | null
    /**
     * Filter, which StudentEnrolledCourseMark to fetch.
     */
    where?: StudentEnrolledCourseMarkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentEnrolledCourseMarks to fetch.
     */
    orderBy?: StudentEnrolledCourseMarkOrderByWithRelationInput | StudentEnrolledCourseMarkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StudentEnrolledCourseMarks.
     */
    cursor?: StudentEnrolledCourseMarkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentEnrolledCourseMarks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentEnrolledCourseMarks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StudentEnrolledCourseMarks.
     */
    distinct?: StudentEnrolledCourseMarkScalarFieldEnum | StudentEnrolledCourseMarkScalarFieldEnum[]
  }

  /**
   * StudentEnrolledCourseMark findMany
   */
  export type StudentEnrolledCourseMarkFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentEnrolledCourseMark
     */
    select?: StudentEnrolledCourseMarkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentEnrolledCourseMark
     */
    omit?: StudentEnrolledCourseMarkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentEnrolledCourseMarkInclude<ExtArgs> | null
    /**
     * Filter, which StudentEnrolledCourseMarks to fetch.
     */
    where?: StudentEnrolledCourseMarkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentEnrolledCourseMarks to fetch.
     */
    orderBy?: StudentEnrolledCourseMarkOrderByWithRelationInput | StudentEnrolledCourseMarkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StudentEnrolledCourseMarks.
     */
    cursor?: StudentEnrolledCourseMarkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentEnrolledCourseMarks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentEnrolledCourseMarks.
     */
    skip?: number
    distinct?: StudentEnrolledCourseMarkScalarFieldEnum | StudentEnrolledCourseMarkScalarFieldEnum[]
  }

  /**
   * StudentEnrolledCourseMark create
   */
  export type StudentEnrolledCourseMarkCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentEnrolledCourseMark
     */
    select?: StudentEnrolledCourseMarkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentEnrolledCourseMark
     */
    omit?: StudentEnrolledCourseMarkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentEnrolledCourseMarkInclude<ExtArgs> | null
    /**
     * The data needed to create a StudentEnrolledCourseMark.
     */
    data: XOR<StudentEnrolledCourseMarkCreateInput, StudentEnrolledCourseMarkUncheckedCreateInput>
  }

  /**
   * StudentEnrolledCourseMark createMany
   */
  export type StudentEnrolledCourseMarkCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many StudentEnrolledCourseMarks.
     */
    data: StudentEnrolledCourseMarkCreateManyInput | StudentEnrolledCourseMarkCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * StudentEnrolledCourseMark update
   */
  export type StudentEnrolledCourseMarkUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentEnrolledCourseMark
     */
    select?: StudentEnrolledCourseMarkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentEnrolledCourseMark
     */
    omit?: StudentEnrolledCourseMarkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentEnrolledCourseMarkInclude<ExtArgs> | null
    /**
     * The data needed to update a StudentEnrolledCourseMark.
     */
    data: XOR<StudentEnrolledCourseMarkUpdateInput, StudentEnrolledCourseMarkUncheckedUpdateInput>
    /**
     * Choose, which StudentEnrolledCourseMark to update.
     */
    where: StudentEnrolledCourseMarkWhereUniqueInput
  }

  /**
   * StudentEnrolledCourseMark updateMany
   */
  export type StudentEnrolledCourseMarkUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update StudentEnrolledCourseMarks.
     */
    data: XOR<StudentEnrolledCourseMarkUpdateManyMutationInput, StudentEnrolledCourseMarkUncheckedUpdateManyInput>
    /**
     * Filter which StudentEnrolledCourseMarks to update
     */
    where?: StudentEnrolledCourseMarkWhereInput
    /**
     * Limit how many StudentEnrolledCourseMarks to update.
     */
    limit?: number
  }

  /**
   * StudentEnrolledCourseMark upsert
   */
  export type StudentEnrolledCourseMarkUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentEnrolledCourseMark
     */
    select?: StudentEnrolledCourseMarkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentEnrolledCourseMark
     */
    omit?: StudentEnrolledCourseMarkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentEnrolledCourseMarkInclude<ExtArgs> | null
    /**
     * The filter to search for the StudentEnrolledCourseMark to update in case it exists.
     */
    where: StudentEnrolledCourseMarkWhereUniqueInput
    /**
     * In case the StudentEnrolledCourseMark found by the `where` argument doesn't exist, create a new StudentEnrolledCourseMark with this data.
     */
    create: XOR<StudentEnrolledCourseMarkCreateInput, StudentEnrolledCourseMarkUncheckedCreateInput>
    /**
     * In case the StudentEnrolledCourseMark was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StudentEnrolledCourseMarkUpdateInput, StudentEnrolledCourseMarkUncheckedUpdateInput>
  }

  /**
   * StudentEnrolledCourseMark delete
   */
  export type StudentEnrolledCourseMarkDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentEnrolledCourseMark
     */
    select?: StudentEnrolledCourseMarkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentEnrolledCourseMark
     */
    omit?: StudentEnrolledCourseMarkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentEnrolledCourseMarkInclude<ExtArgs> | null
    /**
     * Filter which StudentEnrolledCourseMark to delete.
     */
    where: StudentEnrolledCourseMarkWhereUniqueInput
  }

  /**
   * StudentEnrolledCourseMark deleteMany
   */
  export type StudentEnrolledCourseMarkDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StudentEnrolledCourseMarks to delete
     */
    where?: StudentEnrolledCourseMarkWhereInput
    /**
     * Limit how many StudentEnrolledCourseMarks to delete.
     */
    limit?: number
  }

  /**
   * StudentEnrolledCourseMark without action
   */
  export type StudentEnrolledCourseMarkDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentEnrolledCourseMark
     */
    select?: StudentEnrolledCourseMarkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentEnrolledCourseMark
     */
    omit?: StudentEnrolledCourseMarkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentEnrolledCourseMarkInclude<ExtArgs> | null
  }


  /**
   * Model CourseDiscipline
   */

  export type AggregateCourseDiscipline = {
    _count: CourseDisciplineCountAggregateOutputType | null
    _avg: CourseDisciplineAvgAggregateOutputType | null
    _sum: CourseDisciplineSumAggregateOutputType | null
    _min: CourseDisciplineMinAggregateOutputType | null
    _max: CourseDisciplineMaxAggregateOutputType | null
  }

  export type CourseDisciplineAvgAggregateOutputType = {
    credits: number | null
  }

  export type CourseDisciplineSumAggregateOutputType = {
    credits: number | null
  }

  export type CourseDisciplineMinAggregateOutputType = {
    id: string | null
    courseId: string | null
    disciplineId: string | null
    semesterId: string | null
    credits: number | null
  }

  export type CourseDisciplineMaxAggregateOutputType = {
    id: string | null
    courseId: string | null
    disciplineId: string | null
    semesterId: string | null
    credits: number | null
  }

  export type CourseDisciplineCountAggregateOutputType = {
    id: number
    courseId: number
    disciplineId: number
    semesterId: number
    credits: number
    _all: number
  }


  export type CourseDisciplineAvgAggregateInputType = {
    credits?: true
  }

  export type CourseDisciplineSumAggregateInputType = {
    credits?: true
  }

  export type CourseDisciplineMinAggregateInputType = {
    id?: true
    courseId?: true
    disciplineId?: true
    semesterId?: true
    credits?: true
  }

  export type CourseDisciplineMaxAggregateInputType = {
    id?: true
    courseId?: true
    disciplineId?: true
    semesterId?: true
    credits?: true
  }

  export type CourseDisciplineCountAggregateInputType = {
    id?: true
    courseId?: true
    disciplineId?: true
    semesterId?: true
    credits?: true
    _all?: true
  }

  export type CourseDisciplineAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CourseDiscipline to aggregate.
     */
    where?: CourseDisciplineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CourseDisciplines to fetch.
     */
    orderBy?: CourseDisciplineOrderByWithRelationInput | CourseDisciplineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CourseDisciplineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CourseDisciplines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CourseDisciplines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CourseDisciplines
    **/
    _count?: true | CourseDisciplineCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CourseDisciplineAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CourseDisciplineSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CourseDisciplineMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CourseDisciplineMaxAggregateInputType
  }

  export type GetCourseDisciplineAggregateType<T extends CourseDisciplineAggregateArgs> = {
        [P in keyof T & keyof AggregateCourseDiscipline]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCourseDiscipline[P]>
      : GetScalarType<T[P], AggregateCourseDiscipline[P]>
  }




  export type CourseDisciplineGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CourseDisciplineWhereInput
    orderBy?: CourseDisciplineOrderByWithAggregationInput | CourseDisciplineOrderByWithAggregationInput[]
    by: CourseDisciplineScalarFieldEnum[] | CourseDisciplineScalarFieldEnum
    having?: CourseDisciplineScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CourseDisciplineCountAggregateInputType | true
    _avg?: CourseDisciplineAvgAggregateInputType
    _sum?: CourseDisciplineSumAggregateInputType
    _min?: CourseDisciplineMinAggregateInputType
    _max?: CourseDisciplineMaxAggregateInputType
  }

  export type CourseDisciplineGroupByOutputType = {
    id: string
    courseId: string
    disciplineId: string
    semesterId: string
    credits: number
    _count: CourseDisciplineCountAggregateOutputType | null
    _avg: CourseDisciplineAvgAggregateOutputType | null
    _sum: CourseDisciplineSumAggregateOutputType | null
    _min: CourseDisciplineMinAggregateOutputType | null
    _max: CourseDisciplineMaxAggregateOutputType | null
  }

  type GetCourseDisciplineGroupByPayload<T extends CourseDisciplineGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CourseDisciplineGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CourseDisciplineGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CourseDisciplineGroupByOutputType[P]>
            : GetScalarType<T[P], CourseDisciplineGroupByOutputType[P]>
        }
      >
    >


  export type CourseDisciplineSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    courseId?: boolean
    disciplineId?: boolean
    semesterId?: boolean
    credits?: boolean
    course?: boolean | CourseDefaultArgs<ExtArgs>
    discipline?: boolean | DisciplineDefaultArgs<ExtArgs>
    semester?: boolean | AcademicSemesterDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["courseDiscipline"]>



  export type CourseDisciplineSelectScalar = {
    id?: boolean
    courseId?: boolean
    disciplineId?: boolean
    semesterId?: boolean
    credits?: boolean
  }

  export type CourseDisciplineOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "courseId" | "disciplineId" | "semesterId" | "credits", ExtArgs["result"]["courseDiscipline"]>
  export type CourseDisciplineInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    course?: boolean | CourseDefaultArgs<ExtArgs>
    discipline?: boolean | DisciplineDefaultArgs<ExtArgs>
    semester?: boolean | AcademicSemesterDefaultArgs<ExtArgs>
  }

  export type $CourseDisciplinePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CourseDiscipline"
    objects: {
      course: Prisma.$CoursePayload<ExtArgs>
      discipline: Prisma.$DisciplinePayload<ExtArgs>
      semester: Prisma.$AcademicSemesterPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      courseId: string
      disciplineId: string
      semesterId: string
      credits: number
    }, ExtArgs["result"]["courseDiscipline"]>
    composites: {}
  }

  type CourseDisciplineGetPayload<S extends boolean | null | undefined | CourseDisciplineDefaultArgs> = $Result.GetResult<Prisma.$CourseDisciplinePayload, S>

  type CourseDisciplineCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CourseDisciplineFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CourseDisciplineCountAggregateInputType | true
    }

  export interface CourseDisciplineDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CourseDiscipline'], meta: { name: 'CourseDiscipline' } }
    /**
     * Find zero or one CourseDiscipline that matches the filter.
     * @param {CourseDisciplineFindUniqueArgs} args - Arguments to find a CourseDiscipline
     * @example
     * // Get one CourseDiscipline
     * const courseDiscipline = await prisma.courseDiscipline.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CourseDisciplineFindUniqueArgs>(args: SelectSubset<T, CourseDisciplineFindUniqueArgs<ExtArgs>>): Prisma__CourseDisciplineClient<$Result.GetResult<Prisma.$CourseDisciplinePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CourseDiscipline that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CourseDisciplineFindUniqueOrThrowArgs} args - Arguments to find a CourseDiscipline
     * @example
     * // Get one CourseDiscipline
     * const courseDiscipline = await prisma.courseDiscipline.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CourseDisciplineFindUniqueOrThrowArgs>(args: SelectSubset<T, CourseDisciplineFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CourseDisciplineClient<$Result.GetResult<Prisma.$CourseDisciplinePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CourseDiscipline that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseDisciplineFindFirstArgs} args - Arguments to find a CourseDiscipline
     * @example
     * // Get one CourseDiscipline
     * const courseDiscipline = await prisma.courseDiscipline.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CourseDisciplineFindFirstArgs>(args?: SelectSubset<T, CourseDisciplineFindFirstArgs<ExtArgs>>): Prisma__CourseDisciplineClient<$Result.GetResult<Prisma.$CourseDisciplinePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CourseDiscipline that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseDisciplineFindFirstOrThrowArgs} args - Arguments to find a CourseDiscipline
     * @example
     * // Get one CourseDiscipline
     * const courseDiscipline = await prisma.courseDiscipline.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CourseDisciplineFindFirstOrThrowArgs>(args?: SelectSubset<T, CourseDisciplineFindFirstOrThrowArgs<ExtArgs>>): Prisma__CourseDisciplineClient<$Result.GetResult<Prisma.$CourseDisciplinePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CourseDisciplines that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseDisciplineFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CourseDisciplines
     * const courseDisciplines = await prisma.courseDiscipline.findMany()
     * 
     * // Get first 10 CourseDisciplines
     * const courseDisciplines = await prisma.courseDiscipline.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const courseDisciplineWithIdOnly = await prisma.courseDiscipline.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CourseDisciplineFindManyArgs>(args?: SelectSubset<T, CourseDisciplineFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CourseDisciplinePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CourseDiscipline.
     * @param {CourseDisciplineCreateArgs} args - Arguments to create a CourseDiscipline.
     * @example
     * // Create one CourseDiscipline
     * const CourseDiscipline = await prisma.courseDiscipline.create({
     *   data: {
     *     // ... data to create a CourseDiscipline
     *   }
     * })
     * 
     */
    create<T extends CourseDisciplineCreateArgs>(args: SelectSubset<T, CourseDisciplineCreateArgs<ExtArgs>>): Prisma__CourseDisciplineClient<$Result.GetResult<Prisma.$CourseDisciplinePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CourseDisciplines.
     * @param {CourseDisciplineCreateManyArgs} args - Arguments to create many CourseDisciplines.
     * @example
     * // Create many CourseDisciplines
     * const courseDiscipline = await prisma.courseDiscipline.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CourseDisciplineCreateManyArgs>(args?: SelectSubset<T, CourseDisciplineCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a CourseDiscipline.
     * @param {CourseDisciplineDeleteArgs} args - Arguments to delete one CourseDiscipline.
     * @example
     * // Delete one CourseDiscipline
     * const CourseDiscipline = await prisma.courseDiscipline.delete({
     *   where: {
     *     // ... filter to delete one CourseDiscipline
     *   }
     * })
     * 
     */
    delete<T extends CourseDisciplineDeleteArgs>(args: SelectSubset<T, CourseDisciplineDeleteArgs<ExtArgs>>): Prisma__CourseDisciplineClient<$Result.GetResult<Prisma.$CourseDisciplinePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CourseDiscipline.
     * @param {CourseDisciplineUpdateArgs} args - Arguments to update one CourseDiscipline.
     * @example
     * // Update one CourseDiscipline
     * const courseDiscipline = await prisma.courseDiscipline.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CourseDisciplineUpdateArgs>(args: SelectSubset<T, CourseDisciplineUpdateArgs<ExtArgs>>): Prisma__CourseDisciplineClient<$Result.GetResult<Prisma.$CourseDisciplinePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CourseDisciplines.
     * @param {CourseDisciplineDeleteManyArgs} args - Arguments to filter CourseDisciplines to delete.
     * @example
     * // Delete a few CourseDisciplines
     * const { count } = await prisma.courseDiscipline.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CourseDisciplineDeleteManyArgs>(args?: SelectSubset<T, CourseDisciplineDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CourseDisciplines.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseDisciplineUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CourseDisciplines
     * const courseDiscipline = await prisma.courseDiscipline.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CourseDisciplineUpdateManyArgs>(args: SelectSubset<T, CourseDisciplineUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CourseDiscipline.
     * @param {CourseDisciplineUpsertArgs} args - Arguments to update or create a CourseDiscipline.
     * @example
     * // Update or create a CourseDiscipline
     * const courseDiscipline = await prisma.courseDiscipline.upsert({
     *   create: {
     *     // ... data to create a CourseDiscipline
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CourseDiscipline we want to update
     *   }
     * })
     */
    upsert<T extends CourseDisciplineUpsertArgs>(args: SelectSubset<T, CourseDisciplineUpsertArgs<ExtArgs>>): Prisma__CourseDisciplineClient<$Result.GetResult<Prisma.$CourseDisciplinePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CourseDisciplines.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseDisciplineCountArgs} args - Arguments to filter CourseDisciplines to count.
     * @example
     * // Count the number of CourseDisciplines
     * const count = await prisma.courseDiscipline.count({
     *   where: {
     *     // ... the filter for the CourseDisciplines we want to count
     *   }
     * })
    **/
    count<T extends CourseDisciplineCountArgs>(
      args?: Subset<T, CourseDisciplineCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CourseDisciplineCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CourseDiscipline.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseDisciplineAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CourseDisciplineAggregateArgs>(args: Subset<T, CourseDisciplineAggregateArgs>): Prisma.PrismaPromise<GetCourseDisciplineAggregateType<T>>

    /**
     * Group by CourseDiscipline.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseDisciplineGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CourseDisciplineGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CourseDisciplineGroupByArgs['orderBy'] }
        : { orderBy?: CourseDisciplineGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CourseDisciplineGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCourseDisciplineGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CourseDiscipline model
   */
  readonly fields: CourseDisciplineFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CourseDiscipline.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CourseDisciplineClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    course<T extends CourseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CourseDefaultArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    discipline<T extends DisciplineDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DisciplineDefaultArgs<ExtArgs>>): Prisma__DisciplineClient<$Result.GetResult<Prisma.$DisciplinePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    semester<T extends AcademicSemesterDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AcademicSemesterDefaultArgs<ExtArgs>>): Prisma__AcademicSemesterClient<$Result.GetResult<Prisma.$AcademicSemesterPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CourseDiscipline model
   */
  interface CourseDisciplineFieldRefs {
    readonly id: FieldRef<"CourseDiscipline", 'String'>
    readonly courseId: FieldRef<"CourseDiscipline", 'String'>
    readonly disciplineId: FieldRef<"CourseDiscipline", 'String'>
    readonly semesterId: FieldRef<"CourseDiscipline", 'String'>
    readonly credits: FieldRef<"CourseDiscipline", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * CourseDiscipline findUnique
   */
  export type CourseDisciplineFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseDiscipline
     */
    select?: CourseDisciplineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseDiscipline
     */
    omit?: CourseDisciplineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseDisciplineInclude<ExtArgs> | null
    /**
     * Filter, which CourseDiscipline to fetch.
     */
    where: CourseDisciplineWhereUniqueInput
  }

  /**
   * CourseDiscipline findUniqueOrThrow
   */
  export type CourseDisciplineFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseDiscipline
     */
    select?: CourseDisciplineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseDiscipline
     */
    omit?: CourseDisciplineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseDisciplineInclude<ExtArgs> | null
    /**
     * Filter, which CourseDiscipline to fetch.
     */
    where: CourseDisciplineWhereUniqueInput
  }

  /**
   * CourseDiscipline findFirst
   */
  export type CourseDisciplineFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseDiscipline
     */
    select?: CourseDisciplineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseDiscipline
     */
    omit?: CourseDisciplineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseDisciplineInclude<ExtArgs> | null
    /**
     * Filter, which CourseDiscipline to fetch.
     */
    where?: CourseDisciplineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CourseDisciplines to fetch.
     */
    orderBy?: CourseDisciplineOrderByWithRelationInput | CourseDisciplineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CourseDisciplines.
     */
    cursor?: CourseDisciplineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CourseDisciplines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CourseDisciplines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CourseDisciplines.
     */
    distinct?: CourseDisciplineScalarFieldEnum | CourseDisciplineScalarFieldEnum[]
  }

  /**
   * CourseDiscipline findFirstOrThrow
   */
  export type CourseDisciplineFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseDiscipline
     */
    select?: CourseDisciplineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseDiscipline
     */
    omit?: CourseDisciplineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseDisciplineInclude<ExtArgs> | null
    /**
     * Filter, which CourseDiscipline to fetch.
     */
    where?: CourseDisciplineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CourseDisciplines to fetch.
     */
    orderBy?: CourseDisciplineOrderByWithRelationInput | CourseDisciplineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CourseDisciplines.
     */
    cursor?: CourseDisciplineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CourseDisciplines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CourseDisciplines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CourseDisciplines.
     */
    distinct?: CourseDisciplineScalarFieldEnum | CourseDisciplineScalarFieldEnum[]
  }

  /**
   * CourseDiscipline findMany
   */
  export type CourseDisciplineFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseDiscipline
     */
    select?: CourseDisciplineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseDiscipline
     */
    omit?: CourseDisciplineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseDisciplineInclude<ExtArgs> | null
    /**
     * Filter, which CourseDisciplines to fetch.
     */
    where?: CourseDisciplineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CourseDisciplines to fetch.
     */
    orderBy?: CourseDisciplineOrderByWithRelationInput | CourseDisciplineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CourseDisciplines.
     */
    cursor?: CourseDisciplineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CourseDisciplines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CourseDisciplines.
     */
    skip?: number
    distinct?: CourseDisciplineScalarFieldEnum | CourseDisciplineScalarFieldEnum[]
  }

  /**
   * CourseDiscipline create
   */
  export type CourseDisciplineCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseDiscipline
     */
    select?: CourseDisciplineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseDiscipline
     */
    omit?: CourseDisciplineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseDisciplineInclude<ExtArgs> | null
    /**
     * The data needed to create a CourseDiscipline.
     */
    data: XOR<CourseDisciplineCreateInput, CourseDisciplineUncheckedCreateInput>
  }

  /**
   * CourseDiscipline createMany
   */
  export type CourseDisciplineCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CourseDisciplines.
     */
    data: CourseDisciplineCreateManyInput | CourseDisciplineCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CourseDiscipline update
   */
  export type CourseDisciplineUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseDiscipline
     */
    select?: CourseDisciplineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseDiscipline
     */
    omit?: CourseDisciplineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseDisciplineInclude<ExtArgs> | null
    /**
     * The data needed to update a CourseDiscipline.
     */
    data: XOR<CourseDisciplineUpdateInput, CourseDisciplineUncheckedUpdateInput>
    /**
     * Choose, which CourseDiscipline to update.
     */
    where: CourseDisciplineWhereUniqueInput
  }

  /**
   * CourseDiscipline updateMany
   */
  export type CourseDisciplineUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CourseDisciplines.
     */
    data: XOR<CourseDisciplineUpdateManyMutationInput, CourseDisciplineUncheckedUpdateManyInput>
    /**
     * Filter which CourseDisciplines to update
     */
    where?: CourseDisciplineWhereInput
    /**
     * Limit how many CourseDisciplines to update.
     */
    limit?: number
  }

  /**
   * CourseDiscipline upsert
   */
  export type CourseDisciplineUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseDiscipline
     */
    select?: CourseDisciplineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseDiscipline
     */
    omit?: CourseDisciplineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseDisciplineInclude<ExtArgs> | null
    /**
     * The filter to search for the CourseDiscipline to update in case it exists.
     */
    where: CourseDisciplineWhereUniqueInput
    /**
     * In case the CourseDiscipline found by the `where` argument doesn't exist, create a new CourseDiscipline with this data.
     */
    create: XOR<CourseDisciplineCreateInput, CourseDisciplineUncheckedCreateInput>
    /**
     * In case the CourseDiscipline was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CourseDisciplineUpdateInput, CourseDisciplineUncheckedUpdateInput>
  }

  /**
   * CourseDiscipline delete
   */
  export type CourseDisciplineDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseDiscipline
     */
    select?: CourseDisciplineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseDiscipline
     */
    omit?: CourseDisciplineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseDisciplineInclude<ExtArgs> | null
    /**
     * Filter which CourseDiscipline to delete.
     */
    where: CourseDisciplineWhereUniqueInput
  }

  /**
   * CourseDiscipline deleteMany
   */
  export type CourseDisciplineDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CourseDisciplines to delete
     */
    where?: CourseDisciplineWhereInput
    /**
     * Limit how many CourseDisciplines to delete.
     */
    limit?: number
  }

  /**
   * CourseDiscipline without action
   */
  export type CourseDisciplineDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseDiscipline
     */
    select?: CourseDisciplineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseDiscipline
     */
    omit?: CourseDisciplineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseDisciplineInclude<ExtArgs> | null
  }


  /**
   * Model StudentCarriedCourse
   */

  export type AggregateStudentCarriedCourse = {
    _count: StudentCarriedCourseCountAggregateOutputType | null
    _avg: StudentCarriedCourseAvgAggregateOutputType | null
    _sum: StudentCarriedCourseSumAggregateOutputType | null
    _min: StudentCarriedCourseMinAggregateOutputType | null
    _max: StudentCarriedCourseMaxAggregateOutputType | null
  }

  export type StudentCarriedCourseAvgAggregateOutputType = {
    price: number | null
  }

  export type StudentCarriedCourseSumAggregateOutputType = {
    price: number | null
  }

  export type StudentCarriedCourseMinAggregateOutputType = {
    id: string | null
    studentId: string | null
    disciplineId: string | null
    semesterId: string | null
    shift: $Enums.Shift | null
    price: number | null
    status: $Enums.CarriedCourseStatus | null
    createdAt: Date | null
  }

  export type StudentCarriedCourseMaxAggregateOutputType = {
    id: string | null
    studentId: string | null
    disciplineId: string | null
    semesterId: string | null
    shift: $Enums.Shift | null
    price: number | null
    status: $Enums.CarriedCourseStatus | null
    createdAt: Date | null
  }

  export type StudentCarriedCourseCountAggregateOutputType = {
    id: number
    studentId: number
    disciplineId: number
    semesterId: number
    shift: number
    price: number
    status: number
    createdAt: number
    _all: number
  }


  export type StudentCarriedCourseAvgAggregateInputType = {
    price?: true
  }

  export type StudentCarriedCourseSumAggregateInputType = {
    price?: true
  }

  export type StudentCarriedCourseMinAggregateInputType = {
    id?: true
    studentId?: true
    disciplineId?: true
    semesterId?: true
    shift?: true
    price?: true
    status?: true
    createdAt?: true
  }

  export type StudentCarriedCourseMaxAggregateInputType = {
    id?: true
    studentId?: true
    disciplineId?: true
    semesterId?: true
    shift?: true
    price?: true
    status?: true
    createdAt?: true
  }

  export type StudentCarriedCourseCountAggregateInputType = {
    id?: true
    studentId?: true
    disciplineId?: true
    semesterId?: true
    shift?: true
    price?: true
    status?: true
    createdAt?: true
    _all?: true
  }

  export type StudentCarriedCourseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StudentCarriedCourse to aggregate.
     */
    where?: StudentCarriedCourseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentCarriedCourses to fetch.
     */
    orderBy?: StudentCarriedCourseOrderByWithRelationInput | StudentCarriedCourseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StudentCarriedCourseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentCarriedCourses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentCarriedCourses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StudentCarriedCourses
    **/
    _count?: true | StudentCarriedCourseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StudentCarriedCourseAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StudentCarriedCourseSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StudentCarriedCourseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StudentCarriedCourseMaxAggregateInputType
  }

  export type GetStudentCarriedCourseAggregateType<T extends StudentCarriedCourseAggregateArgs> = {
        [P in keyof T & keyof AggregateStudentCarriedCourse]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStudentCarriedCourse[P]>
      : GetScalarType<T[P], AggregateStudentCarriedCourse[P]>
  }




  export type StudentCarriedCourseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentCarriedCourseWhereInput
    orderBy?: StudentCarriedCourseOrderByWithAggregationInput | StudentCarriedCourseOrderByWithAggregationInput[]
    by: StudentCarriedCourseScalarFieldEnum[] | StudentCarriedCourseScalarFieldEnum
    having?: StudentCarriedCourseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StudentCarriedCourseCountAggregateInputType | true
    _avg?: StudentCarriedCourseAvgAggregateInputType
    _sum?: StudentCarriedCourseSumAggregateInputType
    _min?: StudentCarriedCourseMinAggregateInputType
    _max?: StudentCarriedCourseMaxAggregateInputType
  }

  export type StudentCarriedCourseGroupByOutputType = {
    id: string
    studentId: string
    disciplineId: string
    semesterId: string
    shift: $Enums.Shift
    price: number
    status: $Enums.CarriedCourseStatus
    createdAt: Date
    _count: StudentCarriedCourseCountAggregateOutputType | null
    _avg: StudentCarriedCourseAvgAggregateOutputType | null
    _sum: StudentCarriedCourseSumAggregateOutputType | null
    _min: StudentCarriedCourseMinAggregateOutputType | null
    _max: StudentCarriedCourseMaxAggregateOutputType | null
  }

  type GetStudentCarriedCourseGroupByPayload<T extends StudentCarriedCourseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StudentCarriedCourseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StudentCarriedCourseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StudentCarriedCourseGroupByOutputType[P]>
            : GetScalarType<T[P], StudentCarriedCourseGroupByOutputType[P]>
        }
      >
    >


  export type StudentCarriedCourseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    disciplineId?: boolean
    semesterId?: boolean
    shift?: boolean
    price?: boolean
    status?: boolean
    createdAt?: boolean
    student?: boolean | StudentDefaultArgs<ExtArgs>
    discipline?: boolean | DisciplineDefaultArgs<ExtArgs>
    semester?: boolean | AcademicSemesterDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["studentCarriedCourse"]>



  export type StudentCarriedCourseSelectScalar = {
    id?: boolean
    studentId?: boolean
    disciplineId?: boolean
    semesterId?: boolean
    shift?: boolean
    price?: boolean
    status?: boolean
    createdAt?: boolean
  }

  export type StudentCarriedCourseOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "studentId" | "disciplineId" | "semesterId" | "shift" | "price" | "status" | "createdAt", ExtArgs["result"]["studentCarriedCourse"]>
  export type StudentCarriedCourseInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentDefaultArgs<ExtArgs>
    discipline?: boolean | DisciplineDefaultArgs<ExtArgs>
    semester?: boolean | AcademicSemesterDefaultArgs<ExtArgs>
  }

  export type $StudentCarriedCoursePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "StudentCarriedCourse"
    objects: {
      student: Prisma.$StudentPayload<ExtArgs>
      discipline: Prisma.$DisciplinePayload<ExtArgs>
      semester: Prisma.$AcademicSemesterPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      studentId: string
      disciplineId: string
      semesterId: string
      shift: $Enums.Shift
      price: number
      status: $Enums.CarriedCourseStatus
      createdAt: Date
    }, ExtArgs["result"]["studentCarriedCourse"]>
    composites: {}
  }

  type StudentCarriedCourseGetPayload<S extends boolean | null | undefined | StudentCarriedCourseDefaultArgs> = $Result.GetResult<Prisma.$StudentCarriedCoursePayload, S>

  type StudentCarriedCourseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<StudentCarriedCourseFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: StudentCarriedCourseCountAggregateInputType | true
    }

  export interface StudentCarriedCourseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['StudentCarriedCourse'], meta: { name: 'StudentCarriedCourse' } }
    /**
     * Find zero or one StudentCarriedCourse that matches the filter.
     * @param {StudentCarriedCourseFindUniqueArgs} args - Arguments to find a StudentCarriedCourse
     * @example
     * // Get one StudentCarriedCourse
     * const studentCarriedCourse = await prisma.studentCarriedCourse.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StudentCarriedCourseFindUniqueArgs>(args: SelectSubset<T, StudentCarriedCourseFindUniqueArgs<ExtArgs>>): Prisma__StudentCarriedCourseClient<$Result.GetResult<Prisma.$StudentCarriedCoursePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one StudentCarriedCourse that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {StudentCarriedCourseFindUniqueOrThrowArgs} args - Arguments to find a StudentCarriedCourse
     * @example
     * // Get one StudentCarriedCourse
     * const studentCarriedCourse = await prisma.studentCarriedCourse.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StudentCarriedCourseFindUniqueOrThrowArgs>(args: SelectSubset<T, StudentCarriedCourseFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StudentCarriedCourseClient<$Result.GetResult<Prisma.$StudentCarriedCoursePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StudentCarriedCourse that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentCarriedCourseFindFirstArgs} args - Arguments to find a StudentCarriedCourse
     * @example
     * // Get one StudentCarriedCourse
     * const studentCarriedCourse = await prisma.studentCarriedCourse.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StudentCarriedCourseFindFirstArgs>(args?: SelectSubset<T, StudentCarriedCourseFindFirstArgs<ExtArgs>>): Prisma__StudentCarriedCourseClient<$Result.GetResult<Prisma.$StudentCarriedCoursePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StudentCarriedCourse that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentCarriedCourseFindFirstOrThrowArgs} args - Arguments to find a StudentCarriedCourse
     * @example
     * // Get one StudentCarriedCourse
     * const studentCarriedCourse = await prisma.studentCarriedCourse.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StudentCarriedCourseFindFirstOrThrowArgs>(args?: SelectSubset<T, StudentCarriedCourseFindFirstOrThrowArgs<ExtArgs>>): Prisma__StudentCarriedCourseClient<$Result.GetResult<Prisma.$StudentCarriedCoursePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more StudentCarriedCourses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentCarriedCourseFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StudentCarriedCourses
     * const studentCarriedCourses = await prisma.studentCarriedCourse.findMany()
     * 
     * // Get first 10 StudentCarriedCourses
     * const studentCarriedCourses = await prisma.studentCarriedCourse.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const studentCarriedCourseWithIdOnly = await prisma.studentCarriedCourse.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StudentCarriedCourseFindManyArgs>(args?: SelectSubset<T, StudentCarriedCourseFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentCarriedCoursePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a StudentCarriedCourse.
     * @param {StudentCarriedCourseCreateArgs} args - Arguments to create a StudentCarriedCourse.
     * @example
     * // Create one StudentCarriedCourse
     * const StudentCarriedCourse = await prisma.studentCarriedCourse.create({
     *   data: {
     *     // ... data to create a StudentCarriedCourse
     *   }
     * })
     * 
     */
    create<T extends StudentCarriedCourseCreateArgs>(args: SelectSubset<T, StudentCarriedCourseCreateArgs<ExtArgs>>): Prisma__StudentCarriedCourseClient<$Result.GetResult<Prisma.$StudentCarriedCoursePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many StudentCarriedCourses.
     * @param {StudentCarriedCourseCreateManyArgs} args - Arguments to create many StudentCarriedCourses.
     * @example
     * // Create many StudentCarriedCourses
     * const studentCarriedCourse = await prisma.studentCarriedCourse.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StudentCarriedCourseCreateManyArgs>(args?: SelectSubset<T, StudentCarriedCourseCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a StudentCarriedCourse.
     * @param {StudentCarriedCourseDeleteArgs} args - Arguments to delete one StudentCarriedCourse.
     * @example
     * // Delete one StudentCarriedCourse
     * const StudentCarriedCourse = await prisma.studentCarriedCourse.delete({
     *   where: {
     *     // ... filter to delete one StudentCarriedCourse
     *   }
     * })
     * 
     */
    delete<T extends StudentCarriedCourseDeleteArgs>(args: SelectSubset<T, StudentCarriedCourseDeleteArgs<ExtArgs>>): Prisma__StudentCarriedCourseClient<$Result.GetResult<Prisma.$StudentCarriedCoursePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one StudentCarriedCourse.
     * @param {StudentCarriedCourseUpdateArgs} args - Arguments to update one StudentCarriedCourse.
     * @example
     * // Update one StudentCarriedCourse
     * const studentCarriedCourse = await prisma.studentCarriedCourse.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StudentCarriedCourseUpdateArgs>(args: SelectSubset<T, StudentCarriedCourseUpdateArgs<ExtArgs>>): Prisma__StudentCarriedCourseClient<$Result.GetResult<Prisma.$StudentCarriedCoursePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more StudentCarriedCourses.
     * @param {StudentCarriedCourseDeleteManyArgs} args - Arguments to filter StudentCarriedCourses to delete.
     * @example
     * // Delete a few StudentCarriedCourses
     * const { count } = await prisma.studentCarriedCourse.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StudentCarriedCourseDeleteManyArgs>(args?: SelectSubset<T, StudentCarriedCourseDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StudentCarriedCourses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentCarriedCourseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StudentCarriedCourses
     * const studentCarriedCourse = await prisma.studentCarriedCourse.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StudentCarriedCourseUpdateManyArgs>(args: SelectSubset<T, StudentCarriedCourseUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one StudentCarriedCourse.
     * @param {StudentCarriedCourseUpsertArgs} args - Arguments to update or create a StudentCarriedCourse.
     * @example
     * // Update or create a StudentCarriedCourse
     * const studentCarriedCourse = await prisma.studentCarriedCourse.upsert({
     *   create: {
     *     // ... data to create a StudentCarriedCourse
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StudentCarriedCourse we want to update
     *   }
     * })
     */
    upsert<T extends StudentCarriedCourseUpsertArgs>(args: SelectSubset<T, StudentCarriedCourseUpsertArgs<ExtArgs>>): Prisma__StudentCarriedCourseClient<$Result.GetResult<Prisma.$StudentCarriedCoursePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of StudentCarriedCourses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentCarriedCourseCountArgs} args - Arguments to filter StudentCarriedCourses to count.
     * @example
     * // Count the number of StudentCarriedCourses
     * const count = await prisma.studentCarriedCourse.count({
     *   where: {
     *     // ... the filter for the StudentCarriedCourses we want to count
     *   }
     * })
    **/
    count<T extends StudentCarriedCourseCountArgs>(
      args?: Subset<T, StudentCarriedCourseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StudentCarriedCourseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StudentCarriedCourse.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentCarriedCourseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StudentCarriedCourseAggregateArgs>(args: Subset<T, StudentCarriedCourseAggregateArgs>): Prisma.PrismaPromise<GetStudentCarriedCourseAggregateType<T>>

    /**
     * Group by StudentCarriedCourse.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentCarriedCourseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StudentCarriedCourseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StudentCarriedCourseGroupByArgs['orderBy'] }
        : { orderBy?: StudentCarriedCourseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StudentCarriedCourseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStudentCarriedCourseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the StudentCarriedCourse model
   */
  readonly fields: StudentCarriedCourseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for StudentCarriedCourse.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StudentCarriedCourseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    student<T extends StudentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StudentDefaultArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    discipline<T extends DisciplineDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DisciplineDefaultArgs<ExtArgs>>): Prisma__DisciplineClient<$Result.GetResult<Prisma.$DisciplinePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    semester<T extends AcademicSemesterDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AcademicSemesterDefaultArgs<ExtArgs>>): Prisma__AcademicSemesterClient<$Result.GetResult<Prisma.$AcademicSemesterPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the StudentCarriedCourse model
   */
  interface StudentCarriedCourseFieldRefs {
    readonly id: FieldRef<"StudentCarriedCourse", 'String'>
    readonly studentId: FieldRef<"StudentCarriedCourse", 'String'>
    readonly disciplineId: FieldRef<"StudentCarriedCourse", 'String'>
    readonly semesterId: FieldRef<"StudentCarriedCourse", 'String'>
    readonly shift: FieldRef<"StudentCarriedCourse", 'Shift'>
    readonly price: FieldRef<"StudentCarriedCourse", 'Int'>
    readonly status: FieldRef<"StudentCarriedCourse", 'CarriedCourseStatus'>
    readonly createdAt: FieldRef<"StudentCarriedCourse", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * StudentCarriedCourse findUnique
   */
  export type StudentCarriedCourseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentCarriedCourse
     */
    select?: StudentCarriedCourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentCarriedCourse
     */
    omit?: StudentCarriedCourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentCarriedCourseInclude<ExtArgs> | null
    /**
     * Filter, which StudentCarriedCourse to fetch.
     */
    where: StudentCarriedCourseWhereUniqueInput
  }

  /**
   * StudentCarriedCourse findUniqueOrThrow
   */
  export type StudentCarriedCourseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentCarriedCourse
     */
    select?: StudentCarriedCourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentCarriedCourse
     */
    omit?: StudentCarriedCourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentCarriedCourseInclude<ExtArgs> | null
    /**
     * Filter, which StudentCarriedCourse to fetch.
     */
    where: StudentCarriedCourseWhereUniqueInput
  }

  /**
   * StudentCarriedCourse findFirst
   */
  export type StudentCarriedCourseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentCarriedCourse
     */
    select?: StudentCarriedCourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentCarriedCourse
     */
    omit?: StudentCarriedCourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentCarriedCourseInclude<ExtArgs> | null
    /**
     * Filter, which StudentCarriedCourse to fetch.
     */
    where?: StudentCarriedCourseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentCarriedCourses to fetch.
     */
    orderBy?: StudentCarriedCourseOrderByWithRelationInput | StudentCarriedCourseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StudentCarriedCourses.
     */
    cursor?: StudentCarriedCourseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentCarriedCourses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentCarriedCourses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StudentCarriedCourses.
     */
    distinct?: StudentCarriedCourseScalarFieldEnum | StudentCarriedCourseScalarFieldEnum[]
  }

  /**
   * StudentCarriedCourse findFirstOrThrow
   */
  export type StudentCarriedCourseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentCarriedCourse
     */
    select?: StudentCarriedCourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentCarriedCourse
     */
    omit?: StudentCarriedCourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentCarriedCourseInclude<ExtArgs> | null
    /**
     * Filter, which StudentCarriedCourse to fetch.
     */
    where?: StudentCarriedCourseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentCarriedCourses to fetch.
     */
    orderBy?: StudentCarriedCourseOrderByWithRelationInput | StudentCarriedCourseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StudentCarriedCourses.
     */
    cursor?: StudentCarriedCourseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentCarriedCourses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentCarriedCourses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StudentCarriedCourses.
     */
    distinct?: StudentCarriedCourseScalarFieldEnum | StudentCarriedCourseScalarFieldEnum[]
  }

  /**
   * StudentCarriedCourse findMany
   */
  export type StudentCarriedCourseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentCarriedCourse
     */
    select?: StudentCarriedCourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentCarriedCourse
     */
    omit?: StudentCarriedCourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentCarriedCourseInclude<ExtArgs> | null
    /**
     * Filter, which StudentCarriedCourses to fetch.
     */
    where?: StudentCarriedCourseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentCarriedCourses to fetch.
     */
    orderBy?: StudentCarriedCourseOrderByWithRelationInput | StudentCarriedCourseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StudentCarriedCourses.
     */
    cursor?: StudentCarriedCourseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentCarriedCourses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentCarriedCourses.
     */
    skip?: number
    distinct?: StudentCarriedCourseScalarFieldEnum | StudentCarriedCourseScalarFieldEnum[]
  }

  /**
   * StudentCarriedCourse create
   */
  export type StudentCarriedCourseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentCarriedCourse
     */
    select?: StudentCarriedCourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentCarriedCourse
     */
    omit?: StudentCarriedCourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentCarriedCourseInclude<ExtArgs> | null
    /**
     * The data needed to create a StudentCarriedCourse.
     */
    data: XOR<StudentCarriedCourseCreateInput, StudentCarriedCourseUncheckedCreateInput>
  }

  /**
   * StudentCarriedCourse createMany
   */
  export type StudentCarriedCourseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many StudentCarriedCourses.
     */
    data: StudentCarriedCourseCreateManyInput | StudentCarriedCourseCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * StudentCarriedCourse update
   */
  export type StudentCarriedCourseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentCarriedCourse
     */
    select?: StudentCarriedCourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentCarriedCourse
     */
    omit?: StudentCarriedCourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentCarriedCourseInclude<ExtArgs> | null
    /**
     * The data needed to update a StudentCarriedCourse.
     */
    data: XOR<StudentCarriedCourseUpdateInput, StudentCarriedCourseUncheckedUpdateInput>
    /**
     * Choose, which StudentCarriedCourse to update.
     */
    where: StudentCarriedCourseWhereUniqueInput
  }

  /**
   * StudentCarriedCourse updateMany
   */
  export type StudentCarriedCourseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update StudentCarriedCourses.
     */
    data: XOR<StudentCarriedCourseUpdateManyMutationInput, StudentCarriedCourseUncheckedUpdateManyInput>
    /**
     * Filter which StudentCarriedCourses to update
     */
    where?: StudentCarriedCourseWhereInput
    /**
     * Limit how many StudentCarriedCourses to update.
     */
    limit?: number
  }

  /**
   * StudentCarriedCourse upsert
   */
  export type StudentCarriedCourseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentCarriedCourse
     */
    select?: StudentCarriedCourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentCarriedCourse
     */
    omit?: StudentCarriedCourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentCarriedCourseInclude<ExtArgs> | null
    /**
     * The filter to search for the StudentCarriedCourse to update in case it exists.
     */
    where: StudentCarriedCourseWhereUniqueInput
    /**
     * In case the StudentCarriedCourse found by the `where` argument doesn't exist, create a new StudentCarriedCourse with this data.
     */
    create: XOR<StudentCarriedCourseCreateInput, StudentCarriedCourseUncheckedCreateInput>
    /**
     * In case the StudentCarriedCourse was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StudentCarriedCourseUpdateInput, StudentCarriedCourseUncheckedUpdateInput>
  }

  /**
   * StudentCarriedCourse delete
   */
  export type StudentCarriedCourseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentCarriedCourse
     */
    select?: StudentCarriedCourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentCarriedCourse
     */
    omit?: StudentCarriedCourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentCarriedCourseInclude<ExtArgs> | null
    /**
     * Filter which StudentCarriedCourse to delete.
     */
    where: StudentCarriedCourseWhereUniqueInput
  }

  /**
   * StudentCarriedCourse deleteMany
   */
  export type StudentCarriedCourseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StudentCarriedCourses to delete
     */
    where?: StudentCarriedCourseWhereInput
    /**
     * Limit how many StudentCarriedCourses to delete.
     */
    limit?: number
  }

  /**
   * StudentCarriedCourse without action
   */
  export type StudentCarriedCourseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentCarriedCourse
     */
    select?: StudentCarriedCourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentCarriedCourse
     */
    omit?: StudentCarriedCourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentCarriedCourseInclude<ExtArgs> | null
  }


  /**
   * Model CoursePricing
   */

  export type AggregateCoursePricing = {
    _count: CoursePricingCountAggregateOutputType | null
    _avg: CoursePricingAvgAggregateOutputType | null
    _sum: CoursePricingSumAggregateOutputType | null
    _min: CoursePricingMinAggregateOutputType | null
    _max: CoursePricingMaxAggregateOutputType | null
  }

  export type CoursePricingAvgAggregateOutputType = {
    price: number | null
  }

  export type CoursePricingSumAggregateOutputType = {
    price: number | null
  }

  export type CoursePricingMinAggregateOutputType = {
    id: string | null
    price: number | null
    courseId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CoursePricingMaxAggregateOutputType = {
    id: string | null
    price: number | null
    courseId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CoursePricingCountAggregateOutputType = {
    id: number
    price: number
    courseId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CoursePricingAvgAggregateInputType = {
    price?: true
  }

  export type CoursePricingSumAggregateInputType = {
    price?: true
  }

  export type CoursePricingMinAggregateInputType = {
    id?: true
    price?: true
    courseId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CoursePricingMaxAggregateInputType = {
    id?: true
    price?: true
    courseId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CoursePricingCountAggregateInputType = {
    id?: true
    price?: true
    courseId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CoursePricingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CoursePricing to aggregate.
     */
    where?: CoursePricingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CoursePricings to fetch.
     */
    orderBy?: CoursePricingOrderByWithRelationInput | CoursePricingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CoursePricingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CoursePricings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CoursePricings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CoursePricings
    **/
    _count?: true | CoursePricingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CoursePricingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CoursePricingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CoursePricingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CoursePricingMaxAggregateInputType
  }

  export type GetCoursePricingAggregateType<T extends CoursePricingAggregateArgs> = {
        [P in keyof T & keyof AggregateCoursePricing]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCoursePricing[P]>
      : GetScalarType<T[P], AggregateCoursePricing[P]>
  }




  export type CoursePricingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CoursePricingWhereInput
    orderBy?: CoursePricingOrderByWithAggregationInput | CoursePricingOrderByWithAggregationInput[]
    by: CoursePricingScalarFieldEnum[] | CoursePricingScalarFieldEnum
    having?: CoursePricingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CoursePricingCountAggregateInputType | true
    _avg?: CoursePricingAvgAggregateInputType
    _sum?: CoursePricingSumAggregateInputType
    _min?: CoursePricingMinAggregateInputType
    _max?: CoursePricingMaxAggregateInputType
  }

  export type CoursePricingGroupByOutputType = {
    id: string
    price: number
    courseId: string
    createdAt: Date
    updatedAt: Date
    _count: CoursePricingCountAggregateOutputType | null
    _avg: CoursePricingAvgAggregateOutputType | null
    _sum: CoursePricingSumAggregateOutputType | null
    _min: CoursePricingMinAggregateOutputType | null
    _max: CoursePricingMaxAggregateOutputType | null
  }

  type GetCoursePricingGroupByPayload<T extends CoursePricingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CoursePricingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CoursePricingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CoursePricingGroupByOutputType[P]>
            : GetScalarType<T[P], CoursePricingGroupByOutputType[P]>
        }
      >
    >


  export type CoursePricingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    price?: boolean
    courseId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    course?: boolean | CourseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["coursePricing"]>



  export type CoursePricingSelectScalar = {
    id?: boolean
    price?: boolean
    courseId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CoursePricingOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "price" | "courseId" | "createdAt" | "updatedAt", ExtArgs["result"]["coursePricing"]>
  export type CoursePricingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    course?: boolean | CourseDefaultArgs<ExtArgs>
  }

  export type $CoursePricingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CoursePricing"
    objects: {
      course: Prisma.$CoursePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      price: number
      courseId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["coursePricing"]>
    composites: {}
  }

  type CoursePricingGetPayload<S extends boolean | null | undefined | CoursePricingDefaultArgs> = $Result.GetResult<Prisma.$CoursePricingPayload, S>

  type CoursePricingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CoursePricingFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CoursePricingCountAggregateInputType | true
    }

  export interface CoursePricingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CoursePricing'], meta: { name: 'CoursePricing' } }
    /**
     * Find zero or one CoursePricing that matches the filter.
     * @param {CoursePricingFindUniqueArgs} args - Arguments to find a CoursePricing
     * @example
     * // Get one CoursePricing
     * const coursePricing = await prisma.coursePricing.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CoursePricingFindUniqueArgs>(args: SelectSubset<T, CoursePricingFindUniqueArgs<ExtArgs>>): Prisma__CoursePricingClient<$Result.GetResult<Prisma.$CoursePricingPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CoursePricing that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CoursePricingFindUniqueOrThrowArgs} args - Arguments to find a CoursePricing
     * @example
     * // Get one CoursePricing
     * const coursePricing = await prisma.coursePricing.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CoursePricingFindUniqueOrThrowArgs>(args: SelectSubset<T, CoursePricingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CoursePricingClient<$Result.GetResult<Prisma.$CoursePricingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CoursePricing that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CoursePricingFindFirstArgs} args - Arguments to find a CoursePricing
     * @example
     * // Get one CoursePricing
     * const coursePricing = await prisma.coursePricing.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CoursePricingFindFirstArgs>(args?: SelectSubset<T, CoursePricingFindFirstArgs<ExtArgs>>): Prisma__CoursePricingClient<$Result.GetResult<Prisma.$CoursePricingPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CoursePricing that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CoursePricingFindFirstOrThrowArgs} args - Arguments to find a CoursePricing
     * @example
     * // Get one CoursePricing
     * const coursePricing = await prisma.coursePricing.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CoursePricingFindFirstOrThrowArgs>(args?: SelectSubset<T, CoursePricingFindFirstOrThrowArgs<ExtArgs>>): Prisma__CoursePricingClient<$Result.GetResult<Prisma.$CoursePricingPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CoursePricings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CoursePricingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CoursePricings
     * const coursePricings = await prisma.coursePricing.findMany()
     * 
     * // Get first 10 CoursePricings
     * const coursePricings = await prisma.coursePricing.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const coursePricingWithIdOnly = await prisma.coursePricing.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CoursePricingFindManyArgs>(args?: SelectSubset<T, CoursePricingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CoursePricingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CoursePricing.
     * @param {CoursePricingCreateArgs} args - Arguments to create a CoursePricing.
     * @example
     * // Create one CoursePricing
     * const CoursePricing = await prisma.coursePricing.create({
     *   data: {
     *     // ... data to create a CoursePricing
     *   }
     * })
     * 
     */
    create<T extends CoursePricingCreateArgs>(args: SelectSubset<T, CoursePricingCreateArgs<ExtArgs>>): Prisma__CoursePricingClient<$Result.GetResult<Prisma.$CoursePricingPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CoursePricings.
     * @param {CoursePricingCreateManyArgs} args - Arguments to create many CoursePricings.
     * @example
     * // Create many CoursePricings
     * const coursePricing = await prisma.coursePricing.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CoursePricingCreateManyArgs>(args?: SelectSubset<T, CoursePricingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a CoursePricing.
     * @param {CoursePricingDeleteArgs} args - Arguments to delete one CoursePricing.
     * @example
     * // Delete one CoursePricing
     * const CoursePricing = await prisma.coursePricing.delete({
     *   where: {
     *     // ... filter to delete one CoursePricing
     *   }
     * })
     * 
     */
    delete<T extends CoursePricingDeleteArgs>(args: SelectSubset<T, CoursePricingDeleteArgs<ExtArgs>>): Prisma__CoursePricingClient<$Result.GetResult<Prisma.$CoursePricingPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CoursePricing.
     * @param {CoursePricingUpdateArgs} args - Arguments to update one CoursePricing.
     * @example
     * // Update one CoursePricing
     * const coursePricing = await prisma.coursePricing.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CoursePricingUpdateArgs>(args: SelectSubset<T, CoursePricingUpdateArgs<ExtArgs>>): Prisma__CoursePricingClient<$Result.GetResult<Prisma.$CoursePricingPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CoursePricings.
     * @param {CoursePricingDeleteManyArgs} args - Arguments to filter CoursePricings to delete.
     * @example
     * // Delete a few CoursePricings
     * const { count } = await prisma.coursePricing.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CoursePricingDeleteManyArgs>(args?: SelectSubset<T, CoursePricingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CoursePricings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CoursePricingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CoursePricings
     * const coursePricing = await prisma.coursePricing.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CoursePricingUpdateManyArgs>(args: SelectSubset<T, CoursePricingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CoursePricing.
     * @param {CoursePricingUpsertArgs} args - Arguments to update or create a CoursePricing.
     * @example
     * // Update or create a CoursePricing
     * const coursePricing = await prisma.coursePricing.upsert({
     *   create: {
     *     // ... data to create a CoursePricing
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CoursePricing we want to update
     *   }
     * })
     */
    upsert<T extends CoursePricingUpsertArgs>(args: SelectSubset<T, CoursePricingUpsertArgs<ExtArgs>>): Prisma__CoursePricingClient<$Result.GetResult<Prisma.$CoursePricingPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CoursePricings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CoursePricingCountArgs} args - Arguments to filter CoursePricings to count.
     * @example
     * // Count the number of CoursePricings
     * const count = await prisma.coursePricing.count({
     *   where: {
     *     // ... the filter for the CoursePricings we want to count
     *   }
     * })
    **/
    count<T extends CoursePricingCountArgs>(
      args?: Subset<T, CoursePricingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CoursePricingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CoursePricing.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CoursePricingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CoursePricingAggregateArgs>(args: Subset<T, CoursePricingAggregateArgs>): Prisma.PrismaPromise<GetCoursePricingAggregateType<T>>

    /**
     * Group by CoursePricing.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CoursePricingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CoursePricingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CoursePricingGroupByArgs['orderBy'] }
        : { orderBy?: CoursePricingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CoursePricingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCoursePricingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CoursePricing model
   */
  readonly fields: CoursePricingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CoursePricing.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CoursePricingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    course<T extends CourseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CourseDefaultArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CoursePricing model
   */
  interface CoursePricingFieldRefs {
    readonly id: FieldRef<"CoursePricing", 'String'>
    readonly price: FieldRef<"CoursePricing", 'Float'>
    readonly courseId: FieldRef<"CoursePricing", 'String'>
    readonly createdAt: FieldRef<"CoursePricing", 'DateTime'>
    readonly updatedAt: FieldRef<"CoursePricing", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CoursePricing findUnique
   */
  export type CoursePricingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoursePricing
     */
    select?: CoursePricingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CoursePricing
     */
    omit?: CoursePricingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoursePricingInclude<ExtArgs> | null
    /**
     * Filter, which CoursePricing to fetch.
     */
    where: CoursePricingWhereUniqueInput
  }

  /**
   * CoursePricing findUniqueOrThrow
   */
  export type CoursePricingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoursePricing
     */
    select?: CoursePricingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CoursePricing
     */
    omit?: CoursePricingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoursePricingInclude<ExtArgs> | null
    /**
     * Filter, which CoursePricing to fetch.
     */
    where: CoursePricingWhereUniqueInput
  }

  /**
   * CoursePricing findFirst
   */
  export type CoursePricingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoursePricing
     */
    select?: CoursePricingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CoursePricing
     */
    omit?: CoursePricingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoursePricingInclude<ExtArgs> | null
    /**
     * Filter, which CoursePricing to fetch.
     */
    where?: CoursePricingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CoursePricings to fetch.
     */
    orderBy?: CoursePricingOrderByWithRelationInput | CoursePricingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CoursePricings.
     */
    cursor?: CoursePricingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CoursePricings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CoursePricings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CoursePricings.
     */
    distinct?: CoursePricingScalarFieldEnum | CoursePricingScalarFieldEnum[]
  }

  /**
   * CoursePricing findFirstOrThrow
   */
  export type CoursePricingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoursePricing
     */
    select?: CoursePricingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CoursePricing
     */
    omit?: CoursePricingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoursePricingInclude<ExtArgs> | null
    /**
     * Filter, which CoursePricing to fetch.
     */
    where?: CoursePricingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CoursePricings to fetch.
     */
    orderBy?: CoursePricingOrderByWithRelationInput | CoursePricingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CoursePricings.
     */
    cursor?: CoursePricingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CoursePricings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CoursePricings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CoursePricings.
     */
    distinct?: CoursePricingScalarFieldEnum | CoursePricingScalarFieldEnum[]
  }

  /**
   * CoursePricing findMany
   */
  export type CoursePricingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoursePricing
     */
    select?: CoursePricingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CoursePricing
     */
    omit?: CoursePricingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoursePricingInclude<ExtArgs> | null
    /**
     * Filter, which CoursePricings to fetch.
     */
    where?: CoursePricingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CoursePricings to fetch.
     */
    orderBy?: CoursePricingOrderByWithRelationInput | CoursePricingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CoursePricings.
     */
    cursor?: CoursePricingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CoursePricings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CoursePricings.
     */
    skip?: number
    distinct?: CoursePricingScalarFieldEnum | CoursePricingScalarFieldEnum[]
  }

  /**
   * CoursePricing create
   */
  export type CoursePricingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoursePricing
     */
    select?: CoursePricingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CoursePricing
     */
    omit?: CoursePricingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoursePricingInclude<ExtArgs> | null
    /**
     * The data needed to create a CoursePricing.
     */
    data: XOR<CoursePricingCreateInput, CoursePricingUncheckedCreateInput>
  }

  /**
   * CoursePricing createMany
   */
  export type CoursePricingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CoursePricings.
     */
    data: CoursePricingCreateManyInput | CoursePricingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CoursePricing update
   */
  export type CoursePricingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoursePricing
     */
    select?: CoursePricingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CoursePricing
     */
    omit?: CoursePricingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoursePricingInclude<ExtArgs> | null
    /**
     * The data needed to update a CoursePricing.
     */
    data: XOR<CoursePricingUpdateInput, CoursePricingUncheckedUpdateInput>
    /**
     * Choose, which CoursePricing to update.
     */
    where: CoursePricingWhereUniqueInput
  }

  /**
   * CoursePricing updateMany
   */
  export type CoursePricingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CoursePricings.
     */
    data: XOR<CoursePricingUpdateManyMutationInput, CoursePricingUncheckedUpdateManyInput>
    /**
     * Filter which CoursePricings to update
     */
    where?: CoursePricingWhereInput
    /**
     * Limit how many CoursePricings to update.
     */
    limit?: number
  }

  /**
   * CoursePricing upsert
   */
  export type CoursePricingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoursePricing
     */
    select?: CoursePricingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CoursePricing
     */
    omit?: CoursePricingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoursePricingInclude<ExtArgs> | null
    /**
     * The filter to search for the CoursePricing to update in case it exists.
     */
    where: CoursePricingWhereUniqueInput
    /**
     * In case the CoursePricing found by the `where` argument doesn't exist, create a new CoursePricing with this data.
     */
    create: XOR<CoursePricingCreateInput, CoursePricingUncheckedCreateInput>
    /**
     * In case the CoursePricing was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CoursePricingUpdateInput, CoursePricingUncheckedUpdateInput>
  }

  /**
   * CoursePricing delete
   */
  export type CoursePricingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoursePricing
     */
    select?: CoursePricingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CoursePricing
     */
    omit?: CoursePricingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoursePricingInclude<ExtArgs> | null
    /**
     * Filter which CoursePricing to delete.
     */
    where: CoursePricingWhereUniqueInput
  }

  /**
   * CoursePricing deleteMany
   */
  export type CoursePricingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CoursePricings to delete
     */
    where?: CoursePricingWhereInput
    /**
     * Limit how many CoursePricings to delete.
     */
    limit?: number
  }

  /**
   * CoursePricing without action
   */
  export type CoursePricingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoursePricing
     */
    select?: CoursePricingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CoursePricing
     */
    omit?: CoursePricingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoursePricingInclude<ExtArgs> | null
  }


  /**
   * Model Discipline
   */

  export type AggregateDiscipline = {
    _count: DisciplineCountAggregateOutputType | null
    _avg: DisciplineAvgAggregateOutputType | null
    _sum: DisciplineSumAggregateOutputType | null
    _min: DisciplineMinAggregateOutputType | null
    _max: DisciplineMaxAggregateOutputType | null
  }

  export type DisciplineAvgAggregateOutputType = {
    credits: number | null
    minimumGradeToDismiss: number | null
  }

  export type DisciplineSumAggregateOutputType = {
    credits: number | null
    minimumGradeToDismiss: number | null
  }

  export type DisciplineMinAggregateOutputType = {
    id: string | null
    name: string | null
    code: string | null
    description: string | null
    credits: number | null
    minimumGradeToDismiss: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DisciplineMaxAggregateOutputType = {
    id: string | null
    name: string | null
    code: string | null
    description: string | null
    credits: number | null
    minimumGradeToDismiss: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DisciplineCountAggregateOutputType = {
    id: number
    name: number
    code: number
    description: number
    credits: number
    minimumGradeToDismiss: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DisciplineAvgAggregateInputType = {
    credits?: true
    minimumGradeToDismiss?: true
  }

  export type DisciplineSumAggregateInputType = {
    credits?: true
    minimumGradeToDismiss?: true
  }

  export type DisciplineMinAggregateInputType = {
    id?: true
    name?: true
    code?: true
    description?: true
    credits?: true
    minimumGradeToDismiss?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DisciplineMaxAggregateInputType = {
    id?: true
    name?: true
    code?: true
    description?: true
    credits?: true
    minimumGradeToDismiss?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DisciplineCountAggregateInputType = {
    id?: true
    name?: true
    code?: true
    description?: true
    credits?: true
    minimumGradeToDismiss?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DisciplineAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Discipline to aggregate.
     */
    where?: DisciplineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Disciplines to fetch.
     */
    orderBy?: DisciplineOrderByWithRelationInput | DisciplineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DisciplineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Disciplines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Disciplines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Disciplines
    **/
    _count?: true | DisciplineCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DisciplineAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DisciplineSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DisciplineMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DisciplineMaxAggregateInputType
  }

  export type GetDisciplineAggregateType<T extends DisciplineAggregateArgs> = {
        [P in keyof T & keyof AggregateDiscipline]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDiscipline[P]>
      : GetScalarType<T[P], AggregateDiscipline[P]>
  }




  export type DisciplineGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DisciplineWhereInput
    orderBy?: DisciplineOrderByWithAggregationInput | DisciplineOrderByWithAggregationInput[]
    by: DisciplineScalarFieldEnum[] | DisciplineScalarFieldEnum
    having?: DisciplineScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DisciplineCountAggregateInputType | true
    _avg?: DisciplineAvgAggregateInputType
    _sum?: DisciplineSumAggregateInputType
    _min?: DisciplineMinAggregateInputType
    _max?: DisciplineMaxAggregateInputType
  }

  export type DisciplineGroupByOutputType = {
    id: string
    name: string
    code: string
    description: string | null
    credits: number
    minimumGradeToDismiss: number
    createdAt: Date
    updatedAt: Date
    _count: DisciplineCountAggregateOutputType | null
    _avg: DisciplineAvgAggregateOutputType | null
    _sum: DisciplineSumAggregateOutputType | null
    _min: DisciplineMinAggregateOutputType | null
    _max: DisciplineMaxAggregateOutputType | null
  }

  type GetDisciplineGroupByPayload<T extends DisciplineGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DisciplineGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DisciplineGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DisciplineGroupByOutputType[P]>
            : GetScalarType<T[P], DisciplineGroupByOutputType[P]>
        }
      >
    >


  export type DisciplineSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    code?: boolean
    description?: boolean
    credits?: boolean
    minimumGradeToDismiss?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    courseDisciplines?: boolean | Discipline$courseDisciplinesArgs<ExtArgs>
    StudentCarriedCourse?: boolean | Discipline$StudentCarriedCourseArgs<ExtArgs>
    _count?: boolean | DisciplineCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["discipline"]>



  export type DisciplineSelectScalar = {
    id?: boolean
    name?: boolean
    code?: boolean
    description?: boolean
    credits?: boolean
    minimumGradeToDismiss?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type DisciplineOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "code" | "description" | "credits" | "minimumGradeToDismiss" | "createdAt" | "updatedAt", ExtArgs["result"]["discipline"]>
  export type DisciplineInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    courseDisciplines?: boolean | Discipline$courseDisciplinesArgs<ExtArgs>
    StudentCarriedCourse?: boolean | Discipline$StudentCarriedCourseArgs<ExtArgs>
    _count?: boolean | DisciplineCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $DisciplinePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Discipline"
    objects: {
      courseDisciplines: Prisma.$CourseDisciplinePayload<ExtArgs>[]
      StudentCarriedCourse: Prisma.$StudentCarriedCoursePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      code: string
      description: string | null
      credits: number
      minimumGradeToDismiss: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["discipline"]>
    composites: {}
  }

  type DisciplineGetPayload<S extends boolean | null | undefined | DisciplineDefaultArgs> = $Result.GetResult<Prisma.$DisciplinePayload, S>

  type DisciplineCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DisciplineFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DisciplineCountAggregateInputType | true
    }

  export interface DisciplineDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Discipline'], meta: { name: 'Discipline' } }
    /**
     * Find zero or one Discipline that matches the filter.
     * @param {DisciplineFindUniqueArgs} args - Arguments to find a Discipline
     * @example
     * // Get one Discipline
     * const discipline = await prisma.discipline.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DisciplineFindUniqueArgs>(args: SelectSubset<T, DisciplineFindUniqueArgs<ExtArgs>>): Prisma__DisciplineClient<$Result.GetResult<Prisma.$DisciplinePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Discipline that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DisciplineFindUniqueOrThrowArgs} args - Arguments to find a Discipline
     * @example
     * // Get one Discipline
     * const discipline = await prisma.discipline.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DisciplineFindUniqueOrThrowArgs>(args: SelectSubset<T, DisciplineFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DisciplineClient<$Result.GetResult<Prisma.$DisciplinePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Discipline that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DisciplineFindFirstArgs} args - Arguments to find a Discipline
     * @example
     * // Get one Discipline
     * const discipline = await prisma.discipline.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DisciplineFindFirstArgs>(args?: SelectSubset<T, DisciplineFindFirstArgs<ExtArgs>>): Prisma__DisciplineClient<$Result.GetResult<Prisma.$DisciplinePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Discipline that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DisciplineFindFirstOrThrowArgs} args - Arguments to find a Discipline
     * @example
     * // Get one Discipline
     * const discipline = await prisma.discipline.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DisciplineFindFirstOrThrowArgs>(args?: SelectSubset<T, DisciplineFindFirstOrThrowArgs<ExtArgs>>): Prisma__DisciplineClient<$Result.GetResult<Prisma.$DisciplinePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Disciplines that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DisciplineFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Disciplines
     * const disciplines = await prisma.discipline.findMany()
     * 
     * // Get first 10 Disciplines
     * const disciplines = await prisma.discipline.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const disciplineWithIdOnly = await prisma.discipline.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DisciplineFindManyArgs>(args?: SelectSubset<T, DisciplineFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DisciplinePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Discipline.
     * @param {DisciplineCreateArgs} args - Arguments to create a Discipline.
     * @example
     * // Create one Discipline
     * const Discipline = await prisma.discipline.create({
     *   data: {
     *     // ... data to create a Discipline
     *   }
     * })
     * 
     */
    create<T extends DisciplineCreateArgs>(args: SelectSubset<T, DisciplineCreateArgs<ExtArgs>>): Prisma__DisciplineClient<$Result.GetResult<Prisma.$DisciplinePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Disciplines.
     * @param {DisciplineCreateManyArgs} args - Arguments to create many Disciplines.
     * @example
     * // Create many Disciplines
     * const discipline = await prisma.discipline.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DisciplineCreateManyArgs>(args?: SelectSubset<T, DisciplineCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Discipline.
     * @param {DisciplineDeleteArgs} args - Arguments to delete one Discipline.
     * @example
     * // Delete one Discipline
     * const Discipline = await prisma.discipline.delete({
     *   where: {
     *     // ... filter to delete one Discipline
     *   }
     * })
     * 
     */
    delete<T extends DisciplineDeleteArgs>(args: SelectSubset<T, DisciplineDeleteArgs<ExtArgs>>): Prisma__DisciplineClient<$Result.GetResult<Prisma.$DisciplinePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Discipline.
     * @param {DisciplineUpdateArgs} args - Arguments to update one Discipline.
     * @example
     * // Update one Discipline
     * const discipline = await prisma.discipline.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DisciplineUpdateArgs>(args: SelectSubset<T, DisciplineUpdateArgs<ExtArgs>>): Prisma__DisciplineClient<$Result.GetResult<Prisma.$DisciplinePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Disciplines.
     * @param {DisciplineDeleteManyArgs} args - Arguments to filter Disciplines to delete.
     * @example
     * // Delete a few Disciplines
     * const { count } = await prisma.discipline.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DisciplineDeleteManyArgs>(args?: SelectSubset<T, DisciplineDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Disciplines.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DisciplineUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Disciplines
     * const discipline = await prisma.discipline.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DisciplineUpdateManyArgs>(args: SelectSubset<T, DisciplineUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Discipline.
     * @param {DisciplineUpsertArgs} args - Arguments to update or create a Discipline.
     * @example
     * // Update or create a Discipline
     * const discipline = await prisma.discipline.upsert({
     *   create: {
     *     // ... data to create a Discipline
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Discipline we want to update
     *   }
     * })
     */
    upsert<T extends DisciplineUpsertArgs>(args: SelectSubset<T, DisciplineUpsertArgs<ExtArgs>>): Prisma__DisciplineClient<$Result.GetResult<Prisma.$DisciplinePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Disciplines.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DisciplineCountArgs} args - Arguments to filter Disciplines to count.
     * @example
     * // Count the number of Disciplines
     * const count = await prisma.discipline.count({
     *   where: {
     *     // ... the filter for the Disciplines we want to count
     *   }
     * })
    **/
    count<T extends DisciplineCountArgs>(
      args?: Subset<T, DisciplineCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DisciplineCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Discipline.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DisciplineAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DisciplineAggregateArgs>(args: Subset<T, DisciplineAggregateArgs>): Prisma.PrismaPromise<GetDisciplineAggregateType<T>>

    /**
     * Group by Discipline.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DisciplineGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DisciplineGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DisciplineGroupByArgs['orderBy'] }
        : { orderBy?: DisciplineGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DisciplineGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDisciplineGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Discipline model
   */
  readonly fields: DisciplineFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Discipline.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DisciplineClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    courseDisciplines<T extends Discipline$courseDisciplinesArgs<ExtArgs> = {}>(args?: Subset<T, Discipline$courseDisciplinesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CourseDisciplinePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    StudentCarriedCourse<T extends Discipline$StudentCarriedCourseArgs<ExtArgs> = {}>(args?: Subset<T, Discipline$StudentCarriedCourseArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentCarriedCoursePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Discipline model
   */
  interface DisciplineFieldRefs {
    readonly id: FieldRef<"Discipline", 'String'>
    readonly name: FieldRef<"Discipline", 'String'>
    readonly code: FieldRef<"Discipline", 'String'>
    readonly description: FieldRef<"Discipline", 'String'>
    readonly credits: FieldRef<"Discipline", 'Int'>
    readonly minimumGradeToDismiss: FieldRef<"Discipline", 'Float'>
    readonly createdAt: FieldRef<"Discipline", 'DateTime'>
    readonly updatedAt: FieldRef<"Discipline", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Discipline findUnique
   */
  export type DisciplineFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Discipline
     */
    select?: DisciplineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Discipline
     */
    omit?: DisciplineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DisciplineInclude<ExtArgs> | null
    /**
     * Filter, which Discipline to fetch.
     */
    where: DisciplineWhereUniqueInput
  }

  /**
   * Discipline findUniqueOrThrow
   */
  export type DisciplineFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Discipline
     */
    select?: DisciplineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Discipline
     */
    omit?: DisciplineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DisciplineInclude<ExtArgs> | null
    /**
     * Filter, which Discipline to fetch.
     */
    where: DisciplineWhereUniqueInput
  }

  /**
   * Discipline findFirst
   */
  export type DisciplineFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Discipline
     */
    select?: DisciplineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Discipline
     */
    omit?: DisciplineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DisciplineInclude<ExtArgs> | null
    /**
     * Filter, which Discipline to fetch.
     */
    where?: DisciplineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Disciplines to fetch.
     */
    orderBy?: DisciplineOrderByWithRelationInput | DisciplineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Disciplines.
     */
    cursor?: DisciplineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Disciplines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Disciplines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Disciplines.
     */
    distinct?: DisciplineScalarFieldEnum | DisciplineScalarFieldEnum[]
  }

  /**
   * Discipline findFirstOrThrow
   */
  export type DisciplineFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Discipline
     */
    select?: DisciplineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Discipline
     */
    omit?: DisciplineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DisciplineInclude<ExtArgs> | null
    /**
     * Filter, which Discipline to fetch.
     */
    where?: DisciplineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Disciplines to fetch.
     */
    orderBy?: DisciplineOrderByWithRelationInput | DisciplineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Disciplines.
     */
    cursor?: DisciplineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Disciplines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Disciplines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Disciplines.
     */
    distinct?: DisciplineScalarFieldEnum | DisciplineScalarFieldEnum[]
  }

  /**
   * Discipline findMany
   */
  export type DisciplineFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Discipline
     */
    select?: DisciplineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Discipline
     */
    omit?: DisciplineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DisciplineInclude<ExtArgs> | null
    /**
     * Filter, which Disciplines to fetch.
     */
    where?: DisciplineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Disciplines to fetch.
     */
    orderBy?: DisciplineOrderByWithRelationInput | DisciplineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Disciplines.
     */
    cursor?: DisciplineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Disciplines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Disciplines.
     */
    skip?: number
    distinct?: DisciplineScalarFieldEnum | DisciplineScalarFieldEnum[]
  }

  /**
   * Discipline create
   */
  export type DisciplineCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Discipline
     */
    select?: DisciplineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Discipline
     */
    omit?: DisciplineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DisciplineInclude<ExtArgs> | null
    /**
     * The data needed to create a Discipline.
     */
    data: XOR<DisciplineCreateInput, DisciplineUncheckedCreateInput>
  }

  /**
   * Discipline createMany
   */
  export type DisciplineCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Disciplines.
     */
    data: DisciplineCreateManyInput | DisciplineCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Discipline update
   */
  export type DisciplineUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Discipline
     */
    select?: DisciplineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Discipline
     */
    omit?: DisciplineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DisciplineInclude<ExtArgs> | null
    /**
     * The data needed to update a Discipline.
     */
    data: XOR<DisciplineUpdateInput, DisciplineUncheckedUpdateInput>
    /**
     * Choose, which Discipline to update.
     */
    where: DisciplineWhereUniqueInput
  }

  /**
   * Discipline updateMany
   */
  export type DisciplineUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Disciplines.
     */
    data: XOR<DisciplineUpdateManyMutationInput, DisciplineUncheckedUpdateManyInput>
    /**
     * Filter which Disciplines to update
     */
    where?: DisciplineWhereInput
    /**
     * Limit how many Disciplines to update.
     */
    limit?: number
  }

  /**
   * Discipline upsert
   */
  export type DisciplineUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Discipline
     */
    select?: DisciplineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Discipline
     */
    omit?: DisciplineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DisciplineInclude<ExtArgs> | null
    /**
     * The filter to search for the Discipline to update in case it exists.
     */
    where: DisciplineWhereUniqueInput
    /**
     * In case the Discipline found by the `where` argument doesn't exist, create a new Discipline with this data.
     */
    create: XOR<DisciplineCreateInput, DisciplineUncheckedCreateInput>
    /**
     * In case the Discipline was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DisciplineUpdateInput, DisciplineUncheckedUpdateInput>
  }

  /**
   * Discipline delete
   */
  export type DisciplineDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Discipline
     */
    select?: DisciplineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Discipline
     */
    omit?: DisciplineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DisciplineInclude<ExtArgs> | null
    /**
     * Filter which Discipline to delete.
     */
    where: DisciplineWhereUniqueInput
  }

  /**
   * Discipline deleteMany
   */
  export type DisciplineDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Disciplines to delete
     */
    where?: DisciplineWhereInput
    /**
     * Limit how many Disciplines to delete.
     */
    limit?: number
  }

  /**
   * Discipline.courseDisciplines
   */
  export type Discipline$courseDisciplinesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseDiscipline
     */
    select?: CourseDisciplineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseDiscipline
     */
    omit?: CourseDisciplineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseDisciplineInclude<ExtArgs> | null
    where?: CourseDisciplineWhereInput
    orderBy?: CourseDisciplineOrderByWithRelationInput | CourseDisciplineOrderByWithRelationInput[]
    cursor?: CourseDisciplineWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CourseDisciplineScalarFieldEnum | CourseDisciplineScalarFieldEnum[]
  }

  /**
   * Discipline.StudentCarriedCourse
   */
  export type Discipline$StudentCarriedCourseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentCarriedCourse
     */
    select?: StudentCarriedCourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentCarriedCourse
     */
    omit?: StudentCarriedCourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentCarriedCourseInclude<ExtArgs> | null
    where?: StudentCarriedCourseWhereInput
    orderBy?: StudentCarriedCourseOrderByWithRelationInput | StudentCarriedCourseOrderByWithRelationInput[]
    cursor?: StudentCarriedCourseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StudentCarriedCourseScalarFieldEnum | StudentCarriedCourseScalarFieldEnum[]
  }

  /**
   * Discipline without action
   */
  export type DisciplineDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Discipline
     */
    select?: DisciplineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Discipline
     */
    omit?: DisciplineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DisciplineInclude<ExtArgs> | null
  }


  /**
   * Model StudentSemesterPayment
   */

  export type AggregateStudentSemesterPayment = {
    _count: StudentSemesterPaymentCountAggregateOutputType | null
    _avg: StudentSemesterPaymentAvgAggregateOutputType | null
    _sum: StudentSemesterPaymentSumAggregateOutputType | null
    _min: StudentSemesterPaymentMinAggregateOutputType | null
    _max: StudentSemesterPaymentMaxAggregateOutputType | null
  }

  export type StudentSemesterPaymentAvgAggregateOutputType = {
    totalPayment: number | null
    baseAmount: number | null
    lateFee: number | null
    paymentMonth: number | null
    paymentYear: number | null
  }

  export type StudentSemesterPaymentSumAggregateOutputType = {
    totalPayment: number | null
    baseAmount: number | null
    lateFee: number | null
    paymentMonth: number | null
    paymentYear: number | null
  }

  export type StudentSemesterPaymentMinAggregateOutputType = {
    id: string | null
    paymentId: string | null
    totalPayment: number | null
    baseAmount: number | null
    lateFee: number | null
    paymentMonth: number | null
    paymentYear: number | null
    createdAt: Date | null
    updatedAt: Date | null
    studentId: string | null
    academicSemesterId: string | null
  }

  export type StudentSemesterPaymentMaxAggregateOutputType = {
    id: string | null
    paymentId: string | null
    totalPayment: number | null
    baseAmount: number | null
    lateFee: number | null
    paymentMonth: number | null
    paymentYear: number | null
    createdAt: Date | null
    updatedAt: Date | null
    studentId: string | null
    academicSemesterId: string | null
  }

  export type StudentSemesterPaymentCountAggregateOutputType = {
    id: number
    paymentId: number
    totalPayment: number
    baseAmount: number
    lateFee: number
    paymentMonth: number
    paymentYear: number
    createdAt: number
    updatedAt: number
    studentId: number
    academicSemesterId: number
    _all: number
  }


  export type StudentSemesterPaymentAvgAggregateInputType = {
    totalPayment?: true
    baseAmount?: true
    lateFee?: true
    paymentMonth?: true
    paymentYear?: true
  }

  export type StudentSemesterPaymentSumAggregateInputType = {
    totalPayment?: true
    baseAmount?: true
    lateFee?: true
    paymentMonth?: true
    paymentYear?: true
  }

  export type StudentSemesterPaymentMinAggregateInputType = {
    id?: true
    paymentId?: true
    totalPayment?: true
    baseAmount?: true
    lateFee?: true
    paymentMonth?: true
    paymentYear?: true
    createdAt?: true
    updatedAt?: true
    studentId?: true
    academicSemesterId?: true
  }

  export type StudentSemesterPaymentMaxAggregateInputType = {
    id?: true
    paymentId?: true
    totalPayment?: true
    baseAmount?: true
    lateFee?: true
    paymentMonth?: true
    paymentYear?: true
    createdAt?: true
    updatedAt?: true
    studentId?: true
    academicSemesterId?: true
  }

  export type StudentSemesterPaymentCountAggregateInputType = {
    id?: true
    paymentId?: true
    totalPayment?: true
    baseAmount?: true
    lateFee?: true
    paymentMonth?: true
    paymentYear?: true
    createdAt?: true
    updatedAt?: true
    studentId?: true
    academicSemesterId?: true
    _all?: true
  }

  export type StudentSemesterPaymentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StudentSemesterPayment to aggregate.
     */
    where?: StudentSemesterPaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentSemesterPayments to fetch.
     */
    orderBy?: StudentSemesterPaymentOrderByWithRelationInput | StudentSemesterPaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StudentSemesterPaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentSemesterPayments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentSemesterPayments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StudentSemesterPayments
    **/
    _count?: true | StudentSemesterPaymentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StudentSemesterPaymentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StudentSemesterPaymentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StudentSemesterPaymentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StudentSemesterPaymentMaxAggregateInputType
  }

  export type GetStudentSemesterPaymentAggregateType<T extends StudentSemesterPaymentAggregateArgs> = {
        [P in keyof T & keyof AggregateStudentSemesterPayment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStudentSemesterPayment[P]>
      : GetScalarType<T[P], AggregateStudentSemesterPayment[P]>
  }




  export type StudentSemesterPaymentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentSemesterPaymentWhereInput
    orderBy?: StudentSemesterPaymentOrderByWithAggregationInput | StudentSemesterPaymentOrderByWithAggregationInput[]
    by: StudentSemesterPaymentScalarFieldEnum[] | StudentSemesterPaymentScalarFieldEnum
    having?: StudentSemesterPaymentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StudentSemesterPaymentCountAggregateInputType | true
    _avg?: StudentSemesterPaymentAvgAggregateInputType
    _sum?: StudentSemesterPaymentSumAggregateInputType
    _min?: StudentSemesterPaymentMinAggregateInputType
    _max?: StudentSemesterPaymentMaxAggregateInputType
  }

  export type StudentSemesterPaymentGroupByOutputType = {
    id: string
    paymentId: string
    totalPayment: number
    baseAmount: number
    lateFee: number
    paymentMonth: number
    paymentYear: number
    createdAt: Date
    updatedAt: Date
    studentId: string
    academicSemesterId: string
    _count: StudentSemesterPaymentCountAggregateOutputType | null
    _avg: StudentSemesterPaymentAvgAggregateOutputType | null
    _sum: StudentSemesterPaymentSumAggregateOutputType | null
    _min: StudentSemesterPaymentMinAggregateOutputType | null
    _max: StudentSemesterPaymentMaxAggregateOutputType | null
  }

  type GetStudentSemesterPaymentGroupByPayload<T extends StudentSemesterPaymentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StudentSemesterPaymentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StudentSemesterPaymentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StudentSemesterPaymentGroupByOutputType[P]>
            : GetScalarType<T[P], StudentSemesterPaymentGroupByOutputType[P]>
        }
      >
    >


  export type StudentSemesterPaymentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    paymentId?: boolean
    totalPayment?: boolean
    baseAmount?: boolean
    lateFee?: boolean
    paymentMonth?: boolean
    paymentYear?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    studentId?: boolean
    academicSemesterId?: boolean
    payment?: boolean | PaymentDefaultArgs<ExtArgs>
    student?: boolean | StudentDefaultArgs<ExtArgs>
    academicSemester?: boolean | AcademicSemesterDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["studentSemesterPayment"]>



  export type StudentSemesterPaymentSelectScalar = {
    id?: boolean
    paymentId?: boolean
    totalPayment?: boolean
    baseAmount?: boolean
    lateFee?: boolean
    paymentMonth?: boolean
    paymentYear?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    studentId?: boolean
    academicSemesterId?: boolean
  }

  export type StudentSemesterPaymentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "paymentId" | "totalPayment" | "baseAmount" | "lateFee" | "paymentMonth" | "paymentYear" | "createdAt" | "updatedAt" | "studentId" | "academicSemesterId", ExtArgs["result"]["studentSemesterPayment"]>
  export type StudentSemesterPaymentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    payment?: boolean | PaymentDefaultArgs<ExtArgs>
    student?: boolean | StudentDefaultArgs<ExtArgs>
    academicSemester?: boolean | AcademicSemesterDefaultArgs<ExtArgs>
  }

  export type $StudentSemesterPaymentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "StudentSemesterPayment"
    objects: {
      payment: Prisma.$PaymentPayload<ExtArgs>
      student: Prisma.$StudentPayload<ExtArgs>
      academicSemester: Prisma.$AcademicSemesterPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      paymentId: string
      totalPayment: number
      baseAmount: number
      lateFee: number
      paymentMonth: number
      paymentYear: number
      createdAt: Date
      updatedAt: Date
      studentId: string
      academicSemesterId: string
    }, ExtArgs["result"]["studentSemesterPayment"]>
    composites: {}
  }

  type StudentSemesterPaymentGetPayload<S extends boolean | null | undefined | StudentSemesterPaymentDefaultArgs> = $Result.GetResult<Prisma.$StudentSemesterPaymentPayload, S>

  type StudentSemesterPaymentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<StudentSemesterPaymentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: StudentSemesterPaymentCountAggregateInputType | true
    }

  export interface StudentSemesterPaymentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['StudentSemesterPayment'], meta: { name: 'StudentSemesterPayment' } }
    /**
     * Find zero or one StudentSemesterPayment that matches the filter.
     * @param {StudentSemesterPaymentFindUniqueArgs} args - Arguments to find a StudentSemesterPayment
     * @example
     * // Get one StudentSemesterPayment
     * const studentSemesterPayment = await prisma.studentSemesterPayment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StudentSemesterPaymentFindUniqueArgs>(args: SelectSubset<T, StudentSemesterPaymentFindUniqueArgs<ExtArgs>>): Prisma__StudentSemesterPaymentClient<$Result.GetResult<Prisma.$StudentSemesterPaymentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one StudentSemesterPayment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {StudentSemesterPaymentFindUniqueOrThrowArgs} args - Arguments to find a StudentSemesterPayment
     * @example
     * // Get one StudentSemesterPayment
     * const studentSemesterPayment = await prisma.studentSemesterPayment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StudentSemesterPaymentFindUniqueOrThrowArgs>(args: SelectSubset<T, StudentSemesterPaymentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StudentSemesterPaymentClient<$Result.GetResult<Prisma.$StudentSemesterPaymentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StudentSemesterPayment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentSemesterPaymentFindFirstArgs} args - Arguments to find a StudentSemesterPayment
     * @example
     * // Get one StudentSemesterPayment
     * const studentSemesterPayment = await prisma.studentSemesterPayment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StudentSemesterPaymentFindFirstArgs>(args?: SelectSubset<T, StudentSemesterPaymentFindFirstArgs<ExtArgs>>): Prisma__StudentSemesterPaymentClient<$Result.GetResult<Prisma.$StudentSemesterPaymentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StudentSemesterPayment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentSemesterPaymentFindFirstOrThrowArgs} args - Arguments to find a StudentSemesterPayment
     * @example
     * // Get one StudentSemesterPayment
     * const studentSemesterPayment = await prisma.studentSemesterPayment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StudentSemesterPaymentFindFirstOrThrowArgs>(args?: SelectSubset<T, StudentSemesterPaymentFindFirstOrThrowArgs<ExtArgs>>): Prisma__StudentSemesterPaymentClient<$Result.GetResult<Prisma.$StudentSemesterPaymentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more StudentSemesterPayments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentSemesterPaymentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StudentSemesterPayments
     * const studentSemesterPayments = await prisma.studentSemesterPayment.findMany()
     * 
     * // Get first 10 StudentSemesterPayments
     * const studentSemesterPayments = await prisma.studentSemesterPayment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const studentSemesterPaymentWithIdOnly = await prisma.studentSemesterPayment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StudentSemesterPaymentFindManyArgs>(args?: SelectSubset<T, StudentSemesterPaymentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentSemesterPaymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a StudentSemesterPayment.
     * @param {StudentSemesterPaymentCreateArgs} args - Arguments to create a StudentSemesterPayment.
     * @example
     * // Create one StudentSemesterPayment
     * const StudentSemesterPayment = await prisma.studentSemesterPayment.create({
     *   data: {
     *     // ... data to create a StudentSemesterPayment
     *   }
     * })
     * 
     */
    create<T extends StudentSemesterPaymentCreateArgs>(args: SelectSubset<T, StudentSemesterPaymentCreateArgs<ExtArgs>>): Prisma__StudentSemesterPaymentClient<$Result.GetResult<Prisma.$StudentSemesterPaymentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many StudentSemesterPayments.
     * @param {StudentSemesterPaymentCreateManyArgs} args - Arguments to create many StudentSemesterPayments.
     * @example
     * // Create many StudentSemesterPayments
     * const studentSemesterPayment = await prisma.studentSemesterPayment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StudentSemesterPaymentCreateManyArgs>(args?: SelectSubset<T, StudentSemesterPaymentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a StudentSemesterPayment.
     * @param {StudentSemesterPaymentDeleteArgs} args - Arguments to delete one StudentSemesterPayment.
     * @example
     * // Delete one StudentSemesterPayment
     * const StudentSemesterPayment = await prisma.studentSemesterPayment.delete({
     *   where: {
     *     // ... filter to delete one StudentSemesterPayment
     *   }
     * })
     * 
     */
    delete<T extends StudentSemesterPaymentDeleteArgs>(args: SelectSubset<T, StudentSemesterPaymentDeleteArgs<ExtArgs>>): Prisma__StudentSemesterPaymentClient<$Result.GetResult<Prisma.$StudentSemesterPaymentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one StudentSemesterPayment.
     * @param {StudentSemesterPaymentUpdateArgs} args - Arguments to update one StudentSemesterPayment.
     * @example
     * // Update one StudentSemesterPayment
     * const studentSemesterPayment = await prisma.studentSemesterPayment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StudentSemesterPaymentUpdateArgs>(args: SelectSubset<T, StudentSemesterPaymentUpdateArgs<ExtArgs>>): Prisma__StudentSemesterPaymentClient<$Result.GetResult<Prisma.$StudentSemesterPaymentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more StudentSemesterPayments.
     * @param {StudentSemesterPaymentDeleteManyArgs} args - Arguments to filter StudentSemesterPayments to delete.
     * @example
     * // Delete a few StudentSemesterPayments
     * const { count } = await prisma.studentSemesterPayment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StudentSemesterPaymentDeleteManyArgs>(args?: SelectSubset<T, StudentSemesterPaymentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StudentSemesterPayments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentSemesterPaymentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StudentSemesterPayments
     * const studentSemesterPayment = await prisma.studentSemesterPayment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StudentSemesterPaymentUpdateManyArgs>(args: SelectSubset<T, StudentSemesterPaymentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one StudentSemesterPayment.
     * @param {StudentSemesterPaymentUpsertArgs} args - Arguments to update or create a StudentSemesterPayment.
     * @example
     * // Update or create a StudentSemesterPayment
     * const studentSemesterPayment = await prisma.studentSemesterPayment.upsert({
     *   create: {
     *     // ... data to create a StudentSemesterPayment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StudentSemesterPayment we want to update
     *   }
     * })
     */
    upsert<T extends StudentSemesterPaymentUpsertArgs>(args: SelectSubset<T, StudentSemesterPaymentUpsertArgs<ExtArgs>>): Prisma__StudentSemesterPaymentClient<$Result.GetResult<Prisma.$StudentSemesterPaymentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of StudentSemesterPayments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentSemesterPaymentCountArgs} args - Arguments to filter StudentSemesterPayments to count.
     * @example
     * // Count the number of StudentSemesterPayments
     * const count = await prisma.studentSemesterPayment.count({
     *   where: {
     *     // ... the filter for the StudentSemesterPayments we want to count
     *   }
     * })
    **/
    count<T extends StudentSemesterPaymentCountArgs>(
      args?: Subset<T, StudentSemesterPaymentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StudentSemesterPaymentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StudentSemesterPayment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentSemesterPaymentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StudentSemesterPaymentAggregateArgs>(args: Subset<T, StudentSemesterPaymentAggregateArgs>): Prisma.PrismaPromise<GetStudentSemesterPaymentAggregateType<T>>

    /**
     * Group by StudentSemesterPayment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentSemesterPaymentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StudentSemesterPaymentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StudentSemesterPaymentGroupByArgs['orderBy'] }
        : { orderBy?: StudentSemesterPaymentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StudentSemesterPaymentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStudentSemesterPaymentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the StudentSemesterPayment model
   */
  readonly fields: StudentSemesterPaymentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for StudentSemesterPayment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StudentSemesterPaymentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    payment<T extends PaymentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PaymentDefaultArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    student<T extends StudentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StudentDefaultArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    academicSemester<T extends AcademicSemesterDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AcademicSemesterDefaultArgs<ExtArgs>>): Prisma__AcademicSemesterClient<$Result.GetResult<Prisma.$AcademicSemesterPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the StudentSemesterPayment model
   */
  interface StudentSemesterPaymentFieldRefs {
    readonly id: FieldRef<"StudentSemesterPayment", 'String'>
    readonly paymentId: FieldRef<"StudentSemesterPayment", 'String'>
    readonly totalPayment: FieldRef<"StudentSemesterPayment", 'Int'>
    readonly baseAmount: FieldRef<"StudentSemesterPayment", 'Int'>
    readonly lateFee: FieldRef<"StudentSemesterPayment", 'Int'>
    readonly paymentMonth: FieldRef<"StudentSemesterPayment", 'Int'>
    readonly paymentYear: FieldRef<"StudentSemesterPayment", 'Int'>
    readonly createdAt: FieldRef<"StudentSemesterPayment", 'DateTime'>
    readonly updatedAt: FieldRef<"StudentSemesterPayment", 'DateTime'>
    readonly studentId: FieldRef<"StudentSemesterPayment", 'String'>
    readonly academicSemesterId: FieldRef<"StudentSemesterPayment", 'String'>
  }
    

  // Custom InputTypes
  /**
   * StudentSemesterPayment findUnique
   */
  export type StudentSemesterPaymentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentSemesterPayment
     */
    select?: StudentSemesterPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentSemesterPayment
     */
    omit?: StudentSemesterPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentSemesterPaymentInclude<ExtArgs> | null
    /**
     * Filter, which StudentSemesterPayment to fetch.
     */
    where: StudentSemesterPaymentWhereUniqueInput
  }

  /**
   * StudentSemesterPayment findUniqueOrThrow
   */
  export type StudentSemesterPaymentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentSemesterPayment
     */
    select?: StudentSemesterPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentSemesterPayment
     */
    omit?: StudentSemesterPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentSemesterPaymentInclude<ExtArgs> | null
    /**
     * Filter, which StudentSemesterPayment to fetch.
     */
    where: StudentSemesterPaymentWhereUniqueInput
  }

  /**
   * StudentSemesterPayment findFirst
   */
  export type StudentSemesterPaymentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentSemesterPayment
     */
    select?: StudentSemesterPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentSemesterPayment
     */
    omit?: StudentSemesterPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentSemesterPaymentInclude<ExtArgs> | null
    /**
     * Filter, which StudentSemesterPayment to fetch.
     */
    where?: StudentSemesterPaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentSemesterPayments to fetch.
     */
    orderBy?: StudentSemesterPaymentOrderByWithRelationInput | StudentSemesterPaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StudentSemesterPayments.
     */
    cursor?: StudentSemesterPaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentSemesterPayments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentSemesterPayments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StudentSemesterPayments.
     */
    distinct?: StudentSemesterPaymentScalarFieldEnum | StudentSemesterPaymentScalarFieldEnum[]
  }

  /**
   * StudentSemesterPayment findFirstOrThrow
   */
  export type StudentSemesterPaymentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentSemesterPayment
     */
    select?: StudentSemesterPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentSemesterPayment
     */
    omit?: StudentSemesterPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentSemesterPaymentInclude<ExtArgs> | null
    /**
     * Filter, which StudentSemesterPayment to fetch.
     */
    where?: StudentSemesterPaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentSemesterPayments to fetch.
     */
    orderBy?: StudentSemesterPaymentOrderByWithRelationInput | StudentSemesterPaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StudentSemesterPayments.
     */
    cursor?: StudentSemesterPaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentSemesterPayments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentSemesterPayments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StudentSemesterPayments.
     */
    distinct?: StudentSemesterPaymentScalarFieldEnum | StudentSemesterPaymentScalarFieldEnum[]
  }

  /**
   * StudentSemesterPayment findMany
   */
  export type StudentSemesterPaymentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentSemesterPayment
     */
    select?: StudentSemesterPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentSemesterPayment
     */
    omit?: StudentSemesterPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentSemesterPaymentInclude<ExtArgs> | null
    /**
     * Filter, which StudentSemesterPayments to fetch.
     */
    where?: StudentSemesterPaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentSemesterPayments to fetch.
     */
    orderBy?: StudentSemesterPaymentOrderByWithRelationInput | StudentSemesterPaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StudentSemesterPayments.
     */
    cursor?: StudentSemesterPaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentSemesterPayments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentSemesterPayments.
     */
    skip?: number
    distinct?: StudentSemesterPaymentScalarFieldEnum | StudentSemesterPaymentScalarFieldEnum[]
  }

  /**
   * StudentSemesterPayment create
   */
  export type StudentSemesterPaymentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentSemesterPayment
     */
    select?: StudentSemesterPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentSemesterPayment
     */
    omit?: StudentSemesterPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentSemesterPaymentInclude<ExtArgs> | null
    /**
     * The data needed to create a StudentSemesterPayment.
     */
    data: XOR<StudentSemesterPaymentCreateInput, StudentSemesterPaymentUncheckedCreateInput>
  }

  /**
   * StudentSemesterPayment createMany
   */
  export type StudentSemesterPaymentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many StudentSemesterPayments.
     */
    data: StudentSemesterPaymentCreateManyInput | StudentSemesterPaymentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * StudentSemesterPayment update
   */
  export type StudentSemesterPaymentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentSemesterPayment
     */
    select?: StudentSemesterPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentSemesterPayment
     */
    omit?: StudentSemesterPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentSemesterPaymentInclude<ExtArgs> | null
    /**
     * The data needed to update a StudentSemesterPayment.
     */
    data: XOR<StudentSemesterPaymentUpdateInput, StudentSemesterPaymentUncheckedUpdateInput>
    /**
     * Choose, which StudentSemesterPayment to update.
     */
    where: StudentSemesterPaymentWhereUniqueInput
  }

  /**
   * StudentSemesterPayment updateMany
   */
  export type StudentSemesterPaymentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update StudentSemesterPayments.
     */
    data: XOR<StudentSemesterPaymentUpdateManyMutationInput, StudentSemesterPaymentUncheckedUpdateManyInput>
    /**
     * Filter which StudentSemesterPayments to update
     */
    where?: StudentSemesterPaymentWhereInput
    /**
     * Limit how many StudentSemesterPayments to update.
     */
    limit?: number
  }

  /**
   * StudentSemesterPayment upsert
   */
  export type StudentSemesterPaymentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentSemesterPayment
     */
    select?: StudentSemesterPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentSemesterPayment
     */
    omit?: StudentSemesterPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentSemesterPaymentInclude<ExtArgs> | null
    /**
     * The filter to search for the StudentSemesterPayment to update in case it exists.
     */
    where: StudentSemesterPaymentWhereUniqueInput
    /**
     * In case the StudentSemesterPayment found by the `where` argument doesn't exist, create a new StudentSemesterPayment with this data.
     */
    create: XOR<StudentSemesterPaymentCreateInput, StudentSemesterPaymentUncheckedCreateInput>
    /**
     * In case the StudentSemesterPayment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StudentSemesterPaymentUpdateInput, StudentSemesterPaymentUncheckedUpdateInput>
  }

  /**
   * StudentSemesterPayment delete
   */
  export type StudentSemesterPaymentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentSemesterPayment
     */
    select?: StudentSemesterPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentSemesterPayment
     */
    omit?: StudentSemesterPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentSemesterPaymentInclude<ExtArgs> | null
    /**
     * Filter which StudentSemesterPayment to delete.
     */
    where: StudentSemesterPaymentWhereUniqueInput
  }

  /**
   * StudentSemesterPayment deleteMany
   */
  export type StudentSemesterPaymentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StudentSemesterPayments to delete
     */
    where?: StudentSemesterPaymentWhereInput
    /**
     * Limit how many StudentSemesterPayments to delete.
     */
    limit?: number
  }

  /**
   * StudentSemesterPayment without action
   */
  export type StudentSemesterPaymentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentSemesterPayment
     */
    select?: StudentSemesterPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentSemesterPayment
     */
    omit?: StudentSemesterPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentSemesterPaymentInclude<ExtArgs> | null
  }


  /**
   * Model StudentAcademicInfo
   */

  export type AggregateStudentAcademicInfo = {
    _count: StudentAcademicInfoCountAggregateOutputType | null
    _avg: StudentAcademicInfoAvgAggregateOutputType | null
    _sum: StudentAcademicInfoSumAggregateOutputType | null
    _min: StudentAcademicInfoMinAggregateOutputType | null
    _max: StudentAcademicInfoMaxAggregateOutputType | null
  }

  export type StudentAcademicInfoAvgAggregateOutputType = {
    totalCompletedCredits: number | null
    cgpa: number | null
  }

  export type StudentAcademicInfoSumAggregateOutputType = {
    totalCompletedCredits: number | null
    cgpa: number | null
  }

  export type StudentAcademicInfoMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    studentId: string | null
    totalCompletedCredits: number | null
    cgpa: number | null
  }

  export type StudentAcademicInfoMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    studentId: string | null
    totalCompletedCredits: number | null
    cgpa: number | null
  }

  export type StudentAcademicInfoCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    studentId: number
    totalCompletedCredits: number
    cgpa: number
    _all: number
  }


  export type StudentAcademicInfoAvgAggregateInputType = {
    totalCompletedCredits?: true
    cgpa?: true
  }

  export type StudentAcademicInfoSumAggregateInputType = {
    totalCompletedCredits?: true
    cgpa?: true
  }

  export type StudentAcademicInfoMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    studentId?: true
    totalCompletedCredits?: true
    cgpa?: true
  }

  export type StudentAcademicInfoMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    studentId?: true
    totalCompletedCredits?: true
    cgpa?: true
  }

  export type StudentAcademicInfoCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    studentId?: true
    totalCompletedCredits?: true
    cgpa?: true
    _all?: true
  }

  export type StudentAcademicInfoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StudentAcademicInfo to aggregate.
     */
    where?: StudentAcademicInfoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentAcademicInfos to fetch.
     */
    orderBy?: StudentAcademicInfoOrderByWithRelationInput | StudentAcademicInfoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StudentAcademicInfoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentAcademicInfos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentAcademicInfos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StudentAcademicInfos
    **/
    _count?: true | StudentAcademicInfoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StudentAcademicInfoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StudentAcademicInfoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StudentAcademicInfoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StudentAcademicInfoMaxAggregateInputType
  }

  export type GetStudentAcademicInfoAggregateType<T extends StudentAcademicInfoAggregateArgs> = {
        [P in keyof T & keyof AggregateStudentAcademicInfo]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStudentAcademicInfo[P]>
      : GetScalarType<T[P], AggregateStudentAcademicInfo[P]>
  }




  export type StudentAcademicInfoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentAcademicInfoWhereInput
    orderBy?: StudentAcademicInfoOrderByWithAggregationInput | StudentAcademicInfoOrderByWithAggregationInput[]
    by: StudentAcademicInfoScalarFieldEnum[] | StudentAcademicInfoScalarFieldEnum
    having?: StudentAcademicInfoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StudentAcademicInfoCountAggregateInputType | true
    _avg?: StudentAcademicInfoAvgAggregateInputType
    _sum?: StudentAcademicInfoSumAggregateInputType
    _min?: StudentAcademicInfoMinAggregateInputType
    _max?: StudentAcademicInfoMaxAggregateInputType
  }

  export type StudentAcademicInfoGroupByOutputType = {
    id: string
    createdAt: Date
    updatedAt: Date
    studentId: string
    totalCompletedCredits: number | null
    cgpa: number | null
    _count: StudentAcademicInfoCountAggregateOutputType | null
    _avg: StudentAcademicInfoAvgAggregateOutputType | null
    _sum: StudentAcademicInfoSumAggregateOutputType | null
    _min: StudentAcademicInfoMinAggregateOutputType | null
    _max: StudentAcademicInfoMaxAggregateOutputType | null
  }

  type GetStudentAcademicInfoGroupByPayload<T extends StudentAcademicInfoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StudentAcademicInfoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StudentAcademicInfoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StudentAcademicInfoGroupByOutputType[P]>
            : GetScalarType<T[P], StudentAcademicInfoGroupByOutputType[P]>
        }
      >
    >


  export type StudentAcademicInfoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    studentId?: boolean
    totalCompletedCredits?: boolean
    cgpa?: boolean
    student?: boolean | StudentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["studentAcademicInfo"]>



  export type StudentAcademicInfoSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    studentId?: boolean
    totalCompletedCredits?: boolean
    cgpa?: boolean
  }

  export type StudentAcademicInfoOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "createdAt" | "updatedAt" | "studentId" | "totalCompletedCredits" | "cgpa", ExtArgs["result"]["studentAcademicInfo"]>
  export type StudentAcademicInfoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentDefaultArgs<ExtArgs>
  }

  export type $StudentAcademicInfoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "StudentAcademicInfo"
    objects: {
      student: Prisma.$StudentPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      createdAt: Date
      updatedAt: Date
      studentId: string
      totalCompletedCredits: number | null
      cgpa: number | null
    }, ExtArgs["result"]["studentAcademicInfo"]>
    composites: {}
  }

  type StudentAcademicInfoGetPayload<S extends boolean | null | undefined | StudentAcademicInfoDefaultArgs> = $Result.GetResult<Prisma.$StudentAcademicInfoPayload, S>

  type StudentAcademicInfoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<StudentAcademicInfoFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: StudentAcademicInfoCountAggregateInputType | true
    }

  export interface StudentAcademicInfoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['StudentAcademicInfo'], meta: { name: 'StudentAcademicInfo' } }
    /**
     * Find zero or one StudentAcademicInfo that matches the filter.
     * @param {StudentAcademicInfoFindUniqueArgs} args - Arguments to find a StudentAcademicInfo
     * @example
     * // Get one StudentAcademicInfo
     * const studentAcademicInfo = await prisma.studentAcademicInfo.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StudentAcademicInfoFindUniqueArgs>(args: SelectSubset<T, StudentAcademicInfoFindUniqueArgs<ExtArgs>>): Prisma__StudentAcademicInfoClient<$Result.GetResult<Prisma.$StudentAcademicInfoPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one StudentAcademicInfo that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {StudentAcademicInfoFindUniqueOrThrowArgs} args - Arguments to find a StudentAcademicInfo
     * @example
     * // Get one StudentAcademicInfo
     * const studentAcademicInfo = await prisma.studentAcademicInfo.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StudentAcademicInfoFindUniqueOrThrowArgs>(args: SelectSubset<T, StudentAcademicInfoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StudentAcademicInfoClient<$Result.GetResult<Prisma.$StudentAcademicInfoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StudentAcademicInfo that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentAcademicInfoFindFirstArgs} args - Arguments to find a StudentAcademicInfo
     * @example
     * // Get one StudentAcademicInfo
     * const studentAcademicInfo = await prisma.studentAcademicInfo.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StudentAcademicInfoFindFirstArgs>(args?: SelectSubset<T, StudentAcademicInfoFindFirstArgs<ExtArgs>>): Prisma__StudentAcademicInfoClient<$Result.GetResult<Prisma.$StudentAcademicInfoPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StudentAcademicInfo that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentAcademicInfoFindFirstOrThrowArgs} args - Arguments to find a StudentAcademicInfo
     * @example
     * // Get one StudentAcademicInfo
     * const studentAcademicInfo = await prisma.studentAcademicInfo.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StudentAcademicInfoFindFirstOrThrowArgs>(args?: SelectSubset<T, StudentAcademicInfoFindFirstOrThrowArgs<ExtArgs>>): Prisma__StudentAcademicInfoClient<$Result.GetResult<Prisma.$StudentAcademicInfoPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more StudentAcademicInfos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentAcademicInfoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StudentAcademicInfos
     * const studentAcademicInfos = await prisma.studentAcademicInfo.findMany()
     * 
     * // Get first 10 StudentAcademicInfos
     * const studentAcademicInfos = await prisma.studentAcademicInfo.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const studentAcademicInfoWithIdOnly = await prisma.studentAcademicInfo.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StudentAcademicInfoFindManyArgs>(args?: SelectSubset<T, StudentAcademicInfoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentAcademicInfoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a StudentAcademicInfo.
     * @param {StudentAcademicInfoCreateArgs} args - Arguments to create a StudentAcademicInfo.
     * @example
     * // Create one StudentAcademicInfo
     * const StudentAcademicInfo = await prisma.studentAcademicInfo.create({
     *   data: {
     *     // ... data to create a StudentAcademicInfo
     *   }
     * })
     * 
     */
    create<T extends StudentAcademicInfoCreateArgs>(args: SelectSubset<T, StudentAcademicInfoCreateArgs<ExtArgs>>): Prisma__StudentAcademicInfoClient<$Result.GetResult<Prisma.$StudentAcademicInfoPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many StudentAcademicInfos.
     * @param {StudentAcademicInfoCreateManyArgs} args - Arguments to create many StudentAcademicInfos.
     * @example
     * // Create many StudentAcademicInfos
     * const studentAcademicInfo = await prisma.studentAcademicInfo.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StudentAcademicInfoCreateManyArgs>(args?: SelectSubset<T, StudentAcademicInfoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a StudentAcademicInfo.
     * @param {StudentAcademicInfoDeleteArgs} args - Arguments to delete one StudentAcademicInfo.
     * @example
     * // Delete one StudentAcademicInfo
     * const StudentAcademicInfo = await prisma.studentAcademicInfo.delete({
     *   where: {
     *     // ... filter to delete one StudentAcademicInfo
     *   }
     * })
     * 
     */
    delete<T extends StudentAcademicInfoDeleteArgs>(args: SelectSubset<T, StudentAcademicInfoDeleteArgs<ExtArgs>>): Prisma__StudentAcademicInfoClient<$Result.GetResult<Prisma.$StudentAcademicInfoPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one StudentAcademicInfo.
     * @param {StudentAcademicInfoUpdateArgs} args - Arguments to update one StudentAcademicInfo.
     * @example
     * // Update one StudentAcademicInfo
     * const studentAcademicInfo = await prisma.studentAcademicInfo.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StudentAcademicInfoUpdateArgs>(args: SelectSubset<T, StudentAcademicInfoUpdateArgs<ExtArgs>>): Prisma__StudentAcademicInfoClient<$Result.GetResult<Prisma.$StudentAcademicInfoPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more StudentAcademicInfos.
     * @param {StudentAcademicInfoDeleteManyArgs} args - Arguments to filter StudentAcademicInfos to delete.
     * @example
     * // Delete a few StudentAcademicInfos
     * const { count } = await prisma.studentAcademicInfo.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StudentAcademicInfoDeleteManyArgs>(args?: SelectSubset<T, StudentAcademicInfoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StudentAcademicInfos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentAcademicInfoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StudentAcademicInfos
     * const studentAcademicInfo = await prisma.studentAcademicInfo.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StudentAcademicInfoUpdateManyArgs>(args: SelectSubset<T, StudentAcademicInfoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one StudentAcademicInfo.
     * @param {StudentAcademicInfoUpsertArgs} args - Arguments to update or create a StudentAcademicInfo.
     * @example
     * // Update or create a StudentAcademicInfo
     * const studentAcademicInfo = await prisma.studentAcademicInfo.upsert({
     *   create: {
     *     // ... data to create a StudentAcademicInfo
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StudentAcademicInfo we want to update
     *   }
     * })
     */
    upsert<T extends StudentAcademicInfoUpsertArgs>(args: SelectSubset<T, StudentAcademicInfoUpsertArgs<ExtArgs>>): Prisma__StudentAcademicInfoClient<$Result.GetResult<Prisma.$StudentAcademicInfoPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of StudentAcademicInfos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentAcademicInfoCountArgs} args - Arguments to filter StudentAcademicInfos to count.
     * @example
     * // Count the number of StudentAcademicInfos
     * const count = await prisma.studentAcademicInfo.count({
     *   where: {
     *     // ... the filter for the StudentAcademicInfos we want to count
     *   }
     * })
    **/
    count<T extends StudentAcademicInfoCountArgs>(
      args?: Subset<T, StudentAcademicInfoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StudentAcademicInfoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StudentAcademicInfo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentAcademicInfoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StudentAcademicInfoAggregateArgs>(args: Subset<T, StudentAcademicInfoAggregateArgs>): Prisma.PrismaPromise<GetStudentAcademicInfoAggregateType<T>>

    /**
     * Group by StudentAcademicInfo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentAcademicInfoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StudentAcademicInfoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StudentAcademicInfoGroupByArgs['orderBy'] }
        : { orderBy?: StudentAcademicInfoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StudentAcademicInfoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStudentAcademicInfoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the StudentAcademicInfo model
   */
  readonly fields: StudentAcademicInfoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for StudentAcademicInfo.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StudentAcademicInfoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    student<T extends StudentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StudentDefaultArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the StudentAcademicInfo model
   */
  interface StudentAcademicInfoFieldRefs {
    readonly id: FieldRef<"StudentAcademicInfo", 'String'>
    readonly createdAt: FieldRef<"StudentAcademicInfo", 'DateTime'>
    readonly updatedAt: FieldRef<"StudentAcademicInfo", 'DateTime'>
    readonly studentId: FieldRef<"StudentAcademicInfo", 'String'>
    readonly totalCompletedCredits: FieldRef<"StudentAcademicInfo", 'Int'>
    readonly cgpa: FieldRef<"StudentAcademicInfo", 'Float'>
  }
    

  // Custom InputTypes
  /**
   * StudentAcademicInfo findUnique
   */
  export type StudentAcademicInfoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentAcademicInfo
     */
    select?: StudentAcademicInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentAcademicInfo
     */
    omit?: StudentAcademicInfoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentAcademicInfoInclude<ExtArgs> | null
    /**
     * Filter, which StudentAcademicInfo to fetch.
     */
    where: StudentAcademicInfoWhereUniqueInput
  }

  /**
   * StudentAcademicInfo findUniqueOrThrow
   */
  export type StudentAcademicInfoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentAcademicInfo
     */
    select?: StudentAcademicInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentAcademicInfo
     */
    omit?: StudentAcademicInfoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentAcademicInfoInclude<ExtArgs> | null
    /**
     * Filter, which StudentAcademicInfo to fetch.
     */
    where: StudentAcademicInfoWhereUniqueInput
  }

  /**
   * StudentAcademicInfo findFirst
   */
  export type StudentAcademicInfoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentAcademicInfo
     */
    select?: StudentAcademicInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentAcademicInfo
     */
    omit?: StudentAcademicInfoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentAcademicInfoInclude<ExtArgs> | null
    /**
     * Filter, which StudentAcademicInfo to fetch.
     */
    where?: StudentAcademicInfoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentAcademicInfos to fetch.
     */
    orderBy?: StudentAcademicInfoOrderByWithRelationInput | StudentAcademicInfoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StudentAcademicInfos.
     */
    cursor?: StudentAcademicInfoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentAcademicInfos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentAcademicInfos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StudentAcademicInfos.
     */
    distinct?: StudentAcademicInfoScalarFieldEnum | StudentAcademicInfoScalarFieldEnum[]
  }

  /**
   * StudentAcademicInfo findFirstOrThrow
   */
  export type StudentAcademicInfoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentAcademicInfo
     */
    select?: StudentAcademicInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentAcademicInfo
     */
    omit?: StudentAcademicInfoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentAcademicInfoInclude<ExtArgs> | null
    /**
     * Filter, which StudentAcademicInfo to fetch.
     */
    where?: StudentAcademicInfoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentAcademicInfos to fetch.
     */
    orderBy?: StudentAcademicInfoOrderByWithRelationInput | StudentAcademicInfoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StudentAcademicInfos.
     */
    cursor?: StudentAcademicInfoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentAcademicInfos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentAcademicInfos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StudentAcademicInfos.
     */
    distinct?: StudentAcademicInfoScalarFieldEnum | StudentAcademicInfoScalarFieldEnum[]
  }

  /**
   * StudentAcademicInfo findMany
   */
  export type StudentAcademicInfoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentAcademicInfo
     */
    select?: StudentAcademicInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentAcademicInfo
     */
    omit?: StudentAcademicInfoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentAcademicInfoInclude<ExtArgs> | null
    /**
     * Filter, which StudentAcademicInfos to fetch.
     */
    where?: StudentAcademicInfoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentAcademicInfos to fetch.
     */
    orderBy?: StudentAcademicInfoOrderByWithRelationInput | StudentAcademicInfoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StudentAcademicInfos.
     */
    cursor?: StudentAcademicInfoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentAcademicInfos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentAcademicInfos.
     */
    skip?: number
    distinct?: StudentAcademicInfoScalarFieldEnum | StudentAcademicInfoScalarFieldEnum[]
  }

  /**
   * StudentAcademicInfo create
   */
  export type StudentAcademicInfoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentAcademicInfo
     */
    select?: StudentAcademicInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentAcademicInfo
     */
    omit?: StudentAcademicInfoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentAcademicInfoInclude<ExtArgs> | null
    /**
     * The data needed to create a StudentAcademicInfo.
     */
    data: XOR<StudentAcademicInfoCreateInput, StudentAcademicInfoUncheckedCreateInput>
  }

  /**
   * StudentAcademicInfo createMany
   */
  export type StudentAcademicInfoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many StudentAcademicInfos.
     */
    data: StudentAcademicInfoCreateManyInput | StudentAcademicInfoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * StudentAcademicInfo update
   */
  export type StudentAcademicInfoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentAcademicInfo
     */
    select?: StudentAcademicInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentAcademicInfo
     */
    omit?: StudentAcademicInfoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentAcademicInfoInclude<ExtArgs> | null
    /**
     * The data needed to update a StudentAcademicInfo.
     */
    data: XOR<StudentAcademicInfoUpdateInput, StudentAcademicInfoUncheckedUpdateInput>
    /**
     * Choose, which StudentAcademicInfo to update.
     */
    where: StudentAcademicInfoWhereUniqueInput
  }

  /**
   * StudentAcademicInfo updateMany
   */
  export type StudentAcademicInfoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update StudentAcademicInfos.
     */
    data: XOR<StudentAcademicInfoUpdateManyMutationInput, StudentAcademicInfoUncheckedUpdateManyInput>
    /**
     * Filter which StudentAcademicInfos to update
     */
    where?: StudentAcademicInfoWhereInput
    /**
     * Limit how many StudentAcademicInfos to update.
     */
    limit?: number
  }

  /**
   * StudentAcademicInfo upsert
   */
  export type StudentAcademicInfoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentAcademicInfo
     */
    select?: StudentAcademicInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentAcademicInfo
     */
    omit?: StudentAcademicInfoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentAcademicInfoInclude<ExtArgs> | null
    /**
     * The filter to search for the StudentAcademicInfo to update in case it exists.
     */
    where: StudentAcademicInfoWhereUniqueInput
    /**
     * In case the StudentAcademicInfo found by the `where` argument doesn't exist, create a new StudentAcademicInfo with this data.
     */
    create: XOR<StudentAcademicInfoCreateInput, StudentAcademicInfoUncheckedCreateInput>
    /**
     * In case the StudentAcademicInfo was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StudentAcademicInfoUpdateInput, StudentAcademicInfoUncheckedUpdateInput>
  }

  /**
   * StudentAcademicInfo delete
   */
  export type StudentAcademicInfoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentAcademicInfo
     */
    select?: StudentAcademicInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentAcademicInfo
     */
    omit?: StudentAcademicInfoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentAcademicInfoInclude<ExtArgs> | null
    /**
     * Filter which StudentAcademicInfo to delete.
     */
    where: StudentAcademicInfoWhereUniqueInput
  }

  /**
   * StudentAcademicInfo deleteMany
   */
  export type StudentAcademicInfoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StudentAcademicInfos to delete
     */
    where?: StudentAcademicInfoWhereInput
    /**
     * Limit how many StudentAcademicInfos to delete.
     */
    limit?: number
  }

  /**
   * StudentAcademicInfo without action
   */
  export type StudentAcademicInfoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentAcademicInfo
     */
    select?: StudentAcademicInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentAcademicInfo
     */
    omit?: StudentAcademicInfoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentAcademicInfoInclude<ExtArgs> | null
  }


  /**
   * Model Events
   */

  export type AggregateEvents = {
    _count: EventsCountAggregateOutputType | null
    _min: EventsMinAggregateOutputType | null
    _max: EventsMaxAggregateOutputType | null
  }

  export type EventsMinAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    thumbnail: string | null
    color: string | null
    location: Date | null
    mandatory: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EventsMaxAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    thumbnail: string | null
    color: string | null
    location: Date | null
    mandatory: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EventsCountAggregateOutputType = {
    id: number
    title: number
    description: number
    thumbnail: number
    color: number
    location: number
    mandatory: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type EventsMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    thumbnail?: true
    color?: true
    location?: true
    mandatory?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EventsMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    thumbnail?: true
    color?: true
    location?: true
    mandatory?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EventsCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    thumbnail?: true
    color?: true
    location?: true
    mandatory?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type EventsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Events to aggregate.
     */
    where?: EventsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Events to fetch.
     */
    orderBy?: EventsOrderByWithRelationInput | EventsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EventsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Events from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Events.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Events
    **/
    _count?: true | EventsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EventsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EventsMaxAggregateInputType
  }

  export type GetEventsAggregateType<T extends EventsAggregateArgs> = {
        [P in keyof T & keyof AggregateEvents]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEvents[P]>
      : GetScalarType<T[P], AggregateEvents[P]>
  }




  export type EventsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EventsWhereInput
    orderBy?: EventsOrderByWithAggregationInput | EventsOrderByWithAggregationInput[]
    by: EventsScalarFieldEnum[] | EventsScalarFieldEnum
    having?: EventsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EventsCountAggregateInputType | true
    _min?: EventsMinAggregateInputType
    _max?: EventsMaxAggregateInputType
  }

  export type EventsGroupByOutputType = {
    id: string
    title: string
    description: string
    thumbnail: string
    color: string
    location: Date
    mandatory: boolean
    createdAt: Date
    updatedAt: Date
    _count: EventsCountAggregateOutputType | null
    _min: EventsMinAggregateOutputType | null
    _max: EventsMaxAggregateOutputType | null
  }

  type GetEventsGroupByPayload<T extends EventsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EventsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EventsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EventsGroupByOutputType[P]>
            : GetScalarType<T[P], EventsGroupByOutputType[P]>
        }
      >
    >


  export type EventsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    thumbnail?: boolean
    color?: boolean
    location?: boolean
    mandatory?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["events"]>



  export type EventsSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    thumbnail?: boolean
    color?: boolean
    location?: boolean
    mandatory?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type EventsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "description" | "thumbnail" | "color" | "location" | "mandatory" | "createdAt" | "updatedAt", ExtArgs["result"]["events"]>

  export type $EventsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Events"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      description: string
      thumbnail: string
      color: string
      location: Date
      mandatory: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["events"]>
    composites: {}
  }

  type EventsGetPayload<S extends boolean | null | undefined | EventsDefaultArgs> = $Result.GetResult<Prisma.$EventsPayload, S>

  type EventsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EventsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EventsCountAggregateInputType | true
    }

  export interface EventsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Events'], meta: { name: 'Events' } }
    /**
     * Find zero or one Events that matches the filter.
     * @param {EventsFindUniqueArgs} args - Arguments to find a Events
     * @example
     * // Get one Events
     * const events = await prisma.events.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EventsFindUniqueArgs>(args: SelectSubset<T, EventsFindUniqueArgs<ExtArgs>>): Prisma__EventsClient<$Result.GetResult<Prisma.$EventsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Events that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EventsFindUniqueOrThrowArgs} args - Arguments to find a Events
     * @example
     * // Get one Events
     * const events = await prisma.events.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EventsFindUniqueOrThrowArgs>(args: SelectSubset<T, EventsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EventsClient<$Result.GetResult<Prisma.$EventsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Events that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventsFindFirstArgs} args - Arguments to find a Events
     * @example
     * // Get one Events
     * const events = await prisma.events.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EventsFindFirstArgs>(args?: SelectSubset<T, EventsFindFirstArgs<ExtArgs>>): Prisma__EventsClient<$Result.GetResult<Prisma.$EventsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Events that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventsFindFirstOrThrowArgs} args - Arguments to find a Events
     * @example
     * // Get one Events
     * const events = await prisma.events.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EventsFindFirstOrThrowArgs>(args?: SelectSubset<T, EventsFindFirstOrThrowArgs<ExtArgs>>): Prisma__EventsClient<$Result.GetResult<Prisma.$EventsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Events that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Events
     * const events = await prisma.events.findMany()
     * 
     * // Get first 10 Events
     * const events = await prisma.events.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const eventsWithIdOnly = await prisma.events.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EventsFindManyArgs>(args?: SelectSubset<T, EventsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Events.
     * @param {EventsCreateArgs} args - Arguments to create a Events.
     * @example
     * // Create one Events
     * const Events = await prisma.events.create({
     *   data: {
     *     // ... data to create a Events
     *   }
     * })
     * 
     */
    create<T extends EventsCreateArgs>(args: SelectSubset<T, EventsCreateArgs<ExtArgs>>): Prisma__EventsClient<$Result.GetResult<Prisma.$EventsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Events.
     * @param {EventsCreateManyArgs} args - Arguments to create many Events.
     * @example
     * // Create many Events
     * const events = await prisma.events.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EventsCreateManyArgs>(args?: SelectSubset<T, EventsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Events.
     * @param {EventsDeleteArgs} args - Arguments to delete one Events.
     * @example
     * // Delete one Events
     * const Events = await prisma.events.delete({
     *   where: {
     *     // ... filter to delete one Events
     *   }
     * })
     * 
     */
    delete<T extends EventsDeleteArgs>(args: SelectSubset<T, EventsDeleteArgs<ExtArgs>>): Prisma__EventsClient<$Result.GetResult<Prisma.$EventsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Events.
     * @param {EventsUpdateArgs} args - Arguments to update one Events.
     * @example
     * // Update one Events
     * const events = await prisma.events.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EventsUpdateArgs>(args: SelectSubset<T, EventsUpdateArgs<ExtArgs>>): Prisma__EventsClient<$Result.GetResult<Prisma.$EventsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Events.
     * @param {EventsDeleteManyArgs} args - Arguments to filter Events to delete.
     * @example
     * // Delete a few Events
     * const { count } = await prisma.events.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EventsDeleteManyArgs>(args?: SelectSubset<T, EventsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Events.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Events
     * const events = await prisma.events.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EventsUpdateManyArgs>(args: SelectSubset<T, EventsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Events.
     * @param {EventsUpsertArgs} args - Arguments to update or create a Events.
     * @example
     * // Update or create a Events
     * const events = await prisma.events.upsert({
     *   create: {
     *     // ... data to create a Events
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Events we want to update
     *   }
     * })
     */
    upsert<T extends EventsUpsertArgs>(args: SelectSubset<T, EventsUpsertArgs<ExtArgs>>): Prisma__EventsClient<$Result.GetResult<Prisma.$EventsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Events.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventsCountArgs} args - Arguments to filter Events to count.
     * @example
     * // Count the number of Events
     * const count = await prisma.events.count({
     *   where: {
     *     // ... the filter for the Events we want to count
     *   }
     * })
    **/
    count<T extends EventsCountArgs>(
      args?: Subset<T, EventsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EventsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Events.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EventsAggregateArgs>(args: Subset<T, EventsAggregateArgs>): Prisma.PrismaPromise<GetEventsAggregateType<T>>

    /**
     * Group by Events.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EventsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EventsGroupByArgs['orderBy'] }
        : { orderBy?: EventsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EventsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEventsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Events model
   */
  readonly fields: EventsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Events.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EventsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Events model
   */
  interface EventsFieldRefs {
    readonly id: FieldRef<"Events", 'String'>
    readonly title: FieldRef<"Events", 'String'>
    readonly description: FieldRef<"Events", 'String'>
    readonly thumbnail: FieldRef<"Events", 'String'>
    readonly color: FieldRef<"Events", 'String'>
    readonly location: FieldRef<"Events", 'DateTime'>
    readonly mandatory: FieldRef<"Events", 'Boolean'>
    readonly createdAt: FieldRef<"Events", 'DateTime'>
    readonly updatedAt: FieldRef<"Events", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Events findUnique
   */
  export type EventsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Events
     */
    select?: EventsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Events
     */
    omit?: EventsOmit<ExtArgs> | null
    /**
     * Filter, which Events to fetch.
     */
    where: EventsWhereUniqueInput
  }

  /**
   * Events findUniqueOrThrow
   */
  export type EventsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Events
     */
    select?: EventsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Events
     */
    omit?: EventsOmit<ExtArgs> | null
    /**
     * Filter, which Events to fetch.
     */
    where: EventsWhereUniqueInput
  }

  /**
   * Events findFirst
   */
  export type EventsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Events
     */
    select?: EventsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Events
     */
    omit?: EventsOmit<ExtArgs> | null
    /**
     * Filter, which Events to fetch.
     */
    where?: EventsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Events to fetch.
     */
    orderBy?: EventsOrderByWithRelationInput | EventsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Events.
     */
    cursor?: EventsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Events from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Events.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Events.
     */
    distinct?: EventsScalarFieldEnum | EventsScalarFieldEnum[]
  }

  /**
   * Events findFirstOrThrow
   */
  export type EventsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Events
     */
    select?: EventsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Events
     */
    omit?: EventsOmit<ExtArgs> | null
    /**
     * Filter, which Events to fetch.
     */
    where?: EventsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Events to fetch.
     */
    orderBy?: EventsOrderByWithRelationInput | EventsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Events.
     */
    cursor?: EventsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Events from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Events.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Events.
     */
    distinct?: EventsScalarFieldEnum | EventsScalarFieldEnum[]
  }

  /**
   * Events findMany
   */
  export type EventsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Events
     */
    select?: EventsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Events
     */
    omit?: EventsOmit<ExtArgs> | null
    /**
     * Filter, which Events to fetch.
     */
    where?: EventsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Events to fetch.
     */
    orderBy?: EventsOrderByWithRelationInput | EventsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Events.
     */
    cursor?: EventsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Events from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Events.
     */
    skip?: number
    distinct?: EventsScalarFieldEnum | EventsScalarFieldEnum[]
  }

  /**
   * Events create
   */
  export type EventsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Events
     */
    select?: EventsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Events
     */
    omit?: EventsOmit<ExtArgs> | null
    /**
     * The data needed to create a Events.
     */
    data: XOR<EventsCreateInput, EventsUncheckedCreateInput>
  }

  /**
   * Events createMany
   */
  export type EventsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Events.
     */
    data: EventsCreateManyInput | EventsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Events update
   */
  export type EventsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Events
     */
    select?: EventsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Events
     */
    omit?: EventsOmit<ExtArgs> | null
    /**
     * The data needed to update a Events.
     */
    data: XOR<EventsUpdateInput, EventsUncheckedUpdateInput>
    /**
     * Choose, which Events to update.
     */
    where: EventsWhereUniqueInput
  }

  /**
   * Events updateMany
   */
  export type EventsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Events.
     */
    data: XOR<EventsUpdateManyMutationInput, EventsUncheckedUpdateManyInput>
    /**
     * Filter which Events to update
     */
    where?: EventsWhereInput
    /**
     * Limit how many Events to update.
     */
    limit?: number
  }

  /**
   * Events upsert
   */
  export type EventsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Events
     */
    select?: EventsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Events
     */
    omit?: EventsOmit<ExtArgs> | null
    /**
     * The filter to search for the Events to update in case it exists.
     */
    where: EventsWhereUniqueInput
    /**
     * In case the Events found by the `where` argument doesn't exist, create a new Events with this data.
     */
    create: XOR<EventsCreateInput, EventsUncheckedCreateInput>
    /**
     * In case the Events was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EventsUpdateInput, EventsUncheckedUpdateInput>
  }

  /**
   * Events delete
   */
  export type EventsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Events
     */
    select?: EventsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Events
     */
    omit?: EventsOmit<ExtArgs> | null
    /**
     * Filter which Events to delete.
     */
    where: EventsWhereUniqueInput
  }

  /**
   * Events deleteMany
   */
  export type EventsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Events to delete
     */
    where?: EventsWhereInput
    /**
     * Limit how many Events to delete.
     */
    limit?: number
  }

  /**
   * Events without action
   */
  export type EventsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Events
     */
    select?: EventsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Events
     */
    omit?: EventsOmit<ExtArgs> | null
  }


  /**
   * Model Payment
   */

  export type AggregatePayment = {
    _count: PaymentCountAggregateOutputType | null
    _avg: PaymentAvgAggregateOutputType | null
    _sum: PaymentSumAggregateOutputType | null
    _min: PaymentMinAggregateOutputType | null
    _max: PaymentMaxAggregateOutputType | null
  }

  export type PaymentAvgAggregateOutputType = {
    totalAmount: number | null
  }

  export type PaymentSumAggregateOutputType = {
    totalAmount: number | null
  }

  export type PaymentMinAggregateOutputType = {
    id: string | null
    paymentRecipt: string | null
    totalAmount: number | null
    approved: boolean | null
    paymentType: $Enums.PAYMENTTYPE | null
    status: $Enums.PAYMENTSTATUS | null
    method: $Enums.PAYMENTMETHOD | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PaymentMaxAggregateOutputType = {
    id: string | null
    paymentRecipt: string | null
    totalAmount: number | null
    approved: boolean | null
    paymentType: $Enums.PAYMENTTYPE | null
    status: $Enums.PAYMENTSTATUS | null
    method: $Enums.PAYMENTMETHOD | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PaymentCountAggregateOutputType = {
    id: number
    paymentRecipt: number
    totalAmount: number
    approved: number
    paymentType: number
    status: number
    method: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PaymentAvgAggregateInputType = {
    totalAmount?: true
  }

  export type PaymentSumAggregateInputType = {
    totalAmount?: true
  }

  export type PaymentMinAggregateInputType = {
    id?: true
    paymentRecipt?: true
    totalAmount?: true
    approved?: true
    paymentType?: true
    status?: true
    method?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PaymentMaxAggregateInputType = {
    id?: true
    paymentRecipt?: true
    totalAmount?: true
    approved?: true
    paymentType?: true
    status?: true
    method?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PaymentCountAggregateInputType = {
    id?: true
    paymentRecipt?: true
    totalAmount?: true
    approved?: true
    paymentType?: true
    status?: true
    method?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PaymentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Payment to aggregate.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Payments
    **/
    _count?: true | PaymentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PaymentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PaymentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PaymentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PaymentMaxAggregateInputType
  }

  export type GetPaymentAggregateType<T extends PaymentAggregateArgs> = {
        [P in keyof T & keyof AggregatePayment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePayment[P]>
      : GetScalarType<T[P], AggregatePayment[P]>
  }




  export type PaymentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentWhereInput
    orderBy?: PaymentOrderByWithAggregationInput | PaymentOrderByWithAggregationInput[]
    by: PaymentScalarFieldEnum[] | PaymentScalarFieldEnum
    having?: PaymentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PaymentCountAggregateInputType | true
    _avg?: PaymentAvgAggregateInputType
    _sum?: PaymentSumAggregateInputType
    _min?: PaymentMinAggregateInputType
    _max?: PaymentMaxAggregateInputType
  }

  export type PaymentGroupByOutputType = {
    id: string
    paymentRecipt: string | null
    totalAmount: number
    approved: boolean
    paymentType: $Enums.PAYMENTTYPE
    status: $Enums.PAYMENTSTATUS
    method: $Enums.PAYMENTMETHOD
    createdAt: Date
    updatedAt: Date
    _count: PaymentCountAggregateOutputType | null
    _avg: PaymentAvgAggregateOutputType | null
    _sum: PaymentSumAggregateOutputType | null
    _min: PaymentMinAggregateOutputType | null
    _max: PaymentMaxAggregateOutputType | null
  }

  type GetPaymentGroupByPayload<T extends PaymentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PaymentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PaymentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PaymentGroupByOutputType[P]>
            : GetScalarType<T[P], PaymentGroupByOutputType[P]>
        }
      >
    >


  export type PaymentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    paymentRecipt?: boolean
    totalAmount?: boolean
    approved?: boolean
    paymentType?: boolean
    status?: boolean
    method?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    StudentSemesterPayment?: boolean | Payment$StudentSemesterPaymentArgs<ExtArgs>
    PaymentReference?: boolean | Payment$PaymentReferenceArgs<ExtArgs>
    _count?: boolean | PaymentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["payment"]>



  export type PaymentSelectScalar = {
    id?: boolean
    paymentRecipt?: boolean
    totalAmount?: boolean
    approved?: boolean
    paymentType?: boolean
    status?: boolean
    method?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PaymentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "paymentRecipt" | "totalAmount" | "approved" | "paymentType" | "status" | "method" | "createdAt" | "updatedAt", ExtArgs["result"]["payment"]>
  export type PaymentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    StudentSemesterPayment?: boolean | Payment$StudentSemesterPaymentArgs<ExtArgs>
    PaymentReference?: boolean | Payment$PaymentReferenceArgs<ExtArgs>
    _count?: boolean | PaymentCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $PaymentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Payment"
    objects: {
      StudentSemesterPayment: Prisma.$StudentSemesterPaymentPayload<ExtArgs>[]
      PaymentReference: Prisma.$PaymentReferencePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      paymentRecipt: string | null
      totalAmount: number
      approved: boolean
      paymentType: $Enums.PAYMENTTYPE
      status: $Enums.PAYMENTSTATUS
      method: $Enums.PAYMENTMETHOD
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["payment"]>
    composites: {}
  }

  type PaymentGetPayload<S extends boolean | null | undefined | PaymentDefaultArgs> = $Result.GetResult<Prisma.$PaymentPayload, S>

  type PaymentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PaymentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PaymentCountAggregateInputType | true
    }

  export interface PaymentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Payment'], meta: { name: 'Payment' } }
    /**
     * Find zero or one Payment that matches the filter.
     * @param {PaymentFindUniqueArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PaymentFindUniqueArgs>(args: SelectSubset<T, PaymentFindUniqueArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Payment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PaymentFindUniqueOrThrowArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PaymentFindUniqueOrThrowArgs>(args: SelectSubset<T, PaymentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Payment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindFirstArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PaymentFindFirstArgs>(args?: SelectSubset<T, PaymentFindFirstArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Payment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindFirstOrThrowArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PaymentFindFirstOrThrowArgs>(args?: SelectSubset<T, PaymentFindFirstOrThrowArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Payments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Payments
     * const payments = await prisma.payment.findMany()
     * 
     * // Get first 10 Payments
     * const payments = await prisma.payment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const paymentWithIdOnly = await prisma.payment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PaymentFindManyArgs>(args?: SelectSubset<T, PaymentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Payment.
     * @param {PaymentCreateArgs} args - Arguments to create a Payment.
     * @example
     * // Create one Payment
     * const Payment = await prisma.payment.create({
     *   data: {
     *     // ... data to create a Payment
     *   }
     * })
     * 
     */
    create<T extends PaymentCreateArgs>(args: SelectSubset<T, PaymentCreateArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Payments.
     * @param {PaymentCreateManyArgs} args - Arguments to create many Payments.
     * @example
     * // Create many Payments
     * const payment = await prisma.payment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PaymentCreateManyArgs>(args?: SelectSubset<T, PaymentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Payment.
     * @param {PaymentDeleteArgs} args - Arguments to delete one Payment.
     * @example
     * // Delete one Payment
     * const Payment = await prisma.payment.delete({
     *   where: {
     *     // ... filter to delete one Payment
     *   }
     * })
     * 
     */
    delete<T extends PaymentDeleteArgs>(args: SelectSubset<T, PaymentDeleteArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Payment.
     * @param {PaymentUpdateArgs} args - Arguments to update one Payment.
     * @example
     * // Update one Payment
     * const payment = await prisma.payment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PaymentUpdateArgs>(args: SelectSubset<T, PaymentUpdateArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Payments.
     * @param {PaymentDeleteManyArgs} args - Arguments to filter Payments to delete.
     * @example
     * // Delete a few Payments
     * const { count } = await prisma.payment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PaymentDeleteManyArgs>(args?: SelectSubset<T, PaymentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Payments
     * const payment = await prisma.payment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PaymentUpdateManyArgs>(args: SelectSubset<T, PaymentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Payment.
     * @param {PaymentUpsertArgs} args - Arguments to update or create a Payment.
     * @example
     * // Update or create a Payment
     * const payment = await prisma.payment.upsert({
     *   create: {
     *     // ... data to create a Payment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Payment we want to update
     *   }
     * })
     */
    upsert<T extends PaymentUpsertArgs>(args: SelectSubset<T, PaymentUpsertArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentCountArgs} args - Arguments to filter Payments to count.
     * @example
     * // Count the number of Payments
     * const count = await prisma.payment.count({
     *   where: {
     *     // ... the filter for the Payments we want to count
     *   }
     * })
    **/
    count<T extends PaymentCountArgs>(
      args?: Subset<T, PaymentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PaymentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Payment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PaymentAggregateArgs>(args: Subset<T, PaymentAggregateArgs>): Prisma.PrismaPromise<GetPaymentAggregateType<T>>

    /**
     * Group by Payment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PaymentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PaymentGroupByArgs['orderBy'] }
        : { orderBy?: PaymentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PaymentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPaymentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Payment model
   */
  readonly fields: PaymentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Payment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PaymentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    StudentSemesterPayment<T extends Payment$StudentSemesterPaymentArgs<ExtArgs> = {}>(args?: Subset<T, Payment$StudentSemesterPaymentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentSemesterPaymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    PaymentReference<T extends Payment$PaymentReferenceArgs<ExtArgs> = {}>(args?: Subset<T, Payment$PaymentReferenceArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentReferencePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Payment model
   */
  interface PaymentFieldRefs {
    readonly id: FieldRef<"Payment", 'String'>
    readonly paymentRecipt: FieldRef<"Payment", 'String'>
    readonly totalAmount: FieldRef<"Payment", 'Int'>
    readonly approved: FieldRef<"Payment", 'Boolean'>
    readonly paymentType: FieldRef<"Payment", 'PAYMENTTYPE'>
    readonly status: FieldRef<"Payment", 'PAYMENTSTATUS'>
    readonly method: FieldRef<"Payment", 'PAYMENTMETHOD'>
    readonly createdAt: FieldRef<"Payment", 'DateTime'>
    readonly updatedAt: FieldRef<"Payment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Payment findUnique
   */
  export type PaymentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment findUniqueOrThrow
   */
  export type PaymentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment findFirst
   */
  export type PaymentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Payments.
     */
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment findFirstOrThrow
   */
  export type PaymentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Payments.
     */
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment findMany
   */
  export type PaymentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payments to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment create
   */
  export type PaymentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The data needed to create a Payment.
     */
    data: XOR<PaymentCreateInput, PaymentUncheckedCreateInput>
  }

  /**
   * Payment createMany
   */
  export type PaymentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Payments.
     */
    data: PaymentCreateManyInput | PaymentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Payment update
   */
  export type PaymentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The data needed to update a Payment.
     */
    data: XOR<PaymentUpdateInput, PaymentUncheckedUpdateInput>
    /**
     * Choose, which Payment to update.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment updateMany
   */
  export type PaymentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Payments.
     */
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyInput>
    /**
     * Filter which Payments to update
     */
    where?: PaymentWhereInput
    /**
     * Limit how many Payments to update.
     */
    limit?: number
  }

  /**
   * Payment upsert
   */
  export type PaymentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The filter to search for the Payment to update in case it exists.
     */
    where: PaymentWhereUniqueInput
    /**
     * In case the Payment found by the `where` argument doesn't exist, create a new Payment with this data.
     */
    create: XOR<PaymentCreateInput, PaymentUncheckedCreateInput>
    /**
     * In case the Payment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PaymentUpdateInput, PaymentUncheckedUpdateInput>
  }

  /**
   * Payment delete
   */
  export type PaymentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter which Payment to delete.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment deleteMany
   */
  export type PaymentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Payments to delete
     */
    where?: PaymentWhereInput
    /**
     * Limit how many Payments to delete.
     */
    limit?: number
  }

  /**
   * Payment.StudentSemesterPayment
   */
  export type Payment$StudentSemesterPaymentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentSemesterPayment
     */
    select?: StudentSemesterPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentSemesterPayment
     */
    omit?: StudentSemesterPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentSemesterPaymentInclude<ExtArgs> | null
    where?: StudentSemesterPaymentWhereInput
    orderBy?: StudentSemesterPaymentOrderByWithRelationInput | StudentSemesterPaymentOrderByWithRelationInput[]
    cursor?: StudentSemesterPaymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StudentSemesterPaymentScalarFieldEnum | StudentSemesterPaymentScalarFieldEnum[]
  }

  /**
   * Payment.PaymentReference
   */
  export type Payment$PaymentReferenceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentReference
     */
    select?: PaymentReferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentReference
     */
    omit?: PaymentReferenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentReferenceInclude<ExtArgs> | null
    where?: PaymentReferenceWhereInput
    orderBy?: PaymentReferenceOrderByWithRelationInput | PaymentReferenceOrderByWithRelationInput[]
    cursor?: PaymentReferenceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaymentReferenceScalarFieldEnum | PaymentReferenceScalarFieldEnum[]
  }

  /**
   * Payment without action
   */
  export type PaymentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
  }


  /**
   * Model PaymentReference
   */

  export type AggregatePaymentReference = {
    _count: PaymentReferenceCountAggregateOutputType | null
    _avg: PaymentReferenceAvgAggregateOutputType | null
    _sum: PaymentReferenceSumAggregateOutputType | null
    _min: PaymentReferenceMinAggregateOutputType | null
    _max: PaymentReferenceMaxAggregateOutputType | null
  }

  export type PaymentReferenceAvgAggregateOutputType = {
    code: number | null
  }

  export type PaymentReferenceSumAggregateOutputType = {
    code: number | null
  }

  export type PaymentReferenceMinAggregateOutputType = {
    id: string | null
    reference: string | null
    code: number | null
    message: string | null
    paymentId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PaymentReferenceMaxAggregateOutputType = {
    id: string | null
    reference: string | null
    code: number | null
    message: string | null
    paymentId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PaymentReferenceCountAggregateOutputType = {
    id: number
    reference: number
    code: number
    message: number
    paymentId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PaymentReferenceAvgAggregateInputType = {
    code?: true
  }

  export type PaymentReferenceSumAggregateInputType = {
    code?: true
  }

  export type PaymentReferenceMinAggregateInputType = {
    id?: true
    reference?: true
    code?: true
    message?: true
    paymentId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PaymentReferenceMaxAggregateInputType = {
    id?: true
    reference?: true
    code?: true
    message?: true
    paymentId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PaymentReferenceCountAggregateInputType = {
    id?: true
    reference?: true
    code?: true
    message?: true
    paymentId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PaymentReferenceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PaymentReference to aggregate.
     */
    where?: PaymentReferenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentReferences to fetch.
     */
    orderBy?: PaymentReferenceOrderByWithRelationInput | PaymentReferenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PaymentReferenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentReferences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentReferences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PaymentReferences
    **/
    _count?: true | PaymentReferenceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PaymentReferenceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PaymentReferenceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PaymentReferenceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PaymentReferenceMaxAggregateInputType
  }

  export type GetPaymentReferenceAggregateType<T extends PaymentReferenceAggregateArgs> = {
        [P in keyof T & keyof AggregatePaymentReference]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePaymentReference[P]>
      : GetScalarType<T[P], AggregatePaymentReference[P]>
  }




  export type PaymentReferenceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentReferenceWhereInput
    orderBy?: PaymentReferenceOrderByWithAggregationInput | PaymentReferenceOrderByWithAggregationInput[]
    by: PaymentReferenceScalarFieldEnum[] | PaymentReferenceScalarFieldEnum
    having?: PaymentReferenceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PaymentReferenceCountAggregateInputType | true
    _avg?: PaymentReferenceAvgAggregateInputType
    _sum?: PaymentReferenceSumAggregateInputType
    _min?: PaymentReferenceMinAggregateInputType
    _max?: PaymentReferenceMaxAggregateInputType
  }

  export type PaymentReferenceGroupByOutputType = {
    id: string
    reference: string
    code: number
    message: string
    paymentId: string
    createdAt: Date
    updatedAt: Date
    _count: PaymentReferenceCountAggregateOutputType | null
    _avg: PaymentReferenceAvgAggregateOutputType | null
    _sum: PaymentReferenceSumAggregateOutputType | null
    _min: PaymentReferenceMinAggregateOutputType | null
    _max: PaymentReferenceMaxAggregateOutputType | null
  }

  type GetPaymentReferenceGroupByPayload<T extends PaymentReferenceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PaymentReferenceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PaymentReferenceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PaymentReferenceGroupByOutputType[P]>
            : GetScalarType<T[P], PaymentReferenceGroupByOutputType[P]>
        }
      >
    >


  export type PaymentReferenceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    reference?: boolean
    code?: boolean
    message?: boolean
    paymentId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    payment?: boolean | PaymentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["paymentReference"]>



  export type PaymentReferenceSelectScalar = {
    id?: boolean
    reference?: boolean
    code?: boolean
    message?: boolean
    paymentId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PaymentReferenceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "reference" | "code" | "message" | "paymentId" | "createdAt" | "updatedAt", ExtArgs["result"]["paymentReference"]>
  export type PaymentReferenceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    payment?: boolean | PaymentDefaultArgs<ExtArgs>
  }

  export type $PaymentReferencePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PaymentReference"
    objects: {
      payment: Prisma.$PaymentPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      reference: string
      code: number
      message: string
      paymentId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["paymentReference"]>
    composites: {}
  }

  type PaymentReferenceGetPayload<S extends boolean | null | undefined | PaymentReferenceDefaultArgs> = $Result.GetResult<Prisma.$PaymentReferencePayload, S>

  type PaymentReferenceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PaymentReferenceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PaymentReferenceCountAggregateInputType | true
    }

  export interface PaymentReferenceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PaymentReference'], meta: { name: 'PaymentReference' } }
    /**
     * Find zero or one PaymentReference that matches the filter.
     * @param {PaymentReferenceFindUniqueArgs} args - Arguments to find a PaymentReference
     * @example
     * // Get one PaymentReference
     * const paymentReference = await prisma.paymentReference.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PaymentReferenceFindUniqueArgs>(args: SelectSubset<T, PaymentReferenceFindUniqueArgs<ExtArgs>>): Prisma__PaymentReferenceClient<$Result.GetResult<Prisma.$PaymentReferencePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PaymentReference that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PaymentReferenceFindUniqueOrThrowArgs} args - Arguments to find a PaymentReference
     * @example
     * // Get one PaymentReference
     * const paymentReference = await prisma.paymentReference.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PaymentReferenceFindUniqueOrThrowArgs>(args: SelectSubset<T, PaymentReferenceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PaymentReferenceClient<$Result.GetResult<Prisma.$PaymentReferencePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PaymentReference that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentReferenceFindFirstArgs} args - Arguments to find a PaymentReference
     * @example
     * // Get one PaymentReference
     * const paymentReference = await prisma.paymentReference.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PaymentReferenceFindFirstArgs>(args?: SelectSubset<T, PaymentReferenceFindFirstArgs<ExtArgs>>): Prisma__PaymentReferenceClient<$Result.GetResult<Prisma.$PaymentReferencePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PaymentReference that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentReferenceFindFirstOrThrowArgs} args - Arguments to find a PaymentReference
     * @example
     * // Get one PaymentReference
     * const paymentReference = await prisma.paymentReference.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PaymentReferenceFindFirstOrThrowArgs>(args?: SelectSubset<T, PaymentReferenceFindFirstOrThrowArgs<ExtArgs>>): Prisma__PaymentReferenceClient<$Result.GetResult<Prisma.$PaymentReferencePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PaymentReferences that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentReferenceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PaymentReferences
     * const paymentReferences = await prisma.paymentReference.findMany()
     * 
     * // Get first 10 PaymentReferences
     * const paymentReferences = await prisma.paymentReference.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const paymentReferenceWithIdOnly = await prisma.paymentReference.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PaymentReferenceFindManyArgs>(args?: SelectSubset<T, PaymentReferenceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentReferencePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PaymentReference.
     * @param {PaymentReferenceCreateArgs} args - Arguments to create a PaymentReference.
     * @example
     * // Create one PaymentReference
     * const PaymentReference = await prisma.paymentReference.create({
     *   data: {
     *     // ... data to create a PaymentReference
     *   }
     * })
     * 
     */
    create<T extends PaymentReferenceCreateArgs>(args: SelectSubset<T, PaymentReferenceCreateArgs<ExtArgs>>): Prisma__PaymentReferenceClient<$Result.GetResult<Prisma.$PaymentReferencePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PaymentReferences.
     * @param {PaymentReferenceCreateManyArgs} args - Arguments to create many PaymentReferences.
     * @example
     * // Create many PaymentReferences
     * const paymentReference = await prisma.paymentReference.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PaymentReferenceCreateManyArgs>(args?: SelectSubset<T, PaymentReferenceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a PaymentReference.
     * @param {PaymentReferenceDeleteArgs} args - Arguments to delete one PaymentReference.
     * @example
     * // Delete one PaymentReference
     * const PaymentReference = await prisma.paymentReference.delete({
     *   where: {
     *     // ... filter to delete one PaymentReference
     *   }
     * })
     * 
     */
    delete<T extends PaymentReferenceDeleteArgs>(args: SelectSubset<T, PaymentReferenceDeleteArgs<ExtArgs>>): Prisma__PaymentReferenceClient<$Result.GetResult<Prisma.$PaymentReferencePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PaymentReference.
     * @param {PaymentReferenceUpdateArgs} args - Arguments to update one PaymentReference.
     * @example
     * // Update one PaymentReference
     * const paymentReference = await prisma.paymentReference.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PaymentReferenceUpdateArgs>(args: SelectSubset<T, PaymentReferenceUpdateArgs<ExtArgs>>): Prisma__PaymentReferenceClient<$Result.GetResult<Prisma.$PaymentReferencePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PaymentReferences.
     * @param {PaymentReferenceDeleteManyArgs} args - Arguments to filter PaymentReferences to delete.
     * @example
     * // Delete a few PaymentReferences
     * const { count } = await prisma.paymentReference.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PaymentReferenceDeleteManyArgs>(args?: SelectSubset<T, PaymentReferenceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PaymentReferences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentReferenceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PaymentReferences
     * const paymentReference = await prisma.paymentReference.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PaymentReferenceUpdateManyArgs>(args: SelectSubset<T, PaymentReferenceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PaymentReference.
     * @param {PaymentReferenceUpsertArgs} args - Arguments to update or create a PaymentReference.
     * @example
     * // Update or create a PaymentReference
     * const paymentReference = await prisma.paymentReference.upsert({
     *   create: {
     *     // ... data to create a PaymentReference
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PaymentReference we want to update
     *   }
     * })
     */
    upsert<T extends PaymentReferenceUpsertArgs>(args: SelectSubset<T, PaymentReferenceUpsertArgs<ExtArgs>>): Prisma__PaymentReferenceClient<$Result.GetResult<Prisma.$PaymentReferencePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PaymentReferences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentReferenceCountArgs} args - Arguments to filter PaymentReferences to count.
     * @example
     * // Count the number of PaymentReferences
     * const count = await prisma.paymentReference.count({
     *   where: {
     *     // ... the filter for the PaymentReferences we want to count
     *   }
     * })
    **/
    count<T extends PaymentReferenceCountArgs>(
      args?: Subset<T, PaymentReferenceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PaymentReferenceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PaymentReference.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentReferenceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PaymentReferenceAggregateArgs>(args: Subset<T, PaymentReferenceAggregateArgs>): Prisma.PrismaPromise<GetPaymentReferenceAggregateType<T>>

    /**
     * Group by PaymentReference.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentReferenceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PaymentReferenceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PaymentReferenceGroupByArgs['orderBy'] }
        : { orderBy?: PaymentReferenceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PaymentReferenceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPaymentReferenceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PaymentReference model
   */
  readonly fields: PaymentReferenceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PaymentReference.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PaymentReferenceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    payment<T extends PaymentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PaymentDefaultArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PaymentReference model
   */
  interface PaymentReferenceFieldRefs {
    readonly id: FieldRef<"PaymentReference", 'String'>
    readonly reference: FieldRef<"PaymentReference", 'String'>
    readonly code: FieldRef<"PaymentReference", 'Int'>
    readonly message: FieldRef<"PaymentReference", 'String'>
    readonly paymentId: FieldRef<"PaymentReference", 'String'>
    readonly createdAt: FieldRef<"PaymentReference", 'DateTime'>
    readonly updatedAt: FieldRef<"PaymentReference", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PaymentReference findUnique
   */
  export type PaymentReferenceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentReference
     */
    select?: PaymentReferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentReference
     */
    omit?: PaymentReferenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentReferenceInclude<ExtArgs> | null
    /**
     * Filter, which PaymentReference to fetch.
     */
    where: PaymentReferenceWhereUniqueInput
  }

  /**
   * PaymentReference findUniqueOrThrow
   */
  export type PaymentReferenceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentReference
     */
    select?: PaymentReferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentReference
     */
    omit?: PaymentReferenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentReferenceInclude<ExtArgs> | null
    /**
     * Filter, which PaymentReference to fetch.
     */
    where: PaymentReferenceWhereUniqueInput
  }

  /**
   * PaymentReference findFirst
   */
  export type PaymentReferenceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentReference
     */
    select?: PaymentReferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentReference
     */
    omit?: PaymentReferenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentReferenceInclude<ExtArgs> | null
    /**
     * Filter, which PaymentReference to fetch.
     */
    where?: PaymentReferenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentReferences to fetch.
     */
    orderBy?: PaymentReferenceOrderByWithRelationInput | PaymentReferenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PaymentReferences.
     */
    cursor?: PaymentReferenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentReferences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentReferences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PaymentReferences.
     */
    distinct?: PaymentReferenceScalarFieldEnum | PaymentReferenceScalarFieldEnum[]
  }

  /**
   * PaymentReference findFirstOrThrow
   */
  export type PaymentReferenceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentReference
     */
    select?: PaymentReferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentReference
     */
    omit?: PaymentReferenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentReferenceInclude<ExtArgs> | null
    /**
     * Filter, which PaymentReference to fetch.
     */
    where?: PaymentReferenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentReferences to fetch.
     */
    orderBy?: PaymentReferenceOrderByWithRelationInput | PaymentReferenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PaymentReferences.
     */
    cursor?: PaymentReferenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentReferences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentReferences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PaymentReferences.
     */
    distinct?: PaymentReferenceScalarFieldEnum | PaymentReferenceScalarFieldEnum[]
  }

  /**
   * PaymentReference findMany
   */
  export type PaymentReferenceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentReference
     */
    select?: PaymentReferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentReference
     */
    omit?: PaymentReferenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentReferenceInclude<ExtArgs> | null
    /**
     * Filter, which PaymentReferences to fetch.
     */
    where?: PaymentReferenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentReferences to fetch.
     */
    orderBy?: PaymentReferenceOrderByWithRelationInput | PaymentReferenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PaymentReferences.
     */
    cursor?: PaymentReferenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentReferences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentReferences.
     */
    skip?: number
    distinct?: PaymentReferenceScalarFieldEnum | PaymentReferenceScalarFieldEnum[]
  }

  /**
   * PaymentReference create
   */
  export type PaymentReferenceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentReference
     */
    select?: PaymentReferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentReference
     */
    omit?: PaymentReferenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentReferenceInclude<ExtArgs> | null
    /**
     * The data needed to create a PaymentReference.
     */
    data: XOR<PaymentReferenceCreateInput, PaymentReferenceUncheckedCreateInput>
  }

  /**
   * PaymentReference createMany
   */
  export type PaymentReferenceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PaymentReferences.
     */
    data: PaymentReferenceCreateManyInput | PaymentReferenceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PaymentReference update
   */
  export type PaymentReferenceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentReference
     */
    select?: PaymentReferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentReference
     */
    omit?: PaymentReferenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentReferenceInclude<ExtArgs> | null
    /**
     * The data needed to update a PaymentReference.
     */
    data: XOR<PaymentReferenceUpdateInput, PaymentReferenceUncheckedUpdateInput>
    /**
     * Choose, which PaymentReference to update.
     */
    where: PaymentReferenceWhereUniqueInput
  }

  /**
   * PaymentReference updateMany
   */
  export type PaymentReferenceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PaymentReferences.
     */
    data: XOR<PaymentReferenceUpdateManyMutationInput, PaymentReferenceUncheckedUpdateManyInput>
    /**
     * Filter which PaymentReferences to update
     */
    where?: PaymentReferenceWhereInput
    /**
     * Limit how many PaymentReferences to update.
     */
    limit?: number
  }

  /**
   * PaymentReference upsert
   */
  export type PaymentReferenceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentReference
     */
    select?: PaymentReferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentReference
     */
    omit?: PaymentReferenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentReferenceInclude<ExtArgs> | null
    /**
     * The filter to search for the PaymentReference to update in case it exists.
     */
    where: PaymentReferenceWhereUniqueInput
    /**
     * In case the PaymentReference found by the `where` argument doesn't exist, create a new PaymentReference with this data.
     */
    create: XOR<PaymentReferenceCreateInput, PaymentReferenceUncheckedCreateInput>
    /**
     * In case the PaymentReference was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PaymentReferenceUpdateInput, PaymentReferenceUncheckedUpdateInput>
  }

  /**
   * PaymentReference delete
   */
  export type PaymentReferenceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentReference
     */
    select?: PaymentReferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentReference
     */
    omit?: PaymentReferenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentReferenceInclude<ExtArgs> | null
    /**
     * Filter which PaymentReference to delete.
     */
    where: PaymentReferenceWhereUniqueInput
  }

  /**
   * PaymentReference deleteMany
   */
  export type PaymentReferenceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PaymentReferences to delete
     */
    where?: PaymentReferenceWhereInput
    /**
     * Limit how many PaymentReferences to delete.
     */
    limit?: number
  }

  /**
   * PaymentReference without action
   */
  export type PaymentReferenceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentReference
     */
    select?: PaymentReferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentReference
     */
    omit?: PaymentReferenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentReferenceInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UsersScalarFieldEnum: {
    id: 'id',
    name: 'name',
    email: 'email',
    password: 'password',
    avatar: 'avatar',
    role: 'role',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UsersScalarFieldEnum = (typeof UsersScalarFieldEnum)[keyof typeof UsersScalarFieldEnum]


  export const AcademicSemesterScalarFieldEnum: {
    id: 'id',
    title: 'title',
    year: 'year',
    code: 'code',
    startMonth: 'startMonth',
    endMonth: 'endMonth',
    isCurrent: 'isCurrent',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AcademicSemesterScalarFieldEnum = (typeof AcademicSemesterScalarFieldEnum)[keyof typeof AcademicSemesterScalarFieldEnum]


  export const AcademicFacultyScalarFieldEnum: {
    id: 'id',
    title: 'title',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AcademicFacultyScalarFieldEnum = (typeof AcademicFacultyScalarFieldEnum)[keyof typeof AcademicFacultyScalarFieldEnum]


  export const AcademicDepartmentScalarFieldEnum: {
    id: 'id',
    title: 'title',
    academicFacultyId: 'academicFacultyId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    departmentHeadId: 'departmentHeadId'
  };

  export type AcademicDepartmentScalarFieldEnum = (typeof AcademicDepartmentScalarFieldEnum)[keyof typeof AcademicDepartmentScalarFieldEnum]


  export const StudentScalarFieldEnum: {
    id: 'id',
    studentId: 'studentId',
    studentType: 'studentType',
    firstName: 'firstName',
    middleName: 'middleName',
    lastName: 'lastName',
    profileImage: 'profileImage',
    email: 'email',
    contactNo: 'contactNo',
    gender: 'gender',
    isWoker: 'isWoker',
    shift: 'shift',
    yearLevel: 'yearLevel',
    isActive: 'isActive',
    password: 'password',
    gradeDeclarationFile: 'gradeDeclarationFile',
    biFile: 'biFile',
    presentAddress: 'presentAddress',
    permanentAddress: 'permanentAddress',
    academicSemesterId: 'academicSemesterId',
    academicFacultyId: 'academicFacultyId',
    academicDepartmentId: 'academicDepartmentId',
    admissionRegistrationId: 'admissionRegistrationId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type StudentScalarFieldEnum = (typeof StudentScalarFieldEnum)[keyof typeof StudentScalarFieldEnum]


  export const FacultyScalarFieldEnum: {
    id: 'id',
    facultyId: 'facultyId',
    firstName: 'firstName',
    middleName: 'middleName',
    lastName: 'lastName',
    profileImage: 'profileImage',
    email: 'email',
    contactNo: 'contactNo',
    shift: 'shift',
    gender: 'gender',
    designation: 'designation',
    password: 'password',
    academicFacultyId: 'academicFacultyId',
    academicDepartmentId: 'academicDepartmentId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type FacultyScalarFieldEnum = (typeof FacultyScalarFieldEnum)[keyof typeof FacultyScalarFieldEnum]


  export const BuildingScalarFieldEnum: {
    id: 'id',
    title: 'title',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BuildingScalarFieldEnum = (typeof BuildingScalarFieldEnum)[keyof typeof BuildingScalarFieldEnum]


  export const RoomScalarFieldEnum: {
    id: 'id',
    roomNumber: 'roomNumber',
    floor: 'floor',
    buildingId: 'buildingId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type RoomScalarFieldEnum = (typeof RoomScalarFieldEnum)[keyof typeof RoomScalarFieldEnum]


  export const CourseScalarFieldEnum: {
    id: 'id',
    title: 'title',
    code: 'code',
    durationInYears: 'durationInYears',
    yearLevel: 'yearLevel',
    shift: 'shift',
    academicDepartmentId: 'academicDepartmentId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CourseScalarFieldEnum = (typeof CourseScalarFieldEnum)[keyof typeof CourseScalarFieldEnum]


  export const CourseToPreRequisiteScalarFieldEnum: {
    courseId: 'courseId',
    preRequisiteId: 'preRequisiteId'
  };

  export type CourseToPreRequisiteScalarFieldEnum = (typeof CourseToPreRequisiteScalarFieldEnum)[keyof typeof CourseToPreRequisiteScalarFieldEnum]


  export const CourseFacultyScalarFieldEnum: {
    courseId: 'courseId',
    facultyId: 'facultyId'
  };

  export type CourseFacultyScalarFieldEnum = (typeof CourseFacultyScalarFieldEnum)[keyof typeof CourseFacultyScalarFieldEnum]


  export const SemesterRegistrationScalarFieldEnum: {
    id: 'id',
    startDate: 'startDate',
    endDate: 'endDate',
    status: 'status',
    createdAt: 'createdAt',
    updateAt: 'updateAt',
    academicSemesterId: 'academicSemesterId'
  };

  export type SemesterRegistrationScalarFieldEnum = (typeof SemesterRegistrationScalarFieldEnum)[keyof typeof SemesterRegistrationScalarFieldEnum]


  export const AdmitionExameRegistrationScalarFieldEnum: {
    id: 'id',
    applicantName: 'applicantName',
    paymentRecipt: 'paymentRecipt',
    status: 'status',
    document: 'document',
    paymentAmoute: 'paymentAmoute',
    aprovePayment: 'aprovePayment',
    exameResults: 'exameResults',
    passed: 'passed',
    faseId: 'faseId',
    exameDate: 'exameDate',
    rejectionReason: 'rejectionReason',
    phoneNumber: 'phoneNumber',
    email: 'email',
    createdAt: 'createdAt',
    updateAt: 'updateAt',
    academicFalcultyId: 'academicFalcultyId'
  };

  export type AdmitionExameRegistrationScalarFieldEnum = (typeof AdmitionExameRegistrationScalarFieldEnum)[keyof typeof AdmitionExameRegistrationScalarFieldEnum]


  export const AdmitionExamePriceScalarFieldEnum: {
    id: 'id',
    academicFacultyId: 'academicFacultyId',
    price: 'price',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AdmitionExamePriceScalarFieldEnum = (typeof AdmitionExamePriceScalarFieldEnum)[keyof typeof AdmitionExamePriceScalarFieldEnum]


  export const AdmitionExamePeriodScalarFieldEnum: {
    id: 'id',
    startDate: 'startDate',
    endDate: 'endDate',
    academicFacultyId: 'academicFacultyId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AdmitionExamePeriodScalarFieldEnum = (typeof AdmitionExamePeriodScalarFieldEnum)[keyof typeof AdmitionExamePeriodScalarFieldEnum]


  export const ExameFaseScalarFieldEnum: {
    id: 'id',
    name: 'name',
    ordem: 'ordem',
    startDate: 'startDate',
    endDate: 'endDate',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ExameFaseScalarFieldEnum = (typeof ExameFaseScalarFieldEnum)[keyof typeof ExameFaseScalarFieldEnum]


  export const OfferedCourseScalarFieldEnum: {
    id: 'id',
    academicDepartmentId: 'academicDepartmentId',
    courseId: 'courseId',
    semesterRegistrationId: 'semesterRegistrationId',
    suspendGrade: 'suspendGrade'
  };

  export type OfferedCourseScalarFieldEnum = (typeof OfferedCourseScalarFieldEnum)[keyof typeof OfferedCourseScalarFieldEnum]


  export const OfferedCourseSectionScalarFieldEnum: {
    id: 'id',
    title: 'title',
    maxCapacity: 'maxCapacity',
    currentlyEnrolledStudent: 'currentlyEnrolledStudent',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    semesterRegistrationId: 'semesterRegistrationId',
    offeredCourseId: 'offeredCourseId'
  };

  export type OfferedCourseSectionScalarFieldEnum = (typeof OfferedCourseSectionScalarFieldEnum)[keyof typeof OfferedCourseSectionScalarFieldEnum]


  export const OfferedCourseClassScheduleScalarFieldEnum: {
    id: 'id',
    startTime: 'startTime',
    endTime: 'endTime',
    dayOfWeek: 'dayOfWeek',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    offeredCourseSectionId: 'offeredCourseSectionId',
    semesterRegistrationId: 'semesterRegistrationId',
    roomId: 'roomId',
    facultyId: 'facultyId'
  };

  export type OfferedCourseClassScheduleScalarFieldEnum = (typeof OfferedCourseClassScheduleScalarFieldEnum)[keyof typeof OfferedCourseClassScheduleScalarFieldEnum]


  export const StudentSemesterRegistrationScalarFieldEnum: {
    id: 'id',
    isConfirmed: 'isConfirmed',
    totalCreditsTaken: 'totalCreditsTaken',
    paymentRecipt: 'paymentRecipt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    studentId: 'studentId',
    semesterRegistrationId: 'semesterRegistrationId'
  };

  export type StudentSemesterRegistrationScalarFieldEnum = (typeof StudentSemesterRegistrationScalarFieldEnum)[keyof typeof StudentSemesterRegistrationScalarFieldEnum]


  export const StudentSemesterRegistrationCourseScalarFieldEnum: {
    semesterRegistrationId: 'semesterRegistrationId',
    studentId: 'studentId',
    offeredCourseId: 'offeredCourseId',
    offeredCourseSectionId: 'offeredCourseSectionId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type StudentSemesterRegistrationCourseScalarFieldEnum = (typeof StudentSemesterRegistrationCourseScalarFieldEnum)[keyof typeof StudentSemesterRegistrationCourseScalarFieldEnum]


  export const StudentEnrolledCourseScalarFieldEnum: {
    id: 'id',
    grade: 'grade',
    point: 'point',
    totalMarks: 'totalMarks',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    studentId: 'studentId',
    academicSemesterId: 'academicSemesterId',
    courseId: 'courseId'
  };

  export type StudentEnrolledCourseScalarFieldEnum = (typeof StudentEnrolledCourseScalarFieldEnum)[keyof typeof StudentEnrolledCourseScalarFieldEnum]


  export const StudentEnrolledCourseMarkScalarFieldEnum: {
    id: 'id',
    examType: 'examType',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    studentId: 'studentId',
    studentEnrolledCourseId: 'studentEnrolledCourseId',
    academicSemesterId: 'academicSemesterId',
    continuousAssessments: 'continuousAssessments',
    frequencyExam: 'frequencyExam',
    finalExam: 'finalExam',
    resourceExam: 'resourceExam',
    specialExam: 'specialExam',
    recoveryExam: 'recoveryExam',
    totalMarks: 'totalMarks',
    grade: 'grade'
  };

  export type StudentEnrolledCourseMarkScalarFieldEnum = (typeof StudentEnrolledCourseMarkScalarFieldEnum)[keyof typeof StudentEnrolledCourseMarkScalarFieldEnum]


  export const CourseDisciplineScalarFieldEnum: {
    id: 'id',
    courseId: 'courseId',
    disciplineId: 'disciplineId',
    semesterId: 'semesterId',
    credits: 'credits'
  };

  export type CourseDisciplineScalarFieldEnum = (typeof CourseDisciplineScalarFieldEnum)[keyof typeof CourseDisciplineScalarFieldEnum]


  export const StudentCarriedCourseScalarFieldEnum: {
    id: 'id',
    studentId: 'studentId',
    disciplineId: 'disciplineId',
    semesterId: 'semesterId',
    shift: 'shift',
    price: 'price',
    status: 'status',
    createdAt: 'createdAt'
  };

  export type StudentCarriedCourseScalarFieldEnum = (typeof StudentCarriedCourseScalarFieldEnum)[keyof typeof StudentCarriedCourseScalarFieldEnum]


  export const CoursePricingScalarFieldEnum: {
    id: 'id',
    price: 'price',
    courseId: 'courseId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CoursePricingScalarFieldEnum = (typeof CoursePricingScalarFieldEnum)[keyof typeof CoursePricingScalarFieldEnum]


  export const DisciplineScalarFieldEnum: {
    id: 'id',
    name: 'name',
    code: 'code',
    description: 'description',
    credits: 'credits',
    minimumGradeToDismiss: 'minimumGradeToDismiss',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DisciplineScalarFieldEnum = (typeof DisciplineScalarFieldEnum)[keyof typeof DisciplineScalarFieldEnum]


  export const StudentSemesterPaymentScalarFieldEnum: {
    id: 'id',
    paymentId: 'paymentId',
    totalPayment: 'totalPayment',
    baseAmount: 'baseAmount',
    lateFee: 'lateFee',
    paymentMonth: 'paymentMonth',
    paymentYear: 'paymentYear',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    studentId: 'studentId',
    academicSemesterId: 'academicSemesterId'
  };

  export type StudentSemesterPaymentScalarFieldEnum = (typeof StudentSemesterPaymentScalarFieldEnum)[keyof typeof StudentSemesterPaymentScalarFieldEnum]


  export const StudentAcademicInfoScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    studentId: 'studentId',
    totalCompletedCredits: 'totalCompletedCredits',
    cgpa: 'cgpa'
  };

  export type StudentAcademicInfoScalarFieldEnum = (typeof StudentAcademicInfoScalarFieldEnum)[keyof typeof StudentAcademicInfoScalarFieldEnum]


  export const EventsScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    thumbnail: 'thumbnail',
    color: 'color',
    location: 'location',
    mandatory: 'mandatory',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type EventsScalarFieldEnum = (typeof EventsScalarFieldEnum)[keyof typeof EventsScalarFieldEnum]


  export const PaymentScalarFieldEnum: {
    id: 'id',
    paymentRecipt: 'paymentRecipt',
    totalAmount: 'totalAmount',
    approved: 'approved',
    paymentType: 'paymentType',
    status: 'status',
    method: 'method',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PaymentScalarFieldEnum = (typeof PaymentScalarFieldEnum)[keyof typeof PaymentScalarFieldEnum]


  export const PaymentReferenceScalarFieldEnum: {
    id: 'id',
    reference: 'reference',
    code: 'code',
    message: 'message',
    paymentId: 'paymentId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PaymentReferenceScalarFieldEnum = (typeof PaymentReferenceScalarFieldEnum)[keyof typeof PaymentReferenceScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const UsersOrderByRelevanceFieldEnum: {
    id: 'id',
    name: 'name',
    email: 'email',
    password: 'password',
    avatar: 'avatar'
  };

  export type UsersOrderByRelevanceFieldEnum = (typeof UsersOrderByRelevanceFieldEnum)[keyof typeof UsersOrderByRelevanceFieldEnum]


  export const AcademicSemesterOrderByRelevanceFieldEnum: {
    id: 'id',
    title: 'title',
    year: 'year',
    code: 'code',
    startMonth: 'startMonth',
    endMonth: 'endMonth'
  };

  export type AcademicSemesterOrderByRelevanceFieldEnum = (typeof AcademicSemesterOrderByRelevanceFieldEnum)[keyof typeof AcademicSemesterOrderByRelevanceFieldEnum]


  export const AcademicFacultyOrderByRelevanceFieldEnum: {
    id: 'id',
    title: 'title'
  };

  export type AcademicFacultyOrderByRelevanceFieldEnum = (typeof AcademicFacultyOrderByRelevanceFieldEnum)[keyof typeof AcademicFacultyOrderByRelevanceFieldEnum]


  export const AcademicDepartmentOrderByRelevanceFieldEnum: {
    id: 'id',
    title: 'title',
    academicFacultyId: 'academicFacultyId',
    departmentHeadId: 'departmentHeadId'
  };

  export type AcademicDepartmentOrderByRelevanceFieldEnum = (typeof AcademicDepartmentOrderByRelevanceFieldEnum)[keyof typeof AcademicDepartmentOrderByRelevanceFieldEnum]


  export const StudentOrderByRelevanceFieldEnum: {
    id: 'id',
    studentId: 'studentId',
    firstName: 'firstName',
    middleName: 'middleName',
    lastName: 'lastName',
    profileImage: 'profileImage',
    email: 'email',
    contactNo: 'contactNo',
    gender: 'gender',
    password: 'password',
    gradeDeclarationFile: 'gradeDeclarationFile',
    biFile: 'biFile',
    presentAddress: 'presentAddress',
    permanentAddress: 'permanentAddress',
    academicSemesterId: 'academicSemesterId',
    academicFacultyId: 'academicFacultyId',
    academicDepartmentId: 'academicDepartmentId',
    admissionRegistrationId: 'admissionRegistrationId'
  };

  export type StudentOrderByRelevanceFieldEnum = (typeof StudentOrderByRelevanceFieldEnum)[keyof typeof StudentOrderByRelevanceFieldEnum]


  export const FacultyOrderByRelevanceFieldEnum: {
    id: 'id',
    facultyId: 'facultyId',
    firstName: 'firstName',
    middleName: 'middleName',
    lastName: 'lastName',
    profileImage: 'profileImage',
    email: 'email',
    contactNo: 'contactNo',
    gender: 'gender',
    designation: 'designation',
    password: 'password',
    academicFacultyId: 'academicFacultyId',
    academicDepartmentId: 'academicDepartmentId'
  };

  export type FacultyOrderByRelevanceFieldEnum = (typeof FacultyOrderByRelevanceFieldEnum)[keyof typeof FacultyOrderByRelevanceFieldEnum]


  export const BuildingOrderByRelevanceFieldEnum: {
    id: 'id',
    title: 'title'
  };

  export type BuildingOrderByRelevanceFieldEnum = (typeof BuildingOrderByRelevanceFieldEnum)[keyof typeof BuildingOrderByRelevanceFieldEnum]


  export const RoomOrderByRelevanceFieldEnum: {
    id: 'id',
    roomNumber: 'roomNumber',
    floor: 'floor',
    buildingId: 'buildingId'
  };

  export type RoomOrderByRelevanceFieldEnum = (typeof RoomOrderByRelevanceFieldEnum)[keyof typeof RoomOrderByRelevanceFieldEnum]


  export const CourseOrderByRelevanceFieldEnum: {
    id: 'id',
    title: 'title',
    code: 'code',
    academicDepartmentId: 'academicDepartmentId'
  };

  export type CourseOrderByRelevanceFieldEnum = (typeof CourseOrderByRelevanceFieldEnum)[keyof typeof CourseOrderByRelevanceFieldEnum]


  export const CourseToPreRequisiteOrderByRelevanceFieldEnum: {
    courseId: 'courseId',
    preRequisiteId: 'preRequisiteId'
  };

  export type CourseToPreRequisiteOrderByRelevanceFieldEnum = (typeof CourseToPreRequisiteOrderByRelevanceFieldEnum)[keyof typeof CourseToPreRequisiteOrderByRelevanceFieldEnum]


  export const CourseFacultyOrderByRelevanceFieldEnum: {
    courseId: 'courseId',
    facultyId: 'facultyId'
  };

  export type CourseFacultyOrderByRelevanceFieldEnum = (typeof CourseFacultyOrderByRelevanceFieldEnum)[keyof typeof CourseFacultyOrderByRelevanceFieldEnum]


  export const SemesterRegistrationOrderByRelevanceFieldEnum: {
    id: 'id',
    academicSemesterId: 'academicSemesterId'
  };

  export type SemesterRegistrationOrderByRelevanceFieldEnum = (typeof SemesterRegistrationOrderByRelevanceFieldEnum)[keyof typeof SemesterRegistrationOrderByRelevanceFieldEnum]


  export const AdmitionExameRegistrationOrderByRelevanceFieldEnum: {
    id: 'id',
    applicantName: 'applicantName',
    paymentRecipt: 'paymentRecipt',
    document: 'document',
    faseId: 'faseId',
    rejectionReason: 'rejectionReason',
    phoneNumber: 'phoneNumber',
    email: 'email',
    academicFalcultyId: 'academicFalcultyId'
  };

  export type AdmitionExameRegistrationOrderByRelevanceFieldEnum = (typeof AdmitionExameRegistrationOrderByRelevanceFieldEnum)[keyof typeof AdmitionExameRegistrationOrderByRelevanceFieldEnum]


  export const AdmitionExamePriceOrderByRelevanceFieldEnum: {
    id: 'id',
    academicFacultyId: 'academicFacultyId'
  };

  export type AdmitionExamePriceOrderByRelevanceFieldEnum = (typeof AdmitionExamePriceOrderByRelevanceFieldEnum)[keyof typeof AdmitionExamePriceOrderByRelevanceFieldEnum]


  export const AdmitionExamePeriodOrderByRelevanceFieldEnum: {
    id: 'id',
    academicFacultyId: 'academicFacultyId'
  };

  export type AdmitionExamePeriodOrderByRelevanceFieldEnum = (typeof AdmitionExamePeriodOrderByRelevanceFieldEnum)[keyof typeof AdmitionExamePeriodOrderByRelevanceFieldEnum]


  export const ExameFaseOrderByRelevanceFieldEnum: {
    id: 'id',
    name: 'name'
  };

  export type ExameFaseOrderByRelevanceFieldEnum = (typeof ExameFaseOrderByRelevanceFieldEnum)[keyof typeof ExameFaseOrderByRelevanceFieldEnum]


  export const OfferedCourseOrderByRelevanceFieldEnum: {
    id: 'id',
    academicDepartmentId: 'academicDepartmentId',
    courseId: 'courseId',
    semesterRegistrationId: 'semesterRegistrationId'
  };

  export type OfferedCourseOrderByRelevanceFieldEnum = (typeof OfferedCourseOrderByRelevanceFieldEnum)[keyof typeof OfferedCourseOrderByRelevanceFieldEnum]


  export const OfferedCourseSectionOrderByRelevanceFieldEnum: {
    id: 'id',
    title: 'title',
    semesterRegistrationId: 'semesterRegistrationId',
    offeredCourseId: 'offeredCourseId'
  };

  export type OfferedCourseSectionOrderByRelevanceFieldEnum = (typeof OfferedCourseSectionOrderByRelevanceFieldEnum)[keyof typeof OfferedCourseSectionOrderByRelevanceFieldEnum]


  export const OfferedCourseClassScheduleOrderByRelevanceFieldEnum: {
    id: 'id',
    startTime: 'startTime',
    endTime: 'endTime',
    offeredCourseSectionId: 'offeredCourseSectionId',
    semesterRegistrationId: 'semesterRegistrationId',
    roomId: 'roomId',
    facultyId: 'facultyId'
  };

  export type OfferedCourseClassScheduleOrderByRelevanceFieldEnum = (typeof OfferedCourseClassScheduleOrderByRelevanceFieldEnum)[keyof typeof OfferedCourseClassScheduleOrderByRelevanceFieldEnum]


  export const StudentSemesterRegistrationOrderByRelevanceFieldEnum: {
    id: 'id',
    paymentRecipt: 'paymentRecipt',
    studentId: 'studentId',
    semesterRegistrationId: 'semesterRegistrationId'
  };

  export type StudentSemesterRegistrationOrderByRelevanceFieldEnum = (typeof StudentSemesterRegistrationOrderByRelevanceFieldEnum)[keyof typeof StudentSemesterRegistrationOrderByRelevanceFieldEnum]


  export const StudentSemesterRegistrationCourseOrderByRelevanceFieldEnum: {
    semesterRegistrationId: 'semesterRegistrationId',
    studentId: 'studentId',
    offeredCourseId: 'offeredCourseId',
    offeredCourseSectionId: 'offeredCourseSectionId'
  };

  export type StudentSemesterRegistrationCourseOrderByRelevanceFieldEnum = (typeof StudentSemesterRegistrationCourseOrderByRelevanceFieldEnum)[keyof typeof StudentSemesterRegistrationCourseOrderByRelevanceFieldEnum]


  export const StudentEnrolledCourseOrderByRelevanceFieldEnum: {
    id: 'id',
    grade: 'grade',
    studentId: 'studentId',
    academicSemesterId: 'academicSemesterId',
    courseId: 'courseId'
  };

  export type StudentEnrolledCourseOrderByRelevanceFieldEnum = (typeof StudentEnrolledCourseOrderByRelevanceFieldEnum)[keyof typeof StudentEnrolledCourseOrderByRelevanceFieldEnum]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const StudentEnrolledCourseMarkOrderByRelevanceFieldEnum: {
    id: 'id',
    studentId: 'studentId',
    studentEnrolledCourseId: 'studentEnrolledCourseId',
    academicSemesterId: 'academicSemesterId'
  };

  export type StudentEnrolledCourseMarkOrderByRelevanceFieldEnum = (typeof StudentEnrolledCourseMarkOrderByRelevanceFieldEnum)[keyof typeof StudentEnrolledCourseMarkOrderByRelevanceFieldEnum]


  export const CourseDisciplineOrderByRelevanceFieldEnum: {
    id: 'id',
    courseId: 'courseId',
    disciplineId: 'disciplineId',
    semesterId: 'semesterId'
  };

  export type CourseDisciplineOrderByRelevanceFieldEnum = (typeof CourseDisciplineOrderByRelevanceFieldEnum)[keyof typeof CourseDisciplineOrderByRelevanceFieldEnum]


  export const StudentCarriedCourseOrderByRelevanceFieldEnum: {
    id: 'id',
    studentId: 'studentId',
    disciplineId: 'disciplineId',
    semesterId: 'semesterId'
  };

  export type StudentCarriedCourseOrderByRelevanceFieldEnum = (typeof StudentCarriedCourseOrderByRelevanceFieldEnum)[keyof typeof StudentCarriedCourseOrderByRelevanceFieldEnum]


  export const CoursePricingOrderByRelevanceFieldEnum: {
    id: 'id',
    courseId: 'courseId'
  };

  export type CoursePricingOrderByRelevanceFieldEnum = (typeof CoursePricingOrderByRelevanceFieldEnum)[keyof typeof CoursePricingOrderByRelevanceFieldEnum]


  export const DisciplineOrderByRelevanceFieldEnum: {
    id: 'id',
    name: 'name',
    code: 'code',
    description: 'description'
  };

  export type DisciplineOrderByRelevanceFieldEnum = (typeof DisciplineOrderByRelevanceFieldEnum)[keyof typeof DisciplineOrderByRelevanceFieldEnum]


  export const StudentSemesterPaymentOrderByRelevanceFieldEnum: {
    id: 'id',
    paymentId: 'paymentId',
    studentId: 'studentId',
    academicSemesterId: 'academicSemesterId'
  };

  export type StudentSemesterPaymentOrderByRelevanceFieldEnum = (typeof StudentSemesterPaymentOrderByRelevanceFieldEnum)[keyof typeof StudentSemesterPaymentOrderByRelevanceFieldEnum]


  export const StudentAcademicInfoOrderByRelevanceFieldEnum: {
    id: 'id',
    studentId: 'studentId'
  };

  export type StudentAcademicInfoOrderByRelevanceFieldEnum = (typeof StudentAcademicInfoOrderByRelevanceFieldEnum)[keyof typeof StudentAcademicInfoOrderByRelevanceFieldEnum]


  export const EventsOrderByRelevanceFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    thumbnail: 'thumbnail',
    color: 'color'
  };

  export type EventsOrderByRelevanceFieldEnum = (typeof EventsOrderByRelevanceFieldEnum)[keyof typeof EventsOrderByRelevanceFieldEnum]


  export const PaymentOrderByRelevanceFieldEnum: {
    id: 'id',
    paymentRecipt: 'paymentRecipt'
  };

  export type PaymentOrderByRelevanceFieldEnum = (typeof PaymentOrderByRelevanceFieldEnum)[keyof typeof PaymentOrderByRelevanceFieldEnum]


  export const PaymentReferenceOrderByRelevanceFieldEnum: {
    id: 'id',
    reference: 'reference',
    message: 'message',
    paymentId: 'paymentId'
  };

  export type PaymentReferenceOrderByRelevanceFieldEnum = (typeof PaymentReferenceOrderByRelevanceFieldEnum)[keyof typeof PaymentReferenceOrderByRelevanceFieldEnum]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'UserRole'
   */
  export type EnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'StudentType'
   */
  export type EnumStudentTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'StudentType'>
    


  /**
   * Reference to a field of type 'Shift'
   */
  export type EnumShiftFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Shift'>
    


  /**
   * Reference to a field of type 'YearLevel'
   */
  export type EnumYearLevelFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'YearLevel'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'SemesterRegistrationStatus'
   */
  export type EnumSemesterRegistrationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SemesterRegistrationStatus'>
    


  /**
   * Reference to a field of type 'Status'
   */
  export type EnumStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Status'>
    


  /**
   * Reference to a field of type 'WeekDays'
   */
  export type EnumWeekDaysFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'WeekDays'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'StudentEnrolledCourseStatus'
   */
  export type EnumStudentEnrolledCourseStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'StudentEnrolledCourseStatus'>
    


  /**
   * Reference to a field of type 'ExamType'
   */
  export type EnumExamTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ExamType'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


  /**
   * Reference to a field of type 'CarriedCourseStatus'
   */
  export type EnumCarriedCourseStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CarriedCourseStatus'>
    


  /**
   * Reference to a field of type 'PAYMENTTYPE'
   */
  export type EnumPAYMENTTYPEFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PAYMENTTYPE'>
    


  /**
   * Reference to a field of type 'PAYMENTSTATUS'
   */
  export type EnumPAYMENTSTATUSFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PAYMENTSTATUS'>
    


  /**
   * Reference to a field of type 'PAYMENTMETHOD'
   */
  export type EnumPAYMENTMETHODFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PAYMENTMETHOD'>
    
  /**
   * Deep Input Types
   */


  export type UsersWhereInput = {
    AND?: UsersWhereInput | UsersWhereInput[]
    OR?: UsersWhereInput[]
    NOT?: UsersWhereInput | UsersWhereInput[]
    id?: StringFilter<"Users"> | string
    name?: StringFilter<"Users"> | string
    email?: StringFilter<"Users"> | string
    password?: StringFilter<"Users"> | string
    avatar?: StringNullableFilter<"Users"> | string | null
    role?: EnumUserRoleFilter<"Users"> | $Enums.UserRole
    createdAt?: DateTimeFilter<"Users"> | Date | string
    updatedAt?: DateTimeFilter<"Users"> | Date | string
    academicDepartment?: XOR<AcademicDepartmentNullableScalarRelationFilter, AcademicDepartmentWhereInput> | null
    staffDepartments?: AcademicDepartmentListRelationFilter
  }

  export type UsersOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    avatar?: SortOrderInput | SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    academicDepartment?: AcademicDepartmentOrderByWithRelationInput
    staffDepartments?: AcademicDepartmentOrderByRelationAggregateInput
    _relevance?: UsersOrderByRelevanceInput
  }

  export type UsersWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: UsersWhereInput | UsersWhereInput[]
    OR?: UsersWhereInput[]
    NOT?: UsersWhereInput | UsersWhereInput[]
    name?: StringFilter<"Users"> | string
    password?: StringFilter<"Users"> | string
    avatar?: StringNullableFilter<"Users"> | string | null
    role?: EnumUserRoleFilter<"Users"> | $Enums.UserRole
    createdAt?: DateTimeFilter<"Users"> | Date | string
    updatedAt?: DateTimeFilter<"Users"> | Date | string
    academicDepartment?: XOR<AcademicDepartmentNullableScalarRelationFilter, AcademicDepartmentWhereInput> | null
    staffDepartments?: AcademicDepartmentListRelationFilter
  }, "id" | "email">

  export type UsersOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    avatar?: SortOrderInput | SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UsersCountOrderByAggregateInput
    _max?: UsersMaxOrderByAggregateInput
    _min?: UsersMinOrderByAggregateInput
  }

  export type UsersScalarWhereWithAggregatesInput = {
    AND?: UsersScalarWhereWithAggregatesInput | UsersScalarWhereWithAggregatesInput[]
    OR?: UsersScalarWhereWithAggregatesInput[]
    NOT?: UsersScalarWhereWithAggregatesInput | UsersScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Users"> | string
    name?: StringWithAggregatesFilter<"Users"> | string
    email?: StringWithAggregatesFilter<"Users"> | string
    password?: StringWithAggregatesFilter<"Users"> | string
    avatar?: StringNullableWithAggregatesFilter<"Users"> | string | null
    role?: EnumUserRoleWithAggregatesFilter<"Users"> | $Enums.UserRole
    createdAt?: DateTimeWithAggregatesFilter<"Users"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Users"> | Date | string
  }

  export type AcademicSemesterWhereInput = {
    AND?: AcademicSemesterWhereInput | AcademicSemesterWhereInput[]
    OR?: AcademicSemesterWhereInput[]
    NOT?: AcademicSemesterWhereInput | AcademicSemesterWhereInput[]
    id?: StringFilter<"AcademicSemester"> | string
    title?: StringFilter<"AcademicSemester"> | string
    year?: StringFilter<"AcademicSemester"> | string
    code?: StringFilter<"AcademicSemester"> | string
    startMonth?: StringFilter<"AcademicSemester"> | string
    endMonth?: StringFilter<"AcademicSemester"> | string
    isCurrent?: BoolFilter<"AcademicSemester"> | boolean
    createdAt?: DateTimeFilter<"AcademicSemester"> | Date | string
    updatedAt?: DateTimeFilter<"AcademicSemester"> | Date | string
    courseDisciplines?: CourseDisciplineListRelationFilter
    semesterRegistrations?: SemesterRegistrationListRelationFilter
    students?: StudentListRelationFilter
    studentEnrolledCourses?: StudentEnrolledCourseListRelationFilter
    studentEnrolledCourseMarks?: StudentEnrolledCourseMarkListRelationFilter
    studentSemesterPayments?: StudentSemesterPaymentListRelationFilter
    StudentCarriedCourse?: StudentCarriedCourseListRelationFilter
  }

  export type AcademicSemesterOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    year?: SortOrder
    code?: SortOrder
    startMonth?: SortOrder
    endMonth?: SortOrder
    isCurrent?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    courseDisciplines?: CourseDisciplineOrderByRelationAggregateInput
    semesterRegistrations?: SemesterRegistrationOrderByRelationAggregateInput
    students?: StudentOrderByRelationAggregateInput
    studentEnrolledCourses?: StudentEnrolledCourseOrderByRelationAggregateInput
    studentEnrolledCourseMarks?: StudentEnrolledCourseMarkOrderByRelationAggregateInput
    studentSemesterPayments?: StudentSemesterPaymentOrderByRelationAggregateInput
    StudentCarriedCourse?: StudentCarriedCourseOrderByRelationAggregateInput
    _relevance?: AcademicSemesterOrderByRelevanceInput
  }

  export type AcademicSemesterWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AcademicSemesterWhereInput | AcademicSemesterWhereInput[]
    OR?: AcademicSemesterWhereInput[]
    NOT?: AcademicSemesterWhereInput | AcademicSemesterWhereInput[]
    title?: StringFilter<"AcademicSemester"> | string
    year?: StringFilter<"AcademicSemester"> | string
    code?: StringFilter<"AcademicSemester"> | string
    startMonth?: StringFilter<"AcademicSemester"> | string
    endMonth?: StringFilter<"AcademicSemester"> | string
    isCurrent?: BoolFilter<"AcademicSemester"> | boolean
    createdAt?: DateTimeFilter<"AcademicSemester"> | Date | string
    updatedAt?: DateTimeFilter<"AcademicSemester"> | Date | string
    courseDisciplines?: CourseDisciplineListRelationFilter
    semesterRegistrations?: SemesterRegistrationListRelationFilter
    students?: StudentListRelationFilter
    studentEnrolledCourses?: StudentEnrolledCourseListRelationFilter
    studentEnrolledCourseMarks?: StudentEnrolledCourseMarkListRelationFilter
    studentSemesterPayments?: StudentSemesterPaymentListRelationFilter
    StudentCarriedCourse?: StudentCarriedCourseListRelationFilter
  }, "id">

  export type AcademicSemesterOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    year?: SortOrder
    code?: SortOrder
    startMonth?: SortOrder
    endMonth?: SortOrder
    isCurrent?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AcademicSemesterCountOrderByAggregateInput
    _max?: AcademicSemesterMaxOrderByAggregateInput
    _min?: AcademicSemesterMinOrderByAggregateInput
  }

  export type AcademicSemesterScalarWhereWithAggregatesInput = {
    AND?: AcademicSemesterScalarWhereWithAggregatesInput | AcademicSemesterScalarWhereWithAggregatesInput[]
    OR?: AcademicSemesterScalarWhereWithAggregatesInput[]
    NOT?: AcademicSemesterScalarWhereWithAggregatesInput | AcademicSemesterScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AcademicSemester"> | string
    title?: StringWithAggregatesFilter<"AcademicSemester"> | string
    year?: StringWithAggregatesFilter<"AcademicSemester"> | string
    code?: StringWithAggregatesFilter<"AcademicSemester"> | string
    startMonth?: StringWithAggregatesFilter<"AcademicSemester"> | string
    endMonth?: StringWithAggregatesFilter<"AcademicSemester"> | string
    isCurrent?: BoolWithAggregatesFilter<"AcademicSemester"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"AcademicSemester"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AcademicSemester"> | Date | string
  }

  export type AcademicFacultyWhereInput = {
    AND?: AcademicFacultyWhereInput | AcademicFacultyWhereInput[]
    OR?: AcademicFacultyWhereInput[]
    NOT?: AcademicFacultyWhereInput | AcademicFacultyWhereInput[]
    id?: StringFilter<"AcademicFaculty"> | string
    title?: StringFilter<"AcademicFaculty"> | string
    createdAt?: DateTimeFilter<"AcademicFaculty"> | Date | string
    updatedAt?: DateTimeFilter<"AcademicFaculty"> | Date | string
    academicDepartments?: AcademicDepartmentListRelationFilter
    faculties?: FacultyListRelationFilter
    students?: StudentListRelationFilter
    admitionExame?: AdmitionExameRegistrationListRelationFilter
    AdmitionExamePrice?: AdmitionExamePriceListRelationFilter
    AdmitionExamePeriod?: AdmitionExamePeriodListRelationFilter
  }

  export type AcademicFacultyOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    academicDepartments?: AcademicDepartmentOrderByRelationAggregateInput
    faculties?: FacultyOrderByRelationAggregateInput
    students?: StudentOrderByRelationAggregateInput
    admitionExame?: AdmitionExameRegistrationOrderByRelationAggregateInput
    AdmitionExamePrice?: AdmitionExamePriceOrderByRelationAggregateInput
    AdmitionExamePeriod?: AdmitionExamePeriodOrderByRelationAggregateInput
    _relevance?: AcademicFacultyOrderByRelevanceInput
  }

  export type AcademicFacultyWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AcademicFacultyWhereInput | AcademicFacultyWhereInput[]
    OR?: AcademicFacultyWhereInput[]
    NOT?: AcademicFacultyWhereInput | AcademicFacultyWhereInput[]
    title?: StringFilter<"AcademicFaculty"> | string
    createdAt?: DateTimeFilter<"AcademicFaculty"> | Date | string
    updatedAt?: DateTimeFilter<"AcademicFaculty"> | Date | string
    academicDepartments?: AcademicDepartmentListRelationFilter
    faculties?: FacultyListRelationFilter
    students?: StudentListRelationFilter
    admitionExame?: AdmitionExameRegistrationListRelationFilter
    AdmitionExamePrice?: AdmitionExamePriceListRelationFilter
    AdmitionExamePeriod?: AdmitionExamePeriodListRelationFilter
  }, "id">

  export type AcademicFacultyOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AcademicFacultyCountOrderByAggregateInput
    _max?: AcademicFacultyMaxOrderByAggregateInput
    _min?: AcademicFacultyMinOrderByAggregateInput
  }

  export type AcademicFacultyScalarWhereWithAggregatesInput = {
    AND?: AcademicFacultyScalarWhereWithAggregatesInput | AcademicFacultyScalarWhereWithAggregatesInput[]
    OR?: AcademicFacultyScalarWhereWithAggregatesInput[]
    NOT?: AcademicFacultyScalarWhereWithAggregatesInput | AcademicFacultyScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AcademicFaculty"> | string
    title?: StringWithAggregatesFilter<"AcademicFaculty"> | string
    createdAt?: DateTimeWithAggregatesFilter<"AcademicFaculty"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AcademicFaculty"> | Date | string
  }

  export type AcademicDepartmentWhereInput = {
    AND?: AcademicDepartmentWhereInput | AcademicDepartmentWhereInput[]
    OR?: AcademicDepartmentWhereInput[]
    NOT?: AcademicDepartmentWhereInput | AcademicDepartmentWhereInput[]
    id?: StringFilter<"AcademicDepartment"> | string
    title?: StringFilter<"AcademicDepartment"> | string
    academicFacultyId?: StringFilter<"AcademicDepartment"> | string
    createdAt?: DateTimeFilter<"AcademicDepartment"> | Date | string
    updatedAt?: DateTimeFilter<"AcademicDepartment"> | Date | string
    departmentHeadId?: StringNullableFilter<"AcademicDepartment"> | string | null
    academicFaculty?: XOR<AcademicFacultyScalarRelationFilter, AcademicFacultyWhereInput>
    faculties?: FacultyListRelationFilter
    courses?: CourseListRelationFilter
    students?: StudentListRelationFilter
    departmentHead?: XOR<UsersNullableScalarRelationFilter, UsersWhereInput> | null
    staffMembers?: UsersListRelationFilter
    offeredCourses?: OfferedCourseListRelationFilter
  }

  export type AcademicDepartmentOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    academicFacultyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    departmentHeadId?: SortOrderInput | SortOrder
    academicFaculty?: AcademicFacultyOrderByWithRelationInput
    faculties?: FacultyOrderByRelationAggregateInput
    courses?: CourseOrderByRelationAggregateInput
    students?: StudentOrderByRelationAggregateInput
    departmentHead?: UsersOrderByWithRelationInput
    staffMembers?: UsersOrderByRelationAggregateInput
    offeredCourses?: OfferedCourseOrderByRelationAggregateInput
    _relevance?: AcademicDepartmentOrderByRelevanceInput
  }

  export type AcademicDepartmentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    departmentHeadId?: string
    AND?: AcademicDepartmentWhereInput | AcademicDepartmentWhereInput[]
    OR?: AcademicDepartmentWhereInput[]
    NOT?: AcademicDepartmentWhereInput | AcademicDepartmentWhereInput[]
    title?: StringFilter<"AcademicDepartment"> | string
    academicFacultyId?: StringFilter<"AcademicDepartment"> | string
    createdAt?: DateTimeFilter<"AcademicDepartment"> | Date | string
    updatedAt?: DateTimeFilter<"AcademicDepartment"> | Date | string
    academicFaculty?: XOR<AcademicFacultyScalarRelationFilter, AcademicFacultyWhereInput>
    faculties?: FacultyListRelationFilter
    courses?: CourseListRelationFilter
    students?: StudentListRelationFilter
    departmentHead?: XOR<UsersNullableScalarRelationFilter, UsersWhereInput> | null
    staffMembers?: UsersListRelationFilter
    offeredCourses?: OfferedCourseListRelationFilter
  }, "id" | "departmentHeadId">

  export type AcademicDepartmentOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    academicFacultyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    departmentHeadId?: SortOrderInput | SortOrder
    _count?: AcademicDepartmentCountOrderByAggregateInput
    _max?: AcademicDepartmentMaxOrderByAggregateInput
    _min?: AcademicDepartmentMinOrderByAggregateInput
  }

  export type AcademicDepartmentScalarWhereWithAggregatesInput = {
    AND?: AcademicDepartmentScalarWhereWithAggregatesInput | AcademicDepartmentScalarWhereWithAggregatesInput[]
    OR?: AcademicDepartmentScalarWhereWithAggregatesInput[]
    NOT?: AcademicDepartmentScalarWhereWithAggregatesInput | AcademicDepartmentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AcademicDepartment"> | string
    title?: StringWithAggregatesFilter<"AcademicDepartment"> | string
    academicFacultyId?: StringWithAggregatesFilter<"AcademicDepartment"> | string
    createdAt?: DateTimeWithAggregatesFilter<"AcademicDepartment"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AcademicDepartment"> | Date | string
    departmentHeadId?: StringNullableWithAggregatesFilter<"AcademicDepartment"> | string | null
  }

  export type StudentWhereInput = {
    AND?: StudentWhereInput | StudentWhereInput[]
    OR?: StudentWhereInput[]
    NOT?: StudentWhereInput | StudentWhereInput[]
    id?: StringFilter<"Student"> | string
    studentId?: StringFilter<"Student"> | string
    studentType?: EnumStudentTypeFilter<"Student"> | $Enums.StudentType
    firstName?: StringFilter<"Student"> | string
    middleName?: StringNullableFilter<"Student"> | string | null
    lastName?: StringFilter<"Student"> | string
    profileImage?: StringNullableFilter<"Student"> | string | null
    email?: StringNullableFilter<"Student"> | string | null
    contactNo?: StringNullableFilter<"Student"> | string | null
    gender?: StringFilter<"Student"> | string
    isWoker?: BoolFilter<"Student"> | boolean
    shift?: EnumShiftFilter<"Student"> | $Enums.Shift
    yearLevel?: EnumYearLevelFilter<"Student"> | $Enums.YearLevel
    isActive?: BoolFilter<"Student"> | boolean
    password?: StringFilter<"Student"> | string
    gradeDeclarationFile?: StringFilter<"Student"> | string
    biFile?: StringFilter<"Student"> | string
    presentAddress?: StringFilter<"Student"> | string
    permanentAddress?: StringNullableFilter<"Student"> | string | null
    academicSemesterId?: StringFilter<"Student"> | string
    academicFacultyId?: StringFilter<"Student"> | string
    academicDepartmentId?: StringFilter<"Student"> | string
    admissionRegistrationId?: StringNullableFilter<"Student"> | string | null
    createdAt?: DateTimeFilter<"Student"> | Date | string
    updatedAt?: DateTimeFilter<"Student"> | Date | string
    academicFaculty?: XOR<AcademicFacultyScalarRelationFilter, AcademicFacultyWhereInput>
    admissionRegistration?: XOR<AdmitionExameRegistrationNullableScalarRelationFilter, AdmitionExameRegistrationWhereInput> | null
    academicDepartment?: XOR<AcademicDepartmentScalarRelationFilter, AcademicDepartmentWhereInput>
    academicSemester?: XOR<AcademicSemesterScalarRelationFilter, AcademicSemesterWhereInput>
    studentSemesterRegistrations?: StudentSemesterRegistrationListRelationFilter
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseListRelationFilter
    studentEnrolledCourses?: StudentEnrolledCourseListRelationFilter
    studentEnrolledCourseMarks?: StudentEnrolledCourseMarkListRelationFilter
    studentSemesterPayments?: StudentSemesterPaymentListRelationFilter
    studentAcademicInfos?: StudentAcademicInfoListRelationFilter
    StudentCarriedCourse?: StudentCarriedCourseListRelationFilter
  }

  export type StudentOrderByWithRelationInput = {
    id?: SortOrder
    studentId?: SortOrder
    studentType?: SortOrder
    firstName?: SortOrder
    middleName?: SortOrderInput | SortOrder
    lastName?: SortOrder
    profileImage?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    contactNo?: SortOrderInput | SortOrder
    gender?: SortOrder
    isWoker?: SortOrder
    shift?: SortOrder
    yearLevel?: SortOrder
    isActive?: SortOrder
    password?: SortOrder
    gradeDeclarationFile?: SortOrder
    biFile?: SortOrder
    presentAddress?: SortOrder
    permanentAddress?: SortOrderInput | SortOrder
    academicSemesterId?: SortOrder
    academicFacultyId?: SortOrder
    academicDepartmentId?: SortOrder
    admissionRegistrationId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    academicFaculty?: AcademicFacultyOrderByWithRelationInput
    admissionRegistration?: AdmitionExameRegistrationOrderByWithRelationInput
    academicDepartment?: AcademicDepartmentOrderByWithRelationInput
    academicSemester?: AcademicSemesterOrderByWithRelationInput
    studentSemesterRegistrations?: StudentSemesterRegistrationOrderByRelationAggregateInput
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseOrderByRelationAggregateInput
    studentEnrolledCourses?: StudentEnrolledCourseOrderByRelationAggregateInput
    studentEnrolledCourseMarks?: StudentEnrolledCourseMarkOrderByRelationAggregateInput
    studentSemesterPayments?: StudentSemesterPaymentOrderByRelationAggregateInput
    studentAcademicInfos?: StudentAcademicInfoOrderByRelationAggregateInput
    StudentCarriedCourse?: StudentCarriedCourseOrderByRelationAggregateInput
    _relevance?: StudentOrderByRelevanceInput
  }

  export type StudentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    studentId?: string
    admissionRegistrationId?: string
    AND?: StudentWhereInput | StudentWhereInput[]
    OR?: StudentWhereInput[]
    NOT?: StudentWhereInput | StudentWhereInput[]
    studentType?: EnumStudentTypeFilter<"Student"> | $Enums.StudentType
    firstName?: StringFilter<"Student"> | string
    middleName?: StringNullableFilter<"Student"> | string | null
    lastName?: StringFilter<"Student"> | string
    profileImage?: StringNullableFilter<"Student"> | string | null
    email?: StringNullableFilter<"Student"> | string | null
    contactNo?: StringNullableFilter<"Student"> | string | null
    gender?: StringFilter<"Student"> | string
    isWoker?: BoolFilter<"Student"> | boolean
    shift?: EnumShiftFilter<"Student"> | $Enums.Shift
    yearLevel?: EnumYearLevelFilter<"Student"> | $Enums.YearLevel
    isActive?: BoolFilter<"Student"> | boolean
    password?: StringFilter<"Student"> | string
    gradeDeclarationFile?: StringFilter<"Student"> | string
    biFile?: StringFilter<"Student"> | string
    presentAddress?: StringFilter<"Student"> | string
    permanentAddress?: StringNullableFilter<"Student"> | string | null
    academicSemesterId?: StringFilter<"Student"> | string
    academicFacultyId?: StringFilter<"Student"> | string
    academicDepartmentId?: StringFilter<"Student"> | string
    createdAt?: DateTimeFilter<"Student"> | Date | string
    updatedAt?: DateTimeFilter<"Student"> | Date | string
    academicFaculty?: XOR<AcademicFacultyScalarRelationFilter, AcademicFacultyWhereInput>
    admissionRegistration?: XOR<AdmitionExameRegistrationNullableScalarRelationFilter, AdmitionExameRegistrationWhereInput> | null
    academicDepartment?: XOR<AcademicDepartmentScalarRelationFilter, AcademicDepartmentWhereInput>
    academicSemester?: XOR<AcademicSemesterScalarRelationFilter, AcademicSemesterWhereInput>
    studentSemesterRegistrations?: StudentSemesterRegistrationListRelationFilter
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseListRelationFilter
    studentEnrolledCourses?: StudentEnrolledCourseListRelationFilter
    studentEnrolledCourseMarks?: StudentEnrolledCourseMarkListRelationFilter
    studentSemesterPayments?: StudentSemesterPaymentListRelationFilter
    studentAcademicInfos?: StudentAcademicInfoListRelationFilter
    StudentCarriedCourse?: StudentCarriedCourseListRelationFilter
  }, "id" | "studentId" | "admissionRegistrationId">

  export type StudentOrderByWithAggregationInput = {
    id?: SortOrder
    studentId?: SortOrder
    studentType?: SortOrder
    firstName?: SortOrder
    middleName?: SortOrderInput | SortOrder
    lastName?: SortOrder
    profileImage?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    contactNo?: SortOrderInput | SortOrder
    gender?: SortOrder
    isWoker?: SortOrder
    shift?: SortOrder
    yearLevel?: SortOrder
    isActive?: SortOrder
    password?: SortOrder
    gradeDeclarationFile?: SortOrder
    biFile?: SortOrder
    presentAddress?: SortOrder
    permanentAddress?: SortOrderInput | SortOrder
    academicSemesterId?: SortOrder
    academicFacultyId?: SortOrder
    academicDepartmentId?: SortOrder
    admissionRegistrationId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: StudentCountOrderByAggregateInput
    _max?: StudentMaxOrderByAggregateInput
    _min?: StudentMinOrderByAggregateInput
  }

  export type StudentScalarWhereWithAggregatesInput = {
    AND?: StudentScalarWhereWithAggregatesInput | StudentScalarWhereWithAggregatesInput[]
    OR?: StudentScalarWhereWithAggregatesInput[]
    NOT?: StudentScalarWhereWithAggregatesInput | StudentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Student"> | string
    studentId?: StringWithAggregatesFilter<"Student"> | string
    studentType?: EnumStudentTypeWithAggregatesFilter<"Student"> | $Enums.StudentType
    firstName?: StringWithAggregatesFilter<"Student"> | string
    middleName?: StringNullableWithAggregatesFilter<"Student"> | string | null
    lastName?: StringWithAggregatesFilter<"Student"> | string
    profileImage?: StringNullableWithAggregatesFilter<"Student"> | string | null
    email?: StringNullableWithAggregatesFilter<"Student"> | string | null
    contactNo?: StringNullableWithAggregatesFilter<"Student"> | string | null
    gender?: StringWithAggregatesFilter<"Student"> | string
    isWoker?: BoolWithAggregatesFilter<"Student"> | boolean
    shift?: EnumShiftWithAggregatesFilter<"Student"> | $Enums.Shift
    yearLevel?: EnumYearLevelWithAggregatesFilter<"Student"> | $Enums.YearLevel
    isActive?: BoolWithAggregatesFilter<"Student"> | boolean
    password?: StringWithAggregatesFilter<"Student"> | string
    gradeDeclarationFile?: StringWithAggregatesFilter<"Student"> | string
    biFile?: StringWithAggregatesFilter<"Student"> | string
    presentAddress?: StringWithAggregatesFilter<"Student"> | string
    permanentAddress?: StringNullableWithAggregatesFilter<"Student"> | string | null
    academicSemesterId?: StringWithAggregatesFilter<"Student"> | string
    academicFacultyId?: StringWithAggregatesFilter<"Student"> | string
    academicDepartmentId?: StringWithAggregatesFilter<"Student"> | string
    admissionRegistrationId?: StringNullableWithAggregatesFilter<"Student"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Student"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Student"> | Date | string
  }

  export type FacultyWhereInput = {
    AND?: FacultyWhereInput | FacultyWhereInput[]
    OR?: FacultyWhereInput[]
    NOT?: FacultyWhereInput | FacultyWhereInput[]
    id?: StringFilter<"Faculty"> | string
    facultyId?: StringFilter<"Faculty"> | string
    firstName?: StringFilter<"Faculty"> | string
    middleName?: StringNullableFilter<"Faculty"> | string | null
    lastName?: StringFilter<"Faculty"> | string
    profileImage?: StringNullableFilter<"Faculty"> | string | null
    email?: StringNullableFilter<"Faculty"> | string | null
    contactNo?: StringNullableFilter<"Faculty"> | string | null
    shift?: EnumShiftFilter<"Faculty"> | $Enums.Shift
    gender?: StringFilter<"Faculty"> | string
    designation?: StringFilter<"Faculty"> | string
    password?: StringFilter<"Faculty"> | string
    academicFacultyId?: StringFilter<"Faculty"> | string
    academicDepartmentId?: StringFilter<"Faculty"> | string
    createdAt?: DateTimeFilter<"Faculty"> | Date | string
    updatedAt?: DateTimeFilter<"Faculty"> | Date | string
    courses?: CourseFacultyListRelationFilter
    academicDepartment?: XOR<AcademicDepartmentScalarRelationFilter, AcademicDepartmentWhereInput>
    academicFaculty?: XOR<AcademicFacultyScalarRelationFilter, AcademicFacultyWhereInput>
    offeredCourseClassSchedules?: OfferedCourseClassScheduleListRelationFilter
  }

  export type FacultyOrderByWithRelationInput = {
    id?: SortOrder
    facultyId?: SortOrder
    firstName?: SortOrder
    middleName?: SortOrderInput | SortOrder
    lastName?: SortOrder
    profileImage?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    contactNo?: SortOrderInput | SortOrder
    shift?: SortOrder
    gender?: SortOrder
    designation?: SortOrder
    password?: SortOrder
    academicFacultyId?: SortOrder
    academicDepartmentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    courses?: CourseFacultyOrderByRelationAggregateInput
    academicDepartment?: AcademicDepartmentOrderByWithRelationInput
    academicFaculty?: AcademicFacultyOrderByWithRelationInput
    offeredCourseClassSchedules?: OfferedCourseClassScheduleOrderByRelationAggregateInput
    _relevance?: FacultyOrderByRelevanceInput
  }

  export type FacultyWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    facultyId?: string
    academicFacultyId?: string
    academicDepartmentId?: string
    AND?: FacultyWhereInput | FacultyWhereInput[]
    OR?: FacultyWhereInput[]
    NOT?: FacultyWhereInput | FacultyWhereInput[]
    firstName?: StringFilter<"Faculty"> | string
    middleName?: StringNullableFilter<"Faculty"> | string | null
    lastName?: StringFilter<"Faculty"> | string
    profileImage?: StringNullableFilter<"Faculty"> | string | null
    email?: StringNullableFilter<"Faculty"> | string | null
    contactNo?: StringNullableFilter<"Faculty"> | string | null
    shift?: EnumShiftFilter<"Faculty"> | $Enums.Shift
    gender?: StringFilter<"Faculty"> | string
    designation?: StringFilter<"Faculty"> | string
    password?: StringFilter<"Faculty"> | string
    createdAt?: DateTimeFilter<"Faculty"> | Date | string
    updatedAt?: DateTimeFilter<"Faculty"> | Date | string
    courses?: CourseFacultyListRelationFilter
    academicDepartment?: XOR<AcademicDepartmentScalarRelationFilter, AcademicDepartmentWhereInput>
    academicFaculty?: XOR<AcademicFacultyScalarRelationFilter, AcademicFacultyWhereInput>
    offeredCourseClassSchedules?: OfferedCourseClassScheduleListRelationFilter
  }, "id" | "facultyId" | "academicFacultyId" | "academicDepartmentId">

  export type FacultyOrderByWithAggregationInput = {
    id?: SortOrder
    facultyId?: SortOrder
    firstName?: SortOrder
    middleName?: SortOrderInput | SortOrder
    lastName?: SortOrder
    profileImage?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    contactNo?: SortOrderInput | SortOrder
    shift?: SortOrder
    gender?: SortOrder
    designation?: SortOrder
    password?: SortOrder
    academicFacultyId?: SortOrder
    academicDepartmentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: FacultyCountOrderByAggregateInput
    _max?: FacultyMaxOrderByAggregateInput
    _min?: FacultyMinOrderByAggregateInput
  }

  export type FacultyScalarWhereWithAggregatesInput = {
    AND?: FacultyScalarWhereWithAggregatesInput | FacultyScalarWhereWithAggregatesInput[]
    OR?: FacultyScalarWhereWithAggregatesInput[]
    NOT?: FacultyScalarWhereWithAggregatesInput | FacultyScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Faculty"> | string
    facultyId?: StringWithAggregatesFilter<"Faculty"> | string
    firstName?: StringWithAggregatesFilter<"Faculty"> | string
    middleName?: StringNullableWithAggregatesFilter<"Faculty"> | string | null
    lastName?: StringWithAggregatesFilter<"Faculty"> | string
    profileImage?: StringNullableWithAggregatesFilter<"Faculty"> | string | null
    email?: StringNullableWithAggregatesFilter<"Faculty"> | string | null
    contactNo?: StringNullableWithAggregatesFilter<"Faculty"> | string | null
    shift?: EnumShiftWithAggregatesFilter<"Faculty"> | $Enums.Shift
    gender?: StringWithAggregatesFilter<"Faculty"> | string
    designation?: StringWithAggregatesFilter<"Faculty"> | string
    password?: StringWithAggregatesFilter<"Faculty"> | string
    academicFacultyId?: StringWithAggregatesFilter<"Faculty"> | string
    academicDepartmentId?: StringWithAggregatesFilter<"Faculty"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Faculty"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Faculty"> | Date | string
  }

  export type BuildingWhereInput = {
    AND?: BuildingWhereInput | BuildingWhereInput[]
    OR?: BuildingWhereInput[]
    NOT?: BuildingWhereInput | BuildingWhereInput[]
    id?: StringFilter<"Building"> | string
    title?: StringFilter<"Building"> | string
    createdAt?: DateTimeFilter<"Building"> | Date | string
    updatedAt?: DateTimeFilter<"Building"> | Date | string
    rooms?: RoomListRelationFilter
  }

  export type BuildingOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    rooms?: RoomOrderByRelationAggregateInput
    _relevance?: BuildingOrderByRelevanceInput
  }

  export type BuildingWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: BuildingWhereInput | BuildingWhereInput[]
    OR?: BuildingWhereInput[]
    NOT?: BuildingWhereInput | BuildingWhereInput[]
    title?: StringFilter<"Building"> | string
    createdAt?: DateTimeFilter<"Building"> | Date | string
    updatedAt?: DateTimeFilter<"Building"> | Date | string
    rooms?: RoomListRelationFilter
  }, "id">

  export type BuildingOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: BuildingCountOrderByAggregateInput
    _max?: BuildingMaxOrderByAggregateInput
    _min?: BuildingMinOrderByAggregateInput
  }

  export type BuildingScalarWhereWithAggregatesInput = {
    AND?: BuildingScalarWhereWithAggregatesInput | BuildingScalarWhereWithAggregatesInput[]
    OR?: BuildingScalarWhereWithAggregatesInput[]
    NOT?: BuildingScalarWhereWithAggregatesInput | BuildingScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Building"> | string
    title?: StringWithAggregatesFilter<"Building"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Building"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Building"> | Date | string
  }

  export type RoomWhereInput = {
    AND?: RoomWhereInput | RoomWhereInput[]
    OR?: RoomWhereInput[]
    NOT?: RoomWhereInput | RoomWhereInput[]
    id?: StringFilter<"Room"> | string
    roomNumber?: StringFilter<"Room"> | string
    floor?: StringFilter<"Room"> | string
    buildingId?: StringFilter<"Room"> | string
    createdAt?: DateTimeFilter<"Room"> | Date | string
    updatedAt?: DateTimeFilter<"Room"> | Date | string
    building?: XOR<BuildingScalarRelationFilter, BuildingWhereInput>
    offeredCourseClassSchedules?: OfferedCourseClassScheduleListRelationFilter
  }

  export type RoomOrderByWithRelationInput = {
    id?: SortOrder
    roomNumber?: SortOrder
    floor?: SortOrder
    buildingId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    building?: BuildingOrderByWithRelationInput
    offeredCourseClassSchedules?: OfferedCourseClassScheduleOrderByRelationAggregateInput
    _relevance?: RoomOrderByRelevanceInput
  }

  export type RoomWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: RoomWhereInput | RoomWhereInput[]
    OR?: RoomWhereInput[]
    NOT?: RoomWhereInput | RoomWhereInput[]
    roomNumber?: StringFilter<"Room"> | string
    floor?: StringFilter<"Room"> | string
    buildingId?: StringFilter<"Room"> | string
    createdAt?: DateTimeFilter<"Room"> | Date | string
    updatedAt?: DateTimeFilter<"Room"> | Date | string
    building?: XOR<BuildingScalarRelationFilter, BuildingWhereInput>
    offeredCourseClassSchedules?: OfferedCourseClassScheduleListRelationFilter
  }, "id">

  export type RoomOrderByWithAggregationInput = {
    id?: SortOrder
    roomNumber?: SortOrder
    floor?: SortOrder
    buildingId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: RoomCountOrderByAggregateInput
    _max?: RoomMaxOrderByAggregateInput
    _min?: RoomMinOrderByAggregateInput
  }

  export type RoomScalarWhereWithAggregatesInput = {
    AND?: RoomScalarWhereWithAggregatesInput | RoomScalarWhereWithAggregatesInput[]
    OR?: RoomScalarWhereWithAggregatesInput[]
    NOT?: RoomScalarWhereWithAggregatesInput | RoomScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Room"> | string
    roomNumber?: StringWithAggregatesFilter<"Room"> | string
    floor?: StringWithAggregatesFilter<"Room"> | string
    buildingId?: StringWithAggregatesFilter<"Room"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Room"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Room"> | Date | string
  }

  export type CourseWhereInput = {
    AND?: CourseWhereInput | CourseWhereInput[]
    OR?: CourseWhereInput[]
    NOT?: CourseWhereInput | CourseWhereInput[]
    id?: StringFilter<"Course"> | string
    title?: StringFilter<"Course"> | string
    code?: StringFilter<"Course"> | string
    durationInYears?: IntFilter<"Course"> | number
    yearLevel?: EnumYearLevelFilter<"Course"> | $Enums.YearLevel
    shift?: EnumShiftFilter<"Course"> | $Enums.Shift
    academicDepartmentId?: StringFilter<"Course"> | string
    createdAt?: DateTimeFilter<"Course"> | Date | string
    updatedAt?: DateTimeFilter<"Course"> | Date | string
    courseDisciplines?: CourseDisciplineListRelationFilter
    coursePricing?: XOR<CoursePricingNullableScalarRelationFilter, CoursePricingWhereInput> | null
    academicDepartment?: XOR<AcademicDepartmentScalarRelationFilter, AcademicDepartmentWhereInput>
    studentCourses?: StudentEnrolledCourseListRelationFilter
    preRequisite?: CourseToPreRequisiteListRelationFilter
    preRequisiteFor?: CourseToPreRequisiteListRelationFilter
    faculties?: CourseFacultyListRelationFilter
    offeredCourses?: OfferedCourseListRelationFilter
  }

  export type CourseOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    code?: SortOrder
    durationInYears?: SortOrder
    yearLevel?: SortOrder
    shift?: SortOrder
    academicDepartmentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    courseDisciplines?: CourseDisciplineOrderByRelationAggregateInput
    coursePricing?: CoursePricingOrderByWithRelationInput
    academicDepartment?: AcademicDepartmentOrderByWithRelationInput
    studentCourses?: StudentEnrolledCourseOrderByRelationAggregateInput
    preRequisite?: CourseToPreRequisiteOrderByRelationAggregateInput
    preRequisiteFor?: CourseToPreRequisiteOrderByRelationAggregateInput
    faculties?: CourseFacultyOrderByRelationAggregateInput
    offeredCourses?: OfferedCourseOrderByRelationAggregateInput
    _relevance?: CourseOrderByRelevanceInput
  }

  export type CourseWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CourseWhereInput | CourseWhereInput[]
    OR?: CourseWhereInput[]
    NOT?: CourseWhereInput | CourseWhereInput[]
    title?: StringFilter<"Course"> | string
    code?: StringFilter<"Course"> | string
    durationInYears?: IntFilter<"Course"> | number
    yearLevel?: EnumYearLevelFilter<"Course"> | $Enums.YearLevel
    shift?: EnumShiftFilter<"Course"> | $Enums.Shift
    academicDepartmentId?: StringFilter<"Course"> | string
    createdAt?: DateTimeFilter<"Course"> | Date | string
    updatedAt?: DateTimeFilter<"Course"> | Date | string
    courseDisciplines?: CourseDisciplineListRelationFilter
    coursePricing?: XOR<CoursePricingNullableScalarRelationFilter, CoursePricingWhereInput> | null
    academicDepartment?: XOR<AcademicDepartmentScalarRelationFilter, AcademicDepartmentWhereInput>
    studentCourses?: StudentEnrolledCourseListRelationFilter
    preRequisite?: CourseToPreRequisiteListRelationFilter
    preRequisiteFor?: CourseToPreRequisiteListRelationFilter
    faculties?: CourseFacultyListRelationFilter
    offeredCourses?: OfferedCourseListRelationFilter
  }, "id">

  export type CourseOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    code?: SortOrder
    durationInYears?: SortOrder
    yearLevel?: SortOrder
    shift?: SortOrder
    academicDepartmentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CourseCountOrderByAggregateInput
    _avg?: CourseAvgOrderByAggregateInput
    _max?: CourseMaxOrderByAggregateInput
    _min?: CourseMinOrderByAggregateInput
    _sum?: CourseSumOrderByAggregateInput
  }

  export type CourseScalarWhereWithAggregatesInput = {
    AND?: CourseScalarWhereWithAggregatesInput | CourseScalarWhereWithAggregatesInput[]
    OR?: CourseScalarWhereWithAggregatesInput[]
    NOT?: CourseScalarWhereWithAggregatesInput | CourseScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Course"> | string
    title?: StringWithAggregatesFilter<"Course"> | string
    code?: StringWithAggregatesFilter<"Course"> | string
    durationInYears?: IntWithAggregatesFilter<"Course"> | number
    yearLevel?: EnumYearLevelWithAggregatesFilter<"Course"> | $Enums.YearLevel
    shift?: EnumShiftWithAggregatesFilter<"Course"> | $Enums.Shift
    academicDepartmentId?: StringWithAggregatesFilter<"Course"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Course"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Course"> | Date | string
  }

  export type CourseToPreRequisiteWhereInput = {
    AND?: CourseToPreRequisiteWhereInput | CourseToPreRequisiteWhereInput[]
    OR?: CourseToPreRequisiteWhereInput[]
    NOT?: CourseToPreRequisiteWhereInput | CourseToPreRequisiteWhereInput[]
    courseId?: StringFilter<"CourseToPreRequisite"> | string
    preRequisiteId?: StringFilter<"CourseToPreRequisite"> | string
    course?: XOR<CourseScalarRelationFilter, CourseWhereInput>
    preRequisite?: XOR<CourseScalarRelationFilter, CourseWhereInput>
  }

  export type CourseToPreRequisiteOrderByWithRelationInput = {
    courseId?: SortOrder
    preRequisiteId?: SortOrder
    course?: CourseOrderByWithRelationInput
    preRequisite?: CourseOrderByWithRelationInput
    _relevance?: CourseToPreRequisiteOrderByRelevanceInput
  }

  export type CourseToPreRequisiteWhereUniqueInput = Prisma.AtLeast<{
    courseId_preRequisiteId?: CourseToPreRequisiteCourseIdPreRequisiteIdCompoundUniqueInput
    AND?: CourseToPreRequisiteWhereInput | CourseToPreRequisiteWhereInput[]
    OR?: CourseToPreRequisiteWhereInput[]
    NOT?: CourseToPreRequisiteWhereInput | CourseToPreRequisiteWhereInput[]
    courseId?: StringFilter<"CourseToPreRequisite"> | string
    preRequisiteId?: StringFilter<"CourseToPreRequisite"> | string
    course?: XOR<CourseScalarRelationFilter, CourseWhereInput>
    preRequisite?: XOR<CourseScalarRelationFilter, CourseWhereInput>
  }, "courseId_preRequisiteId">

  export type CourseToPreRequisiteOrderByWithAggregationInput = {
    courseId?: SortOrder
    preRequisiteId?: SortOrder
    _count?: CourseToPreRequisiteCountOrderByAggregateInput
    _max?: CourseToPreRequisiteMaxOrderByAggregateInput
    _min?: CourseToPreRequisiteMinOrderByAggregateInput
  }

  export type CourseToPreRequisiteScalarWhereWithAggregatesInput = {
    AND?: CourseToPreRequisiteScalarWhereWithAggregatesInput | CourseToPreRequisiteScalarWhereWithAggregatesInput[]
    OR?: CourseToPreRequisiteScalarWhereWithAggregatesInput[]
    NOT?: CourseToPreRequisiteScalarWhereWithAggregatesInput | CourseToPreRequisiteScalarWhereWithAggregatesInput[]
    courseId?: StringWithAggregatesFilter<"CourseToPreRequisite"> | string
    preRequisiteId?: StringWithAggregatesFilter<"CourseToPreRequisite"> | string
  }

  export type CourseFacultyWhereInput = {
    AND?: CourseFacultyWhereInput | CourseFacultyWhereInput[]
    OR?: CourseFacultyWhereInput[]
    NOT?: CourseFacultyWhereInput | CourseFacultyWhereInput[]
    courseId?: StringFilter<"CourseFaculty"> | string
    facultyId?: StringFilter<"CourseFaculty"> | string
    course?: XOR<CourseScalarRelationFilter, CourseWhereInput>
    faculty?: XOR<FacultyScalarRelationFilter, FacultyWhereInput>
  }

  export type CourseFacultyOrderByWithRelationInput = {
    courseId?: SortOrder
    facultyId?: SortOrder
    course?: CourseOrderByWithRelationInput
    faculty?: FacultyOrderByWithRelationInput
    _relevance?: CourseFacultyOrderByRelevanceInput
  }

  export type CourseFacultyWhereUniqueInput = Prisma.AtLeast<{
    courseId_facultyId?: CourseFacultyCourseIdFacultyIdCompoundUniqueInput
    AND?: CourseFacultyWhereInput | CourseFacultyWhereInput[]
    OR?: CourseFacultyWhereInput[]
    NOT?: CourseFacultyWhereInput | CourseFacultyWhereInput[]
    courseId?: StringFilter<"CourseFaculty"> | string
    facultyId?: StringFilter<"CourseFaculty"> | string
    course?: XOR<CourseScalarRelationFilter, CourseWhereInput>
    faculty?: XOR<FacultyScalarRelationFilter, FacultyWhereInput>
  }, "courseId_facultyId">

  export type CourseFacultyOrderByWithAggregationInput = {
    courseId?: SortOrder
    facultyId?: SortOrder
    _count?: CourseFacultyCountOrderByAggregateInput
    _max?: CourseFacultyMaxOrderByAggregateInput
    _min?: CourseFacultyMinOrderByAggregateInput
  }

  export type CourseFacultyScalarWhereWithAggregatesInput = {
    AND?: CourseFacultyScalarWhereWithAggregatesInput | CourseFacultyScalarWhereWithAggregatesInput[]
    OR?: CourseFacultyScalarWhereWithAggregatesInput[]
    NOT?: CourseFacultyScalarWhereWithAggregatesInput | CourseFacultyScalarWhereWithAggregatesInput[]
    courseId?: StringWithAggregatesFilter<"CourseFaculty"> | string
    facultyId?: StringWithAggregatesFilter<"CourseFaculty"> | string
  }

  export type SemesterRegistrationWhereInput = {
    AND?: SemesterRegistrationWhereInput | SemesterRegistrationWhereInput[]
    OR?: SemesterRegistrationWhereInput[]
    NOT?: SemesterRegistrationWhereInput | SemesterRegistrationWhereInput[]
    id?: StringFilter<"SemesterRegistration"> | string
    startDate?: DateTimeFilter<"SemesterRegistration"> | Date | string
    endDate?: DateTimeFilter<"SemesterRegistration"> | Date | string
    status?: EnumSemesterRegistrationStatusNullableFilter<"SemesterRegistration"> | $Enums.SemesterRegistrationStatus | null
    createdAt?: DateTimeFilter<"SemesterRegistration"> | Date | string
    updateAt?: DateTimeFilter<"SemesterRegistration"> | Date | string
    academicSemesterId?: StringFilter<"SemesterRegistration"> | string
    academicSemester?: XOR<AcademicSemesterScalarRelationFilter, AcademicSemesterWhereInput>
    offeredCourses?: OfferedCourseListRelationFilter
    offeredCourseSections?: OfferedCourseSectionListRelationFilter
    offeredCourseClassSchedules?: OfferedCourseClassScheduleListRelationFilter
    studentSemesterRegistrations?: StudentSemesterRegistrationListRelationFilter
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseListRelationFilter
  }

  export type SemesterRegistrationOrderByWithRelationInput = {
    id?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    status?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updateAt?: SortOrder
    academicSemesterId?: SortOrder
    academicSemester?: AcademicSemesterOrderByWithRelationInput
    offeredCourses?: OfferedCourseOrderByRelationAggregateInput
    offeredCourseSections?: OfferedCourseSectionOrderByRelationAggregateInput
    offeredCourseClassSchedules?: OfferedCourseClassScheduleOrderByRelationAggregateInput
    studentSemesterRegistrations?: StudentSemesterRegistrationOrderByRelationAggregateInput
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseOrderByRelationAggregateInput
    _relevance?: SemesterRegistrationOrderByRelevanceInput
  }

  export type SemesterRegistrationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SemesterRegistrationWhereInput | SemesterRegistrationWhereInput[]
    OR?: SemesterRegistrationWhereInput[]
    NOT?: SemesterRegistrationWhereInput | SemesterRegistrationWhereInput[]
    startDate?: DateTimeFilter<"SemesterRegistration"> | Date | string
    endDate?: DateTimeFilter<"SemesterRegistration"> | Date | string
    status?: EnumSemesterRegistrationStatusNullableFilter<"SemesterRegistration"> | $Enums.SemesterRegistrationStatus | null
    createdAt?: DateTimeFilter<"SemesterRegistration"> | Date | string
    updateAt?: DateTimeFilter<"SemesterRegistration"> | Date | string
    academicSemesterId?: StringFilter<"SemesterRegistration"> | string
    academicSemester?: XOR<AcademicSemesterScalarRelationFilter, AcademicSemesterWhereInput>
    offeredCourses?: OfferedCourseListRelationFilter
    offeredCourseSections?: OfferedCourseSectionListRelationFilter
    offeredCourseClassSchedules?: OfferedCourseClassScheduleListRelationFilter
    studentSemesterRegistrations?: StudentSemesterRegistrationListRelationFilter
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseListRelationFilter
  }, "id">

  export type SemesterRegistrationOrderByWithAggregationInput = {
    id?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    status?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updateAt?: SortOrder
    academicSemesterId?: SortOrder
    _count?: SemesterRegistrationCountOrderByAggregateInput
    _max?: SemesterRegistrationMaxOrderByAggregateInput
    _min?: SemesterRegistrationMinOrderByAggregateInput
  }

  export type SemesterRegistrationScalarWhereWithAggregatesInput = {
    AND?: SemesterRegistrationScalarWhereWithAggregatesInput | SemesterRegistrationScalarWhereWithAggregatesInput[]
    OR?: SemesterRegistrationScalarWhereWithAggregatesInput[]
    NOT?: SemesterRegistrationScalarWhereWithAggregatesInput | SemesterRegistrationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SemesterRegistration"> | string
    startDate?: DateTimeWithAggregatesFilter<"SemesterRegistration"> | Date | string
    endDate?: DateTimeWithAggregatesFilter<"SemesterRegistration"> | Date | string
    status?: EnumSemesterRegistrationStatusNullableWithAggregatesFilter<"SemesterRegistration"> | $Enums.SemesterRegistrationStatus | null
    createdAt?: DateTimeWithAggregatesFilter<"SemesterRegistration"> | Date | string
    updateAt?: DateTimeWithAggregatesFilter<"SemesterRegistration"> | Date | string
    academicSemesterId?: StringWithAggregatesFilter<"SemesterRegistration"> | string
  }

  export type AdmitionExameRegistrationWhereInput = {
    AND?: AdmitionExameRegistrationWhereInput | AdmitionExameRegistrationWhereInput[]
    OR?: AdmitionExameRegistrationWhereInput[]
    NOT?: AdmitionExameRegistrationWhereInput | AdmitionExameRegistrationWhereInput[]
    id?: StringFilter<"AdmitionExameRegistration"> | string
    applicantName?: StringFilter<"AdmitionExameRegistration"> | string
    paymentRecipt?: StringFilter<"AdmitionExameRegistration"> | string
    status?: EnumStatusFilter<"AdmitionExameRegistration"> | $Enums.Status
    document?: StringFilter<"AdmitionExameRegistration"> | string
    paymentAmoute?: IntNullableFilter<"AdmitionExameRegistration"> | number | null
    aprovePayment?: BoolNullableFilter<"AdmitionExameRegistration"> | boolean | null
    exameResults?: IntNullableFilter<"AdmitionExameRegistration"> | number | null
    passed?: BoolNullableFilter<"AdmitionExameRegistration"> | boolean | null
    faseId?: StringFilter<"AdmitionExameRegistration"> | string
    exameDate?: DateTimeFilter<"AdmitionExameRegistration"> | Date | string
    rejectionReason?: StringNullableFilter<"AdmitionExameRegistration"> | string | null
    phoneNumber?: StringFilter<"AdmitionExameRegistration"> | string
    email?: StringFilter<"AdmitionExameRegistration"> | string
    createdAt?: DateTimeFilter<"AdmitionExameRegistration"> | Date | string
    updateAt?: DateTimeFilter<"AdmitionExameRegistration"> | Date | string
    academicFalcultyId?: StringFilter<"AdmitionExameRegistration"> | string
    fase?: XOR<ExameFaseScalarRelationFilter, ExameFaseWhereInput>
    academicFalculty?: XOR<AcademicFacultyScalarRelationFilter, AcademicFacultyWhereInput>
    Student?: XOR<StudentNullableScalarRelationFilter, StudentWhereInput> | null
  }

  export type AdmitionExameRegistrationOrderByWithRelationInput = {
    id?: SortOrder
    applicantName?: SortOrder
    paymentRecipt?: SortOrder
    status?: SortOrder
    document?: SortOrder
    paymentAmoute?: SortOrderInput | SortOrder
    aprovePayment?: SortOrderInput | SortOrder
    exameResults?: SortOrderInput | SortOrder
    passed?: SortOrderInput | SortOrder
    faseId?: SortOrder
    exameDate?: SortOrder
    rejectionReason?: SortOrderInput | SortOrder
    phoneNumber?: SortOrder
    email?: SortOrder
    createdAt?: SortOrder
    updateAt?: SortOrder
    academicFalcultyId?: SortOrder
    fase?: ExameFaseOrderByWithRelationInput
    academicFalculty?: AcademicFacultyOrderByWithRelationInput
    Student?: StudentOrderByWithRelationInput
    _relevance?: AdmitionExameRegistrationOrderByRelevanceInput
  }

  export type AdmitionExameRegistrationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    applicantName?: string
    AND?: AdmitionExameRegistrationWhereInput | AdmitionExameRegistrationWhereInput[]
    OR?: AdmitionExameRegistrationWhereInput[]
    NOT?: AdmitionExameRegistrationWhereInput | AdmitionExameRegistrationWhereInput[]
    paymentRecipt?: StringFilter<"AdmitionExameRegistration"> | string
    status?: EnumStatusFilter<"AdmitionExameRegistration"> | $Enums.Status
    document?: StringFilter<"AdmitionExameRegistration"> | string
    paymentAmoute?: IntNullableFilter<"AdmitionExameRegistration"> | number | null
    aprovePayment?: BoolNullableFilter<"AdmitionExameRegistration"> | boolean | null
    exameResults?: IntNullableFilter<"AdmitionExameRegistration"> | number | null
    passed?: BoolNullableFilter<"AdmitionExameRegistration"> | boolean | null
    faseId?: StringFilter<"AdmitionExameRegistration"> | string
    exameDate?: DateTimeFilter<"AdmitionExameRegistration"> | Date | string
    rejectionReason?: StringNullableFilter<"AdmitionExameRegistration"> | string | null
    phoneNumber?: StringFilter<"AdmitionExameRegistration"> | string
    email?: StringFilter<"AdmitionExameRegistration"> | string
    createdAt?: DateTimeFilter<"AdmitionExameRegistration"> | Date | string
    updateAt?: DateTimeFilter<"AdmitionExameRegistration"> | Date | string
    academicFalcultyId?: StringFilter<"AdmitionExameRegistration"> | string
    fase?: XOR<ExameFaseScalarRelationFilter, ExameFaseWhereInput>
    academicFalculty?: XOR<AcademicFacultyScalarRelationFilter, AcademicFacultyWhereInput>
    Student?: XOR<StudentNullableScalarRelationFilter, StudentWhereInput> | null
  }, "id" | "applicantName">

  export type AdmitionExameRegistrationOrderByWithAggregationInput = {
    id?: SortOrder
    applicantName?: SortOrder
    paymentRecipt?: SortOrder
    status?: SortOrder
    document?: SortOrder
    paymentAmoute?: SortOrderInput | SortOrder
    aprovePayment?: SortOrderInput | SortOrder
    exameResults?: SortOrderInput | SortOrder
    passed?: SortOrderInput | SortOrder
    faseId?: SortOrder
    exameDate?: SortOrder
    rejectionReason?: SortOrderInput | SortOrder
    phoneNumber?: SortOrder
    email?: SortOrder
    createdAt?: SortOrder
    updateAt?: SortOrder
    academicFalcultyId?: SortOrder
    _count?: AdmitionExameRegistrationCountOrderByAggregateInput
    _avg?: AdmitionExameRegistrationAvgOrderByAggregateInput
    _max?: AdmitionExameRegistrationMaxOrderByAggregateInput
    _min?: AdmitionExameRegistrationMinOrderByAggregateInput
    _sum?: AdmitionExameRegistrationSumOrderByAggregateInput
  }

  export type AdmitionExameRegistrationScalarWhereWithAggregatesInput = {
    AND?: AdmitionExameRegistrationScalarWhereWithAggregatesInput | AdmitionExameRegistrationScalarWhereWithAggregatesInput[]
    OR?: AdmitionExameRegistrationScalarWhereWithAggregatesInput[]
    NOT?: AdmitionExameRegistrationScalarWhereWithAggregatesInput | AdmitionExameRegistrationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AdmitionExameRegistration"> | string
    applicantName?: StringWithAggregatesFilter<"AdmitionExameRegistration"> | string
    paymentRecipt?: StringWithAggregatesFilter<"AdmitionExameRegistration"> | string
    status?: EnumStatusWithAggregatesFilter<"AdmitionExameRegistration"> | $Enums.Status
    document?: StringWithAggregatesFilter<"AdmitionExameRegistration"> | string
    paymentAmoute?: IntNullableWithAggregatesFilter<"AdmitionExameRegistration"> | number | null
    aprovePayment?: BoolNullableWithAggregatesFilter<"AdmitionExameRegistration"> | boolean | null
    exameResults?: IntNullableWithAggregatesFilter<"AdmitionExameRegistration"> | number | null
    passed?: BoolNullableWithAggregatesFilter<"AdmitionExameRegistration"> | boolean | null
    faseId?: StringWithAggregatesFilter<"AdmitionExameRegistration"> | string
    exameDate?: DateTimeWithAggregatesFilter<"AdmitionExameRegistration"> | Date | string
    rejectionReason?: StringNullableWithAggregatesFilter<"AdmitionExameRegistration"> | string | null
    phoneNumber?: StringWithAggregatesFilter<"AdmitionExameRegistration"> | string
    email?: StringWithAggregatesFilter<"AdmitionExameRegistration"> | string
    createdAt?: DateTimeWithAggregatesFilter<"AdmitionExameRegistration"> | Date | string
    updateAt?: DateTimeWithAggregatesFilter<"AdmitionExameRegistration"> | Date | string
    academicFalcultyId?: StringWithAggregatesFilter<"AdmitionExameRegistration"> | string
  }

  export type AdmitionExamePriceWhereInput = {
    AND?: AdmitionExamePriceWhereInput | AdmitionExamePriceWhereInput[]
    OR?: AdmitionExamePriceWhereInput[]
    NOT?: AdmitionExamePriceWhereInput | AdmitionExamePriceWhereInput[]
    id?: StringFilter<"AdmitionExamePrice"> | string
    academicFacultyId?: StringFilter<"AdmitionExamePrice"> | string
    price?: IntFilter<"AdmitionExamePrice"> | number
    createdAt?: DateTimeFilter<"AdmitionExamePrice"> | Date | string
    updatedAt?: DateTimeFilter<"AdmitionExamePrice"> | Date | string
    academicFaculty?: XOR<AcademicFacultyScalarRelationFilter, AcademicFacultyWhereInput>
  }

  export type AdmitionExamePriceOrderByWithRelationInput = {
    id?: SortOrder
    academicFacultyId?: SortOrder
    price?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    academicFaculty?: AcademicFacultyOrderByWithRelationInput
    _relevance?: AdmitionExamePriceOrderByRelevanceInput
  }

  export type AdmitionExamePriceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AdmitionExamePriceWhereInput | AdmitionExamePriceWhereInput[]
    OR?: AdmitionExamePriceWhereInput[]
    NOT?: AdmitionExamePriceWhereInput | AdmitionExamePriceWhereInput[]
    academicFacultyId?: StringFilter<"AdmitionExamePrice"> | string
    price?: IntFilter<"AdmitionExamePrice"> | number
    createdAt?: DateTimeFilter<"AdmitionExamePrice"> | Date | string
    updatedAt?: DateTimeFilter<"AdmitionExamePrice"> | Date | string
    academicFaculty?: XOR<AcademicFacultyScalarRelationFilter, AcademicFacultyWhereInput>
  }, "id">

  export type AdmitionExamePriceOrderByWithAggregationInput = {
    id?: SortOrder
    academicFacultyId?: SortOrder
    price?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AdmitionExamePriceCountOrderByAggregateInput
    _avg?: AdmitionExamePriceAvgOrderByAggregateInput
    _max?: AdmitionExamePriceMaxOrderByAggregateInput
    _min?: AdmitionExamePriceMinOrderByAggregateInput
    _sum?: AdmitionExamePriceSumOrderByAggregateInput
  }

  export type AdmitionExamePriceScalarWhereWithAggregatesInput = {
    AND?: AdmitionExamePriceScalarWhereWithAggregatesInput | AdmitionExamePriceScalarWhereWithAggregatesInput[]
    OR?: AdmitionExamePriceScalarWhereWithAggregatesInput[]
    NOT?: AdmitionExamePriceScalarWhereWithAggregatesInput | AdmitionExamePriceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AdmitionExamePrice"> | string
    academicFacultyId?: StringWithAggregatesFilter<"AdmitionExamePrice"> | string
    price?: IntWithAggregatesFilter<"AdmitionExamePrice"> | number
    createdAt?: DateTimeWithAggregatesFilter<"AdmitionExamePrice"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AdmitionExamePrice"> | Date | string
  }

  export type AdmitionExamePeriodWhereInput = {
    AND?: AdmitionExamePeriodWhereInput | AdmitionExamePeriodWhereInput[]
    OR?: AdmitionExamePeriodWhereInput[]
    NOT?: AdmitionExamePeriodWhereInput | AdmitionExamePeriodWhereInput[]
    id?: StringFilter<"AdmitionExamePeriod"> | string
    startDate?: DateTimeFilter<"AdmitionExamePeriod"> | Date | string
    endDate?: DateTimeFilter<"AdmitionExamePeriod"> | Date | string
    academicFacultyId?: StringFilter<"AdmitionExamePeriod"> | string
    createdAt?: DateTimeFilter<"AdmitionExamePeriod"> | Date | string
    updatedAt?: DateTimeFilter<"AdmitionExamePeriod"> | Date | string
    academicFaculty?: XOR<AcademicFacultyScalarRelationFilter, AcademicFacultyWhereInput>
  }

  export type AdmitionExamePeriodOrderByWithRelationInput = {
    id?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    academicFacultyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    academicFaculty?: AcademicFacultyOrderByWithRelationInput
    _relevance?: AdmitionExamePeriodOrderByRelevanceInput
  }

  export type AdmitionExamePeriodWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AdmitionExamePeriodWhereInput | AdmitionExamePeriodWhereInput[]
    OR?: AdmitionExamePeriodWhereInput[]
    NOT?: AdmitionExamePeriodWhereInput | AdmitionExamePeriodWhereInput[]
    startDate?: DateTimeFilter<"AdmitionExamePeriod"> | Date | string
    endDate?: DateTimeFilter<"AdmitionExamePeriod"> | Date | string
    academicFacultyId?: StringFilter<"AdmitionExamePeriod"> | string
    createdAt?: DateTimeFilter<"AdmitionExamePeriod"> | Date | string
    updatedAt?: DateTimeFilter<"AdmitionExamePeriod"> | Date | string
    academicFaculty?: XOR<AcademicFacultyScalarRelationFilter, AcademicFacultyWhereInput>
  }, "id">

  export type AdmitionExamePeriodOrderByWithAggregationInput = {
    id?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    academicFacultyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AdmitionExamePeriodCountOrderByAggregateInput
    _max?: AdmitionExamePeriodMaxOrderByAggregateInput
    _min?: AdmitionExamePeriodMinOrderByAggregateInput
  }

  export type AdmitionExamePeriodScalarWhereWithAggregatesInput = {
    AND?: AdmitionExamePeriodScalarWhereWithAggregatesInput | AdmitionExamePeriodScalarWhereWithAggregatesInput[]
    OR?: AdmitionExamePeriodScalarWhereWithAggregatesInput[]
    NOT?: AdmitionExamePeriodScalarWhereWithAggregatesInput | AdmitionExamePeriodScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AdmitionExamePeriod"> | string
    startDate?: DateTimeWithAggregatesFilter<"AdmitionExamePeriod"> | Date | string
    endDate?: DateTimeWithAggregatesFilter<"AdmitionExamePeriod"> | Date | string
    academicFacultyId?: StringWithAggregatesFilter<"AdmitionExamePeriod"> | string
    createdAt?: DateTimeWithAggregatesFilter<"AdmitionExamePeriod"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AdmitionExamePeriod"> | Date | string
  }

  export type ExameFaseWhereInput = {
    AND?: ExameFaseWhereInput | ExameFaseWhereInput[]
    OR?: ExameFaseWhereInput[]
    NOT?: ExameFaseWhereInput | ExameFaseWhereInput[]
    id?: StringFilter<"ExameFase"> | string
    name?: StringFilter<"ExameFase"> | string
    ordem?: IntFilter<"ExameFase"> | number
    startDate?: DateTimeFilter<"ExameFase"> | Date | string
    endDate?: DateTimeFilter<"ExameFase"> | Date | string
    createdAt?: DateTimeFilter<"ExameFase"> | Date | string
    updatedAt?: DateTimeFilter<"ExameFase"> | Date | string
    registrations?: AdmitionExameRegistrationListRelationFilter
  }

  export type ExameFaseOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    ordem?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    registrations?: AdmitionExameRegistrationOrderByRelationAggregateInput
    _relevance?: ExameFaseOrderByRelevanceInput
  }

  export type ExameFaseWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ExameFaseWhereInput | ExameFaseWhereInput[]
    OR?: ExameFaseWhereInput[]
    NOT?: ExameFaseWhereInput | ExameFaseWhereInput[]
    name?: StringFilter<"ExameFase"> | string
    ordem?: IntFilter<"ExameFase"> | number
    startDate?: DateTimeFilter<"ExameFase"> | Date | string
    endDate?: DateTimeFilter<"ExameFase"> | Date | string
    createdAt?: DateTimeFilter<"ExameFase"> | Date | string
    updatedAt?: DateTimeFilter<"ExameFase"> | Date | string
    registrations?: AdmitionExameRegistrationListRelationFilter
  }, "id">

  export type ExameFaseOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    ordem?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ExameFaseCountOrderByAggregateInput
    _avg?: ExameFaseAvgOrderByAggregateInput
    _max?: ExameFaseMaxOrderByAggregateInput
    _min?: ExameFaseMinOrderByAggregateInput
    _sum?: ExameFaseSumOrderByAggregateInput
  }

  export type ExameFaseScalarWhereWithAggregatesInput = {
    AND?: ExameFaseScalarWhereWithAggregatesInput | ExameFaseScalarWhereWithAggregatesInput[]
    OR?: ExameFaseScalarWhereWithAggregatesInput[]
    NOT?: ExameFaseScalarWhereWithAggregatesInput | ExameFaseScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ExameFase"> | string
    name?: StringWithAggregatesFilter<"ExameFase"> | string
    ordem?: IntWithAggregatesFilter<"ExameFase"> | number
    startDate?: DateTimeWithAggregatesFilter<"ExameFase"> | Date | string
    endDate?: DateTimeWithAggregatesFilter<"ExameFase"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"ExameFase"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ExameFase"> | Date | string
  }

  export type OfferedCourseWhereInput = {
    AND?: OfferedCourseWhereInput | OfferedCourseWhereInput[]
    OR?: OfferedCourseWhereInput[]
    NOT?: OfferedCourseWhereInput | OfferedCourseWhereInput[]
    id?: StringFilter<"OfferedCourse"> | string
    academicDepartmentId?: StringFilter<"OfferedCourse"> | string
    courseId?: StringFilter<"OfferedCourse"> | string
    semesterRegistrationId?: StringFilter<"OfferedCourse"> | string
    suspendGrade?: IntFilter<"OfferedCourse"> | number
    academicDepartment?: XOR<AcademicDepartmentScalarRelationFilter, AcademicDepartmentWhereInput>
    semesterRegistration?: XOR<SemesterRegistrationScalarRelationFilter, SemesterRegistrationWhereInput>
    course?: XOR<CourseScalarRelationFilter, CourseWhereInput>
    offeredCourseSections?: OfferedCourseSectionListRelationFilter
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseListRelationFilter
  }

  export type OfferedCourseOrderByWithRelationInput = {
    id?: SortOrder
    academicDepartmentId?: SortOrder
    courseId?: SortOrder
    semesterRegistrationId?: SortOrder
    suspendGrade?: SortOrder
    academicDepartment?: AcademicDepartmentOrderByWithRelationInput
    semesterRegistration?: SemesterRegistrationOrderByWithRelationInput
    course?: CourseOrderByWithRelationInput
    offeredCourseSections?: OfferedCourseSectionOrderByRelationAggregateInput
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseOrderByRelationAggregateInput
    _relevance?: OfferedCourseOrderByRelevanceInput
  }

  export type OfferedCourseWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: OfferedCourseWhereInput | OfferedCourseWhereInput[]
    OR?: OfferedCourseWhereInput[]
    NOT?: OfferedCourseWhereInput | OfferedCourseWhereInput[]
    academicDepartmentId?: StringFilter<"OfferedCourse"> | string
    courseId?: StringFilter<"OfferedCourse"> | string
    semesterRegistrationId?: StringFilter<"OfferedCourse"> | string
    suspendGrade?: IntFilter<"OfferedCourse"> | number
    academicDepartment?: XOR<AcademicDepartmentScalarRelationFilter, AcademicDepartmentWhereInput>
    semesterRegistration?: XOR<SemesterRegistrationScalarRelationFilter, SemesterRegistrationWhereInput>
    course?: XOR<CourseScalarRelationFilter, CourseWhereInput>
    offeredCourseSections?: OfferedCourseSectionListRelationFilter
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseListRelationFilter
  }, "id">

  export type OfferedCourseOrderByWithAggregationInput = {
    id?: SortOrder
    academicDepartmentId?: SortOrder
    courseId?: SortOrder
    semesterRegistrationId?: SortOrder
    suspendGrade?: SortOrder
    _count?: OfferedCourseCountOrderByAggregateInput
    _avg?: OfferedCourseAvgOrderByAggregateInput
    _max?: OfferedCourseMaxOrderByAggregateInput
    _min?: OfferedCourseMinOrderByAggregateInput
    _sum?: OfferedCourseSumOrderByAggregateInput
  }

  export type OfferedCourseScalarWhereWithAggregatesInput = {
    AND?: OfferedCourseScalarWhereWithAggregatesInput | OfferedCourseScalarWhereWithAggregatesInput[]
    OR?: OfferedCourseScalarWhereWithAggregatesInput[]
    NOT?: OfferedCourseScalarWhereWithAggregatesInput | OfferedCourseScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"OfferedCourse"> | string
    academicDepartmentId?: StringWithAggregatesFilter<"OfferedCourse"> | string
    courseId?: StringWithAggregatesFilter<"OfferedCourse"> | string
    semesterRegistrationId?: StringWithAggregatesFilter<"OfferedCourse"> | string
    suspendGrade?: IntWithAggregatesFilter<"OfferedCourse"> | number
  }

  export type OfferedCourseSectionWhereInput = {
    AND?: OfferedCourseSectionWhereInput | OfferedCourseSectionWhereInput[]
    OR?: OfferedCourseSectionWhereInput[]
    NOT?: OfferedCourseSectionWhereInput | OfferedCourseSectionWhereInput[]
    id?: StringFilter<"OfferedCourseSection"> | string
    title?: StringFilter<"OfferedCourseSection"> | string
    maxCapacity?: IntFilter<"OfferedCourseSection"> | number
    currentlyEnrolledStudent?: IntFilter<"OfferedCourseSection"> | number
    createdAt?: DateTimeFilter<"OfferedCourseSection"> | Date | string
    updatedAt?: DateTimeFilter<"OfferedCourseSection"> | Date | string
    semesterRegistrationId?: StringFilter<"OfferedCourseSection"> | string
    offeredCourseId?: StringFilter<"OfferedCourseSection"> | string
    semesterRegistration?: XOR<SemesterRegistrationScalarRelationFilter, SemesterRegistrationWhereInput>
    offeredCourse?: XOR<OfferedCourseScalarRelationFilter, OfferedCourseWhereInput>
    offeredCourseClassSchedules?: OfferedCourseClassScheduleListRelationFilter
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseListRelationFilter
  }

  export type OfferedCourseSectionOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    maxCapacity?: SortOrder
    currentlyEnrolledStudent?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    semesterRegistrationId?: SortOrder
    offeredCourseId?: SortOrder
    semesterRegistration?: SemesterRegistrationOrderByWithRelationInput
    offeredCourse?: OfferedCourseOrderByWithRelationInput
    offeredCourseClassSchedules?: OfferedCourseClassScheduleOrderByRelationAggregateInput
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseOrderByRelationAggregateInput
    _relevance?: OfferedCourseSectionOrderByRelevanceInput
  }

  export type OfferedCourseSectionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: OfferedCourseSectionWhereInput | OfferedCourseSectionWhereInput[]
    OR?: OfferedCourseSectionWhereInput[]
    NOT?: OfferedCourseSectionWhereInput | OfferedCourseSectionWhereInput[]
    title?: StringFilter<"OfferedCourseSection"> | string
    maxCapacity?: IntFilter<"OfferedCourseSection"> | number
    currentlyEnrolledStudent?: IntFilter<"OfferedCourseSection"> | number
    createdAt?: DateTimeFilter<"OfferedCourseSection"> | Date | string
    updatedAt?: DateTimeFilter<"OfferedCourseSection"> | Date | string
    semesterRegistrationId?: StringFilter<"OfferedCourseSection"> | string
    offeredCourseId?: StringFilter<"OfferedCourseSection"> | string
    semesterRegistration?: XOR<SemesterRegistrationScalarRelationFilter, SemesterRegistrationWhereInput>
    offeredCourse?: XOR<OfferedCourseScalarRelationFilter, OfferedCourseWhereInput>
    offeredCourseClassSchedules?: OfferedCourseClassScheduleListRelationFilter
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseListRelationFilter
  }, "id">

  export type OfferedCourseSectionOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    maxCapacity?: SortOrder
    currentlyEnrolledStudent?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    semesterRegistrationId?: SortOrder
    offeredCourseId?: SortOrder
    _count?: OfferedCourseSectionCountOrderByAggregateInput
    _avg?: OfferedCourseSectionAvgOrderByAggregateInput
    _max?: OfferedCourseSectionMaxOrderByAggregateInput
    _min?: OfferedCourseSectionMinOrderByAggregateInput
    _sum?: OfferedCourseSectionSumOrderByAggregateInput
  }

  export type OfferedCourseSectionScalarWhereWithAggregatesInput = {
    AND?: OfferedCourseSectionScalarWhereWithAggregatesInput | OfferedCourseSectionScalarWhereWithAggregatesInput[]
    OR?: OfferedCourseSectionScalarWhereWithAggregatesInput[]
    NOT?: OfferedCourseSectionScalarWhereWithAggregatesInput | OfferedCourseSectionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"OfferedCourseSection"> | string
    title?: StringWithAggregatesFilter<"OfferedCourseSection"> | string
    maxCapacity?: IntWithAggregatesFilter<"OfferedCourseSection"> | number
    currentlyEnrolledStudent?: IntWithAggregatesFilter<"OfferedCourseSection"> | number
    createdAt?: DateTimeWithAggregatesFilter<"OfferedCourseSection"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"OfferedCourseSection"> | Date | string
    semesterRegistrationId?: StringWithAggregatesFilter<"OfferedCourseSection"> | string
    offeredCourseId?: StringWithAggregatesFilter<"OfferedCourseSection"> | string
  }

  export type OfferedCourseClassScheduleWhereInput = {
    AND?: OfferedCourseClassScheduleWhereInput | OfferedCourseClassScheduleWhereInput[]
    OR?: OfferedCourseClassScheduleWhereInput[]
    NOT?: OfferedCourseClassScheduleWhereInput | OfferedCourseClassScheduleWhereInput[]
    id?: StringFilter<"OfferedCourseClassSchedule"> | string
    startTime?: StringFilter<"OfferedCourseClassSchedule"> | string
    endTime?: StringFilter<"OfferedCourseClassSchedule"> | string
    dayOfWeek?: EnumWeekDaysFilter<"OfferedCourseClassSchedule"> | $Enums.WeekDays
    createdAt?: DateTimeFilter<"OfferedCourseClassSchedule"> | Date | string
    updatedAt?: DateTimeFilter<"OfferedCourseClassSchedule"> | Date | string
    offeredCourseSectionId?: StringFilter<"OfferedCourseClassSchedule"> | string
    semesterRegistrationId?: StringFilter<"OfferedCourseClassSchedule"> | string
    roomId?: StringFilter<"OfferedCourseClassSchedule"> | string
    facultyId?: StringFilter<"OfferedCourseClassSchedule"> | string
    offeredCourseSection?: XOR<OfferedCourseSectionScalarRelationFilter, OfferedCourseSectionWhereInput>
    semesterRegistration?: XOR<SemesterRegistrationScalarRelationFilter, SemesterRegistrationWhereInput>
    room?: XOR<RoomScalarRelationFilter, RoomWhereInput>
    faculty?: XOR<FacultyScalarRelationFilter, FacultyWhereInput>
  }

  export type OfferedCourseClassScheduleOrderByWithRelationInput = {
    id?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    dayOfWeek?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    offeredCourseSectionId?: SortOrder
    semesterRegistrationId?: SortOrder
    roomId?: SortOrder
    facultyId?: SortOrder
    offeredCourseSection?: OfferedCourseSectionOrderByWithRelationInput
    semesterRegistration?: SemesterRegistrationOrderByWithRelationInput
    room?: RoomOrderByWithRelationInput
    faculty?: FacultyOrderByWithRelationInput
    _relevance?: OfferedCourseClassScheduleOrderByRelevanceInput
  }

  export type OfferedCourseClassScheduleWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: OfferedCourseClassScheduleWhereInput | OfferedCourseClassScheduleWhereInput[]
    OR?: OfferedCourseClassScheduleWhereInput[]
    NOT?: OfferedCourseClassScheduleWhereInput | OfferedCourseClassScheduleWhereInput[]
    startTime?: StringFilter<"OfferedCourseClassSchedule"> | string
    endTime?: StringFilter<"OfferedCourseClassSchedule"> | string
    dayOfWeek?: EnumWeekDaysFilter<"OfferedCourseClassSchedule"> | $Enums.WeekDays
    createdAt?: DateTimeFilter<"OfferedCourseClassSchedule"> | Date | string
    updatedAt?: DateTimeFilter<"OfferedCourseClassSchedule"> | Date | string
    offeredCourseSectionId?: StringFilter<"OfferedCourseClassSchedule"> | string
    semesterRegistrationId?: StringFilter<"OfferedCourseClassSchedule"> | string
    roomId?: StringFilter<"OfferedCourseClassSchedule"> | string
    facultyId?: StringFilter<"OfferedCourseClassSchedule"> | string
    offeredCourseSection?: XOR<OfferedCourseSectionScalarRelationFilter, OfferedCourseSectionWhereInput>
    semesterRegistration?: XOR<SemesterRegistrationScalarRelationFilter, SemesterRegistrationWhereInput>
    room?: XOR<RoomScalarRelationFilter, RoomWhereInput>
    faculty?: XOR<FacultyScalarRelationFilter, FacultyWhereInput>
  }, "id">

  export type OfferedCourseClassScheduleOrderByWithAggregationInput = {
    id?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    dayOfWeek?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    offeredCourseSectionId?: SortOrder
    semesterRegistrationId?: SortOrder
    roomId?: SortOrder
    facultyId?: SortOrder
    _count?: OfferedCourseClassScheduleCountOrderByAggregateInput
    _max?: OfferedCourseClassScheduleMaxOrderByAggregateInput
    _min?: OfferedCourseClassScheduleMinOrderByAggregateInput
  }

  export type OfferedCourseClassScheduleScalarWhereWithAggregatesInput = {
    AND?: OfferedCourseClassScheduleScalarWhereWithAggregatesInput | OfferedCourseClassScheduleScalarWhereWithAggregatesInput[]
    OR?: OfferedCourseClassScheduleScalarWhereWithAggregatesInput[]
    NOT?: OfferedCourseClassScheduleScalarWhereWithAggregatesInput | OfferedCourseClassScheduleScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"OfferedCourseClassSchedule"> | string
    startTime?: StringWithAggregatesFilter<"OfferedCourseClassSchedule"> | string
    endTime?: StringWithAggregatesFilter<"OfferedCourseClassSchedule"> | string
    dayOfWeek?: EnumWeekDaysWithAggregatesFilter<"OfferedCourseClassSchedule"> | $Enums.WeekDays
    createdAt?: DateTimeWithAggregatesFilter<"OfferedCourseClassSchedule"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"OfferedCourseClassSchedule"> | Date | string
    offeredCourseSectionId?: StringWithAggregatesFilter<"OfferedCourseClassSchedule"> | string
    semesterRegistrationId?: StringWithAggregatesFilter<"OfferedCourseClassSchedule"> | string
    roomId?: StringWithAggregatesFilter<"OfferedCourseClassSchedule"> | string
    facultyId?: StringWithAggregatesFilter<"OfferedCourseClassSchedule"> | string
  }

  export type StudentSemesterRegistrationWhereInput = {
    AND?: StudentSemesterRegistrationWhereInput | StudentSemesterRegistrationWhereInput[]
    OR?: StudentSemesterRegistrationWhereInput[]
    NOT?: StudentSemesterRegistrationWhereInput | StudentSemesterRegistrationWhereInput[]
    id?: StringFilter<"StudentSemesterRegistration"> | string
    isConfirmed?: BoolNullableFilter<"StudentSemesterRegistration"> | boolean | null
    totalCreditsTaken?: IntNullableFilter<"StudentSemesterRegistration"> | number | null
    paymentRecipt?: StringNullableFilter<"StudentSemesterRegistration"> | string | null
    createdAt?: DateTimeFilter<"StudentSemesterRegistration"> | Date | string
    updatedAt?: DateTimeFilter<"StudentSemesterRegistration"> | Date | string
    studentId?: StringFilter<"StudentSemesterRegistration"> | string
    semesterRegistrationId?: StringFilter<"StudentSemesterRegistration"> | string
    student?: XOR<StudentScalarRelationFilter, StudentWhereInput>
    semesterRegistration?: XOR<SemesterRegistrationScalarRelationFilter, SemesterRegistrationWhereInput>
  }

  export type StudentSemesterRegistrationOrderByWithRelationInput = {
    id?: SortOrder
    isConfirmed?: SortOrderInput | SortOrder
    totalCreditsTaken?: SortOrderInput | SortOrder
    paymentRecipt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    studentId?: SortOrder
    semesterRegistrationId?: SortOrder
    student?: StudentOrderByWithRelationInput
    semesterRegistration?: SemesterRegistrationOrderByWithRelationInput
    _relevance?: StudentSemesterRegistrationOrderByRelevanceInput
  }

  export type StudentSemesterRegistrationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: StudentSemesterRegistrationWhereInput | StudentSemesterRegistrationWhereInput[]
    OR?: StudentSemesterRegistrationWhereInput[]
    NOT?: StudentSemesterRegistrationWhereInput | StudentSemesterRegistrationWhereInput[]
    isConfirmed?: BoolNullableFilter<"StudentSemesterRegistration"> | boolean | null
    totalCreditsTaken?: IntNullableFilter<"StudentSemesterRegistration"> | number | null
    paymentRecipt?: StringNullableFilter<"StudentSemesterRegistration"> | string | null
    createdAt?: DateTimeFilter<"StudentSemesterRegistration"> | Date | string
    updatedAt?: DateTimeFilter<"StudentSemesterRegistration"> | Date | string
    studentId?: StringFilter<"StudentSemesterRegistration"> | string
    semesterRegistrationId?: StringFilter<"StudentSemesterRegistration"> | string
    student?: XOR<StudentScalarRelationFilter, StudentWhereInput>
    semesterRegistration?: XOR<SemesterRegistrationScalarRelationFilter, SemesterRegistrationWhereInput>
  }, "id">

  export type StudentSemesterRegistrationOrderByWithAggregationInput = {
    id?: SortOrder
    isConfirmed?: SortOrderInput | SortOrder
    totalCreditsTaken?: SortOrderInput | SortOrder
    paymentRecipt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    studentId?: SortOrder
    semesterRegistrationId?: SortOrder
    _count?: StudentSemesterRegistrationCountOrderByAggregateInput
    _avg?: StudentSemesterRegistrationAvgOrderByAggregateInput
    _max?: StudentSemesterRegistrationMaxOrderByAggregateInput
    _min?: StudentSemesterRegistrationMinOrderByAggregateInput
    _sum?: StudentSemesterRegistrationSumOrderByAggregateInput
  }

  export type StudentSemesterRegistrationScalarWhereWithAggregatesInput = {
    AND?: StudentSemesterRegistrationScalarWhereWithAggregatesInput | StudentSemesterRegistrationScalarWhereWithAggregatesInput[]
    OR?: StudentSemesterRegistrationScalarWhereWithAggregatesInput[]
    NOT?: StudentSemesterRegistrationScalarWhereWithAggregatesInput | StudentSemesterRegistrationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"StudentSemesterRegistration"> | string
    isConfirmed?: BoolNullableWithAggregatesFilter<"StudentSemesterRegistration"> | boolean | null
    totalCreditsTaken?: IntNullableWithAggregatesFilter<"StudentSemesterRegistration"> | number | null
    paymentRecipt?: StringNullableWithAggregatesFilter<"StudentSemesterRegistration"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"StudentSemesterRegistration"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"StudentSemesterRegistration"> | Date | string
    studentId?: StringWithAggregatesFilter<"StudentSemesterRegistration"> | string
    semesterRegistrationId?: StringWithAggregatesFilter<"StudentSemesterRegistration"> | string
  }

  export type StudentSemesterRegistrationCourseWhereInput = {
    AND?: StudentSemesterRegistrationCourseWhereInput | StudentSemesterRegistrationCourseWhereInput[]
    OR?: StudentSemesterRegistrationCourseWhereInput[]
    NOT?: StudentSemesterRegistrationCourseWhereInput | StudentSemesterRegistrationCourseWhereInput[]
    semesterRegistrationId?: StringFilter<"StudentSemesterRegistrationCourse"> | string
    studentId?: StringFilter<"StudentSemesterRegistrationCourse"> | string
    offeredCourseId?: StringFilter<"StudentSemesterRegistrationCourse"> | string
    offeredCourseSectionId?: StringFilter<"StudentSemesterRegistrationCourse"> | string
    createdAt?: DateTimeFilter<"StudentSemesterRegistrationCourse"> | Date | string
    updatedAt?: DateTimeFilter<"StudentSemesterRegistrationCourse"> | Date | string
    semesterRegistration?: XOR<SemesterRegistrationScalarRelationFilter, SemesterRegistrationWhereInput>
    student?: XOR<StudentScalarRelationFilter, StudentWhereInput>
    offeredCourse?: XOR<OfferedCourseScalarRelationFilter, OfferedCourseWhereInput>
    offeredCourseSection?: XOR<OfferedCourseSectionScalarRelationFilter, OfferedCourseSectionWhereInput>
  }

  export type StudentSemesterRegistrationCourseOrderByWithRelationInput = {
    semesterRegistrationId?: SortOrder
    studentId?: SortOrder
    offeredCourseId?: SortOrder
    offeredCourseSectionId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    semesterRegistration?: SemesterRegistrationOrderByWithRelationInput
    student?: StudentOrderByWithRelationInput
    offeredCourse?: OfferedCourseOrderByWithRelationInput
    offeredCourseSection?: OfferedCourseSectionOrderByWithRelationInput
    _relevance?: StudentSemesterRegistrationCourseOrderByRelevanceInput
  }

  export type StudentSemesterRegistrationCourseWhereUniqueInput = Prisma.AtLeast<{
    semesterRegistrationId_studentId_offeredCourseId?: StudentSemesterRegistrationCourseSemesterRegistrationIdStudentIdOfferedCourseIdCompoundUniqueInput
    AND?: StudentSemesterRegistrationCourseWhereInput | StudentSemesterRegistrationCourseWhereInput[]
    OR?: StudentSemesterRegistrationCourseWhereInput[]
    NOT?: StudentSemesterRegistrationCourseWhereInput | StudentSemesterRegistrationCourseWhereInput[]
    semesterRegistrationId?: StringFilter<"StudentSemesterRegistrationCourse"> | string
    studentId?: StringFilter<"StudentSemesterRegistrationCourse"> | string
    offeredCourseId?: StringFilter<"StudentSemesterRegistrationCourse"> | string
    offeredCourseSectionId?: StringFilter<"StudentSemesterRegistrationCourse"> | string
    createdAt?: DateTimeFilter<"StudentSemesterRegistrationCourse"> | Date | string
    updatedAt?: DateTimeFilter<"StudentSemesterRegistrationCourse"> | Date | string
    semesterRegistration?: XOR<SemesterRegistrationScalarRelationFilter, SemesterRegistrationWhereInput>
    student?: XOR<StudentScalarRelationFilter, StudentWhereInput>
    offeredCourse?: XOR<OfferedCourseScalarRelationFilter, OfferedCourseWhereInput>
    offeredCourseSection?: XOR<OfferedCourseSectionScalarRelationFilter, OfferedCourseSectionWhereInput>
  }, "semesterRegistrationId_studentId_offeredCourseId">

  export type StudentSemesterRegistrationCourseOrderByWithAggregationInput = {
    semesterRegistrationId?: SortOrder
    studentId?: SortOrder
    offeredCourseId?: SortOrder
    offeredCourseSectionId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: StudentSemesterRegistrationCourseCountOrderByAggregateInput
    _max?: StudentSemesterRegistrationCourseMaxOrderByAggregateInput
    _min?: StudentSemesterRegistrationCourseMinOrderByAggregateInput
  }

  export type StudentSemesterRegistrationCourseScalarWhereWithAggregatesInput = {
    AND?: StudentSemesterRegistrationCourseScalarWhereWithAggregatesInput | StudentSemesterRegistrationCourseScalarWhereWithAggregatesInput[]
    OR?: StudentSemesterRegistrationCourseScalarWhereWithAggregatesInput[]
    NOT?: StudentSemesterRegistrationCourseScalarWhereWithAggregatesInput | StudentSemesterRegistrationCourseScalarWhereWithAggregatesInput[]
    semesterRegistrationId?: StringWithAggregatesFilter<"StudentSemesterRegistrationCourse"> | string
    studentId?: StringWithAggregatesFilter<"StudentSemesterRegistrationCourse"> | string
    offeredCourseId?: StringWithAggregatesFilter<"StudentSemesterRegistrationCourse"> | string
    offeredCourseSectionId?: StringWithAggregatesFilter<"StudentSemesterRegistrationCourse"> | string
    createdAt?: DateTimeWithAggregatesFilter<"StudentSemesterRegistrationCourse"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"StudentSemesterRegistrationCourse"> | Date | string
  }

  export type StudentEnrolledCourseWhereInput = {
    AND?: StudentEnrolledCourseWhereInput | StudentEnrolledCourseWhereInput[]
    OR?: StudentEnrolledCourseWhereInput[]
    NOT?: StudentEnrolledCourseWhereInput | StudentEnrolledCourseWhereInput[]
    id?: StringFilter<"StudentEnrolledCourse"> | string
    grade?: StringNullableFilter<"StudentEnrolledCourse"> | string | null
    point?: FloatNullableFilter<"StudentEnrolledCourse"> | number | null
    totalMarks?: IntNullableFilter<"StudentEnrolledCourse"> | number | null
    status?: EnumStudentEnrolledCourseStatusNullableFilter<"StudentEnrolledCourse"> | $Enums.StudentEnrolledCourseStatus | null
    createdAt?: DateTimeFilter<"StudentEnrolledCourse"> | Date | string
    updatedAt?: DateTimeFilter<"StudentEnrolledCourse"> | Date | string
    studentId?: StringFilter<"StudentEnrolledCourse"> | string
    academicSemesterId?: StringFilter<"StudentEnrolledCourse"> | string
    courseId?: StringFilter<"StudentEnrolledCourse"> | string
    student?: XOR<StudentScalarRelationFilter, StudentWhereInput>
    course?: XOR<CourseScalarRelationFilter, CourseWhereInput>
    studentEnrolledCourseMarks?: StudentEnrolledCourseMarkListRelationFilter
    academicSemester?: XOR<AcademicSemesterScalarRelationFilter, AcademicSemesterWhereInput>
  }

  export type StudentEnrolledCourseOrderByWithRelationInput = {
    id?: SortOrder
    grade?: SortOrderInput | SortOrder
    point?: SortOrderInput | SortOrder
    totalMarks?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    studentId?: SortOrder
    academicSemesterId?: SortOrder
    courseId?: SortOrder
    student?: StudentOrderByWithRelationInput
    course?: CourseOrderByWithRelationInput
    studentEnrolledCourseMarks?: StudentEnrolledCourseMarkOrderByRelationAggregateInput
    academicSemester?: AcademicSemesterOrderByWithRelationInput
    _relevance?: StudentEnrolledCourseOrderByRelevanceInput
  }

  export type StudentEnrolledCourseWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: StudentEnrolledCourseWhereInput | StudentEnrolledCourseWhereInput[]
    OR?: StudentEnrolledCourseWhereInput[]
    NOT?: StudentEnrolledCourseWhereInput | StudentEnrolledCourseWhereInput[]
    grade?: StringNullableFilter<"StudentEnrolledCourse"> | string | null
    point?: FloatNullableFilter<"StudentEnrolledCourse"> | number | null
    totalMarks?: IntNullableFilter<"StudentEnrolledCourse"> | number | null
    status?: EnumStudentEnrolledCourseStatusNullableFilter<"StudentEnrolledCourse"> | $Enums.StudentEnrolledCourseStatus | null
    createdAt?: DateTimeFilter<"StudentEnrolledCourse"> | Date | string
    updatedAt?: DateTimeFilter<"StudentEnrolledCourse"> | Date | string
    studentId?: StringFilter<"StudentEnrolledCourse"> | string
    academicSemesterId?: StringFilter<"StudentEnrolledCourse"> | string
    courseId?: StringFilter<"StudentEnrolledCourse"> | string
    student?: XOR<StudentScalarRelationFilter, StudentWhereInput>
    course?: XOR<CourseScalarRelationFilter, CourseWhereInput>
    studentEnrolledCourseMarks?: StudentEnrolledCourseMarkListRelationFilter
    academicSemester?: XOR<AcademicSemesterScalarRelationFilter, AcademicSemesterWhereInput>
  }, "id">

  export type StudentEnrolledCourseOrderByWithAggregationInput = {
    id?: SortOrder
    grade?: SortOrderInput | SortOrder
    point?: SortOrderInput | SortOrder
    totalMarks?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    studentId?: SortOrder
    academicSemesterId?: SortOrder
    courseId?: SortOrder
    _count?: StudentEnrolledCourseCountOrderByAggregateInput
    _avg?: StudentEnrolledCourseAvgOrderByAggregateInput
    _max?: StudentEnrolledCourseMaxOrderByAggregateInput
    _min?: StudentEnrolledCourseMinOrderByAggregateInput
    _sum?: StudentEnrolledCourseSumOrderByAggregateInput
  }

  export type StudentEnrolledCourseScalarWhereWithAggregatesInput = {
    AND?: StudentEnrolledCourseScalarWhereWithAggregatesInput | StudentEnrolledCourseScalarWhereWithAggregatesInput[]
    OR?: StudentEnrolledCourseScalarWhereWithAggregatesInput[]
    NOT?: StudentEnrolledCourseScalarWhereWithAggregatesInput | StudentEnrolledCourseScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"StudentEnrolledCourse"> | string
    grade?: StringNullableWithAggregatesFilter<"StudentEnrolledCourse"> | string | null
    point?: FloatNullableWithAggregatesFilter<"StudentEnrolledCourse"> | number | null
    totalMarks?: IntNullableWithAggregatesFilter<"StudentEnrolledCourse"> | number | null
    status?: EnumStudentEnrolledCourseStatusNullableWithAggregatesFilter<"StudentEnrolledCourse"> | $Enums.StudentEnrolledCourseStatus | null
    createdAt?: DateTimeWithAggregatesFilter<"StudentEnrolledCourse"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"StudentEnrolledCourse"> | Date | string
    studentId?: StringWithAggregatesFilter<"StudentEnrolledCourse"> | string
    academicSemesterId?: StringWithAggregatesFilter<"StudentEnrolledCourse"> | string
    courseId?: StringWithAggregatesFilter<"StudentEnrolledCourse"> | string
  }

  export type StudentEnrolledCourseMarkWhereInput = {
    AND?: StudentEnrolledCourseMarkWhereInput | StudentEnrolledCourseMarkWhereInput[]
    OR?: StudentEnrolledCourseMarkWhereInput[]
    NOT?: StudentEnrolledCourseMarkWhereInput | StudentEnrolledCourseMarkWhereInput[]
    id?: StringFilter<"StudentEnrolledCourseMark"> | string
    examType?: EnumExamTypeNullableFilter<"StudentEnrolledCourseMark"> | $Enums.ExamType | null
    createdAt?: DateTimeFilter<"StudentEnrolledCourseMark"> | Date | string
    updatedAt?: DateTimeFilter<"StudentEnrolledCourseMark"> | Date | string
    studentId?: StringFilter<"StudentEnrolledCourseMark"> | string
    studentEnrolledCourseId?: StringFilter<"StudentEnrolledCourseMark"> | string
    academicSemesterId?: StringFilter<"StudentEnrolledCourseMark"> | string
    continuousAssessments?: JsonFilter<"StudentEnrolledCourseMark">
    frequencyExam?: FloatNullableFilter<"StudentEnrolledCourseMark"> | number | null
    finalExam?: FloatNullableFilter<"StudentEnrolledCourseMark"> | number | null
    resourceExam?: FloatNullableFilter<"StudentEnrolledCourseMark"> | number | null
    specialExam?: FloatNullableFilter<"StudentEnrolledCourseMark"> | number | null
    recoveryExam?: FloatNullableFilter<"StudentEnrolledCourseMark"> | number | null
    totalMarks?: FloatFilter<"StudentEnrolledCourseMark"> | number
    grade?: FloatFilter<"StudentEnrolledCourseMark"> | number
    student?: XOR<StudentScalarRelationFilter, StudentWhereInput>
    studentEnrolledCourse?: XOR<StudentEnrolledCourseScalarRelationFilter, StudentEnrolledCourseWhereInput>
    academicSemester?: XOR<AcademicSemesterScalarRelationFilter, AcademicSemesterWhereInput>
  }

  export type StudentEnrolledCourseMarkOrderByWithRelationInput = {
    id?: SortOrder
    examType?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    studentId?: SortOrder
    studentEnrolledCourseId?: SortOrder
    academicSemesterId?: SortOrder
    continuousAssessments?: SortOrder
    frequencyExam?: SortOrderInput | SortOrder
    finalExam?: SortOrderInput | SortOrder
    resourceExam?: SortOrderInput | SortOrder
    specialExam?: SortOrderInput | SortOrder
    recoveryExam?: SortOrderInput | SortOrder
    totalMarks?: SortOrder
    grade?: SortOrder
    student?: StudentOrderByWithRelationInput
    studentEnrolledCourse?: StudentEnrolledCourseOrderByWithRelationInput
    academicSemester?: AcademicSemesterOrderByWithRelationInput
    _relevance?: StudentEnrolledCourseMarkOrderByRelevanceInput
  }

  export type StudentEnrolledCourseMarkWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: StudentEnrolledCourseMarkWhereInput | StudentEnrolledCourseMarkWhereInput[]
    OR?: StudentEnrolledCourseMarkWhereInput[]
    NOT?: StudentEnrolledCourseMarkWhereInput | StudentEnrolledCourseMarkWhereInput[]
    examType?: EnumExamTypeNullableFilter<"StudentEnrolledCourseMark"> | $Enums.ExamType | null
    createdAt?: DateTimeFilter<"StudentEnrolledCourseMark"> | Date | string
    updatedAt?: DateTimeFilter<"StudentEnrolledCourseMark"> | Date | string
    studentId?: StringFilter<"StudentEnrolledCourseMark"> | string
    studentEnrolledCourseId?: StringFilter<"StudentEnrolledCourseMark"> | string
    academicSemesterId?: StringFilter<"StudentEnrolledCourseMark"> | string
    continuousAssessments?: JsonFilter<"StudentEnrolledCourseMark">
    frequencyExam?: FloatNullableFilter<"StudentEnrolledCourseMark"> | number | null
    finalExam?: FloatNullableFilter<"StudentEnrolledCourseMark"> | number | null
    resourceExam?: FloatNullableFilter<"StudentEnrolledCourseMark"> | number | null
    specialExam?: FloatNullableFilter<"StudentEnrolledCourseMark"> | number | null
    recoveryExam?: FloatNullableFilter<"StudentEnrolledCourseMark"> | number | null
    totalMarks?: FloatFilter<"StudentEnrolledCourseMark"> | number
    grade?: FloatFilter<"StudentEnrolledCourseMark"> | number
    student?: XOR<StudentScalarRelationFilter, StudentWhereInput>
    studentEnrolledCourse?: XOR<StudentEnrolledCourseScalarRelationFilter, StudentEnrolledCourseWhereInput>
    academicSemester?: XOR<AcademicSemesterScalarRelationFilter, AcademicSemesterWhereInput>
  }, "id">

  export type StudentEnrolledCourseMarkOrderByWithAggregationInput = {
    id?: SortOrder
    examType?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    studentId?: SortOrder
    studentEnrolledCourseId?: SortOrder
    academicSemesterId?: SortOrder
    continuousAssessments?: SortOrder
    frequencyExam?: SortOrderInput | SortOrder
    finalExam?: SortOrderInput | SortOrder
    resourceExam?: SortOrderInput | SortOrder
    specialExam?: SortOrderInput | SortOrder
    recoveryExam?: SortOrderInput | SortOrder
    totalMarks?: SortOrder
    grade?: SortOrder
    _count?: StudentEnrolledCourseMarkCountOrderByAggregateInput
    _avg?: StudentEnrolledCourseMarkAvgOrderByAggregateInput
    _max?: StudentEnrolledCourseMarkMaxOrderByAggregateInput
    _min?: StudentEnrolledCourseMarkMinOrderByAggregateInput
    _sum?: StudentEnrolledCourseMarkSumOrderByAggregateInput
  }

  export type StudentEnrolledCourseMarkScalarWhereWithAggregatesInput = {
    AND?: StudentEnrolledCourseMarkScalarWhereWithAggregatesInput | StudentEnrolledCourseMarkScalarWhereWithAggregatesInput[]
    OR?: StudentEnrolledCourseMarkScalarWhereWithAggregatesInput[]
    NOT?: StudentEnrolledCourseMarkScalarWhereWithAggregatesInput | StudentEnrolledCourseMarkScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"StudentEnrolledCourseMark"> | string
    examType?: EnumExamTypeNullableWithAggregatesFilter<"StudentEnrolledCourseMark"> | $Enums.ExamType | null
    createdAt?: DateTimeWithAggregatesFilter<"StudentEnrolledCourseMark"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"StudentEnrolledCourseMark"> | Date | string
    studentId?: StringWithAggregatesFilter<"StudentEnrolledCourseMark"> | string
    studentEnrolledCourseId?: StringWithAggregatesFilter<"StudentEnrolledCourseMark"> | string
    academicSemesterId?: StringWithAggregatesFilter<"StudentEnrolledCourseMark"> | string
    continuousAssessments?: JsonWithAggregatesFilter<"StudentEnrolledCourseMark">
    frequencyExam?: FloatNullableWithAggregatesFilter<"StudentEnrolledCourseMark"> | number | null
    finalExam?: FloatNullableWithAggregatesFilter<"StudentEnrolledCourseMark"> | number | null
    resourceExam?: FloatNullableWithAggregatesFilter<"StudentEnrolledCourseMark"> | number | null
    specialExam?: FloatNullableWithAggregatesFilter<"StudentEnrolledCourseMark"> | number | null
    recoveryExam?: FloatNullableWithAggregatesFilter<"StudentEnrolledCourseMark"> | number | null
    totalMarks?: FloatWithAggregatesFilter<"StudentEnrolledCourseMark"> | number
    grade?: FloatWithAggregatesFilter<"StudentEnrolledCourseMark"> | number
  }

  export type CourseDisciplineWhereInput = {
    AND?: CourseDisciplineWhereInput | CourseDisciplineWhereInput[]
    OR?: CourseDisciplineWhereInput[]
    NOT?: CourseDisciplineWhereInput | CourseDisciplineWhereInput[]
    id?: StringFilter<"CourseDiscipline"> | string
    courseId?: StringFilter<"CourseDiscipline"> | string
    disciplineId?: StringFilter<"CourseDiscipline"> | string
    semesterId?: StringFilter<"CourseDiscipline"> | string
    credits?: IntFilter<"CourseDiscipline"> | number
    course?: XOR<CourseScalarRelationFilter, CourseWhereInput>
    discipline?: XOR<DisciplineScalarRelationFilter, DisciplineWhereInput>
    semester?: XOR<AcademicSemesterScalarRelationFilter, AcademicSemesterWhereInput>
  }

  export type CourseDisciplineOrderByWithRelationInput = {
    id?: SortOrder
    courseId?: SortOrder
    disciplineId?: SortOrder
    semesterId?: SortOrder
    credits?: SortOrder
    course?: CourseOrderByWithRelationInput
    discipline?: DisciplineOrderByWithRelationInput
    semester?: AcademicSemesterOrderByWithRelationInput
    _relevance?: CourseDisciplineOrderByRelevanceInput
  }

  export type CourseDisciplineWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    courseId_disciplineId_semesterId?: CourseDisciplineCourseIdDisciplineIdSemesterIdCompoundUniqueInput
    AND?: CourseDisciplineWhereInput | CourseDisciplineWhereInput[]
    OR?: CourseDisciplineWhereInput[]
    NOT?: CourseDisciplineWhereInput | CourseDisciplineWhereInput[]
    courseId?: StringFilter<"CourseDiscipline"> | string
    disciplineId?: StringFilter<"CourseDiscipline"> | string
    semesterId?: StringFilter<"CourseDiscipline"> | string
    credits?: IntFilter<"CourseDiscipline"> | number
    course?: XOR<CourseScalarRelationFilter, CourseWhereInput>
    discipline?: XOR<DisciplineScalarRelationFilter, DisciplineWhereInput>
    semester?: XOR<AcademicSemesterScalarRelationFilter, AcademicSemesterWhereInput>
  }, "id" | "courseId_disciplineId_semesterId">

  export type CourseDisciplineOrderByWithAggregationInput = {
    id?: SortOrder
    courseId?: SortOrder
    disciplineId?: SortOrder
    semesterId?: SortOrder
    credits?: SortOrder
    _count?: CourseDisciplineCountOrderByAggregateInput
    _avg?: CourseDisciplineAvgOrderByAggregateInput
    _max?: CourseDisciplineMaxOrderByAggregateInput
    _min?: CourseDisciplineMinOrderByAggregateInput
    _sum?: CourseDisciplineSumOrderByAggregateInput
  }

  export type CourseDisciplineScalarWhereWithAggregatesInput = {
    AND?: CourseDisciplineScalarWhereWithAggregatesInput | CourseDisciplineScalarWhereWithAggregatesInput[]
    OR?: CourseDisciplineScalarWhereWithAggregatesInput[]
    NOT?: CourseDisciplineScalarWhereWithAggregatesInput | CourseDisciplineScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CourseDiscipline"> | string
    courseId?: StringWithAggregatesFilter<"CourseDiscipline"> | string
    disciplineId?: StringWithAggregatesFilter<"CourseDiscipline"> | string
    semesterId?: StringWithAggregatesFilter<"CourseDiscipline"> | string
    credits?: IntWithAggregatesFilter<"CourseDiscipline"> | number
  }

  export type StudentCarriedCourseWhereInput = {
    AND?: StudentCarriedCourseWhereInput | StudentCarriedCourseWhereInput[]
    OR?: StudentCarriedCourseWhereInput[]
    NOT?: StudentCarriedCourseWhereInput | StudentCarriedCourseWhereInput[]
    id?: StringFilter<"StudentCarriedCourse"> | string
    studentId?: StringFilter<"StudentCarriedCourse"> | string
    disciplineId?: StringFilter<"StudentCarriedCourse"> | string
    semesterId?: StringFilter<"StudentCarriedCourse"> | string
    shift?: EnumShiftFilter<"StudentCarriedCourse"> | $Enums.Shift
    price?: IntFilter<"StudentCarriedCourse"> | number
    status?: EnumCarriedCourseStatusFilter<"StudentCarriedCourse"> | $Enums.CarriedCourseStatus
    createdAt?: DateTimeFilter<"StudentCarriedCourse"> | Date | string
    student?: XOR<StudentScalarRelationFilter, StudentWhereInput>
    discipline?: XOR<DisciplineScalarRelationFilter, DisciplineWhereInput>
    semester?: XOR<AcademicSemesterScalarRelationFilter, AcademicSemesterWhereInput>
  }

  export type StudentCarriedCourseOrderByWithRelationInput = {
    id?: SortOrder
    studentId?: SortOrder
    disciplineId?: SortOrder
    semesterId?: SortOrder
    shift?: SortOrder
    price?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    student?: StudentOrderByWithRelationInput
    discipline?: DisciplineOrderByWithRelationInput
    semester?: AcademicSemesterOrderByWithRelationInput
    _relevance?: StudentCarriedCourseOrderByRelevanceInput
  }

  export type StudentCarriedCourseWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: StudentCarriedCourseWhereInput | StudentCarriedCourseWhereInput[]
    OR?: StudentCarriedCourseWhereInput[]
    NOT?: StudentCarriedCourseWhereInput | StudentCarriedCourseWhereInput[]
    studentId?: StringFilter<"StudentCarriedCourse"> | string
    disciplineId?: StringFilter<"StudentCarriedCourse"> | string
    semesterId?: StringFilter<"StudentCarriedCourse"> | string
    shift?: EnumShiftFilter<"StudentCarriedCourse"> | $Enums.Shift
    price?: IntFilter<"StudentCarriedCourse"> | number
    status?: EnumCarriedCourseStatusFilter<"StudentCarriedCourse"> | $Enums.CarriedCourseStatus
    createdAt?: DateTimeFilter<"StudentCarriedCourse"> | Date | string
    student?: XOR<StudentScalarRelationFilter, StudentWhereInput>
    discipline?: XOR<DisciplineScalarRelationFilter, DisciplineWhereInput>
    semester?: XOR<AcademicSemesterScalarRelationFilter, AcademicSemesterWhereInput>
  }, "id">

  export type StudentCarriedCourseOrderByWithAggregationInput = {
    id?: SortOrder
    studentId?: SortOrder
    disciplineId?: SortOrder
    semesterId?: SortOrder
    shift?: SortOrder
    price?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    _count?: StudentCarriedCourseCountOrderByAggregateInput
    _avg?: StudentCarriedCourseAvgOrderByAggregateInput
    _max?: StudentCarriedCourseMaxOrderByAggregateInput
    _min?: StudentCarriedCourseMinOrderByAggregateInput
    _sum?: StudentCarriedCourseSumOrderByAggregateInput
  }

  export type StudentCarriedCourseScalarWhereWithAggregatesInput = {
    AND?: StudentCarriedCourseScalarWhereWithAggregatesInput | StudentCarriedCourseScalarWhereWithAggregatesInput[]
    OR?: StudentCarriedCourseScalarWhereWithAggregatesInput[]
    NOT?: StudentCarriedCourseScalarWhereWithAggregatesInput | StudentCarriedCourseScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"StudentCarriedCourse"> | string
    studentId?: StringWithAggregatesFilter<"StudentCarriedCourse"> | string
    disciplineId?: StringWithAggregatesFilter<"StudentCarriedCourse"> | string
    semesterId?: StringWithAggregatesFilter<"StudentCarriedCourse"> | string
    shift?: EnumShiftWithAggregatesFilter<"StudentCarriedCourse"> | $Enums.Shift
    price?: IntWithAggregatesFilter<"StudentCarriedCourse"> | number
    status?: EnumCarriedCourseStatusWithAggregatesFilter<"StudentCarriedCourse"> | $Enums.CarriedCourseStatus
    createdAt?: DateTimeWithAggregatesFilter<"StudentCarriedCourse"> | Date | string
  }

  export type CoursePricingWhereInput = {
    AND?: CoursePricingWhereInput | CoursePricingWhereInput[]
    OR?: CoursePricingWhereInput[]
    NOT?: CoursePricingWhereInput | CoursePricingWhereInput[]
    id?: StringFilter<"CoursePricing"> | string
    price?: FloatFilter<"CoursePricing"> | number
    courseId?: StringFilter<"CoursePricing"> | string
    createdAt?: DateTimeFilter<"CoursePricing"> | Date | string
    updatedAt?: DateTimeFilter<"CoursePricing"> | Date | string
    course?: XOR<CourseScalarRelationFilter, CourseWhereInput>
  }

  export type CoursePricingOrderByWithRelationInput = {
    id?: SortOrder
    price?: SortOrder
    courseId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    course?: CourseOrderByWithRelationInput
    _relevance?: CoursePricingOrderByRelevanceInput
  }

  export type CoursePricingWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    courseId?: string
    AND?: CoursePricingWhereInput | CoursePricingWhereInput[]
    OR?: CoursePricingWhereInput[]
    NOT?: CoursePricingWhereInput | CoursePricingWhereInput[]
    price?: FloatFilter<"CoursePricing"> | number
    createdAt?: DateTimeFilter<"CoursePricing"> | Date | string
    updatedAt?: DateTimeFilter<"CoursePricing"> | Date | string
    course?: XOR<CourseScalarRelationFilter, CourseWhereInput>
  }, "id" | "courseId">

  export type CoursePricingOrderByWithAggregationInput = {
    id?: SortOrder
    price?: SortOrder
    courseId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CoursePricingCountOrderByAggregateInput
    _avg?: CoursePricingAvgOrderByAggregateInput
    _max?: CoursePricingMaxOrderByAggregateInput
    _min?: CoursePricingMinOrderByAggregateInput
    _sum?: CoursePricingSumOrderByAggregateInput
  }

  export type CoursePricingScalarWhereWithAggregatesInput = {
    AND?: CoursePricingScalarWhereWithAggregatesInput | CoursePricingScalarWhereWithAggregatesInput[]
    OR?: CoursePricingScalarWhereWithAggregatesInput[]
    NOT?: CoursePricingScalarWhereWithAggregatesInput | CoursePricingScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CoursePricing"> | string
    price?: FloatWithAggregatesFilter<"CoursePricing"> | number
    courseId?: StringWithAggregatesFilter<"CoursePricing"> | string
    createdAt?: DateTimeWithAggregatesFilter<"CoursePricing"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CoursePricing"> | Date | string
  }

  export type DisciplineWhereInput = {
    AND?: DisciplineWhereInput | DisciplineWhereInput[]
    OR?: DisciplineWhereInput[]
    NOT?: DisciplineWhereInput | DisciplineWhereInput[]
    id?: StringFilter<"Discipline"> | string
    name?: StringFilter<"Discipline"> | string
    code?: StringFilter<"Discipline"> | string
    description?: StringNullableFilter<"Discipline"> | string | null
    credits?: IntFilter<"Discipline"> | number
    minimumGradeToDismiss?: FloatFilter<"Discipline"> | number
    createdAt?: DateTimeFilter<"Discipline"> | Date | string
    updatedAt?: DateTimeFilter<"Discipline"> | Date | string
    courseDisciplines?: CourseDisciplineListRelationFilter
    StudentCarriedCourse?: StudentCarriedCourseListRelationFilter
  }

  export type DisciplineOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    description?: SortOrderInput | SortOrder
    credits?: SortOrder
    minimumGradeToDismiss?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    courseDisciplines?: CourseDisciplineOrderByRelationAggregateInput
    StudentCarriedCourse?: StudentCarriedCourseOrderByRelationAggregateInput
    _relevance?: DisciplineOrderByRelevanceInput
  }

  export type DisciplineWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    code?: string
    AND?: DisciplineWhereInput | DisciplineWhereInput[]
    OR?: DisciplineWhereInput[]
    NOT?: DisciplineWhereInput | DisciplineWhereInput[]
    name?: StringFilter<"Discipline"> | string
    description?: StringNullableFilter<"Discipline"> | string | null
    credits?: IntFilter<"Discipline"> | number
    minimumGradeToDismiss?: FloatFilter<"Discipline"> | number
    createdAt?: DateTimeFilter<"Discipline"> | Date | string
    updatedAt?: DateTimeFilter<"Discipline"> | Date | string
    courseDisciplines?: CourseDisciplineListRelationFilter
    StudentCarriedCourse?: StudentCarriedCourseListRelationFilter
  }, "id" | "code">

  export type DisciplineOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    description?: SortOrderInput | SortOrder
    credits?: SortOrder
    minimumGradeToDismiss?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: DisciplineCountOrderByAggregateInput
    _avg?: DisciplineAvgOrderByAggregateInput
    _max?: DisciplineMaxOrderByAggregateInput
    _min?: DisciplineMinOrderByAggregateInput
    _sum?: DisciplineSumOrderByAggregateInput
  }

  export type DisciplineScalarWhereWithAggregatesInput = {
    AND?: DisciplineScalarWhereWithAggregatesInput | DisciplineScalarWhereWithAggregatesInput[]
    OR?: DisciplineScalarWhereWithAggregatesInput[]
    NOT?: DisciplineScalarWhereWithAggregatesInput | DisciplineScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Discipline"> | string
    name?: StringWithAggregatesFilter<"Discipline"> | string
    code?: StringWithAggregatesFilter<"Discipline"> | string
    description?: StringNullableWithAggregatesFilter<"Discipline"> | string | null
    credits?: IntWithAggregatesFilter<"Discipline"> | number
    minimumGradeToDismiss?: FloatWithAggregatesFilter<"Discipline"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Discipline"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Discipline"> | Date | string
  }

  export type StudentSemesterPaymentWhereInput = {
    AND?: StudentSemesterPaymentWhereInput | StudentSemesterPaymentWhereInput[]
    OR?: StudentSemesterPaymentWhereInput[]
    NOT?: StudentSemesterPaymentWhereInput | StudentSemesterPaymentWhereInput[]
    id?: StringFilter<"StudentSemesterPayment"> | string
    paymentId?: StringFilter<"StudentSemesterPayment"> | string
    totalPayment?: IntFilter<"StudentSemesterPayment"> | number
    baseAmount?: IntFilter<"StudentSemesterPayment"> | number
    lateFee?: IntFilter<"StudentSemesterPayment"> | number
    paymentMonth?: IntFilter<"StudentSemesterPayment"> | number
    paymentYear?: IntFilter<"StudentSemesterPayment"> | number
    createdAt?: DateTimeFilter<"StudentSemesterPayment"> | Date | string
    updatedAt?: DateTimeFilter<"StudentSemesterPayment"> | Date | string
    studentId?: StringFilter<"StudentSemesterPayment"> | string
    academicSemesterId?: StringFilter<"StudentSemesterPayment"> | string
    payment?: XOR<PaymentScalarRelationFilter, PaymentWhereInput>
    student?: XOR<StudentScalarRelationFilter, StudentWhereInput>
    academicSemester?: XOR<AcademicSemesterScalarRelationFilter, AcademicSemesterWhereInput>
  }

  export type StudentSemesterPaymentOrderByWithRelationInput = {
    id?: SortOrder
    paymentId?: SortOrder
    totalPayment?: SortOrder
    baseAmount?: SortOrder
    lateFee?: SortOrder
    paymentMonth?: SortOrder
    paymentYear?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    studentId?: SortOrder
    academicSemesterId?: SortOrder
    payment?: PaymentOrderByWithRelationInput
    student?: StudentOrderByWithRelationInput
    academicSemester?: AcademicSemesterOrderByWithRelationInput
    _relevance?: StudentSemesterPaymentOrderByRelevanceInput
  }

  export type StudentSemesterPaymentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: StudentSemesterPaymentWhereInput | StudentSemesterPaymentWhereInput[]
    OR?: StudentSemesterPaymentWhereInput[]
    NOT?: StudentSemesterPaymentWhereInput | StudentSemesterPaymentWhereInput[]
    paymentId?: StringFilter<"StudentSemesterPayment"> | string
    totalPayment?: IntFilter<"StudentSemesterPayment"> | number
    baseAmount?: IntFilter<"StudentSemesterPayment"> | number
    lateFee?: IntFilter<"StudentSemesterPayment"> | number
    paymentMonth?: IntFilter<"StudentSemesterPayment"> | number
    paymentYear?: IntFilter<"StudentSemesterPayment"> | number
    createdAt?: DateTimeFilter<"StudentSemesterPayment"> | Date | string
    updatedAt?: DateTimeFilter<"StudentSemesterPayment"> | Date | string
    studentId?: StringFilter<"StudentSemesterPayment"> | string
    academicSemesterId?: StringFilter<"StudentSemesterPayment"> | string
    payment?: XOR<PaymentScalarRelationFilter, PaymentWhereInput>
    student?: XOR<StudentScalarRelationFilter, StudentWhereInput>
    academicSemester?: XOR<AcademicSemesterScalarRelationFilter, AcademicSemesterWhereInput>
  }, "id">

  export type StudentSemesterPaymentOrderByWithAggregationInput = {
    id?: SortOrder
    paymentId?: SortOrder
    totalPayment?: SortOrder
    baseAmount?: SortOrder
    lateFee?: SortOrder
    paymentMonth?: SortOrder
    paymentYear?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    studentId?: SortOrder
    academicSemesterId?: SortOrder
    _count?: StudentSemesterPaymentCountOrderByAggregateInput
    _avg?: StudentSemesterPaymentAvgOrderByAggregateInput
    _max?: StudentSemesterPaymentMaxOrderByAggregateInput
    _min?: StudentSemesterPaymentMinOrderByAggregateInput
    _sum?: StudentSemesterPaymentSumOrderByAggregateInput
  }

  export type StudentSemesterPaymentScalarWhereWithAggregatesInput = {
    AND?: StudentSemesterPaymentScalarWhereWithAggregatesInput | StudentSemesterPaymentScalarWhereWithAggregatesInput[]
    OR?: StudentSemesterPaymentScalarWhereWithAggregatesInput[]
    NOT?: StudentSemesterPaymentScalarWhereWithAggregatesInput | StudentSemesterPaymentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"StudentSemesterPayment"> | string
    paymentId?: StringWithAggregatesFilter<"StudentSemesterPayment"> | string
    totalPayment?: IntWithAggregatesFilter<"StudentSemesterPayment"> | number
    baseAmount?: IntWithAggregatesFilter<"StudentSemesterPayment"> | number
    lateFee?: IntWithAggregatesFilter<"StudentSemesterPayment"> | number
    paymentMonth?: IntWithAggregatesFilter<"StudentSemesterPayment"> | number
    paymentYear?: IntWithAggregatesFilter<"StudentSemesterPayment"> | number
    createdAt?: DateTimeWithAggregatesFilter<"StudentSemesterPayment"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"StudentSemesterPayment"> | Date | string
    studentId?: StringWithAggregatesFilter<"StudentSemesterPayment"> | string
    academicSemesterId?: StringWithAggregatesFilter<"StudentSemesterPayment"> | string
  }

  export type StudentAcademicInfoWhereInput = {
    AND?: StudentAcademicInfoWhereInput | StudentAcademicInfoWhereInput[]
    OR?: StudentAcademicInfoWhereInput[]
    NOT?: StudentAcademicInfoWhereInput | StudentAcademicInfoWhereInput[]
    id?: StringFilter<"StudentAcademicInfo"> | string
    createdAt?: DateTimeFilter<"StudentAcademicInfo"> | Date | string
    updatedAt?: DateTimeFilter<"StudentAcademicInfo"> | Date | string
    studentId?: StringFilter<"StudentAcademicInfo"> | string
    totalCompletedCredits?: IntNullableFilter<"StudentAcademicInfo"> | number | null
    cgpa?: FloatNullableFilter<"StudentAcademicInfo"> | number | null
    student?: XOR<StudentScalarRelationFilter, StudentWhereInput>
  }

  export type StudentAcademicInfoOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    studentId?: SortOrder
    totalCompletedCredits?: SortOrderInput | SortOrder
    cgpa?: SortOrderInput | SortOrder
    student?: StudentOrderByWithRelationInput
    _relevance?: StudentAcademicInfoOrderByRelevanceInput
  }

  export type StudentAcademicInfoWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: StudentAcademicInfoWhereInput | StudentAcademicInfoWhereInput[]
    OR?: StudentAcademicInfoWhereInput[]
    NOT?: StudentAcademicInfoWhereInput | StudentAcademicInfoWhereInput[]
    createdAt?: DateTimeFilter<"StudentAcademicInfo"> | Date | string
    updatedAt?: DateTimeFilter<"StudentAcademicInfo"> | Date | string
    studentId?: StringFilter<"StudentAcademicInfo"> | string
    totalCompletedCredits?: IntNullableFilter<"StudentAcademicInfo"> | number | null
    cgpa?: FloatNullableFilter<"StudentAcademicInfo"> | number | null
    student?: XOR<StudentScalarRelationFilter, StudentWhereInput>
  }, "id">

  export type StudentAcademicInfoOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    studentId?: SortOrder
    totalCompletedCredits?: SortOrderInput | SortOrder
    cgpa?: SortOrderInput | SortOrder
    _count?: StudentAcademicInfoCountOrderByAggregateInput
    _avg?: StudentAcademicInfoAvgOrderByAggregateInput
    _max?: StudentAcademicInfoMaxOrderByAggregateInput
    _min?: StudentAcademicInfoMinOrderByAggregateInput
    _sum?: StudentAcademicInfoSumOrderByAggregateInput
  }

  export type StudentAcademicInfoScalarWhereWithAggregatesInput = {
    AND?: StudentAcademicInfoScalarWhereWithAggregatesInput | StudentAcademicInfoScalarWhereWithAggregatesInput[]
    OR?: StudentAcademicInfoScalarWhereWithAggregatesInput[]
    NOT?: StudentAcademicInfoScalarWhereWithAggregatesInput | StudentAcademicInfoScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"StudentAcademicInfo"> | string
    createdAt?: DateTimeWithAggregatesFilter<"StudentAcademicInfo"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"StudentAcademicInfo"> | Date | string
    studentId?: StringWithAggregatesFilter<"StudentAcademicInfo"> | string
    totalCompletedCredits?: IntNullableWithAggregatesFilter<"StudentAcademicInfo"> | number | null
    cgpa?: FloatNullableWithAggregatesFilter<"StudentAcademicInfo"> | number | null
  }

  export type EventsWhereInput = {
    AND?: EventsWhereInput | EventsWhereInput[]
    OR?: EventsWhereInput[]
    NOT?: EventsWhereInput | EventsWhereInput[]
    id?: StringFilter<"Events"> | string
    title?: StringFilter<"Events"> | string
    description?: StringFilter<"Events"> | string
    thumbnail?: StringFilter<"Events"> | string
    color?: StringFilter<"Events"> | string
    location?: DateTimeFilter<"Events"> | Date | string
    mandatory?: BoolFilter<"Events"> | boolean
    createdAt?: DateTimeFilter<"Events"> | Date | string
    updatedAt?: DateTimeFilter<"Events"> | Date | string
  }

  export type EventsOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    thumbnail?: SortOrder
    color?: SortOrder
    location?: SortOrder
    mandatory?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _relevance?: EventsOrderByRelevanceInput
  }

  export type EventsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: EventsWhereInput | EventsWhereInput[]
    OR?: EventsWhereInput[]
    NOT?: EventsWhereInput | EventsWhereInput[]
    title?: StringFilter<"Events"> | string
    description?: StringFilter<"Events"> | string
    thumbnail?: StringFilter<"Events"> | string
    color?: StringFilter<"Events"> | string
    location?: DateTimeFilter<"Events"> | Date | string
    mandatory?: BoolFilter<"Events"> | boolean
    createdAt?: DateTimeFilter<"Events"> | Date | string
    updatedAt?: DateTimeFilter<"Events"> | Date | string
  }, "id">

  export type EventsOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    thumbnail?: SortOrder
    color?: SortOrder
    location?: SortOrder
    mandatory?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: EventsCountOrderByAggregateInput
    _max?: EventsMaxOrderByAggregateInput
    _min?: EventsMinOrderByAggregateInput
  }

  export type EventsScalarWhereWithAggregatesInput = {
    AND?: EventsScalarWhereWithAggregatesInput | EventsScalarWhereWithAggregatesInput[]
    OR?: EventsScalarWhereWithAggregatesInput[]
    NOT?: EventsScalarWhereWithAggregatesInput | EventsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Events"> | string
    title?: StringWithAggregatesFilter<"Events"> | string
    description?: StringWithAggregatesFilter<"Events"> | string
    thumbnail?: StringWithAggregatesFilter<"Events"> | string
    color?: StringWithAggregatesFilter<"Events"> | string
    location?: DateTimeWithAggregatesFilter<"Events"> | Date | string
    mandatory?: BoolWithAggregatesFilter<"Events"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Events"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Events"> | Date | string
  }

  export type PaymentWhereInput = {
    AND?: PaymentWhereInput | PaymentWhereInput[]
    OR?: PaymentWhereInput[]
    NOT?: PaymentWhereInput | PaymentWhereInput[]
    id?: StringFilter<"Payment"> | string
    paymentRecipt?: StringNullableFilter<"Payment"> | string | null
    totalAmount?: IntFilter<"Payment"> | number
    approved?: BoolFilter<"Payment"> | boolean
    paymentType?: EnumPAYMENTTYPEFilter<"Payment"> | $Enums.PAYMENTTYPE
    status?: EnumPAYMENTSTATUSFilter<"Payment"> | $Enums.PAYMENTSTATUS
    method?: EnumPAYMENTMETHODFilter<"Payment"> | $Enums.PAYMENTMETHOD
    createdAt?: DateTimeFilter<"Payment"> | Date | string
    updatedAt?: DateTimeFilter<"Payment"> | Date | string
    StudentSemesterPayment?: StudentSemesterPaymentListRelationFilter
    PaymentReference?: PaymentReferenceListRelationFilter
  }

  export type PaymentOrderByWithRelationInput = {
    id?: SortOrder
    paymentRecipt?: SortOrderInput | SortOrder
    totalAmount?: SortOrder
    approved?: SortOrder
    paymentType?: SortOrder
    status?: SortOrder
    method?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    StudentSemesterPayment?: StudentSemesterPaymentOrderByRelationAggregateInput
    PaymentReference?: PaymentReferenceOrderByRelationAggregateInput
    _relevance?: PaymentOrderByRelevanceInput
  }

  export type PaymentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PaymentWhereInput | PaymentWhereInput[]
    OR?: PaymentWhereInput[]
    NOT?: PaymentWhereInput | PaymentWhereInput[]
    paymentRecipt?: StringNullableFilter<"Payment"> | string | null
    totalAmount?: IntFilter<"Payment"> | number
    approved?: BoolFilter<"Payment"> | boolean
    paymentType?: EnumPAYMENTTYPEFilter<"Payment"> | $Enums.PAYMENTTYPE
    status?: EnumPAYMENTSTATUSFilter<"Payment"> | $Enums.PAYMENTSTATUS
    method?: EnumPAYMENTMETHODFilter<"Payment"> | $Enums.PAYMENTMETHOD
    createdAt?: DateTimeFilter<"Payment"> | Date | string
    updatedAt?: DateTimeFilter<"Payment"> | Date | string
    StudentSemesterPayment?: StudentSemesterPaymentListRelationFilter
    PaymentReference?: PaymentReferenceListRelationFilter
  }, "id">

  export type PaymentOrderByWithAggregationInput = {
    id?: SortOrder
    paymentRecipt?: SortOrderInput | SortOrder
    totalAmount?: SortOrder
    approved?: SortOrder
    paymentType?: SortOrder
    status?: SortOrder
    method?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PaymentCountOrderByAggregateInput
    _avg?: PaymentAvgOrderByAggregateInput
    _max?: PaymentMaxOrderByAggregateInput
    _min?: PaymentMinOrderByAggregateInput
    _sum?: PaymentSumOrderByAggregateInput
  }

  export type PaymentScalarWhereWithAggregatesInput = {
    AND?: PaymentScalarWhereWithAggregatesInput | PaymentScalarWhereWithAggregatesInput[]
    OR?: PaymentScalarWhereWithAggregatesInput[]
    NOT?: PaymentScalarWhereWithAggregatesInput | PaymentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Payment"> | string
    paymentRecipt?: StringNullableWithAggregatesFilter<"Payment"> | string | null
    totalAmount?: IntWithAggregatesFilter<"Payment"> | number
    approved?: BoolWithAggregatesFilter<"Payment"> | boolean
    paymentType?: EnumPAYMENTTYPEWithAggregatesFilter<"Payment"> | $Enums.PAYMENTTYPE
    status?: EnumPAYMENTSTATUSWithAggregatesFilter<"Payment"> | $Enums.PAYMENTSTATUS
    method?: EnumPAYMENTMETHODWithAggregatesFilter<"Payment"> | $Enums.PAYMENTMETHOD
    createdAt?: DateTimeWithAggregatesFilter<"Payment"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Payment"> | Date | string
  }

  export type PaymentReferenceWhereInput = {
    AND?: PaymentReferenceWhereInput | PaymentReferenceWhereInput[]
    OR?: PaymentReferenceWhereInput[]
    NOT?: PaymentReferenceWhereInput | PaymentReferenceWhereInput[]
    id?: StringFilter<"PaymentReference"> | string
    reference?: StringFilter<"PaymentReference"> | string
    code?: IntFilter<"PaymentReference"> | number
    message?: StringFilter<"PaymentReference"> | string
    paymentId?: StringFilter<"PaymentReference"> | string
    createdAt?: DateTimeFilter<"PaymentReference"> | Date | string
    updatedAt?: DateTimeFilter<"PaymentReference"> | Date | string
    payment?: XOR<PaymentScalarRelationFilter, PaymentWhereInput>
  }

  export type PaymentReferenceOrderByWithRelationInput = {
    id?: SortOrder
    reference?: SortOrder
    code?: SortOrder
    message?: SortOrder
    paymentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    payment?: PaymentOrderByWithRelationInput
    _relevance?: PaymentReferenceOrderByRelevanceInput
  }

  export type PaymentReferenceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PaymentReferenceWhereInput | PaymentReferenceWhereInput[]
    OR?: PaymentReferenceWhereInput[]
    NOT?: PaymentReferenceWhereInput | PaymentReferenceWhereInput[]
    reference?: StringFilter<"PaymentReference"> | string
    code?: IntFilter<"PaymentReference"> | number
    message?: StringFilter<"PaymentReference"> | string
    paymentId?: StringFilter<"PaymentReference"> | string
    createdAt?: DateTimeFilter<"PaymentReference"> | Date | string
    updatedAt?: DateTimeFilter<"PaymentReference"> | Date | string
    payment?: XOR<PaymentScalarRelationFilter, PaymentWhereInput>
  }, "id">

  export type PaymentReferenceOrderByWithAggregationInput = {
    id?: SortOrder
    reference?: SortOrder
    code?: SortOrder
    message?: SortOrder
    paymentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PaymentReferenceCountOrderByAggregateInput
    _avg?: PaymentReferenceAvgOrderByAggregateInput
    _max?: PaymentReferenceMaxOrderByAggregateInput
    _min?: PaymentReferenceMinOrderByAggregateInput
    _sum?: PaymentReferenceSumOrderByAggregateInput
  }

  export type PaymentReferenceScalarWhereWithAggregatesInput = {
    AND?: PaymentReferenceScalarWhereWithAggregatesInput | PaymentReferenceScalarWhereWithAggregatesInput[]
    OR?: PaymentReferenceScalarWhereWithAggregatesInput[]
    NOT?: PaymentReferenceScalarWhereWithAggregatesInput | PaymentReferenceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PaymentReference"> | string
    reference?: StringWithAggregatesFilter<"PaymentReference"> | string
    code?: IntWithAggregatesFilter<"PaymentReference"> | number
    message?: StringWithAggregatesFilter<"PaymentReference"> | string
    paymentId?: StringWithAggregatesFilter<"PaymentReference"> | string
    createdAt?: DateTimeWithAggregatesFilter<"PaymentReference"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PaymentReference"> | Date | string
  }

  export type UsersCreateInput = {
    id?: string
    name: string
    email: string
    password: string
    avatar?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    academicDepartment?: AcademicDepartmentCreateNestedOneWithoutDepartmentHeadInput
    staffDepartments?: AcademicDepartmentCreateNestedManyWithoutStaffMembersInput
  }

  export type UsersUncheckedCreateInput = {
    id?: string
    name: string
    email: string
    password: string
    avatar?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    academicDepartment?: AcademicDepartmentUncheckedCreateNestedOneWithoutDepartmentHeadInput
    staffDepartments?: AcademicDepartmentUncheckedCreateNestedManyWithoutStaffMembersInput
  }

  export type UsersUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    academicDepartment?: AcademicDepartmentUpdateOneWithoutDepartmentHeadNestedInput
    staffDepartments?: AcademicDepartmentUpdateManyWithoutStaffMembersNestedInput
  }

  export type UsersUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    academicDepartment?: AcademicDepartmentUncheckedUpdateOneWithoutDepartmentHeadNestedInput
    staffDepartments?: AcademicDepartmentUncheckedUpdateManyWithoutStaffMembersNestedInput
  }

  export type UsersCreateManyInput = {
    id?: string
    name: string
    email: string
    password: string
    avatar?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UsersUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UsersUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AcademicSemesterCreateInput = {
    id?: string
    title: string
    year: string
    code: string
    startMonth: string
    endMonth: string
    isCurrent?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    courseDisciplines?: CourseDisciplineCreateNestedManyWithoutSemesterInput
    semesterRegistrations?: SemesterRegistrationCreateNestedManyWithoutAcademicSemesterInput
    students?: StudentCreateNestedManyWithoutAcademicSemesterInput
    studentEnrolledCourses?: StudentEnrolledCourseCreateNestedManyWithoutAcademicSemesterInput
    studentEnrolledCourseMarks?: StudentEnrolledCourseMarkCreateNestedManyWithoutAcademicSemesterInput
    studentSemesterPayments?: StudentSemesterPaymentCreateNestedManyWithoutAcademicSemesterInput
    StudentCarriedCourse?: StudentCarriedCourseCreateNestedManyWithoutSemesterInput
  }

  export type AcademicSemesterUncheckedCreateInput = {
    id?: string
    title: string
    year: string
    code: string
    startMonth: string
    endMonth: string
    isCurrent?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    courseDisciplines?: CourseDisciplineUncheckedCreateNestedManyWithoutSemesterInput
    semesterRegistrations?: SemesterRegistrationUncheckedCreateNestedManyWithoutAcademicSemesterInput
    students?: StudentUncheckedCreateNestedManyWithoutAcademicSemesterInput
    studentEnrolledCourses?: StudentEnrolledCourseUncheckedCreateNestedManyWithoutAcademicSemesterInput
    studentEnrolledCourseMarks?: StudentEnrolledCourseMarkUncheckedCreateNestedManyWithoutAcademicSemesterInput
    studentSemesterPayments?: StudentSemesterPaymentUncheckedCreateNestedManyWithoutAcademicSemesterInput
    StudentCarriedCourse?: StudentCarriedCourseUncheckedCreateNestedManyWithoutSemesterInput
  }

  export type AcademicSemesterUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    year?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    startMonth?: StringFieldUpdateOperationsInput | string
    endMonth?: StringFieldUpdateOperationsInput | string
    isCurrent?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    courseDisciplines?: CourseDisciplineUpdateManyWithoutSemesterNestedInput
    semesterRegistrations?: SemesterRegistrationUpdateManyWithoutAcademicSemesterNestedInput
    students?: StudentUpdateManyWithoutAcademicSemesterNestedInput
    studentEnrolledCourses?: StudentEnrolledCourseUpdateManyWithoutAcademicSemesterNestedInput
    studentEnrolledCourseMarks?: StudentEnrolledCourseMarkUpdateManyWithoutAcademicSemesterNestedInput
    studentSemesterPayments?: StudentSemesterPaymentUpdateManyWithoutAcademicSemesterNestedInput
    StudentCarriedCourse?: StudentCarriedCourseUpdateManyWithoutSemesterNestedInput
  }

  export type AcademicSemesterUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    year?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    startMonth?: StringFieldUpdateOperationsInput | string
    endMonth?: StringFieldUpdateOperationsInput | string
    isCurrent?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    courseDisciplines?: CourseDisciplineUncheckedUpdateManyWithoutSemesterNestedInput
    semesterRegistrations?: SemesterRegistrationUncheckedUpdateManyWithoutAcademicSemesterNestedInput
    students?: StudentUncheckedUpdateManyWithoutAcademicSemesterNestedInput
    studentEnrolledCourses?: StudentEnrolledCourseUncheckedUpdateManyWithoutAcademicSemesterNestedInput
    studentEnrolledCourseMarks?: StudentEnrolledCourseMarkUncheckedUpdateManyWithoutAcademicSemesterNestedInput
    studentSemesterPayments?: StudentSemesterPaymentUncheckedUpdateManyWithoutAcademicSemesterNestedInput
    StudentCarriedCourse?: StudentCarriedCourseUncheckedUpdateManyWithoutSemesterNestedInput
  }

  export type AcademicSemesterCreateManyInput = {
    id?: string
    title: string
    year: string
    code: string
    startMonth: string
    endMonth: string
    isCurrent?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AcademicSemesterUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    year?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    startMonth?: StringFieldUpdateOperationsInput | string
    endMonth?: StringFieldUpdateOperationsInput | string
    isCurrent?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AcademicSemesterUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    year?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    startMonth?: StringFieldUpdateOperationsInput | string
    endMonth?: StringFieldUpdateOperationsInput | string
    isCurrent?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AcademicFacultyCreateInput = {
    id?: string
    title: string
    createdAt?: Date | string
    updatedAt?: Date | string
    academicDepartments?: AcademicDepartmentCreateNestedManyWithoutAcademicFacultyInput
    faculties?: FacultyCreateNestedManyWithoutAcademicFacultyInput
    students?: StudentCreateNestedManyWithoutAcademicFacultyInput
    admitionExame?: AdmitionExameRegistrationCreateNestedManyWithoutAcademicFalcultyInput
    AdmitionExamePrice?: AdmitionExamePriceCreateNestedManyWithoutAcademicFacultyInput
    AdmitionExamePeriod?: AdmitionExamePeriodCreateNestedManyWithoutAcademicFacultyInput
  }

  export type AcademicFacultyUncheckedCreateInput = {
    id?: string
    title: string
    createdAt?: Date | string
    updatedAt?: Date | string
    academicDepartments?: AcademicDepartmentUncheckedCreateNestedManyWithoutAcademicFacultyInput
    faculties?: FacultyUncheckedCreateNestedManyWithoutAcademicFacultyInput
    students?: StudentUncheckedCreateNestedManyWithoutAcademicFacultyInput
    admitionExame?: AdmitionExameRegistrationUncheckedCreateNestedManyWithoutAcademicFalcultyInput
    AdmitionExamePrice?: AdmitionExamePriceUncheckedCreateNestedManyWithoutAcademicFacultyInput
    AdmitionExamePeriod?: AdmitionExamePeriodUncheckedCreateNestedManyWithoutAcademicFacultyInput
  }

  export type AcademicFacultyUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    academicDepartments?: AcademicDepartmentUpdateManyWithoutAcademicFacultyNestedInput
    faculties?: FacultyUpdateManyWithoutAcademicFacultyNestedInput
    students?: StudentUpdateManyWithoutAcademicFacultyNestedInput
    admitionExame?: AdmitionExameRegistrationUpdateManyWithoutAcademicFalcultyNestedInput
    AdmitionExamePrice?: AdmitionExamePriceUpdateManyWithoutAcademicFacultyNestedInput
    AdmitionExamePeriod?: AdmitionExamePeriodUpdateManyWithoutAcademicFacultyNestedInput
  }

  export type AcademicFacultyUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    academicDepartments?: AcademicDepartmentUncheckedUpdateManyWithoutAcademicFacultyNestedInput
    faculties?: FacultyUncheckedUpdateManyWithoutAcademicFacultyNestedInput
    students?: StudentUncheckedUpdateManyWithoutAcademicFacultyNestedInput
    admitionExame?: AdmitionExameRegistrationUncheckedUpdateManyWithoutAcademicFalcultyNestedInput
    AdmitionExamePrice?: AdmitionExamePriceUncheckedUpdateManyWithoutAcademicFacultyNestedInput
    AdmitionExamePeriod?: AdmitionExamePeriodUncheckedUpdateManyWithoutAcademicFacultyNestedInput
  }

  export type AcademicFacultyCreateManyInput = {
    id?: string
    title: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AcademicFacultyUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AcademicFacultyUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AcademicDepartmentCreateInput = {
    id?: string
    title: string
    createdAt?: Date | string
    updatedAt?: Date | string
    academicFaculty: AcademicFacultyCreateNestedOneWithoutAcademicDepartmentsInput
    faculties?: FacultyCreateNestedManyWithoutAcademicDepartmentInput
    courses?: CourseCreateNestedManyWithoutAcademicDepartmentInput
    students?: StudentCreateNestedManyWithoutAcademicDepartmentInput
    departmentHead?: UsersCreateNestedOneWithoutAcademicDepartmentInput
    staffMembers?: UsersCreateNestedManyWithoutStaffDepartmentsInput
    offeredCourses?: OfferedCourseCreateNestedManyWithoutAcademicDepartmentInput
  }

  export type AcademicDepartmentUncheckedCreateInput = {
    id?: string
    title: string
    academicFacultyId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    departmentHeadId?: string | null
    faculties?: FacultyUncheckedCreateNestedManyWithoutAcademicDepartmentInput
    courses?: CourseUncheckedCreateNestedManyWithoutAcademicDepartmentInput
    students?: StudentUncheckedCreateNestedManyWithoutAcademicDepartmentInput
    staffMembers?: UsersUncheckedCreateNestedManyWithoutStaffDepartmentsInput
    offeredCourses?: OfferedCourseUncheckedCreateNestedManyWithoutAcademicDepartmentInput
  }

  export type AcademicDepartmentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    academicFaculty?: AcademicFacultyUpdateOneRequiredWithoutAcademicDepartmentsNestedInput
    faculties?: FacultyUpdateManyWithoutAcademicDepartmentNestedInput
    courses?: CourseUpdateManyWithoutAcademicDepartmentNestedInput
    students?: StudentUpdateManyWithoutAcademicDepartmentNestedInput
    departmentHead?: UsersUpdateOneWithoutAcademicDepartmentNestedInput
    staffMembers?: UsersUpdateManyWithoutStaffDepartmentsNestedInput
    offeredCourses?: OfferedCourseUpdateManyWithoutAcademicDepartmentNestedInput
  }

  export type AcademicDepartmentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    academicFacultyId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    departmentHeadId?: NullableStringFieldUpdateOperationsInput | string | null
    faculties?: FacultyUncheckedUpdateManyWithoutAcademicDepartmentNestedInput
    courses?: CourseUncheckedUpdateManyWithoutAcademicDepartmentNestedInput
    students?: StudentUncheckedUpdateManyWithoutAcademicDepartmentNestedInput
    staffMembers?: UsersUncheckedUpdateManyWithoutStaffDepartmentsNestedInput
    offeredCourses?: OfferedCourseUncheckedUpdateManyWithoutAcademicDepartmentNestedInput
  }

  export type AcademicDepartmentCreateManyInput = {
    id?: string
    title: string
    academicFacultyId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    departmentHeadId?: string | null
  }

  export type AcademicDepartmentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AcademicDepartmentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    academicFacultyId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    departmentHeadId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type StudentCreateInput = {
    id?: string
    studentId: string
    studentType?: $Enums.StudentType
    firstName: string
    middleName?: string | null
    lastName: string
    profileImage?: string | null
    email?: string | null
    contactNo?: string | null
    gender: string
    isWoker?: boolean
    shift?: $Enums.Shift
    yearLevel?: $Enums.YearLevel
    isActive?: boolean
    password: string
    gradeDeclarationFile: string
    biFile: string
    presentAddress: string
    permanentAddress?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    academicFaculty: AcademicFacultyCreateNestedOneWithoutStudentsInput
    admissionRegistration?: AdmitionExameRegistrationCreateNestedOneWithoutStudentInput
    academicDepartment: AcademicDepartmentCreateNestedOneWithoutStudentsInput
    academicSemester: AcademicSemesterCreateNestedOneWithoutStudentsInput
    studentSemesterRegistrations?: StudentSemesterRegistrationCreateNestedManyWithoutStudentInput
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseCreateNestedManyWithoutStudentInput
    studentEnrolledCourses?: StudentEnrolledCourseCreateNestedManyWithoutStudentInput
    studentEnrolledCourseMarks?: StudentEnrolledCourseMarkCreateNestedManyWithoutStudentInput
    studentSemesterPayments?: StudentSemesterPaymentCreateNestedManyWithoutStudentInput
    studentAcademicInfos?: StudentAcademicInfoCreateNestedManyWithoutStudentInput
    StudentCarriedCourse?: StudentCarriedCourseCreateNestedManyWithoutStudentInput
  }

  export type StudentUncheckedCreateInput = {
    id?: string
    studentId: string
    studentType?: $Enums.StudentType
    firstName: string
    middleName?: string | null
    lastName: string
    profileImage?: string | null
    email?: string | null
    contactNo?: string | null
    gender: string
    isWoker?: boolean
    shift?: $Enums.Shift
    yearLevel?: $Enums.YearLevel
    isActive?: boolean
    password: string
    gradeDeclarationFile: string
    biFile: string
    presentAddress: string
    permanentAddress?: string | null
    academicSemesterId: string
    academicFacultyId: string
    academicDepartmentId: string
    admissionRegistrationId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    studentSemesterRegistrations?: StudentSemesterRegistrationUncheckedCreateNestedManyWithoutStudentInput
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseUncheckedCreateNestedManyWithoutStudentInput
    studentEnrolledCourses?: StudentEnrolledCourseUncheckedCreateNestedManyWithoutStudentInput
    studentEnrolledCourseMarks?: StudentEnrolledCourseMarkUncheckedCreateNestedManyWithoutStudentInput
    studentSemesterPayments?: StudentSemesterPaymentUncheckedCreateNestedManyWithoutStudentInput
    studentAcademicInfos?: StudentAcademicInfoUncheckedCreateNestedManyWithoutStudentInput
    StudentCarriedCourse?: StudentCarriedCourseUncheckedCreateNestedManyWithoutStudentInput
  }

  export type StudentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    studentType?: EnumStudentTypeFieldUpdateOperationsInput | $Enums.StudentType
    firstName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    contactNo?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: StringFieldUpdateOperationsInput | string
    isWoker?: BoolFieldUpdateOperationsInput | boolean
    shift?: EnumShiftFieldUpdateOperationsInput | $Enums.Shift
    yearLevel?: EnumYearLevelFieldUpdateOperationsInput | $Enums.YearLevel
    isActive?: BoolFieldUpdateOperationsInput | boolean
    password?: StringFieldUpdateOperationsInput | string
    gradeDeclarationFile?: StringFieldUpdateOperationsInput | string
    biFile?: StringFieldUpdateOperationsInput | string
    presentAddress?: StringFieldUpdateOperationsInput | string
    permanentAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    academicFaculty?: AcademicFacultyUpdateOneRequiredWithoutStudentsNestedInput
    admissionRegistration?: AdmitionExameRegistrationUpdateOneWithoutStudentNestedInput
    academicDepartment?: AcademicDepartmentUpdateOneRequiredWithoutStudentsNestedInput
    academicSemester?: AcademicSemesterUpdateOneRequiredWithoutStudentsNestedInput
    studentSemesterRegistrations?: StudentSemesterRegistrationUpdateManyWithoutStudentNestedInput
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseUpdateManyWithoutStudentNestedInput
    studentEnrolledCourses?: StudentEnrolledCourseUpdateManyWithoutStudentNestedInput
    studentEnrolledCourseMarks?: StudentEnrolledCourseMarkUpdateManyWithoutStudentNestedInput
    studentSemesterPayments?: StudentSemesterPaymentUpdateManyWithoutStudentNestedInput
    studentAcademicInfos?: StudentAcademicInfoUpdateManyWithoutStudentNestedInput
    StudentCarriedCourse?: StudentCarriedCourseUpdateManyWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    studentType?: EnumStudentTypeFieldUpdateOperationsInput | $Enums.StudentType
    firstName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    contactNo?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: StringFieldUpdateOperationsInput | string
    isWoker?: BoolFieldUpdateOperationsInput | boolean
    shift?: EnumShiftFieldUpdateOperationsInput | $Enums.Shift
    yearLevel?: EnumYearLevelFieldUpdateOperationsInput | $Enums.YearLevel
    isActive?: BoolFieldUpdateOperationsInput | boolean
    password?: StringFieldUpdateOperationsInput | string
    gradeDeclarationFile?: StringFieldUpdateOperationsInput | string
    biFile?: StringFieldUpdateOperationsInput | string
    presentAddress?: StringFieldUpdateOperationsInput | string
    permanentAddress?: NullableStringFieldUpdateOperationsInput | string | null
    academicSemesterId?: StringFieldUpdateOperationsInput | string
    academicFacultyId?: StringFieldUpdateOperationsInput | string
    academicDepartmentId?: StringFieldUpdateOperationsInput | string
    admissionRegistrationId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    studentSemesterRegistrations?: StudentSemesterRegistrationUncheckedUpdateManyWithoutStudentNestedInput
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseUncheckedUpdateManyWithoutStudentNestedInput
    studentEnrolledCourses?: StudentEnrolledCourseUncheckedUpdateManyWithoutStudentNestedInput
    studentEnrolledCourseMarks?: StudentEnrolledCourseMarkUncheckedUpdateManyWithoutStudentNestedInput
    studentSemesterPayments?: StudentSemesterPaymentUncheckedUpdateManyWithoutStudentNestedInput
    studentAcademicInfos?: StudentAcademicInfoUncheckedUpdateManyWithoutStudentNestedInput
    StudentCarriedCourse?: StudentCarriedCourseUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type StudentCreateManyInput = {
    id?: string
    studentId: string
    studentType?: $Enums.StudentType
    firstName: string
    middleName?: string | null
    lastName: string
    profileImage?: string | null
    email?: string | null
    contactNo?: string | null
    gender: string
    isWoker?: boolean
    shift?: $Enums.Shift
    yearLevel?: $Enums.YearLevel
    isActive?: boolean
    password: string
    gradeDeclarationFile: string
    biFile: string
    presentAddress: string
    permanentAddress?: string | null
    academicSemesterId: string
    academicFacultyId: string
    academicDepartmentId: string
    admissionRegistrationId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StudentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    studentType?: EnumStudentTypeFieldUpdateOperationsInput | $Enums.StudentType
    firstName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    contactNo?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: StringFieldUpdateOperationsInput | string
    isWoker?: BoolFieldUpdateOperationsInput | boolean
    shift?: EnumShiftFieldUpdateOperationsInput | $Enums.Shift
    yearLevel?: EnumYearLevelFieldUpdateOperationsInput | $Enums.YearLevel
    isActive?: BoolFieldUpdateOperationsInput | boolean
    password?: StringFieldUpdateOperationsInput | string
    gradeDeclarationFile?: StringFieldUpdateOperationsInput | string
    biFile?: StringFieldUpdateOperationsInput | string
    presentAddress?: StringFieldUpdateOperationsInput | string
    permanentAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    studentType?: EnumStudentTypeFieldUpdateOperationsInput | $Enums.StudentType
    firstName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    contactNo?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: StringFieldUpdateOperationsInput | string
    isWoker?: BoolFieldUpdateOperationsInput | boolean
    shift?: EnumShiftFieldUpdateOperationsInput | $Enums.Shift
    yearLevel?: EnumYearLevelFieldUpdateOperationsInput | $Enums.YearLevel
    isActive?: BoolFieldUpdateOperationsInput | boolean
    password?: StringFieldUpdateOperationsInput | string
    gradeDeclarationFile?: StringFieldUpdateOperationsInput | string
    biFile?: StringFieldUpdateOperationsInput | string
    presentAddress?: StringFieldUpdateOperationsInput | string
    permanentAddress?: NullableStringFieldUpdateOperationsInput | string | null
    academicSemesterId?: StringFieldUpdateOperationsInput | string
    academicFacultyId?: StringFieldUpdateOperationsInput | string
    academicDepartmentId?: StringFieldUpdateOperationsInput | string
    admissionRegistrationId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FacultyCreateInput = {
    id?: string
    facultyId: string
    firstName: string
    middleName?: string | null
    lastName: string
    profileImage?: string | null
    email?: string | null
    contactNo?: string | null
    shift?: $Enums.Shift
    gender: string
    designation: string
    password: string
    createdAt?: Date | string
    updatedAt?: Date | string
    courses?: CourseFacultyCreateNestedManyWithoutFacultyInput
    academicDepartment: AcademicDepartmentCreateNestedOneWithoutFacultiesInput
    academicFaculty: AcademicFacultyCreateNestedOneWithoutFacultiesInput
    offeredCourseClassSchedules?: OfferedCourseClassScheduleCreateNestedManyWithoutFacultyInput
  }

  export type FacultyUncheckedCreateInput = {
    id?: string
    facultyId: string
    firstName: string
    middleName?: string | null
    lastName: string
    profileImage?: string | null
    email?: string | null
    contactNo?: string | null
    shift?: $Enums.Shift
    gender: string
    designation: string
    password: string
    academicFacultyId: string
    academicDepartmentId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    courses?: CourseFacultyUncheckedCreateNestedManyWithoutFacultyInput
    offeredCourseClassSchedules?: OfferedCourseClassScheduleUncheckedCreateNestedManyWithoutFacultyInput
  }

  export type FacultyUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    facultyId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    contactNo?: NullableStringFieldUpdateOperationsInput | string | null
    shift?: EnumShiftFieldUpdateOperationsInput | $Enums.Shift
    gender?: StringFieldUpdateOperationsInput | string
    designation?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    courses?: CourseFacultyUpdateManyWithoutFacultyNestedInput
    academicDepartment?: AcademicDepartmentUpdateOneRequiredWithoutFacultiesNestedInput
    academicFaculty?: AcademicFacultyUpdateOneRequiredWithoutFacultiesNestedInput
    offeredCourseClassSchedules?: OfferedCourseClassScheduleUpdateManyWithoutFacultyNestedInput
  }

  export type FacultyUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    facultyId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    contactNo?: NullableStringFieldUpdateOperationsInput | string | null
    shift?: EnumShiftFieldUpdateOperationsInput | $Enums.Shift
    gender?: StringFieldUpdateOperationsInput | string
    designation?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    academicFacultyId?: StringFieldUpdateOperationsInput | string
    academicDepartmentId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    courses?: CourseFacultyUncheckedUpdateManyWithoutFacultyNestedInput
    offeredCourseClassSchedules?: OfferedCourseClassScheduleUncheckedUpdateManyWithoutFacultyNestedInput
  }

  export type FacultyCreateManyInput = {
    id?: string
    facultyId: string
    firstName: string
    middleName?: string | null
    lastName: string
    profileImage?: string | null
    email?: string | null
    contactNo?: string | null
    shift?: $Enums.Shift
    gender: string
    designation: string
    password: string
    academicFacultyId: string
    academicDepartmentId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FacultyUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    facultyId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    contactNo?: NullableStringFieldUpdateOperationsInput | string | null
    shift?: EnumShiftFieldUpdateOperationsInput | $Enums.Shift
    gender?: StringFieldUpdateOperationsInput | string
    designation?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FacultyUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    facultyId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    contactNo?: NullableStringFieldUpdateOperationsInput | string | null
    shift?: EnumShiftFieldUpdateOperationsInput | $Enums.Shift
    gender?: StringFieldUpdateOperationsInput | string
    designation?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    academicFacultyId?: StringFieldUpdateOperationsInput | string
    academicDepartmentId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BuildingCreateInput = {
    id?: string
    title: string
    createdAt?: Date | string
    updatedAt?: Date | string
    rooms?: RoomCreateNestedManyWithoutBuildingInput
  }

  export type BuildingUncheckedCreateInput = {
    id?: string
    title: string
    createdAt?: Date | string
    updatedAt?: Date | string
    rooms?: RoomUncheckedCreateNestedManyWithoutBuildingInput
  }

  export type BuildingUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rooms?: RoomUpdateManyWithoutBuildingNestedInput
  }

  export type BuildingUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rooms?: RoomUncheckedUpdateManyWithoutBuildingNestedInput
  }

  export type BuildingCreateManyInput = {
    id?: string
    title: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BuildingUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BuildingUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoomCreateInput = {
    id?: string
    roomNumber: string
    floor: string
    createdAt?: Date | string
    updatedAt?: Date | string
    building: BuildingCreateNestedOneWithoutRoomsInput
    offeredCourseClassSchedules?: OfferedCourseClassScheduleCreateNestedManyWithoutRoomInput
  }

  export type RoomUncheckedCreateInput = {
    id?: string
    roomNumber: string
    floor: string
    buildingId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    offeredCourseClassSchedules?: OfferedCourseClassScheduleUncheckedCreateNestedManyWithoutRoomInput
  }

  export type RoomUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    roomNumber?: StringFieldUpdateOperationsInput | string
    floor?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    building?: BuildingUpdateOneRequiredWithoutRoomsNestedInput
    offeredCourseClassSchedules?: OfferedCourseClassScheduleUpdateManyWithoutRoomNestedInput
  }

  export type RoomUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    roomNumber?: StringFieldUpdateOperationsInput | string
    floor?: StringFieldUpdateOperationsInput | string
    buildingId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    offeredCourseClassSchedules?: OfferedCourseClassScheduleUncheckedUpdateManyWithoutRoomNestedInput
  }

  export type RoomCreateManyInput = {
    id?: string
    roomNumber: string
    floor: string
    buildingId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RoomUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    roomNumber?: StringFieldUpdateOperationsInput | string
    floor?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoomUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    roomNumber?: StringFieldUpdateOperationsInput | string
    floor?: StringFieldUpdateOperationsInput | string
    buildingId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CourseCreateInput = {
    id?: string
    title: string
    code: string
    durationInYears: number
    yearLevel?: $Enums.YearLevel
    shift?: $Enums.Shift
    createdAt?: Date | string
    updatedAt?: Date | string
    courseDisciplines?: CourseDisciplineCreateNestedManyWithoutCourseInput
    coursePricing?: CoursePricingCreateNestedOneWithoutCourseInput
    academicDepartment: AcademicDepartmentCreateNestedOneWithoutCoursesInput
    studentCourses?: StudentEnrolledCourseCreateNestedManyWithoutCourseInput
    preRequisite?: CourseToPreRequisiteCreateNestedManyWithoutCourseInput
    preRequisiteFor?: CourseToPreRequisiteCreateNestedManyWithoutPreRequisiteInput
    faculties?: CourseFacultyCreateNestedManyWithoutCourseInput
    offeredCourses?: OfferedCourseCreateNestedManyWithoutCourseInput
  }

  export type CourseUncheckedCreateInput = {
    id?: string
    title: string
    code: string
    durationInYears: number
    yearLevel?: $Enums.YearLevel
    shift?: $Enums.Shift
    academicDepartmentId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    courseDisciplines?: CourseDisciplineUncheckedCreateNestedManyWithoutCourseInput
    coursePricing?: CoursePricingUncheckedCreateNestedOneWithoutCourseInput
    studentCourses?: StudentEnrolledCourseUncheckedCreateNestedManyWithoutCourseInput
    preRequisite?: CourseToPreRequisiteUncheckedCreateNestedManyWithoutCourseInput
    preRequisiteFor?: CourseToPreRequisiteUncheckedCreateNestedManyWithoutPreRequisiteInput
    faculties?: CourseFacultyUncheckedCreateNestedManyWithoutCourseInput
    offeredCourses?: OfferedCourseUncheckedCreateNestedManyWithoutCourseInput
  }

  export type CourseUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    durationInYears?: IntFieldUpdateOperationsInput | number
    yearLevel?: EnumYearLevelFieldUpdateOperationsInput | $Enums.YearLevel
    shift?: EnumShiftFieldUpdateOperationsInput | $Enums.Shift
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    courseDisciplines?: CourseDisciplineUpdateManyWithoutCourseNestedInput
    coursePricing?: CoursePricingUpdateOneWithoutCourseNestedInput
    academicDepartment?: AcademicDepartmentUpdateOneRequiredWithoutCoursesNestedInput
    studentCourses?: StudentEnrolledCourseUpdateManyWithoutCourseNestedInput
    preRequisite?: CourseToPreRequisiteUpdateManyWithoutCourseNestedInput
    preRequisiteFor?: CourseToPreRequisiteUpdateManyWithoutPreRequisiteNestedInput
    faculties?: CourseFacultyUpdateManyWithoutCourseNestedInput
    offeredCourses?: OfferedCourseUpdateManyWithoutCourseNestedInput
  }

  export type CourseUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    durationInYears?: IntFieldUpdateOperationsInput | number
    yearLevel?: EnumYearLevelFieldUpdateOperationsInput | $Enums.YearLevel
    shift?: EnumShiftFieldUpdateOperationsInput | $Enums.Shift
    academicDepartmentId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    courseDisciplines?: CourseDisciplineUncheckedUpdateManyWithoutCourseNestedInput
    coursePricing?: CoursePricingUncheckedUpdateOneWithoutCourseNestedInput
    studentCourses?: StudentEnrolledCourseUncheckedUpdateManyWithoutCourseNestedInput
    preRequisite?: CourseToPreRequisiteUncheckedUpdateManyWithoutCourseNestedInput
    preRequisiteFor?: CourseToPreRequisiteUncheckedUpdateManyWithoutPreRequisiteNestedInput
    faculties?: CourseFacultyUncheckedUpdateManyWithoutCourseNestedInput
    offeredCourses?: OfferedCourseUncheckedUpdateManyWithoutCourseNestedInput
  }

  export type CourseCreateManyInput = {
    id?: string
    title: string
    code: string
    durationInYears: number
    yearLevel?: $Enums.YearLevel
    shift?: $Enums.Shift
    academicDepartmentId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CourseUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    durationInYears?: IntFieldUpdateOperationsInput | number
    yearLevel?: EnumYearLevelFieldUpdateOperationsInput | $Enums.YearLevel
    shift?: EnumShiftFieldUpdateOperationsInput | $Enums.Shift
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CourseUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    durationInYears?: IntFieldUpdateOperationsInput | number
    yearLevel?: EnumYearLevelFieldUpdateOperationsInput | $Enums.YearLevel
    shift?: EnumShiftFieldUpdateOperationsInput | $Enums.Shift
    academicDepartmentId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CourseToPreRequisiteCreateInput = {
    course: CourseCreateNestedOneWithoutPreRequisiteInput
    preRequisite: CourseCreateNestedOneWithoutPreRequisiteForInput
  }

  export type CourseToPreRequisiteUncheckedCreateInput = {
    courseId: string
    preRequisiteId: string
  }

  export type CourseToPreRequisiteUpdateInput = {
    course?: CourseUpdateOneRequiredWithoutPreRequisiteNestedInput
    preRequisite?: CourseUpdateOneRequiredWithoutPreRequisiteForNestedInput
  }

  export type CourseToPreRequisiteUncheckedUpdateInput = {
    courseId?: StringFieldUpdateOperationsInput | string
    preRequisiteId?: StringFieldUpdateOperationsInput | string
  }

  export type CourseToPreRequisiteCreateManyInput = {
    courseId: string
    preRequisiteId: string
  }

  export type CourseToPreRequisiteUpdateManyMutationInput = {

  }

  export type CourseToPreRequisiteUncheckedUpdateManyInput = {
    courseId?: StringFieldUpdateOperationsInput | string
    preRequisiteId?: StringFieldUpdateOperationsInput | string
  }

  export type CourseFacultyCreateInput = {
    course: CourseCreateNestedOneWithoutFacultiesInput
    faculty: FacultyCreateNestedOneWithoutCoursesInput
  }

  export type CourseFacultyUncheckedCreateInput = {
    courseId: string
    facultyId: string
  }

  export type CourseFacultyUpdateInput = {
    course?: CourseUpdateOneRequiredWithoutFacultiesNestedInput
    faculty?: FacultyUpdateOneRequiredWithoutCoursesNestedInput
  }

  export type CourseFacultyUncheckedUpdateInput = {
    courseId?: StringFieldUpdateOperationsInput | string
    facultyId?: StringFieldUpdateOperationsInput | string
  }

  export type CourseFacultyCreateManyInput = {
    courseId: string
    facultyId: string
  }

  export type CourseFacultyUpdateManyMutationInput = {

  }

  export type CourseFacultyUncheckedUpdateManyInput = {
    courseId?: StringFieldUpdateOperationsInput | string
    facultyId?: StringFieldUpdateOperationsInput | string
  }

  export type SemesterRegistrationCreateInput = {
    id?: string
    startDate: Date | string
    endDate: Date | string
    status?: $Enums.SemesterRegistrationStatus | null
    createdAt?: Date | string
    updateAt?: Date | string
    academicSemester: AcademicSemesterCreateNestedOneWithoutSemesterRegistrationsInput
    offeredCourses?: OfferedCourseCreateNestedManyWithoutSemesterRegistrationInput
    offeredCourseSections?: OfferedCourseSectionCreateNestedManyWithoutSemesterRegistrationInput
    offeredCourseClassSchedules?: OfferedCourseClassScheduleCreateNestedManyWithoutSemesterRegistrationInput
    studentSemesterRegistrations?: StudentSemesterRegistrationCreateNestedManyWithoutSemesterRegistrationInput
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseCreateNestedManyWithoutSemesterRegistrationInput
  }

  export type SemesterRegistrationUncheckedCreateInput = {
    id?: string
    startDate: Date | string
    endDate: Date | string
    status?: $Enums.SemesterRegistrationStatus | null
    createdAt?: Date | string
    updateAt?: Date | string
    academicSemesterId: string
    offeredCourses?: OfferedCourseUncheckedCreateNestedManyWithoutSemesterRegistrationInput
    offeredCourseSections?: OfferedCourseSectionUncheckedCreateNestedManyWithoutSemesterRegistrationInput
    offeredCourseClassSchedules?: OfferedCourseClassScheduleUncheckedCreateNestedManyWithoutSemesterRegistrationInput
    studentSemesterRegistrations?: StudentSemesterRegistrationUncheckedCreateNestedManyWithoutSemesterRegistrationInput
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseUncheckedCreateNestedManyWithoutSemesterRegistrationInput
  }

  export type SemesterRegistrationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: NullableEnumSemesterRegistrationStatusFieldUpdateOperationsInput | $Enums.SemesterRegistrationStatus | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    academicSemester?: AcademicSemesterUpdateOneRequiredWithoutSemesterRegistrationsNestedInput
    offeredCourses?: OfferedCourseUpdateManyWithoutSemesterRegistrationNestedInput
    offeredCourseSections?: OfferedCourseSectionUpdateManyWithoutSemesterRegistrationNestedInput
    offeredCourseClassSchedules?: OfferedCourseClassScheduleUpdateManyWithoutSemesterRegistrationNestedInput
    studentSemesterRegistrations?: StudentSemesterRegistrationUpdateManyWithoutSemesterRegistrationNestedInput
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseUpdateManyWithoutSemesterRegistrationNestedInput
  }

  export type SemesterRegistrationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: NullableEnumSemesterRegistrationStatusFieldUpdateOperationsInput | $Enums.SemesterRegistrationStatus | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    academicSemesterId?: StringFieldUpdateOperationsInput | string
    offeredCourses?: OfferedCourseUncheckedUpdateManyWithoutSemesterRegistrationNestedInput
    offeredCourseSections?: OfferedCourseSectionUncheckedUpdateManyWithoutSemesterRegistrationNestedInput
    offeredCourseClassSchedules?: OfferedCourseClassScheduleUncheckedUpdateManyWithoutSemesterRegistrationNestedInput
    studentSemesterRegistrations?: StudentSemesterRegistrationUncheckedUpdateManyWithoutSemesterRegistrationNestedInput
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseUncheckedUpdateManyWithoutSemesterRegistrationNestedInput
  }

  export type SemesterRegistrationCreateManyInput = {
    id?: string
    startDate: Date | string
    endDate: Date | string
    status?: $Enums.SemesterRegistrationStatus | null
    createdAt?: Date | string
    updateAt?: Date | string
    academicSemesterId: string
  }

  export type SemesterRegistrationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: NullableEnumSemesterRegistrationStatusFieldUpdateOperationsInput | $Enums.SemesterRegistrationStatus | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SemesterRegistrationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: NullableEnumSemesterRegistrationStatusFieldUpdateOperationsInput | $Enums.SemesterRegistrationStatus | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    academicSemesterId?: StringFieldUpdateOperationsInput | string
  }

  export type AdmitionExameRegistrationCreateInput = {
    id?: string
    applicantName: string
    paymentRecipt: string
    status?: $Enums.Status
    document: string
    paymentAmoute?: number | null
    aprovePayment?: boolean | null
    exameResults?: number | null
    passed?: boolean | null
    exameDate: Date | string
    rejectionReason?: string | null
    phoneNumber: string
    email: string
    createdAt?: Date | string
    updateAt?: Date | string
    fase: ExameFaseCreateNestedOneWithoutRegistrationsInput
    academicFalculty: AcademicFacultyCreateNestedOneWithoutAdmitionExameInput
    Student?: StudentCreateNestedOneWithoutAdmissionRegistrationInput
  }

  export type AdmitionExameRegistrationUncheckedCreateInput = {
    id?: string
    applicantName: string
    paymentRecipt: string
    status?: $Enums.Status
    document: string
    paymentAmoute?: number | null
    aprovePayment?: boolean | null
    exameResults?: number | null
    passed?: boolean | null
    faseId: string
    exameDate: Date | string
    rejectionReason?: string | null
    phoneNumber: string
    email: string
    createdAt?: Date | string
    updateAt?: Date | string
    academicFalcultyId: string
    Student?: StudentUncheckedCreateNestedOneWithoutAdmissionRegistrationInput
  }

  export type AdmitionExameRegistrationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    applicantName?: StringFieldUpdateOperationsInput | string
    paymentRecipt?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    document?: StringFieldUpdateOperationsInput | string
    paymentAmoute?: NullableIntFieldUpdateOperationsInput | number | null
    aprovePayment?: NullableBoolFieldUpdateOperationsInput | boolean | null
    exameResults?: NullableIntFieldUpdateOperationsInput | number | null
    passed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    exameDate?: DateTimeFieldUpdateOperationsInput | Date | string
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fase?: ExameFaseUpdateOneRequiredWithoutRegistrationsNestedInput
    academicFalculty?: AcademicFacultyUpdateOneRequiredWithoutAdmitionExameNestedInput
    Student?: StudentUpdateOneWithoutAdmissionRegistrationNestedInput
  }

  export type AdmitionExameRegistrationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    applicantName?: StringFieldUpdateOperationsInput | string
    paymentRecipt?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    document?: StringFieldUpdateOperationsInput | string
    paymentAmoute?: NullableIntFieldUpdateOperationsInput | number | null
    aprovePayment?: NullableBoolFieldUpdateOperationsInput | boolean | null
    exameResults?: NullableIntFieldUpdateOperationsInput | number | null
    passed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    faseId?: StringFieldUpdateOperationsInput | string
    exameDate?: DateTimeFieldUpdateOperationsInput | Date | string
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    academicFalcultyId?: StringFieldUpdateOperationsInput | string
    Student?: StudentUncheckedUpdateOneWithoutAdmissionRegistrationNestedInput
  }

  export type AdmitionExameRegistrationCreateManyInput = {
    id?: string
    applicantName: string
    paymentRecipt: string
    status?: $Enums.Status
    document: string
    paymentAmoute?: number | null
    aprovePayment?: boolean | null
    exameResults?: number | null
    passed?: boolean | null
    faseId: string
    exameDate: Date | string
    rejectionReason?: string | null
    phoneNumber: string
    email: string
    createdAt?: Date | string
    updateAt?: Date | string
    academicFalcultyId: string
  }

  export type AdmitionExameRegistrationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    applicantName?: StringFieldUpdateOperationsInput | string
    paymentRecipt?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    document?: StringFieldUpdateOperationsInput | string
    paymentAmoute?: NullableIntFieldUpdateOperationsInput | number | null
    aprovePayment?: NullableBoolFieldUpdateOperationsInput | boolean | null
    exameResults?: NullableIntFieldUpdateOperationsInput | number | null
    passed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    exameDate?: DateTimeFieldUpdateOperationsInput | Date | string
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdmitionExameRegistrationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    applicantName?: StringFieldUpdateOperationsInput | string
    paymentRecipt?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    document?: StringFieldUpdateOperationsInput | string
    paymentAmoute?: NullableIntFieldUpdateOperationsInput | number | null
    aprovePayment?: NullableBoolFieldUpdateOperationsInput | boolean | null
    exameResults?: NullableIntFieldUpdateOperationsInput | number | null
    passed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    faseId?: StringFieldUpdateOperationsInput | string
    exameDate?: DateTimeFieldUpdateOperationsInput | Date | string
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    academicFalcultyId?: StringFieldUpdateOperationsInput | string
  }

  export type AdmitionExamePriceCreateInput = {
    id?: string
    price: number
    createdAt?: Date | string
    updatedAt?: Date | string
    academicFaculty: AcademicFacultyCreateNestedOneWithoutAdmitionExamePriceInput
  }

  export type AdmitionExamePriceUncheckedCreateInput = {
    id?: string
    academicFacultyId: string
    price: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AdmitionExamePriceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    academicFaculty?: AcademicFacultyUpdateOneRequiredWithoutAdmitionExamePriceNestedInput
  }

  export type AdmitionExamePriceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    academicFacultyId?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdmitionExamePriceCreateManyInput = {
    id?: string
    academicFacultyId: string
    price: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AdmitionExamePriceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdmitionExamePriceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    academicFacultyId?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdmitionExamePeriodCreateInput = {
    id?: string
    startDate: Date | string
    endDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    academicFaculty: AcademicFacultyCreateNestedOneWithoutAdmitionExamePeriodInput
  }

  export type AdmitionExamePeriodUncheckedCreateInput = {
    id?: string
    startDate: Date | string
    endDate: Date | string
    academicFacultyId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AdmitionExamePeriodUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    academicFaculty?: AcademicFacultyUpdateOneRequiredWithoutAdmitionExamePeriodNestedInput
  }

  export type AdmitionExamePeriodUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    academicFacultyId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdmitionExamePeriodCreateManyInput = {
    id?: string
    startDate: Date | string
    endDate: Date | string
    academicFacultyId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AdmitionExamePeriodUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdmitionExamePeriodUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    academicFacultyId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExameFaseCreateInput = {
    id?: string
    name: string
    ordem: number
    startDate: Date | string
    endDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    registrations?: AdmitionExameRegistrationCreateNestedManyWithoutFaseInput
  }

  export type ExameFaseUncheckedCreateInput = {
    id?: string
    name: string
    ordem: number
    startDate: Date | string
    endDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    registrations?: AdmitionExameRegistrationUncheckedCreateNestedManyWithoutFaseInput
  }

  export type ExameFaseUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    ordem?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    registrations?: AdmitionExameRegistrationUpdateManyWithoutFaseNestedInput
  }

  export type ExameFaseUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    ordem?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    registrations?: AdmitionExameRegistrationUncheckedUpdateManyWithoutFaseNestedInput
  }

  export type ExameFaseCreateManyInput = {
    id?: string
    name: string
    ordem: number
    startDate: Date | string
    endDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExameFaseUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    ordem?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExameFaseUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    ordem?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OfferedCourseCreateInput = {
    id?: string
    suspendGrade?: number
    academicDepartment: AcademicDepartmentCreateNestedOneWithoutOfferedCoursesInput
    semesterRegistration: SemesterRegistrationCreateNestedOneWithoutOfferedCoursesInput
    course: CourseCreateNestedOneWithoutOfferedCoursesInput
    offeredCourseSections?: OfferedCourseSectionCreateNestedManyWithoutOfferedCourseInput
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseCreateNestedManyWithoutOfferedCourseInput
  }

  export type OfferedCourseUncheckedCreateInput = {
    id?: string
    academicDepartmentId: string
    courseId: string
    semesterRegistrationId: string
    suspendGrade?: number
    offeredCourseSections?: OfferedCourseSectionUncheckedCreateNestedManyWithoutOfferedCourseInput
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseUncheckedCreateNestedManyWithoutOfferedCourseInput
  }

  export type OfferedCourseUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    suspendGrade?: IntFieldUpdateOperationsInput | number
    academicDepartment?: AcademicDepartmentUpdateOneRequiredWithoutOfferedCoursesNestedInput
    semesterRegistration?: SemesterRegistrationUpdateOneRequiredWithoutOfferedCoursesNestedInput
    course?: CourseUpdateOneRequiredWithoutOfferedCoursesNestedInput
    offeredCourseSections?: OfferedCourseSectionUpdateManyWithoutOfferedCourseNestedInput
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseUpdateManyWithoutOfferedCourseNestedInput
  }

  export type OfferedCourseUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    academicDepartmentId?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    semesterRegistrationId?: StringFieldUpdateOperationsInput | string
    suspendGrade?: IntFieldUpdateOperationsInput | number
    offeredCourseSections?: OfferedCourseSectionUncheckedUpdateManyWithoutOfferedCourseNestedInput
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseUncheckedUpdateManyWithoutOfferedCourseNestedInput
  }

  export type OfferedCourseCreateManyInput = {
    id?: string
    academicDepartmentId: string
    courseId: string
    semesterRegistrationId: string
    suspendGrade?: number
  }

  export type OfferedCourseUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    suspendGrade?: IntFieldUpdateOperationsInput | number
  }

  export type OfferedCourseUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    academicDepartmentId?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    semesterRegistrationId?: StringFieldUpdateOperationsInput | string
    suspendGrade?: IntFieldUpdateOperationsInput | number
  }

  export type OfferedCourseSectionCreateInput = {
    id?: string
    title: string
    maxCapacity?: number
    currentlyEnrolledStudent?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    semesterRegistration: SemesterRegistrationCreateNestedOneWithoutOfferedCourseSectionsInput
    offeredCourse: OfferedCourseCreateNestedOneWithoutOfferedCourseSectionsInput
    offeredCourseClassSchedules?: OfferedCourseClassScheduleCreateNestedManyWithoutOfferedCourseSectionInput
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseCreateNestedManyWithoutOfferedCourseSectionInput
  }

  export type OfferedCourseSectionUncheckedCreateInput = {
    id?: string
    title: string
    maxCapacity?: number
    currentlyEnrolledStudent?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    semesterRegistrationId: string
    offeredCourseId: string
    offeredCourseClassSchedules?: OfferedCourseClassScheduleUncheckedCreateNestedManyWithoutOfferedCourseSectionInput
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseUncheckedCreateNestedManyWithoutOfferedCourseSectionInput
  }

  export type OfferedCourseSectionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    maxCapacity?: IntFieldUpdateOperationsInput | number
    currentlyEnrolledStudent?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    semesterRegistration?: SemesterRegistrationUpdateOneRequiredWithoutOfferedCourseSectionsNestedInput
    offeredCourse?: OfferedCourseUpdateOneRequiredWithoutOfferedCourseSectionsNestedInput
    offeredCourseClassSchedules?: OfferedCourseClassScheduleUpdateManyWithoutOfferedCourseSectionNestedInput
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseUpdateManyWithoutOfferedCourseSectionNestedInput
  }

  export type OfferedCourseSectionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    maxCapacity?: IntFieldUpdateOperationsInput | number
    currentlyEnrolledStudent?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    semesterRegistrationId?: StringFieldUpdateOperationsInput | string
    offeredCourseId?: StringFieldUpdateOperationsInput | string
    offeredCourseClassSchedules?: OfferedCourseClassScheduleUncheckedUpdateManyWithoutOfferedCourseSectionNestedInput
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseUncheckedUpdateManyWithoutOfferedCourseSectionNestedInput
  }

  export type OfferedCourseSectionCreateManyInput = {
    id?: string
    title: string
    maxCapacity?: number
    currentlyEnrolledStudent?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    semesterRegistrationId: string
    offeredCourseId: string
  }

  export type OfferedCourseSectionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    maxCapacity?: IntFieldUpdateOperationsInput | number
    currentlyEnrolledStudent?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OfferedCourseSectionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    maxCapacity?: IntFieldUpdateOperationsInput | number
    currentlyEnrolledStudent?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    semesterRegistrationId?: StringFieldUpdateOperationsInput | string
    offeredCourseId?: StringFieldUpdateOperationsInput | string
  }

  export type OfferedCourseClassScheduleCreateInput = {
    id?: string
    startTime: string
    endTime: string
    dayOfWeek?: $Enums.WeekDays
    createdAt?: Date | string
    updatedAt?: Date | string
    offeredCourseSection: OfferedCourseSectionCreateNestedOneWithoutOfferedCourseClassSchedulesInput
    semesterRegistration: SemesterRegistrationCreateNestedOneWithoutOfferedCourseClassSchedulesInput
    room: RoomCreateNestedOneWithoutOfferedCourseClassSchedulesInput
    faculty: FacultyCreateNestedOneWithoutOfferedCourseClassSchedulesInput
  }

  export type OfferedCourseClassScheduleUncheckedCreateInput = {
    id?: string
    startTime: string
    endTime: string
    dayOfWeek?: $Enums.WeekDays
    createdAt?: Date | string
    updatedAt?: Date | string
    offeredCourseSectionId: string
    semesterRegistrationId: string
    roomId: string
    facultyId: string
  }

  export type OfferedCourseClassScheduleUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    dayOfWeek?: EnumWeekDaysFieldUpdateOperationsInput | $Enums.WeekDays
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    offeredCourseSection?: OfferedCourseSectionUpdateOneRequiredWithoutOfferedCourseClassSchedulesNestedInput
    semesterRegistration?: SemesterRegistrationUpdateOneRequiredWithoutOfferedCourseClassSchedulesNestedInput
    room?: RoomUpdateOneRequiredWithoutOfferedCourseClassSchedulesNestedInput
    faculty?: FacultyUpdateOneRequiredWithoutOfferedCourseClassSchedulesNestedInput
  }

  export type OfferedCourseClassScheduleUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    dayOfWeek?: EnumWeekDaysFieldUpdateOperationsInput | $Enums.WeekDays
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    offeredCourseSectionId?: StringFieldUpdateOperationsInput | string
    semesterRegistrationId?: StringFieldUpdateOperationsInput | string
    roomId?: StringFieldUpdateOperationsInput | string
    facultyId?: StringFieldUpdateOperationsInput | string
  }

  export type OfferedCourseClassScheduleCreateManyInput = {
    id?: string
    startTime: string
    endTime: string
    dayOfWeek?: $Enums.WeekDays
    createdAt?: Date | string
    updatedAt?: Date | string
    offeredCourseSectionId: string
    semesterRegistrationId: string
    roomId: string
    facultyId: string
  }

  export type OfferedCourseClassScheduleUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    dayOfWeek?: EnumWeekDaysFieldUpdateOperationsInput | $Enums.WeekDays
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OfferedCourseClassScheduleUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    dayOfWeek?: EnumWeekDaysFieldUpdateOperationsInput | $Enums.WeekDays
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    offeredCourseSectionId?: StringFieldUpdateOperationsInput | string
    semesterRegistrationId?: StringFieldUpdateOperationsInput | string
    roomId?: StringFieldUpdateOperationsInput | string
    facultyId?: StringFieldUpdateOperationsInput | string
  }

  export type StudentSemesterRegistrationCreateInput = {
    id?: string
    isConfirmed?: boolean | null
    totalCreditsTaken?: number | null
    paymentRecipt?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    student: StudentCreateNestedOneWithoutStudentSemesterRegistrationsInput
    semesterRegistration: SemesterRegistrationCreateNestedOneWithoutStudentSemesterRegistrationsInput
  }

  export type StudentSemesterRegistrationUncheckedCreateInput = {
    id?: string
    isConfirmed?: boolean | null
    totalCreditsTaken?: number | null
    paymentRecipt?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    studentId: string
    semesterRegistrationId: string
  }

  export type StudentSemesterRegistrationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    isConfirmed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    totalCreditsTaken?: NullableIntFieldUpdateOperationsInput | number | null
    paymentRecipt?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUpdateOneRequiredWithoutStudentSemesterRegistrationsNestedInput
    semesterRegistration?: SemesterRegistrationUpdateOneRequiredWithoutStudentSemesterRegistrationsNestedInput
  }

  export type StudentSemesterRegistrationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    isConfirmed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    totalCreditsTaken?: NullableIntFieldUpdateOperationsInput | number | null
    paymentRecipt?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    studentId?: StringFieldUpdateOperationsInput | string
    semesterRegistrationId?: StringFieldUpdateOperationsInput | string
  }

  export type StudentSemesterRegistrationCreateManyInput = {
    id?: string
    isConfirmed?: boolean | null
    totalCreditsTaken?: number | null
    paymentRecipt?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    studentId: string
    semesterRegistrationId: string
  }

  export type StudentSemesterRegistrationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    isConfirmed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    totalCreditsTaken?: NullableIntFieldUpdateOperationsInput | number | null
    paymentRecipt?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentSemesterRegistrationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    isConfirmed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    totalCreditsTaken?: NullableIntFieldUpdateOperationsInput | number | null
    paymentRecipt?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    studentId?: StringFieldUpdateOperationsInput | string
    semesterRegistrationId?: StringFieldUpdateOperationsInput | string
  }

  export type StudentSemesterRegistrationCourseCreateInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    semesterRegistration: SemesterRegistrationCreateNestedOneWithoutStudentSemesterRegistrationCoursesInput
    student: StudentCreateNestedOneWithoutStudentSemesterRegistrationCoursesInput
    offeredCourse: OfferedCourseCreateNestedOneWithoutStudentSemesterRegistrationCoursesInput
    offeredCourseSection: OfferedCourseSectionCreateNestedOneWithoutStudentSemesterRegistrationCoursesInput
  }

  export type StudentSemesterRegistrationCourseUncheckedCreateInput = {
    semesterRegistrationId: string
    studentId: string
    offeredCourseId: string
    offeredCourseSectionId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StudentSemesterRegistrationCourseUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    semesterRegistration?: SemesterRegistrationUpdateOneRequiredWithoutStudentSemesterRegistrationCoursesNestedInput
    student?: StudentUpdateOneRequiredWithoutStudentSemesterRegistrationCoursesNestedInput
    offeredCourse?: OfferedCourseUpdateOneRequiredWithoutStudentSemesterRegistrationCoursesNestedInput
    offeredCourseSection?: OfferedCourseSectionUpdateOneRequiredWithoutStudentSemesterRegistrationCoursesNestedInput
  }

  export type StudentSemesterRegistrationCourseUncheckedUpdateInput = {
    semesterRegistrationId?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    offeredCourseId?: StringFieldUpdateOperationsInput | string
    offeredCourseSectionId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentSemesterRegistrationCourseCreateManyInput = {
    semesterRegistrationId: string
    studentId: string
    offeredCourseId: string
    offeredCourseSectionId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StudentSemesterRegistrationCourseUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentSemesterRegistrationCourseUncheckedUpdateManyInput = {
    semesterRegistrationId?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    offeredCourseId?: StringFieldUpdateOperationsInput | string
    offeredCourseSectionId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentEnrolledCourseCreateInput = {
    id?: string
    grade?: string | null
    point?: number | null
    totalMarks?: number | null
    status?: $Enums.StudentEnrolledCourseStatus | null
    createdAt?: Date | string
    updatedAt?: Date | string
    student: StudentCreateNestedOneWithoutStudentEnrolledCoursesInput
    course: CourseCreateNestedOneWithoutStudentCoursesInput
    studentEnrolledCourseMarks?: StudentEnrolledCourseMarkCreateNestedManyWithoutStudentEnrolledCourseInput
    academicSemester: AcademicSemesterCreateNestedOneWithoutStudentEnrolledCoursesInput
  }

  export type StudentEnrolledCourseUncheckedCreateInput = {
    id?: string
    grade?: string | null
    point?: number | null
    totalMarks?: number | null
    status?: $Enums.StudentEnrolledCourseStatus | null
    createdAt?: Date | string
    updatedAt?: Date | string
    studentId: string
    academicSemesterId: string
    courseId: string
    studentEnrolledCourseMarks?: StudentEnrolledCourseMarkUncheckedCreateNestedManyWithoutStudentEnrolledCourseInput
  }

  export type StudentEnrolledCourseUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    grade?: NullableStringFieldUpdateOperationsInput | string | null
    point?: NullableFloatFieldUpdateOperationsInput | number | null
    totalMarks?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableEnumStudentEnrolledCourseStatusFieldUpdateOperationsInput | $Enums.StudentEnrolledCourseStatus | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUpdateOneRequiredWithoutStudentEnrolledCoursesNestedInput
    course?: CourseUpdateOneRequiredWithoutStudentCoursesNestedInput
    studentEnrolledCourseMarks?: StudentEnrolledCourseMarkUpdateManyWithoutStudentEnrolledCourseNestedInput
    academicSemester?: AcademicSemesterUpdateOneRequiredWithoutStudentEnrolledCoursesNestedInput
  }

  export type StudentEnrolledCourseUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    grade?: NullableStringFieldUpdateOperationsInput | string | null
    point?: NullableFloatFieldUpdateOperationsInput | number | null
    totalMarks?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableEnumStudentEnrolledCourseStatusFieldUpdateOperationsInput | $Enums.StudentEnrolledCourseStatus | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    studentId?: StringFieldUpdateOperationsInput | string
    academicSemesterId?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    studentEnrolledCourseMarks?: StudentEnrolledCourseMarkUncheckedUpdateManyWithoutStudentEnrolledCourseNestedInput
  }

  export type StudentEnrolledCourseCreateManyInput = {
    id?: string
    grade?: string | null
    point?: number | null
    totalMarks?: number | null
    status?: $Enums.StudentEnrolledCourseStatus | null
    createdAt?: Date | string
    updatedAt?: Date | string
    studentId: string
    academicSemesterId: string
    courseId: string
  }

  export type StudentEnrolledCourseUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    grade?: NullableStringFieldUpdateOperationsInput | string | null
    point?: NullableFloatFieldUpdateOperationsInput | number | null
    totalMarks?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableEnumStudentEnrolledCourseStatusFieldUpdateOperationsInput | $Enums.StudentEnrolledCourseStatus | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentEnrolledCourseUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    grade?: NullableStringFieldUpdateOperationsInput | string | null
    point?: NullableFloatFieldUpdateOperationsInput | number | null
    totalMarks?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableEnumStudentEnrolledCourseStatusFieldUpdateOperationsInput | $Enums.StudentEnrolledCourseStatus | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    studentId?: StringFieldUpdateOperationsInput | string
    academicSemesterId?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
  }

  export type StudentEnrolledCourseMarkCreateInput = {
    id?: string
    examType?: $Enums.ExamType | null
    createdAt?: Date | string
    updatedAt?: Date | string
    continuousAssessments: JsonNullValueInput | InputJsonValue
    frequencyExam?: number | null
    finalExam?: number | null
    resourceExam?: number | null
    specialExam?: number | null
    recoveryExam?: number | null
    totalMarks?: number
    grade?: number
    student: StudentCreateNestedOneWithoutStudentEnrolledCourseMarksInput
    studentEnrolledCourse: StudentEnrolledCourseCreateNestedOneWithoutStudentEnrolledCourseMarksInput
    academicSemester: AcademicSemesterCreateNestedOneWithoutStudentEnrolledCourseMarksInput
  }

  export type StudentEnrolledCourseMarkUncheckedCreateInput = {
    id?: string
    examType?: $Enums.ExamType | null
    createdAt?: Date | string
    updatedAt?: Date | string
    studentId: string
    studentEnrolledCourseId: string
    academicSemesterId: string
    continuousAssessments: JsonNullValueInput | InputJsonValue
    frequencyExam?: number | null
    finalExam?: number | null
    resourceExam?: number | null
    specialExam?: number | null
    recoveryExam?: number | null
    totalMarks?: number
    grade?: number
  }

  export type StudentEnrolledCourseMarkUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    examType?: NullableEnumExamTypeFieldUpdateOperationsInput | $Enums.ExamType | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    continuousAssessments?: JsonNullValueInput | InputJsonValue
    frequencyExam?: NullableFloatFieldUpdateOperationsInput | number | null
    finalExam?: NullableFloatFieldUpdateOperationsInput | number | null
    resourceExam?: NullableFloatFieldUpdateOperationsInput | number | null
    specialExam?: NullableFloatFieldUpdateOperationsInput | number | null
    recoveryExam?: NullableFloatFieldUpdateOperationsInput | number | null
    totalMarks?: FloatFieldUpdateOperationsInput | number
    grade?: FloatFieldUpdateOperationsInput | number
    student?: StudentUpdateOneRequiredWithoutStudentEnrolledCourseMarksNestedInput
    studentEnrolledCourse?: StudentEnrolledCourseUpdateOneRequiredWithoutStudentEnrolledCourseMarksNestedInput
    academicSemester?: AcademicSemesterUpdateOneRequiredWithoutStudentEnrolledCourseMarksNestedInput
  }

  export type StudentEnrolledCourseMarkUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    examType?: NullableEnumExamTypeFieldUpdateOperationsInput | $Enums.ExamType | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    studentId?: StringFieldUpdateOperationsInput | string
    studentEnrolledCourseId?: StringFieldUpdateOperationsInput | string
    academicSemesterId?: StringFieldUpdateOperationsInput | string
    continuousAssessments?: JsonNullValueInput | InputJsonValue
    frequencyExam?: NullableFloatFieldUpdateOperationsInput | number | null
    finalExam?: NullableFloatFieldUpdateOperationsInput | number | null
    resourceExam?: NullableFloatFieldUpdateOperationsInput | number | null
    specialExam?: NullableFloatFieldUpdateOperationsInput | number | null
    recoveryExam?: NullableFloatFieldUpdateOperationsInput | number | null
    totalMarks?: FloatFieldUpdateOperationsInput | number
    grade?: FloatFieldUpdateOperationsInput | number
  }

  export type StudentEnrolledCourseMarkCreateManyInput = {
    id?: string
    examType?: $Enums.ExamType | null
    createdAt?: Date | string
    updatedAt?: Date | string
    studentId: string
    studentEnrolledCourseId: string
    academicSemesterId: string
    continuousAssessments: JsonNullValueInput | InputJsonValue
    frequencyExam?: number | null
    finalExam?: number | null
    resourceExam?: number | null
    specialExam?: number | null
    recoveryExam?: number | null
    totalMarks?: number
    grade?: number
  }

  export type StudentEnrolledCourseMarkUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    examType?: NullableEnumExamTypeFieldUpdateOperationsInput | $Enums.ExamType | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    continuousAssessments?: JsonNullValueInput | InputJsonValue
    frequencyExam?: NullableFloatFieldUpdateOperationsInput | number | null
    finalExam?: NullableFloatFieldUpdateOperationsInput | number | null
    resourceExam?: NullableFloatFieldUpdateOperationsInput | number | null
    specialExam?: NullableFloatFieldUpdateOperationsInput | number | null
    recoveryExam?: NullableFloatFieldUpdateOperationsInput | number | null
    totalMarks?: FloatFieldUpdateOperationsInput | number
    grade?: FloatFieldUpdateOperationsInput | number
  }

  export type StudentEnrolledCourseMarkUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    examType?: NullableEnumExamTypeFieldUpdateOperationsInput | $Enums.ExamType | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    studentId?: StringFieldUpdateOperationsInput | string
    studentEnrolledCourseId?: StringFieldUpdateOperationsInput | string
    academicSemesterId?: StringFieldUpdateOperationsInput | string
    continuousAssessments?: JsonNullValueInput | InputJsonValue
    frequencyExam?: NullableFloatFieldUpdateOperationsInput | number | null
    finalExam?: NullableFloatFieldUpdateOperationsInput | number | null
    resourceExam?: NullableFloatFieldUpdateOperationsInput | number | null
    specialExam?: NullableFloatFieldUpdateOperationsInput | number | null
    recoveryExam?: NullableFloatFieldUpdateOperationsInput | number | null
    totalMarks?: FloatFieldUpdateOperationsInput | number
    grade?: FloatFieldUpdateOperationsInput | number
  }

  export type CourseDisciplineCreateInput = {
    id?: string
    credits: number
    course: CourseCreateNestedOneWithoutCourseDisciplinesInput
    discipline: DisciplineCreateNestedOneWithoutCourseDisciplinesInput
    semester: AcademicSemesterCreateNestedOneWithoutCourseDisciplinesInput
  }

  export type CourseDisciplineUncheckedCreateInput = {
    id?: string
    courseId: string
    disciplineId: string
    semesterId: string
    credits: number
  }

  export type CourseDisciplineUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    credits?: IntFieldUpdateOperationsInput | number
    course?: CourseUpdateOneRequiredWithoutCourseDisciplinesNestedInput
    discipline?: DisciplineUpdateOneRequiredWithoutCourseDisciplinesNestedInput
    semester?: AcademicSemesterUpdateOneRequiredWithoutCourseDisciplinesNestedInput
  }

  export type CourseDisciplineUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    disciplineId?: StringFieldUpdateOperationsInput | string
    semesterId?: StringFieldUpdateOperationsInput | string
    credits?: IntFieldUpdateOperationsInput | number
  }

  export type CourseDisciplineCreateManyInput = {
    id?: string
    courseId: string
    disciplineId: string
    semesterId: string
    credits: number
  }

  export type CourseDisciplineUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    credits?: IntFieldUpdateOperationsInput | number
  }

  export type CourseDisciplineUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    disciplineId?: StringFieldUpdateOperationsInput | string
    semesterId?: StringFieldUpdateOperationsInput | string
    credits?: IntFieldUpdateOperationsInput | number
  }

  export type StudentCarriedCourseCreateInput = {
    id?: string
    shift: $Enums.Shift
    price: number
    status?: $Enums.CarriedCourseStatus
    createdAt?: Date | string
    student: StudentCreateNestedOneWithoutStudentCarriedCourseInput
    discipline: DisciplineCreateNestedOneWithoutStudentCarriedCourseInput
    semester: AcademicSemesterCreateNestedOneWithoutStudentCarriedCourseInput
  }

  export type StudentCarriedCourseUncheckedCreateInput = {
    id?: string
    studentId: string
    disciplineId: string
    semesterId: string
    shift: $Enums.Shift
    price: number
    status?: $Enums.CarriedCourseStatus
    createdAt?: Date | string
  }

  export type StudentCarriedCourseUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    shift?: EnumShiftFieldUpdateOperationsInput | $Enums.Shift
    price?: IntFieldUpdateOperationsInput | number
    status?: EnumCarriedCourseStatusFieldUpdateOperationsInput | $Enums.CarriedCourseStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUpdateOneRequiredWithoutStudentCarriedCourseNestedInput
    discipline?: DisciplineUpdateOneRequiredWithoutStudentCarriedCourseNestedInput
    semester?: AcademicSemesterUpdateOneRequiredWithoutStudentCarriedCourseNestedInput
  }

  export type StudentCarriedCourseUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    disciplineId?: StringFieldUpdateOperationsInput | string
    semesterId?: StringFieldUpdateOperationsInput | string
    shift?: EnumShiftFieldUpdateOperationsInput | $Enums.Shift
    price?: IntFieldUpdateOperationsInput | number
    status?: EnumCarriedCourseStatusFieldUpdateOperationsInput | $Enums.CarriedCourseStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentCarriedCourseCreateManyInput = {
    id?: string
    studentId: string
    disciplineId: string
    semesterId: string
    shift: $Enums.Shift
    price: number
    status?: $Enums.CarriedCourseStatus
    createdAt?: Date | string
  }

  export type StudentCarriedCourseUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    shift?: EnumShiftFieldUpdateOperationsInput | $Enums.Shift
    price?: IntFieldUpdateOperationsInput | number
    status?: EnumCarriedCourseStatusFieldUpdateOperationsInput | $Enums.CarriedCourseStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentCarriedCourseUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    disciplineId?: StringFieldUpdateOperationsInput | string
    semesterId?: StringFieldUpdateOperationsInput | string
    shift?: EnumShiftFieldUpdateOperationsInput | $Enums.Shift
    price?: IntFieldUpdateOperationsInput | number
    status?: EnumCarriedCourseStatusFieldUpdateOperationsInput | $Enums.CarriedCourseStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CoursePricingCreateInput = {
    id?: string
    price: number
    createdAt?: Date | string
    updatedAt?: Date | string
    course: CourseCreateNestedOneWithoutCoursePricingInput
  }

  export type CoursePricingUncheckedCreateInput = {
    id?: string
    price: number
    courseId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CoursePricingUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    course?: CourseUpdateOneRequiredWithoutCoursePricingNestedInput
  }

  export type CoursePricingUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    courseId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CoursePricingCreateManyInput = {
    id?: string
    price: number
    courseId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CoursePricingUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CoursePricingUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    courseId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DisciplineCreateInput = {
    id?: string
    name: string
    code: string
    description?: string | null
    credits: number
    minimumGradeToDismiss?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    courseDisciplines?: CourseDisciplineCreateNestedManyWithoutDisciplineInput
    StudentCarriedCourse?: StudentCarriedCourseCreateNestedManyWithoutDisciplineInput
  }

  export type DisciplineUncheckedCreateInput = {
    id?: string
    name: string
    code: string
    description?: string | null
    credits: number
    minimumGradeToDismiss?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    courseDisciplines?: CourseDisciplineUncheckedCreateNestedManyWithoutDisciplineInput
    StudentCarriedCourse?: StudentCarriedCourseUncheckedCreateNestedManyWithoutDisciplineInput
  }

  export type DisciplineUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    credits?: IntFieldUpdateOperationsInput | number
    minimumGradeToDismiss?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    courseDisciplines?: CourseDisciplineUpdateManyWithoutDisciplineNestedInput
    StudentCarriedCourse?: StudentCarriedCourseUpdateManyWithoutDisciplineNestedInput
  }

  export type DisciplineUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    credits?: IntFieldUpdateOperationsInput | number
    minimumGradeToDismiss?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    courseDisciplines?: CourseDisciplineUncheckedUpdateManyWithoutDisciplineNestedInput
    StudentCarriedCourse?: StudentCarriedCourseUncheckedUpdateManyWithoutDisciplineNestedInput
  }

  export type DisciplineCreateManyInput = {
    id?: string
    name: string
    code: string
    description?: string | null
    credits: number
    minimumGradeToDismiss?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DisciplineUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    credits?: IntFieldUpdateOperationsInput | number
    minimumGradeToDismiss?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DisciplineUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    credits?: IntFieldUpdateOperationsInput | number
    minimumGradeToDismiss?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentSemesterPaymentCreateInput = {
    id?: string
    totalPayment: number
    baseAmount: number
    lateFee?: number
    paymentMonth: number
    paymentYear: number
    createdAt?: Date | string
    updatedAt?: Date | string
    payment: PaymentCreateNestedOneWithoutStudentSemesterPaymentInput
    student: StudentCreateNestedOneWithoutStudentSemesterPaymentsInput
    academicSemester: AcademicSemesterCreateNestedOneWithoutStudentSemesterPaymentsInput
  }

  export type StudentSemesterPaymentUncheckedCreateInput = {
    id?: string
    paymentId: string
    totalPayment: number
    baseAmount: number
    lateFee?: number
    paymentMonth: number
    paymentYear: number
    createdAt?: Date | string
    updatedAt?: Date | string
    studentId: string
    academicSemesterId: string
  }

  export type StudentSemesterPaymentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    totalPayment?: IntFieldUpdateOperationsInput | number
    baseAmount?: IntFieldUpdateOperationsInput | number
    lateFee?: IntFieldUpdateOperationsInput | number
    paymentMonth?: IntFieldUpdateOperationsInput | number
    paymentYear?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payment?: PaymentUpdateOneRequiredWithoutStudentSemesterPaymentNestedInput
    student?: StudentUpdateOneRequiredWithoutStudentSemesterPaymentsNestedInput
    academicSemester?: AcademicSemesterUpdateOneRequiredWithoutStudentSemesterPaymentsNestedInput
  }

  export type StudentSemesterPaymentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    paymentId?: StringFieldUpdateOperationsInput | string
    totalPayment?: IntFieldUpdateOperationsInput | number
    baseAmount?: IntFieldUpdateOperationsInput | number
    lateFee?: IntFieldUpdateOperationsInput | number
    paymentMonth?: IntFieldUpdateOperationsInput | number
    paymentYear?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    studentId?: StringFieldUpdateOperationsInput | string
    academicSemesterId?: StringFieldUpdateOperationsInput | string
  }

  export type StudentSemesterPaymentCreateManyInput = {
    id?: string
    paymentId: string
    totalPayment: number
    baseAmount: number
    lateFee?: number
    paymentMonth: number
    paymentYear: number
    createdAt?: Date | string
    updatedAt?: Date | string
    studentId: string
    academicSemesterId: string
  }

  export type StudentSemesterPaymentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    totalPayment?: IntFieldUpdateOperationsInput | number
    baseAmount?: IntFieldUpdateOperationsInput | number
    lateFee?: IntFieldUpdateOperationsInput | number
    paymentMonth?: IntFieldUpdateOperationsInput | number
    paymentYear?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentSemesterPaymentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    paymentId?: StringFieldUpdateOperationsInput | string
    totalPayment?: IntFieldUpdateOperationsInput | number
    baseAmount?: IntFieldUpdateOperationsInput | number
    lateFee?: IntFieldUpdateOperationsInput | number
    paymentMonth?: IntFieldUpdateOperationsInput | number
    paymentYear?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    studentId?: StringFieldUpdateOperationsInput | string
    academicSemesterId?: StringFieldUpdateOperationsInput | string
  }

  export type StudentAcademicInfoCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    totalCompletedCredits?: number | null
    cgpa?: number | null
    student: StudentCreateNestedOneWithoutStudentAcademicInfosInput
  }

  export type StudentAcademicInfoUncheckedCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    studentId: string
    totalCompletedCredits?: number | null
    cgpa?: number | null
  }

  export type StudentAcademicInfoUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    totalCompletedCredits?: NullableIntFieldUpdateOperationsInput | number | null
    cgpa?: NullableFloatFieldUpdateOperationsInput | number | null
    student?: StudentUpdateOneRequiredWithoutStudentAcademicInfosNestedInput
  }

  export type StudentAcademicInfoUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    studentId?: StringFieldUpdateOperationsInput | string
    totalCompletedCredits?: NullableIntFieldUpdateOperationsInput | number | null
    cgpa?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type StudentAcademicInfoCreateManyInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    studentId: string
    totalCompletedCredits?: number | null
    cgpa?: number | null
  }

  export type StudentAcademicInfoUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    totalCompletedCredits?: NullableIntFieldUpdateOperationsInput | number | null
    cgpa?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type StudentAcademicInfoUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    studentId?: StringFieldUpdateOperationsInput | string
    totalCompletedCredits?: NullableIntFieldUpdateOperationsInput | number | null
    cgpa?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type EventsCreateInput = {
    id?: string
    title: string
    description: string
    thumbnail: string
    color: string
    location: Date | string
    mandatory?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EventsUncheckedCreateInput = {
    id?: string
    title: string
    description: string
    thumbnail: string
    color: string
    location: Date | string
    mandatory?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EventsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    thumbnail?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    location?: DateTimeFieldUpdateOperationsInput | Date | string
    mandatory?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    thumbnail?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    location?: DateTimeFieldUpdateOperationsInput | Date | string
    mandatory?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventsCreateManyInput = {
    id?: string
    title: string
    description: string
    thumbnail: string
    color: string
    location: Date | string
    mandatory?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EventsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    thumbnail?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    location?: DateTimeFieldUpdateOperationsInput | Date | string
    mandatory?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    thumbnail?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    location?: DateTimeFieldUpdateOperationsInput | Date | string
    mandatory?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentCreateInput = {
    id?: string
    paymentRecipt?: string | null
    totalAmount?: number
    approved?: boolean
    paymentType?: $Enums.PAYMENTTYPE
    status?: $Enums.PAYMENTSTATUS
    method?: $Enums.PAYMENTMETHOD
    createdAt?: Date | string
    updatedAt?: Date | string
    StudentSemesterPayment?: StudentSemesterPaymentCreateNestedManyWithoutPaymentInput
    PaymentReference?: PaymentReferenceCreateNestedManyWithoutPaymentInput
  }

  export type PaymentUncheckedCreateInput = {
    id?: string
    paymentRecipt?: string | null
    totalAmount?: number
    approved?: boolean
    paymentType?: $Enums.PAYMENTTYPE
    status?: $Enums.PAYMENTSTATUS
    method?: $Enums.PAYMENTMETHOD
    createdAt?: Date | string
    updatedAt?: Date | string
    StudentSemesterPayment?: StudentSemesterPaymentUncheckedCreateNestedManyWithoutPaymentInput
    PaymentReference?: PaymentReferenceUncheckedCreateNestedManyWithoutPaymentInput
  }

  export type PaymentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    paymentRecipt?: NullableStringFieldUpdateOperationsInput | string | null
    totalAmount?: IntFieldUpdateOperationsInput | number
    approved?: BoolFieldUpdateOperationsInput | boolean
    paymentType?: EnumPAYMENTTYPEFieldUpdateOperationsInput | $Enums.PAYMENTTYPE
    status?: EnumPAYMENTSTATUSFieldUpdateOperationsInput | $Enums.PAYMENTSTATUS
    method?: EnumPAYMENTMETHODFieldUpdateOperationsInput | $Enums.PAYMENTMETHOD
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    StudentSemesterPayment?: StudentSemesterPaymentUpdateManyWithoutPaymentNestedInput
    PaymentReference?: PaymentReferenceUpdateManyWithoutPaymentNestedInput
  }

  export type PaymentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    paymentRecipt?: NullableStringFieldUpdateOperationsInput | string | null
    totalAmount?: IntFieldUpdateOperationsInput | number
    approved?: BoolFieldUpdateOperationsInput | boolean
    paymentType?: EnumPAYMENTTYPEFieldUpdateOperationsInput | $Enums.PAYMENTTYPE
    status?: EnumPAYMENTSTATUSFieldUpdateOperationsInput | $Enums.PAYMENTSTATUS
    method?: EnumPAYMENTMETHODFieldUpdateOperationsInput | $Enums.PAYMENTMETHOD
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    StudentSemesterPayment?: StudentSemesterPaymentUncheckedUpdateManyWithoutPaymentNestedInput
    PaymentReference?: PaymentReferenceUncheckedUpdateManyWithoutPaymentNestedInput
  }

  export type PaymentCreateManyInput = {
    id?: string
    paymentRecipt?: string | null
    totalAmount?: number
    approved?: boolean
    paymentType?: $Enums.PAYMENTTYPE
    status?: $Enums.PAYMENTSTATUS
    method?: $Enums.PAYMENTMETHOD
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    paymentRecipt?: NullableStringFieldUpdateOperationsInput | string | null
    totalAmount?: IntFieldUpdateOperationsInput | number
    approved?: BoolFieldUpdateOperationsInput | boolean
    paymentType?: EnumPAYMENTTYPEFieldUpdateOperationsInput | $Enums.PAYMENTTYPE
    status?: EnumPAYMENTSTATUSFieldUpdateOperationsInput | $Enums.PAYMENTSTATUS
    method?: EnumPAYMENTMETHODFieldUpdateOperationsInput | $Enums.PAYMENTMETHOD
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    paymentRecipt?: NullableStringFieldUpdateOperationsInput | string | null
    totalAmount?: IntFieldUpdateOperationsInput | number
    approved?: BoolFieldUpdateOperationsInput | boolean
    paymentType?: EnumPAYMENTTYPEFieldUpdateOperationsInput | $Enums.PAYMENTTYPE
    status?: EnumPAYMENTSTATUSFieldUpdateOperationsInput | $Enums.PAYMENTSTATUS
    method?: EnumPAYMENTMETHODFieldUpdateOperationsInput | $Enums.PAYMENTMETHOD
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentReferenceCreateInput = {
    id?: string
    reference: string
    code: number
    message: string
    createdAt?: Date | string
    updatedAt?: Date | string
    payment: PaymentCreateNestedOneWithoutPaymentReferenceInput
  }

  export type PaymentReferenceUncheckedCreateInput = {
    id?: string
    reference: string
    code: number
    message: string
    paymentId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentReferenceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    reference?: StringFieldUpdateOperationsInput | string
    code?: IntFieldUpdateOperationsInput | number
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payment?: PaymentUpdateOneRequiredWithoutPaymentReferenceNestedInput
  }

  export type PaymentReferenceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    reference?: StringFieldUpdateOperationsInput | string
    code?: IntFieldUpdateOperationsInput | number
    message?: StringFieldUpdateOperationsInput | string
    paymentId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentReferenceCreateManyInput = {
    id?: string
    reference: string
    code: number
    message: string
    paymentId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentReferenceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    reference?: StringFieldUpdateOperationsInput | string
    code?: IntFieldUpdateOperationsInput | number
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentReferenceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    reference?: StringFieldUpdateOperationsInput | string
    code?: IntFieldUpdateOperationsInput | number
    message?: StringFieldUpdateOperationsInput | string
    paymentId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type EnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[]
    notIn?: $Enums.UserRole[]
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type AcademicDepartmentNullableScalarRelationFilter = {
    is?: AcademicDepartmentWhereInput | null
    isNot?: AcademicDepartmentWhereInput | null
  }

  export type AcademicDepartmentListRelationFilter = {
    every?: AcademicDepartmentWhereInput
    some?: AcademicDepartmentWhereInput
    none?: AcademicDepartmentWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type AcademicDepartmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UsersOrderByRelevanceInput = {
    fields: UsersOrderByRelevanceFieldEnum | UsersOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type UsersCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    avatar?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UsersMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    avatar?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UsersMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    avatar?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type EnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[]
    notIn?: $Enums.UserRole[]
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type CourseDisciplineListRelationFilter = {
    every?: CourseDisciplineWhereInput
    some?: CourseDisciplineWhereInput
    none?: CourseDisciplineWhereInput
  }

  export type SemesterRegistrationListRelationFilter = {
    every?: SemesterRegistrationWhereInput
    some?: SemesterRegistrationWhereInput
    none?: SemesterRegistrationWhereInput
  }

  export type StudentListRelationFilter = {
    every?: StudentWhereInput
    some?: StudentWhereInput
    none?: StudentWhereInput
  }

  export type StudentEnrolledCourseListRelationFilter = {
    every?: StudentEnrolledCourseWhereInput
    some?: StudentEnrolledCourseWhereInput
    none?: StudentEnrolledCourseWhereInput
  }

  export type StudentEnrolledCourseMarkListRelationFilter = {
    every?: StudentEnrolledCourseMarkWhereInput
    some?: StudentEnrolledCourseMarkWhereInput
    none?: StudentEnrolledCourseMarkWhereInput
  }

  export type StudentSemesterPaymentListRelationFilter = {
    every?: StudentSemesterPaymentWhereInput
    some?: StudentSemesterPaymentWhereInput
    none?: StudentSemesterPaymentWhereInput
  }

  export type StudentCarriedCourseListRelationFilter = {
    every?: StudentCarriedCourseWhereInput
    some?: StudentCarriedCourseWhereInput
    none?: StudentCarriedCourseWhereInput
  }

  export type CourseDisciplineOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SemesterRegistrationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StudentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StudentEnrolledCourseOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StudentEnrolledCourseMarkOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StudentSemesterPaymentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StudentCarriedCourseOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AcademicSemesterOrderByRelevanceInput = {
    fields: AcademicSemesterOrderByRelevanceFieldEnum | AcademicSemesterOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type AcademicSemesterCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    year?: SortOrder
    code?: SortOrder
    startMonth?: SortOrder
    endMonth?: SortOrder
    isCurrent?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AcademicSemesterMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    year?: SortOrder
    code?: SortOrder
    startMonth?: SortOrder
    endMonth?: SortOrder
    isCurrent?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AcademicSemesterMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    year?: SortOrder
    code?: SortOrder
    startMonth?: SortOrder
    endMonth?: SortOrder
    isCurrent?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type FacultyListRelationFilter = {
    every?: FacultyWhereInput
    some?: FacultyWhereInput
    none?: FacultyWhereInput
  }

  export type AdmitionExameRegistrationListRelationFilter = {
    every?: AdmitionExameRegistrationWhereInput
    some?: AdmitionExameRegistrationWhereInput
    none?: AdmitionExameRegistrationWhereInput
  }

  export type AdmitionExamePriceListRelationFilter = {
    every?: AdmitionExamePriceWhereInput
    some?: AdmitionExamePriceWhereInput
    none?: AdmitionExamePriceWhereInput
  }

  export type AdmitionExamePeriodListRelationFilter = {
    every?: AdmitionExamePeriodWhereInput
    some?: AdmitionExamePeriodWhereInput
    none?: AdmitionExamePeriodWhereInput
  }

  export type FacultyOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AdmitionExameRegistrationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AdmitionExamePriceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AdmitionExamePeriodOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AcademicFacultyOrderByRelevanceInput = {
    fields: AcademicFacultyOrderByRelevanceFieldEnum | AcademicFacultyOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type AcademicFacultyCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AcademicFacultyMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AcademicFacultyMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AcademicFacultyScalarRelationFilter = {
    is?: AcademicFacultyWhereInput
    isNot?: AcademicFacultyWhereInput
  }

  export type CourseListRelationFilter = {
    every?: CourseWhereInput
    some?: CourseWhereInput
    none?: CourseWhereInput
  }

  export type UsersNullableScalarRelationFilter = {
    is?: UsersWhereInput | null
    isNot?: UsersWhereInput | null
  }

  export type UsersListRelationFilter = {
    every?: UsersWhereInput
    some?: UsersWhereInput
    none?: UsersWhereInput
  }

  export type OfferedCourseListRelationFilter = {
    every?: OfferedCourseWhereInput
    some?: OfferedCourseWhereInput
    none?: OfferedCourseWhereInput
  }

  export type CourseOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UsersOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OfferedCourseOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AcademicDepartmentOrderByRelevanceInput = {
    fields: AcademicDepartmentOrderByRelevanceFieldEnum | AcademicDepartmentOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type AcademicDepartmentCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    academicFacultyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    departmentHeadId?: SortOrder
  }

  export type AcademicDepartmentMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    academicFacultyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    departmentHeadId?: SortOrder
  }

  export type AcademicDepartmentMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    academicFacultyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    departmentHeadId?: SortOrder
  }

  export type EnumStudentTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.StudentType | EnumStudentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.StudentType[]
    notIn?: $Enums.StudentType[]
    not?: NestedEnumStudentTypeFilter<$PrismaModel> | $Enums.StudentType
  }

  export type EnumShiftFilter<$PrismaModel = never> = {
    equals?: $Enums.Shift | EnumShiftFieldRefInput<$PrismaModel>
    in?: $Enums.Shift[]
    notIn?: $Enums.Shift[]
    not?: NestedEnumShiftFilter<$PrismaModel> | $Enums.Shift
  }

  export type EnumYearLevelFilter<$PrismaModel = never> = {
    equals?: $Enums.YearLevel | EnumYearLevelFieldRefInput<$PrismaModel>
    in?: $Enums.YearLevel[]
    notIn?: $Enums.YearLevel[]
    not?: NestedEnumYearLevelFilter<$PrismaModel> | $Enums.YearLevel
  }

  export type AdmitionExameRegistrationNullableScalarRelationFilter = {
    is?: AdmitionExameRegistrationWhereInput | null
    isNot?: AdmitionExameRegistrationWhereInput | null
  }

  export type AcademicDepartmentScalarRelationFilter = {
    is?: AcademicDepartmentWhereInput
    isNot?: AcademicDepartmentWhereInput
  }

  export type AcademicSemesterScalarRelationFilter = {
    is?: AcademicSemesterWhereInput
    isNot?: AcademicSemesterWhereInput
  }

  export type StudentSemesterRegistrationListRelationFilter = {
    every?: StudentSemesterRegistrationWhereInput
    some?: StudentSemesterRegistrationWhereInput
    none?: StudentSemesterRegistrationWhereInput
  }

  export type StudentSemesterRegistrationCourseListRelationFilter = {
    every?: StudentSemesterRegistrationCourseWhereInput
    some?: StudentSemesterRegistrationCourseWhereInput
    none?: StudentSemesterRegistrationCourseWhereInput
  }

  export type StudentAcademicInfoListRelationFilter = {
    every?: StudentAcademicInfoWhereInput
    some?: StudentAcademicInfoWhereInput
    none?: StudentAcademicInfoWhereInput
  }

  export type StudentSemesterRegistrationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StudentSemesterRegistrationCourseOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StudentAcademicInfoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StudentOrderByRelevanceInput = {
    fields: StudentOrderByRelevanceFieldEnum | StudentOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type StudentCountOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    studentType?: SortOrder
    firstName?: SortOrder
    middleName?: SortOrder
    lastName?: SortOrder
    profileImage?: SortOrder
    email?: SortOrder
    contactNo?: SortOrder
    gender?: SortOrder
    isWoker?: SortOrder
    shift?: SortOrder
    yearLevel?: SortOrder
    isActive?: SortOrder
    password?: SortOrder
    gradeDeclarationFile?: SortOrder
    biFile?: SortOrder
    presentAddress?: SortOrder
    permanentAddress?: SortOrder
    academicSemesterId?: SortOrder
    academicFacultyId?: SortOrder
    academicDepartmentId?: SortOrder
    admissionRegistrationId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StudentMaxOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    studentType?: SortOrder
    firstName?: SortOrder
    middleName?: SortOrder
    lastName?: SortOrder
    profileImage?: SortOrder
    email?: SortOrder
    contactNo?: SortOrder
    gender?: SortOrder
    isWoker?: SortOrder
    shift?: SortOrder
    yearLevel?: SortOrder
    isActive?: SortOrder
    password?: SortOrder
    gradeDeclarationFile?: SortOrder
    biFile?: SortOrder
    presentAddress?: SortOrder
    permanentAddress?: SortOrder
    academicSemesterId?: SortOrder
    academicFacultyId?: SortOrder
    academicDepartmentId?: SortOrder
    admissionRegistrationId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StudentMinOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    studentType?: SortOrder
    firstName?: SortOrder
    middleName?: SortOrder
    lastName?: SortOrder
    profileImage?: SortOrder
    email?: SortOrder
    contactNo?: SortOrder
    gender?: SortOrder
    isWoker?: SortOrder
    shift?: SortOrder
    yearLevel?: SortOrder
    isActive?: SortOrder
    password?: SortOrder
    gradeDeclarationFile?: SortOrder
    biFile?: SortOrder
    presentAddress?: SortOrder
    permanentAddress?: SortOrder
    academicSemesterId?: SortOrder
    academicFacultyId?: SortOrder
    academicDepartmentId?: SortOrder
    admissionRegistrationId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumStudentTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.StudentType | EnumStudentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.StudentType[]
    notIn?: $Enums.StudentType[]
    not?: NestedEnumStudentTypeWithAggregatesFilter<$PrismaModel> | $Enums.StudentType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStudentTypeFilter<$PrismaModel>
    _max?: NestedEnumStudentTypeFilter<$PrismaModel>
  }

  export type EnumShiftWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Shift | EnumShiftFieldRefInput<$PrismaModel>
    in?: $Enums.Shift[]
    notIn?: $Enums.Shift[]
    not?: NestedEnumShiftWithAggregatesFilter<$PrismaModel> | $Enums.Shift
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumShiftFilter<$PrismaModel>
    _max?: NestedEnumShiftFilter<$PrismaModel>
  }

  export type EnumYearLevelWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.YearLevel | EnumYearLevelFieldRefInput<$PrismaModel>
    in?: $Enums.YearLevel[]
    notIn?: $Enums.YearLevel[]
    not?: NestedEnumYearLevelWithAggregatesFilter<$PrismaModel> | $Enums.YearLevel
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumYearLevelFilter<$PrismaModel>
    _max?: NestedEnumYearLevelFilter<$PrismaModel>
  }

  export type CourseFacultyListRelationFilter = {
    every?: CourseFacultyWhereInput
    some?: CourseFacultyWhereInput
    none?: CourseFacultyWhereInput
  }

  export type OfferedCourseClassScheduleListRelationFilter = {
    every?: OfferedCourseClassScheduleWhereInput
    some?: OfferedCourseClassScheduleWhereInput
    none?: OfferedCourseClassScheduleWhereInput
  }

  export type CourseFacultyOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OfferedCourseClassScheduleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FacultyOrderByRelevanceInput = {
    fields: FacultyOrderByRelevanceFieldEnum | FacultyOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type FacultyCountOrderByAggregateInput = {
    id?: SortOrder
    facultyId?: SortOrder
    firstName?: SortOrder
    middleName?: SortOrder
    lastName?: SortOrder
    profileImage?: SortOrder
    email?: SortOrder
    contactNo?: SortOrder
    shift?: SortOrder
    gender?: SortOrder
    designation?: SortOrder
    password?: SortOrder
    academicFacultyId?: SortOrder
    academicDepartmentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FacultyMaxOrderByAggregateInput = {
    id?: SortOrder
    facultyId?: SortOrder
    firstName?: SortOrder
    middleName?: SortOrder
    lastName?: SortOrder
    profileImage?: SortOrder
    email?: SortOrder
    contactNo?: SortOrder
    shift?: SortOrder
    gender?: SortOrder
    designation?: SortOrder
    password?: SortOrder
    academicFacultyId?: SortOrder
    academicDepartmentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FacultyMinOrderByAggregateInput = {
    id?: SortOrder
    facultyId?: SortOrder
    firstName?: SortOrder
    middleName?: SortOrder
    lastName?: SortOrder
    profileImage?: SortOrder
    email?: SortOrder
    contactNo?: SortOrder
    shift?: SortOrder
    gender?: SortOrder
    designation?: SortOrder
    password?: SortOrder
    academicFacultyId?: SortOrder
    academicDepartmentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RoomListRelationFilter = {
    every?: RoomWhereInput
    some?: RoomWhereInput
    none?: RoomWhereInput
  }

  export type RoomOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BuildingOrderByRelevanceInput = {
    fields: BuildingOrderByRelevanceFieldEnum | BuildingOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type BuildingCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BuildingMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BuildingMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BuildingScalarRelationFilter = {
    is?: BuildingWhereInput
    isNot?: BuildingWhereInput
  }

  export type RoomOrderByRelevanceInput = {
    fields: RoomOrderByRelevanceFieldEnum | RoomOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type RoomCountOrderByAggregateInput = {
    id?: SortOrder
    roomNumber?: SortOrder
    floor?: SortOrder
    buildingId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RoomMaxOrderByAggregateInput = {
    id?: SortOrder
    roomNumber?: SortOrder
    floor?: SortOrder
    buildingId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RoomMinOrderByAggregateInput = {
    id?: SortOrder
    roomNumber?: SortOrder
    floor?: SortOrder
    buildingId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type CoursePricingNullableScalarRelationFilter = {
    is?: CoursePricingWhereInput | null
    isNot?: CoursePricingWhereInput | null
  }

  export type CourseToPreRequisiteListRelationFilter = {
    every?: CourseToPreRequisiteWhereInput
    some?: CourseToPreRequisiteWhereInput
    none?: CourseToPreRequisiteWhereInput
  }

  export type CourseToPreRequisiteOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CourseOrderByRelevanceInput = {
    fields: CourseOrderByRelevanceFieldEnum | CourseOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type CourseCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    code?: SortOrder
    durationInYears?: SortOrder
    yearLevel?: SortOrder
    shift?: SortOrder
    academicDepartmentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CourseAvgOrderByAggregateInput = {
    durationInYears?: SortOrder
  }

  export type CourseMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    code?: SortOrder
    durationInYears?: SortOrder
    yearLevel?: SortOrder
    shift?: SortOrder
    academicDepartmentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CourseMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    code?: SortOrder
    durationInYears?: SortOrder
    yearLevel?: SortOrder
    shift?: SortOrder
    academicDepartmentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CourseSumOrderByAggregateInput = {
    durationInYears?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type CourseScalarRelationFilter = {
    is?: CourseWhereInput
    isNot?: CourseWhereInput
  }

  export type CourseToPreRequisiteOrderByRelevanceInput = {
    fields: CourseToPreRequisiteOrderByRelevanceFieldEnum | CourseToPreRequisiteOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type CourseToPreRequisiteCourseIdPreRequisiteIdCompoundUniqueInput = {
    courseId: string
    preRequisiteId: string
  }

  export type CourseToPreRequisiteCountOrderByAggregateInput = {
    courseId?: SortOrder
    preRequisiteId?: SortOrder
  }

  export type CourseToPreRequisiteMaxOrderByAggregateInput = {
    courseId?: SortOrder
    preRequisiteId?: SortOrder
  }

  export type CourseToPreRequisiteMinOrderByAggregateInput = {
    courseId?: SortOrder
    preRequisiteId?: SortOrder
  }

  export type FacultyScalarRelationFilter = {
    is?: FacultyWhereInput
    isNot?: FacultyWhereInput
  }

  export type CourseFacultyOrderByRelevanceInput = {
    fields: CourseFacultyOrderByRelevanceFieldEnum | CourseFacultyOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type CourseFacultyCourseIdFacultyIdCompoundUniqueInput = {
    courseId: string
    facultyId: string
  }

  export type CourseFacultyCountOrderByAggregateInput = {
    courseId?: SortOrder
    facultyId?: SortOrder
  }

  export type CourseFacultyMaxOrderByAggregateInput = {
    courseId?: SortOrder
    facultyId?: SortOrder
  }

  export type CourseFacultyMinOrderByAggregateInput = {
    courseId?: SortOrder
    facultyId?: SortOrder
  }

  export type EnumSemesterRegistrationStatusNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.SemesterRegistrationStatus | EnumSemesterRegistrationStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.SemesterRegistrationStatus[] | null
    notIn?: $Enums.SemesterRegistrationStatus[] | null
    not?: NestedEnumSemesterRegistrationStatusNullableFilter<$PrismaModel> | $Enums.SemesterRegistrationStatus | null
  }

  export type OfferedCourseSectionListRelationFilter = {
    every?: OfferedCourseSectionWhereInput
    some?: OfferedCourseSectionWhereInput
    none?: OfferedCourseSectionWhereInput
  }

  export type OfferedCourseSectionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SemesterRegistrationOrderByRelevanceInput = {
    fields: SemesterRegistrationOrderByRelevanceFieldEnum | SemesterRegistrationOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type SemesterRegistrationCountOrderByAggregateInput = {
    id?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updateAt?: SortOrder
    academicSemesterId?: SortOrder
  }

  export type SemesterRegistrationMaxOrderByAggregateInput = {
    id?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updateAt?: SortOrder
    academicSemesterId?: SortOrder
  }

  export type SemesterRegistrationMinOrderByAggregateInput = {
    id?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updateAt?: SortOrder
    academicSemesterId?: SortOrder
  }

  export type EnumSemesterRegistrationStatusNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SemesterRegistrationStatus | EnumSemesterRegistrationStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.SemesterRegistrationStatus[] | null
    notIn?: $Enums.SemesterRegistrationStatus[] | null
    not?: NestedEnumSemesterRegistrationStatusNullableWithAggregatesFilter<$PrismaModel> | $Enums.SemesterRegistrationStatus | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumSemesterRegistrationStatusNullableFilter<$PrismaModel>
    _max?: NestedEnumSemesterRegistrationStatusNullableFilter<$PrismaModel>
  }

  export type EnumStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.Status | EnumStatusFieldRefInput<$PrismaModel>
    in?: $Enums.Status[]
    notIn?: $Enums.Status[]
    not?: NestedEnumStatusFilter<$PrismaModel> | $Enums.Status
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type BoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type ExameFaseScalarRelationFilter = {
    is?: ExameFaseWhereInput
    isNot?: ExameFaseWhereInput
  }

  export type StudentNullableScalarRelationFilter = {
    is?: StudentWhereInput | null
    isNot?: StudentWhereInput | null
  }

  export type AdmitionExameRegistrationOrderByRelevanceInput = {
    fields: AdmitionExameRegistrationOrderByRelevanceFieldEnum | AdmitionExameRegistrationOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type AdmitionExameRegistrationCountOrderByAggregateInput = {
    id?: SortOrder
    applicantName?: SortOrder
    paymentRecipt?: SortOrder
    status?: SortOrder
    document?: SortOrder
    paymentAmoute?: SortOrder
    aprovePayment?: SortOrder
    exameResults?: SortOrder
    passed?: SortOrder
    faseId?: SortOrder
    exameDate?: SortOrder
    rejectionReason?: SortOrder
    phoneNumber?: SortOrder
    email?: SortOrder
    createdAt?: SortOrder
    updateAt?: SortOrder
    academicFalcultyId?: SortOrder
  }

  export type AdmitionExameRegistrationAvgOrderByAggregateInput = {
    paymentAmoute?: SortOrder
    exameResults?: SortOrder
  }

  export type AdmitionExameRegistrationMaxOrderByAggregateInput = {
    id?: SortOrder
    applicantName?: SortOrder
    paymentRecipt?: SortOrder
    status?: SortOrder
    document?: SortOrder
    paymentAmoute?: SortOrder
    aprovePayment?: SortOrder
    exameResults?: SortOrder
    passed?: SortOrder
    faseId?: SortOrder
    exameDate?: SortOrder
    rejectionReason?: SortOrder
    phoneNumber?: SortOrder
    email?: SortOrder
    createdAt?: SortOrder
    updateAt?: SortOrder
    academicFalcultyId?: SortOrder
  }

  export type AdmitionExameRegistrationMinOrderByAggregateInput = {
    id?: SortOrder
    applicantName?: SortOrder
    paymentRecipt?: SortOrder
    status?: SortOrder
    document?: SortOrder
    paymentAmoute?: SortOrder
    aprovePayment?: SortOrder
    exameResults?: SortOrder
    passed?: SortOrder
    faseId?: SortOrder
    exameDate?: SortOrder
    rejectionReason?: SortOrder
    phoneNumber?: SortOrder
    email?: SortOrder
    createdAt?: SortOrder
    updateAt?: SortOrder
    academicFalcultyId?: SortOrder
  }

  export type AdmitionExameRegistrationSumOrderByAggregateInput = {
    paymentAmoute?: SortOrder
    exameResults?: SortOrder
  }

  export type EnumStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Status | EnumStatusFieldRefInput<$PrismaModel>
    in?: $Enums.Status[]
    notIn?: $Enums.Status[]
    not?: NestedEnumStatusWithAggregatesFilter<$PrismaModel> | $Enums.Status
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStatusFilter<$PrismaModel>
    _max?: NestedEnumStatusFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type BoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type AdmitionExamePriceOrderByRelevanceInput = {
    fields: AdmitionExamePriceOrderByRelevanceFieldEnum | AdmitionExamePriceOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type AdmitionExamePriceCountOrderByAggregateInput = {
    id?: SortOrder
    academicFacultyId?: SortOrder
    price?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AdmitionExamePriceAvgOrderByAggregateInput = {
    price?: SortOrder
  }

  export type AdmitionExamePriceMaxOrderByAggregateInput = {
    id?: SortOrder
    academicFacultyId?: SortOrder
    price?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AdmitionExamePriceMinOrderByAggregateInput = {
    id?: SortOrder
    academicFacultyId?: SortOrder
    price?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AdmitionExamePriceSumOrderByAggregateInput = {
    price?: SortOrder
  }

  export type AdmitionExamePeriodOrderByRelevanceInput = {
    fields: AdmitionExamePeriodOrderByRelevanceFieldEnum | AdmitionExamePeriodOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type AdmitionExamePeriodCountOrderByAggregateInput = {
    id?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    academicFacultyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AdmitionExamePeriodMaxOrderByAggregateInput = {
    id?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    academicFacultyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AdmitionExamePeriodMinOrderByAggregateInput = {
    id?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    academicFacultyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ExameFaseOrderByRelevanceInput = {
    fields: ExameFaseOrderByRelevanceFieldEnum | ExameFaseOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ExameFaseCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    ordem?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ExameFaseAvgOrderByAggregateInput = {
    ordem?: SortOrder
  }

  export type ExameFaseMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    ordem?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ExameFaseMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    ordem?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ExameFaseSumOrderByAggregateInput = {
    ordem?: SortOrder
  }

  export type SemesterRegistrationScalarRelationFilter = {
    is?: SemesterRegistrationWhereInput
    isNot?: SemesterRegistrationWhereInput
  }

  export type OfferedCourseOrderByRelevanceInput = {
    fields: OfferedCourseOrderByRelevanceFieldEnum | OfferedCourseOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type OfferedCourseCountOrderByAggregateInput = {
    id?: SortOrder
    academicDepartmentId?: SortOrder
    courseId?: SortOrder
    semesterRegistrationId?: SortOrder
    suspendGrade?: SortOrder
  }

  export type OfferedCourseAvgOrderByAggregateInput = {
    suspendGrade?: SortOrder
  }

  export type OfferedCourseMaxOrderByAggregateInput = {
    id?: SortOrder
    academicDepartmentId?: SortOrder
    courseId?: SortOrder
    semesterRegistrationId?: SortOrder
    suspendGrade?: SortOrder
  }

  export type OfferedCourseMinOrderByAggregateInput = {
    id?: SortOrder
    academicDepartmentId?: SortOrder
    courseId?: SortOrder
    semesterRegistrationId?: SortOrder
    suspendGrade?: SortOrder
  }

  export type OfferedCourseSumOrderByAggregateInput = {
    suspendGrade?: SortOrder
  }

  export type OfferedCourseScalarRelationFilter = {
    is?: OfferedCourseWhereInput
    isNot?: OfferedCourseWhereInput
  }

  export type OfferedCourseSectionOrderByRelevanceInput = {
    fields: OfferedCourseSectionOrderByRelevanceFieldEnum | OfferedCourseSectionOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type OfferedCourseSectionCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    maxCapacity?: SortOrder
    currentlyEnrolledStudent?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    semesterRegistrationId?: SortOrder
    offeredCourseId?: SortOrder
  }

  export type OfferedCourseSectionAvgOrderByAggregateInput = {
    maxCapacity?: SortOrder
    currentlyEnrolledStudent?: SortOrder
  }

  export type OfferedCourseSectionMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    maxCapacity?: SortOrder
    currentlyEnrolledStudent?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    semesterRegistrationId?: SortOrder
    offeredCourseId?: SortOrder
  }

  export type OfferedCourseSectionMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    maxCapacity?: SortOrder
    currentlyEnrolledStudent?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    semesterRegistrationId?: SortOrder
    offeredCourseId?: SortOrder
  }

  export type OfferedCourseSectionSumOrderByAggregateInput = {
    maxCapacity?: SortOrder
    currentlyEnrolledStudent?: SortOrder
  }

  export type EnumWeekDaysFilter<$PrismaModel = never> = {
    equals?: $Enums.WeekDays | EnumWeekDaysFieldRefInput<$PrismaModel>
    in?: $Enums.WeekDays[]
    notIn?: $Enums.WeekDays[]
    not?: NestedEnumWeekDaysFilter<$PrismaModel> | $Enums.WeekDays
  }

  export type OfferedCourseSectionScalarRelationFilter = {
    is?: OfferedCourseSectionWhereInput
    isNot?: OfferedCourseSectionWhereInput
  }

  export type RoomScalarRelationFilter = {
    is?: RoomWhereInput
    isNot?: RoomWhereInput
  }

  export type OfferedCourseClassScheduleOrderByRelevanceInput = {
    fields: OfferedCourseClassScheduleOrderByRelevanceFieldEnum | OfferedCourseClassScheduleOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type OfferedCourseClassScheduleCountOrderByAggregateInput = {
    id?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    dayOfWeek?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    offeredCourseSectionId?: SortOrder
    semesterRegistrationId?: SortOrder
    roomId?: SortOrder
    facultyId?: SortOrder
  }

  export type OfferedCourseClassScheduleMaxOrderByAggregateInput = {
    id?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    dayOfWeek?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    offeredCourseSectionId?: SortOrder
    semesterRegistrationId?: SortOrder
    roomId?: SortOrder
    facultyId?: SortOrder
  }

  export type OfferedCourseClassScheduleMinOrderByAggregateInput = {
    id?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    dayOfWeek?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    offeredCourseSectionId?: SortOrder
    semesterRegistrationId?: SortOrder
    roomId?: SortOrder
    facultyId?: SortOrder
  }

  export type EnumWeekDaysWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.WeekDays | EnumWeekDaysFieldRefInput<$PrismaModel>
    in?: $Enums.WeekDays[]
    notIn?: $Enums.WeekDays[]
    not?: NestedEnumWeekDaysWithAggregatesFilter<$PrismaModel> | $Enums.WeekDays
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumWeekDaysFilter<$PrismaModel>
    _max?: NestedEnumWeekDaysFilter<$PrismaModel>
  }

  export type StudentScalarRelationFilter = {
    is?: StudentWhereInput
    isNot?: StudentWhereInput
  }

  export type StudentSemesterRegistrationOrderByRelevanceInput = {
    fields: StudentSemesterRegistrationOrderByRelevanceFieldEnum | StudentSemesterRegistrationOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type StudentSemesterRegistrationCountOrderByAggregateInput = {
    id?: SortOrder
    isConfirmed?: SortOrder
    totalCreditsTaken?: SortOrder
    paymentRecipt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    studentId?: SortOrder
    semesterRegistrationId?: SortOrder
  }

  export type StudentSemesterRegistrationAvgOrderByAggregateInput = {
    totalCreditsTaken?: SortOrder
  }

  export type StudentSemesterRegistrationMaxOrderByAggregateInput = {
    id?: SortOrder
    isConfirmed?: SortOrder
    totalCreditsTaken?: SortOrder
    paymentRecipt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    studentId?: SortOrder
    semesterRegistrationId?: SortOrder
  }

  export type StudentSemesterRegistrationMinOrderByAggregateInput = {
    id?: SortOrder
    isConfirmed?: SortOrder
    totalCreditsTaken?: SortOrder
    paymentRecipt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    studentId?: SortOrder
    semesterRegistrationId?: SortOrder
  }

  export type StudentSemesterRegistrationSumOrderByAggregateInput = {
    totalCreditsTaken?: SortOrder
  }

  export type StudentSemesterRegistrationCourseOrderByRelevanceInput = {
    fields: StudentSemesterRegistrationCourseOrderByRelevanceFieldEnum | StudentSemesterRegistrationCourseOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type StudentSemesterRegistrationCourseSemesterRegistrationIdStudentIdOfferedCourseIdCompoundUniqueInput = {
    semesterRegistrationId: string
    studentId: string
    offeredCourseId: string
  }

  export type StudentSemesterRegistrationCourseCountOrderByAggregateInput = {
    semesterRegistrationId?: SortOrder
    studentId?: SortOrder
    offeredCourseId?: SortOrder
    offeredCourseSectionId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StudentSemesterRegistrationCourseMaxOrderByAggregateInput = {
    semesterRegistrationId?: SortOrder
    studentId?: SortOrder
    offeredCourseId?: SortOrder
    offeredCourseSectionId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StudentSemesterRegistrationCourseMinOrderByAggregateInput = {
    semesterRegistrationId?: SortOrder
    studentId?: SortOrder
    offeredCourseId?: SortOrder
    offeredCourseSectionId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type EnumStudentEnrolledCourseStatusNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.StudentEnrolledCourseStatus | EnumStudentEnrolledCourseStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.StudentEnrolledCourseStatus[] | null
    notIn?: $Enums.StudentEnrolledCourseStatus[] | null
    not?: NestedEnumStudentEnrolledCourseStatusNullableFilter<$PrismaModel> | $Enums.StudentEnrolledCourseStatus | null
  }

  export type StudentEnrolledCourseOrderByRelevanceInput = {
    fields: StudentEnrolledCourseOrderByRelevanceFieldEnum | StudentEnrolledCourseOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type StudentEnrolledCourseCountOrderByAggregateInput = {
    id?: SortOrder
    grade?: SortOrder
    point?: SortOrder
    totalMarks?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    studentId?: SortOrder
    academicSemesterId?: SortOrder
    courseId?: SortOrder
  }

  export type StudentEnrolledCourseAvgOrderByAggregateInput = {
    point?: SortOrder
    totalMarks?: SortOrder
  }

  export type StudentEnrolledCourseMaxOrderByAggregateInput = {
    id?: SortOrder
    grade?: SortOrder
    point?: SortOrder
    totalMarks?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    studentId?: SortOrder
    academicSemesterId?: SortOrder
    courseId?: SortOrder
  }

  export type StudentEnrolledCourseMinOrderByAggregateInput = {
    id?: SortOrder
    grade?: SortOrder
    point?: SortOrder
    totalMarks?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    studentId?: SortOrder
    academicSemesterId?: SortOrder
    courseId?: SortOrder
  }

  export type StudentEnrolledCourseSumOrderByAggregateInput = {
    point?: SortOrder
    totalMarks?: SortOrder
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type EnumStudentEnrolledCourseStatusNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.StudentEnrolledCourseStatus | EnumStudentEnrolledCourseStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.StudentEnrolledCourseStatus[] | null
    notIn?: $Enums.StudentEnrolledCourseStatus[] | null
    not?: NestedEnumStudentEnrolledCourseStatusNullableWithAggregatesFilter<$PrismaModel> | $Enums.StudentEnrolledCourseStatus | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumStudentEnrolledCourseStatusNullableFilter<$PrismaModel>
    _max?: NestedEnumStudentEnrolledCourseStatusNullableFilter<$PrismaModel>
  }

  export type EnumExamTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.ExamType | EnumExamTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.ExamType[] | null
    notIn?: $Enums.ExamType[] | null
    not?: NestedEnumExamTypeNullableFilter<$PrismaModel> | $Enums.ExamType | null
  }
  export type JsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type StudentEnrolledCourseScalarRelationFilter = {
    is?: StudentEnrolledCourseWhereInput
    isNot?: StudentEnrolledCourseWhereInput
  }

  export type StudentEnrolledCourseMarkOrderByRelevanceInput = {
    fields: StudentEnrolledCourseMarkOrderByRelevanceFieldEnum | StudentEnrolledCourseMarkOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type StudentEnrolledCourseMarkCountOrderByAggregateInput = {
    id?: SortOrder
    examType?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    studentId?: SortOrder
    studentEnrolledCourseId?: SortOrder
    academicSemesterId?: SortOrder
    continuousAssessments?: SortOrder
    frequencyExam?: SortOrder
    finalExam?: SortOrder
    resourceExam?: SortOrder
    specialExam?: SortOrder
    recoveryExam?: SortOrder
    totalMarks?: SortOrder
    grade?: SortOrder
  }

  export type StudentEnrolledCourseMarkAvgOrderByAggregateInput = {
    frequencyExam?: SortOrder
    finalExam?: SortOrder
    resourceExam?: SortOrder
    specialExam?: SortOrder
    recoveryExam?: SortOrder
    totalMarks?: SortOrder
    grade?: SortOrder
  }

  export type StudentEnrolledCourseMarkMaxOrderByAggregateInput = {
    id?: SortOrder
    examType?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    studentId?: SortOrder
    studentEnrolledCourseId?: SortOrder
    academicSemesterId?: SortOrder
    frequencyExam?: SortOrder
    finalExam?: SortOrder
    resourceExam?: SortOrder
    specialExam?: SortOrder
    recoveryExam?: SortOrder
    totalMarks?: SortOrder
    grade?: SortOrder
  }

  export type StudentEnrolledCourseMarkMinOrderByAggregateInput = {
    id?: SortOrder
    examType?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    studentId?: SortOrder
    studentEnrolledCourseId?: SortOrder
    academicSemesterId?: SortOrder
    frequencyExam?: SortOrder
    finalExam?: SortOrder
    resourceExam?: SortOrder
    specialExam?: SortOrder
    recoveryExam?: SortOrder
    totalMarks?: SortOrder
    grade?: SortOrder
  }

  export type StudentEnrolledCourseMarkSumOrderByAggregateInput = {
    frequencyExam?: SortOrder
    finalExam?: SortOrder
    resourceExam?: SortOrder
    specialExam?: SortOrder
    recoveryExam?: SortOrder
    totalMarks?: SortOrder
    grade?: SortOrder
  }

  export type EnumExamTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ExamType | EnumExamTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.ExamType[] | null
    notIn?: $Enums.ExamType[] | null
    not?: NestedEnumExamTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.ExamType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumExamTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumExamTypeNullableFilter<$PrismaModel>
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type DisciplineScalarRelationFilter = {
    is?: DisciplineWhereInput
    isNot?: DisciplineWhereInput
  }

  export type CourseDisciplineOrderByRelevanceInput = {
    fields: CourseDisciplineOrderByRelevanceFieldEnum | CourseDisciplineOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type CourseDisciplineCourseIdDisciplineIdSemesterIdCompoundUniqueInput = {
    courseId: string
    disciplineId: string
    semesterId: string
  }

  export type CourseDisciplineCountOrderByAggregateInput = {
    id?: SortOrder
    courseId?: SortOrder
    disciplineId?: SortOrder
    semesterId?: SortOrder
    credits?: SortOrder
  }

  export type CourseDisciplineAvgOrderByAggregateInput = {
    credits?: SortOrder
  }

  export type CourseDisciplineMaxOrderByAggregateInput = {
    id?: SortOrder
    courseId?: SortOrder
    disciplineId?: SortOrder
    semesterId?: SortOrder
    credits?: SortOrder
  }

  export type CourseDisciplineMinOrderByAggregateInput = {
    id?: SortOrder
    courseId?: SortOrder
    disciplineId?: SortOrder
    semesterId?: SortOrder
    credits?: SortOrder
  }

  export type CourseDisciplineSumOrderByAggregateInput = {
    credits?: SortOrder
  }

  export type EnumCarriedCourseStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.CarriedCourseStatus | EnumCarriedCourseStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CarriedCourseStatus[]
    notIn?: $Enums.CarriedCourseStatus[]
    not?: NestedEnumCarriedCourseStatusFilter<$PrismaModel> | $Enums.CarriedCourseStatus
  }

  export type StudentCarriedCourseOrderByRelevanceInput = {
    fields: StudentCarriedCourseOrderByRelevanceFieldEnum | StudentCarriedCourseOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type StudentCarriedCourseCountOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    disciplineId?: SortOrder
    semesterId?: SortOrder
    shift?: SortOrder
    price?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
  }

  export type StudentCarriedCourseAvgOrderByAggregateInput = {
    price?: SortOrder
  }

  export type StudentCarriedCourseMaxOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    disciplineId?: SortOrder
    semesterId?: SortOrder
    shift?: SortOrder
    price?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
  }

  export type StudentCarriedCourseMinOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    disciplineId?: SortOrder
    semesterId?: SortOrder
    shift?: SortOrder
    price?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
  }

  export type StudentCarriedCourseSumOrderByAggregateInput = {
    price?: SortOrder
  }

  export type EnumCarriedCourseStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CarriedCourseStatus | EnumCarriedCourseStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CarriedCourseStatus[]
    notIn?: $Enums.CarriedCourseStatus[]
    not?: NestedEnumCarriedCourseStatusWithAggregatesFilter<$PrismaModel> | $Enums.CarriedCourseStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCarriedCourseStatusFilter<$PrismaModel>
    _max?: NestedEnumCarriedCourseStatusFilter<$PrismaModel>
  }

  export type CoursePricingOrderByRelevanceInput = {
    fields: CoursePricingOrderByRelevanceFieldEnum | CoursePricingOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type CoursePricingCountOrderByAggregateInput = {
    id?: SortOrder
    price?: SortOrder
    courseId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CoursePricingAvgOrderByAggregateInput = {
    price?: SortOrder
  }

  export type CoursePricingMaxOrderByAggregateInput = {
    id?: SortOrder
    price?: SortOrder
    courseId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CoursePricingMinOrderByAggregateInput = {
    id?: SortOrder
    price?: SortOrder
    courseId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CoursePricingSumOrderByAggregateInput = {
    price?: SortOrder
  }

  export type DisciplineOrderByRelevanceInput = {
    fields: DisciplineOrderByRelevanceFieldEnum | DisciplineOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type DisciplineCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    description?: SortOrder
    credits?: SortOrder
    minimumGradeToDismiss?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DisciplineAvgOrderByAggregateInput = {
    credits?: SortOrder
    minimumGradeToDismiss?: SortOrder
  }

  export type DisciplineMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    description?: SortOrder
    credits?: SortOrder
    minimumGradeToDismiss?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DisciplineMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    description?: SortOrder
    credits?: SortOrder
    minimumGradeToDismiss?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DisciplineSumOrderByAggregateInput = {
    credits?: SortOrder
    minimumGradeToDismiss?: SortOrder
  }

  export type PaymentScalarRelationFilter = {
    is?: PaymentWhereInput
    isNot?: PaymentWhereInput
  }

  export type StudentSemesterPaymentOrderByRelevanceInput = {
    fields: StudentSemesterPaymentOrderByRelevanceFieldEnum | StudentSemesterPaymentOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type StudentSemesterPaymentCountOrderByAggregateInput = {
    id?: SortOrder
    paymentId?: SortOrder
    totalPayment?: SortOrder
    baseAmount?: SortOrder
    lateFee?: SortOrder
    paymentMonth?: SortOrder
    paymentYear?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    studentId?: SortOrder
    academicSemesterId?: SortOrder
  }

  export type StudentSemesterPaymentAvgOrderByAggregateInput = {
    totalPayment?: SortOrder
    baseAmount?: SortOrder
    lateFee?: SortOrder
    paymentMonth?: SortOrder
    paymentYear?: SortOrder
  }

  export type StudentSemesterPaymentMaxOrderByAggregateInput = {
    id?: SortOrder
    paymentId?: SortOrder
    totalPayment?: SortOrder
    baseAmount?: SortOrder
    lateFee?: SortOrder
    paymentMonth?: SortOrder
    paymentYear?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    studentId?: SortOrder
    academicSemesterId?: SortOrder
  }

  export type StudentSemesterPaymentMinOrderByAggregateInput = {
    id?: SortOrder
    paymentId?: SortOrder
    totalPayment?: SortOrder
    baseAmount?: SortOrder
    lateFee?: SortOrder
    paymentMonth?: SortOrder
    paymentYear?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    studentId?: SortOrder
    academicSemesterId?: SortOrder
  }

  export type StudentSemesterPaymentSumOrderByAggregateInput = {
    totalPayment?: SortOrder
    baseAmount?: SortOrder
    lateFee?: SortOrder
    paymentMonth?: SortOrder
    paymentYear?: SortOrder
  }

  export type StudentAcademicInfoOrderByRelevanceInput = {
    fields: StudentAcademicInfoOrderByRelevanceFieldEnum | StudentAcademicInfoOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type StudentAcademicInfoCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    studentId?: SortOrder
    totalCompletedCredits?: SortOrder
    cgpa?: SortOrder
  }

  export type StudentAcademicInfoAvgOrderByAggregateInput = {
    totalCompletedCredits?: SortOrder
    cgpa?: SortOrder
  }

  export type StudentAcademicInfoMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    studentId?: SortOrder
    totalCompletedCredits?: SortOrder
    cgpa?: SortOrder
  }

  export type StudentAcademicInfoMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    studentId?: SortOrder
    totalCompletedCredits?: SortOrder
    cgpa?: SortOrder
  }

  export type StudentAcademicInfoSumOrderByAggregateInput = {
    totalCompletedCredits?: SortOrder
    cgpa?: SortOrder
  }

  export type EventsOrderByRelevanceInput = {
    fields: EventsOrderByRelevanceFieldEnum | EventsOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type EventsCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    thumbnail?: SortOrder
    color?: SortOrder
    location?: SortOrder
    mandatory?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EventsMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    thumbnail?: SortOrder
    color?: SortOrder
    location?: SortOrder
    mandatory?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EventsMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    thumbnail?: SortOrder
    color?: SortOrder
    location?: SortOrder
    mandatory?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumPAYMENTTYPEFilter<$PrismaModel = never> = {
    equals?: $Enums.PAYMENTTYPE | EnumPAYMENTTYPEFieldRefInput<$PrismaModel>
    in?: $Enums.PAYMENTTYPE[]
    notIn?: $Enums.PAYMENTTYPE[]
    not?: NestedEnumPAYMENTTYPEFilter<$PrismaModel> | $Enums.PAYMENTTYPE
  }

  export type EnumPAYMENTSTATUSFilter<$PrismaModel = never> = {
    equals?: $Enums.PAYMENTSTATUS | EnumPAYMENTSTATUSFieldRefInput<$PrismaModel>
    in?: $Enums.PAYMENTSTATUS[]
    notIn?: $Enums.PAYMENTSTATUS[]
    not?: NestedEnumPAYMENTSTATUSFilter<$PrismaModel> | $Enums.PAYMENTSTATUS
  }

  export type EnumPAYMENTMETHODFilter<$PrismaModel = never> = {
    equals?: $Enums.PAYMENTMETHOD | EnumPAYMENTMETHODFieldRefInput<$PrismaModel>
    in?: $Enums.PAYMENTMETHOD[]
    notIn?: $Enums.PAYMENTMETHOD[]
    not?: NestedEnumPAYMENTMETHODFilter<$PrismaModel> | $Enums.PAYMENTMETHOD
  }

  export type PaymentReferenceListRelationFilter = {
    every?: PaymentReferenceWhereInput
    some?: PaymentReferenceWhereInput
    none?: PaymentReferenceWhereInput
  }

  export type PaymentReferenceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PaymentOrderByRelevanceInput = {
    fields: PaymentOrderByRelevanceFieldEnum | PaymentOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type PaymentCountOrderByAggregateInput = {
    id?: SortOrder
    paymentRecipt?: SortOrder
    totalAmount?: SortOrder
    approved?: SortOrder
    paymentType?: SortOrder
    status?: SortOrder
    method?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentAvgOrderByAggregateInput = {
    totalAmount?: SortOrder
  }

  export type PaymentMaxOrderByAggregateInput = {
    id?: SortOrder
    paymentRecipt?: SortOrder
    totalAmount?: SortOrder
    approved?: SortOrder
    paymentType?: SortOrder
    status?: SortOrder
    method?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentMinOrderByAggregateInput = {
    id?: SortOrder
    paymentRecipt?: SortOrder
    totalAmount?: SortOrder
    approved?: SortOrder
    paymentType?: SortOrder
    status?: SortOrder
    method?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentSumOrderByAggregateInput = {
    totalAmount?: SortOrder
  }

  export type EnumPAYMENTTYPEWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PAYMENTTYPE | EnumPAYMENTTYPEFieldRefInput<$PrismaModel>
    in?: $Enums.PAYMENTTYPE[]
    notIn?: $Enums.PAYMENTTYPE[]
    not?: NestedEnumPAYMENTTYPEWithAggregatesFilter<$PrismaModel> | $Enums.PAYMENTTYPE
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPAYMENTTYPEFilter<$PrismaModel>
    _max?: NestedEnumPAYMENTTYPEFilter<$PrismaModel>
  }

  export type EnumPAYMENTSTATUSWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PAYMENTSTATUS | EnumPAYMENTSTATUSFieldRefInput<$PrismaModel>
    in?: $Enums.PAYMENTSTATUS[]
    notIn?: $Enums.PAYMENTSTATUS[]
    not?: NestedEnumPAYMENTSTATUSWithAggregatesFilter<$PrismaModel> | $Enums.PAYMENTSTATUS
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPAYMENTSTATUSFilter<$PrismaModel>
    _max?: NestedEnumPAYMENTSTATUSFilter<$PrismaModel>
  }

  export type EnumPAYMENTMETHODWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PAYMENTMETHOD | EnumPAYMENTMETHODFieldRefInput<$PrismaModel>
    in?: $Enums.PAYMENTMETHOD[]
    notIn?: $Enums.PAYMENTMETHOD[]
    not?: NestedEnumPAYMENTMETHODWithAggregatesFilter<$PrismaModel> | $Enums.PAYMENTMETHOD
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPAYMENTMETHODFilter<$PrismaModel>
    _max?: NestedEnumPAYMENTMETHODFilter<$PrismaModel>
  }

  export type PaymentReferenceOrderByRelevanceInput = {
    fields: PaymentReferenceOrderByRelevanceFieldEnum | PaymentReferenceOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type PaymentReferenceCountOrderByAggregateInput = {
    id?: SortOrder
    reference?: SortOrder
    code?: SortOrder
    message?: SortOrder
    paymentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentReferenceAvgOrderByAggregateInput = {
    code?: SortOrder
  }

  export type PaymentReferenceMaxOrderByAggregateInput = {
    id?: SortOrder
    reference?: SortOrder
    code?: SortOrder
    message?: SortOrder
    paymentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentReferenceMinOrderByAggregateInput = {
    id?: SortOrder
    reference?: SortOrder
    code?: SortOrder
    message?: SortOrder
    paymentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentReferenceSumOrderByAggregateInput = {
    code?: SortOrder
  }

  export type AcademicDepartmentCreateNestedOneWithoutDepartmentHeadInput = {
    create?: XOR<AcademicDepartmentCreateWithoutDepartmentHeadInput, AcademicDepartmentUncheckedCreateWithoutDepartmentHeadInput>
    connectOrCreate?: AcademicDepartmentCreateOrConnectWithoutDepartmentHeadInput
    connect?: AcademicDepartmentWhereUniqueInput
  }

  export type AcademicDepartmentCreateNestedManyWithoutStaffMembersInput = {
    create?: XOR<AcademicDepartmentCreateWithoutStaffMembersInput, AcademicDepartmentUncheckedCreateWithoutStaffMembersInput> | AcademicDepartmentCreateWithoutStaffMembersInput[] | AcademicDepartmentUncheckedCreateWithoutStaffMembersInput[]
    connectOrCreate?: AcademicDepartmentCreateOrConnectWithoutStaffMembersInput | AcademicDepartmentCreateOrConnectWithoutStaffMembersInput[]
    connect?: AcademicDepartmentWhereUniqueInput | AcademicDepartmentWhereUniqueInput[]
  }

  export type AcademicDepartmentUncheckedCreateNestedOneWithoutDepartmentHeadInput = {
    create?: XOR<AcademicDepartmentCreateWithoutDepartmentHeadInput, AcademicDepartmentUncheckedCreateWithoutDepartmentHeadInput>
    connectOrCreate?: AcademicDepartmentCreateOrConnectWithoutDepartmentHeadInput
    connect?: AcademicDepartmentWhereUniqueInput
  }

  export type AcademicDepartmentUncheckedCreateNestedManyWithoutStaffMembersInput = {
    create?: XOR<AcademicDepartmentCreateWithoutStaffMembersInput, AcademicDepartmentUncheckedCreateWithoutStaffMembersInput> | AcademicDepartmentCreateWithoutStaffMembersInput[] | AcademicDepartmentUncheckedCreateWithoutStaffMembersInput[]
    connectOrCreate?: AcademicDepartmentCreateOrConnectWithoutStaffMembersInput | AcademicDepartmentCreateOrConnectWithoutStaffMembersInput[]
    connect?: AcademicDepartmentWhereUniqueInput | AcademicDepartmentWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type EnumUserRoleFieldUpdateOperationsInput = {
    set?: $Enums.UserRole
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type AcademicDepartmentUpdateOneWithoutDepartmentHeadNestedInput = {
    create?: XOR<AcademicDepartmentCreateWithoutDepartmentHeadInput, AcademicDepartmentUncheckedCreateWithoutDepartmentHeadInput>
    connectOrCreate?: AcademicDepartmentCreateOrConnectWithoutDepartmentHeadInput
    upsert?: AcademicDepartmentUpsertWithoutDepartmentHeadInput
    disconnect?: AcademicDepartmentWhereInput | boolean
    delete?: AcademicDepartmentWhereInput | boolean
    connect?: AcademicDepartmentWhereUniqueInput
    update?: XOR<XOR<AcademicDepartmentUpdateToOneWithWhereWithoutDepartmentHeadInput, AcademicDepartmentUpdateWithoutDepartmentHeadInput>, AcademicDepartmentUncheckedUpdateWithoutDepartmentHeadInput>
  }

  export type AcademicDepartmentUpdateManyWithoutStaffMembersNestedInput = {
    create?: XOR<AcademicDepartmentCreateWithoutStaffMembersInput, AcademicDepartmentUncheckedCreateWithoutStaffMembersInput> | AcademicDepartmentCreateWithoutStaffMembersInput[] | AcademicDepartmentUncheckedCreateWithoutStaffMembersInput[]
    connectOrCreate?: AcademicDepartmentCreateOrConnectWithoutStaffMembersInput | AcademicDepartmentCreateOrConnectWithoutStaffMembersInput[]
    upsert?: AcademicDepartmentUpsertWithWhereUniqueWithoutStaffMembersInput | AcademicDepartmentUpsertWithWhereUniqueWithoutStaffMembersInput[]
    set?: AcademicDepartmentWhereUniqueInput | AcademicDepartmentWhereUniqueInput[]
    disconnect?: AcademicDepartmentWhereUniqueInput | AcademicDepartmentWhereUniqueInput[]
    delete?: AcademicDepartmentWhereUniqueInput | AcademicDepartmentWhereUniqueInput[]
    connect?: AcademicDepartmentWhereUniqueInput | AcademicDepartmentWhereUniqueInput[]
    update?: AcademicDepartmentUpdateWithWhereUniqueWithoutStaffMembersInput | AcademicDepartmentUpdateWithWhereUniqueWithoutStaffMembersInput[]
    updateMany?: AcademicDepartmentUpdateManyWithWhereWithoutStaffMembersInput | AcademicDepartmentUpdateManyWithWhereWithoutStaffMembersInput[]
    deleteMany?: AcademicDepartmentScalarWhereInput | AcademicDepartmentScalarWhereInput[]
  }

  export type AcademicDepartmentUncheckedUpdateOneWithoutDepartmentHeadNestedInput = {
    create?: XOR<AcademicDepartmentCreateWithoutDepartmentHeadInput, AcademicDepartmentUncheckedCreateWithoutDepartmentHeadInput>
    connectOrCreate?: AcademicDepartmentCreateOrConnectWithoutDepartmentHeadInput
    upsert?: AcademicDepartmentUpsertWithoutDepartmentHeadInput
    disconnect?: AcademicDepartmentWhereInput | boolean
    delete?: AcademicDepartmentWhereInput | boolean
    connect?: AcademicDepartmentWhereUniqueInput
    update?: XOR<XOR<AcademicDepartmentUpdateToOneWithWhereWithoutDepartmentHeadInput, AcademicDepartmentUpdateWithoutDepartmentHeadInput>, AcademicDepartmentUncheckedUpdateWithoutDepartmentHeadInput>
  }

  export type AcademicDepartmentUncheckedUpdateManyWithoutStaffMembersNestedInput = {
    create?: XOR<AcademicDepartmentCreateWithoutStaffMembersInput, AcademicDepartmentUncheckedCreateWithoutStaffMembersInput> | AcademicDepartmentCreateWithoutStaffMembersInput[] | AcademicDepartmentUncheckedCreateWithoutStaffMembersInput[]
    connectOrCreate?: AcademicDepartmentCreateOrConnectWithoutStaffMembersInput | AcademicDepartmentCreateOrConnectWithoutStaffMembersInput[]
    upsert?: AcademicDepartmentUpsertWithWhereUniqueWithoutStaffMembersInput | AcademicDepartmentUpsertWithWhereUniqueWithoutStaffMembersInput[]
    set?: AcademicDepartmentWhereUniqueInput | AcademicDepartmentWhereUniqueInput[]
    disconnect?: AcademicDepartmentWhereUniqueInput | AcademicDepartmentWhereUniqueInput[]
    delete?: AcademicDepartmentWhereUniqueInput | AcademicDepartmentWhereUniqueInput[]
    connect?: AcademicDepartmentWhereUniqueInput | AcademicDepartmentWhereUniqueInput[]
    update?: AcademicDepartmentUpdateWithWhereUniqueWithoutStaffMembersInput | AcademicDepartmentUpdateWithWhereUniqueWithoutStaffMembersInput[]
    updateMany?: AcademicDepartmentUpdateManyWithWhereWithoutStaffMembersInput | AcademicDepartmentUpdateManyWithWhereWithoutStaffMembersInput[]
    deleteMany?: AcademicDepartmentScalarWhereInput | AcademicDepartmentScalarWhereInput[]
  }

  export type CourseDisciplineCreateNestedManyWithoutSemesterInput = {
    create?: XOR<CourseDisciplineCreateWithoutSemesterInput, CourseDisciplineUncheckedCreateWithoutSemesterInput> | CourseDisciplineCreateWithoutSemesterInput[] | CourseDisciplineUncheckedCreateWithoutSemesterInput[]
    connectOrCreate?: CourseDisciplineCreateOrConnectWithoutSemesterInput | CourseDisciplineCreateOrConnectWithoutSemesterInput[]
    createMany?: CourseDisciplineCreateManySemesterInputEnvelope
    connect?: CourseDisciplineWhereUniqueInput | CourseDisciplineWhereUniqueInput[]
  }

  export type SemesterRegistrationCreateNestedManyWithoutAcademicSemesterInput = {
    create?: XOR<SemesterRegistrationCreateWithoutAcademicSemesterInput, SemesterRegistrationUncheckedCreateWithoutAcademicSemesterInput> | SemesterRegistrationCreateWithoutAcademicSemesterInput[] | SemesterRegistrationUncheckedCreateWithoutAcademicSemesterInput[]
    connectOrCreate?: SemesterRegistrationCreateOrConnectWithoutAcademicSemesterInput | SemesterRegistrationCreateOrConnectWithoutAcademicSemesterInput[]
    createMany?: SemesterRegistrationCreateManyAcademicSemesterInputEnvelope
    connect?: SemesterRegistrationWhereUniqueInput | SemesterRegistrationWhereUniqueInput[]
  }

  export type StudentCreateNestedManyWithoutAcademicSemesterInput = {
    create?: XOR<StudentCreateWithoutAcademicSemesterInput, StudentUncheckedCreateWithoutAcademicSemesterInput> | StudentCreateWithoutAcademicSemesterInput[] | StudentUncheckedCreateWithoutAcademicSemesterInput[]
    connectOrCreate?: StudentCreateOrConnectWithoutAcademicSemesterInput | StudentCreateOrConnectWithoutAcademicSemesterInput[]
    createMany?: StudentCreateManyAcademicSemesterInputEnvelope
    connect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
  }

  export type StudentEnrolledCourseCreateNestedManyWithoutAcademicSemesterInput = {
    create?: XOR<StudentEnrolledCourseCreateWithoutAcademicSemesterInput, StudentEnrolledCourseUncheckedCreateWithoutAcademicSemesterInput> | StudentEnrolledCourseCreateWithoutAcademicSemesterInput[] | StudentEnrolledCourseUncheckedCreateWithoutAcademicSemesterInput[]
    connectOrCreate?: StudentEnrolledCourseCreateOrConnectWithoutAcademicSemesterInput | StudentEnrolledCourseCreateOrConnectWithoutAcademicSemesterInput[]
    createMany?: StudentEnrolledCourseCreateManyAcademicSemesterInputEnvelope
    connect?: StudentEnrolledCourseWhereUniqueInput | StudentEnrolledCourseWhereUniqueInput[]
  }

  export type StudentEnrolledCourseMarkCreateNestedManyWithoutAcademicSemesterInput = {
    create?: XOR<StudentEnrolledCourseMarkCreateWithoutAcademicSemesterInput, StudentEnrolledCourseMarkUncheckedCreateWithoutAcademicSemesterInput> | StudentEnrolledCourseMarkCreateWithoutAcademicSemesterInput[] | StudentEnrolledCourseMarkUncheckedCreateWithoutAcademicSemesterInput[]
    connectOrCreate?: StudentEnrolledCourseMarkCreateOrConnectWithoutAcademicSemesterInput | StudentEnrolledCourseMarkCreateOrConnectWithoutAcademicSemesterInput[]
    createMany?: StudentEnrolledCourseMarkCreateManyAcademicSemesterInputEnvelope
    connect?: StudentEnrolledCourseMarkWhereUniqueInput | StudentEnrolledCourseMarkWhereUniqueInput[]
  }

  export type StudentSemesterPaymentCreateNestedManyWithoutAcademicSemesterInput = {
    create?: XOR<StudentSemesterPaymentCreateWithoutAcademicSemesterInput, StudentSemesterPaymentUncheckedCreateWithoutAcademicSemesterInput> | StudentSemesterPaymentCreateWithoutAcademicSemesterInput[] | StudentSemesterPaymentUncheckedCreateWithoutAcademicSemesterInput[]
    connectOrCreate?: StudentSemesterPaymentCreateOrConnectWithoutAcademicSemesterInput | StudentSemesterPaymentCreateOrConnectWithoutAcademicSemesterInput[]
    createMany?: StudentSemesterPaymentCreateManyAcademicSemesterInputEnvelope
    connect?: StudentSemesterPaymentWhereUniqueInput | StudentSemesterPaymentWhereUniqueInput[]
  }

  export type StudentCarriedCourseCreateNestedManyWithoutSemesterInput = {
    create?: XOR<StudentCarriedCourseCreateWithoutSemesterInput, StudentCarriedCourseUncheckedCreateWithoutSemesterInput> | StudentCarriedCourseCreateWithoutSemesterInput[] | StudentCarriedCourseUncheckedCreateWithoutSemesterInput[]
    connectOrCreate?: StudentCarriedCourseCreateOrConnectWithoutSemesterInput | StudentCarriedCourseCreateOrConnectWithoutSemesterInput[]
    createMany?: StudentCarriedCourseCreateManySemesterInputEnvelope
    connect?: StudentCarriedCourseWhereUniqueInput | StudentCarriedCourseWhereUniqueInput[]
  }

  export type CourseDisciplineUncheckedCreateNestedManyWithoutSemesterInput = {
    create?: XOR<CourseDisciplineCreateWithoutSemesterInput, CourseDisciplineUncheckedCreateWithoutSemesterInput> | CourseDisciplineCreateWithoutSemesterInput[] | CourseDisciplineUncheckedCreateWithoutSemesterInput[]
    connectOrCreate?: CourseDisciplineCreateOrConnectWithoutSemesterInput | CourseDisciplineCreateOrConnectWithoutSemesterInput[]
    createMany?: CourseDisciplineCreateManySemesterInputEnvelope
    connect?: CourseDisciplineWhereUniqueInput | CourseDisciplineWhereUniqueInput[]
  }

  export type SemesterRegistrationUncheckedCreateNestedManyWithoutAcademicSemesterInput = {
    create?: XOR<SemesterRegistrationCreateWithoutAcademicSemesterInput, SemesterRegistrationUncheckedCreateWithoutAcademicSemesterInput> | SemesterRegistrationCreateWithoutAcademicSemesterInput[] | SemesterRegistrationUncheckedCreateWithoutAcademicSemesterInput[]
    connectOrCreate?: SemesterRegistrationCreateOrConnectWithoutAcademicSemesterInput | SemesterRegistrationCreateOrConnectWithoutAcademicSemesterInput[]
    createMany?: SemesterRegistrationCreateManyAcademicSemesterInputEnvelope
    connect?: SemesterRegistrationWhereUniqueInput | SemesterRegistrationWhereUniqueInput[]
  }

  export type StudentUncheckedCreateNestedManyWithoutAcademicSemesterInput = {
    create?: XOR<StudentCreateWithoutAcademicSemesterInput, StudentUncheckedCreateWithoutAcademicSemesterInput> | StudentCreateWithoutAcademicSemesterInput[] | StudentUncheckedCreateWithoutAcademicSemesterInput[]
    connectOrCreate?: StudentCreateOrConnectWithoutAcademicSemesterInput | StudentCreateOrConnectWithoutAcademicSemesterInput[]
    createMany?: StudentCreateManyAcademicSemesterInputEnvelope
    connect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
  }

  export type StudentEnrolledCourseUncheckedCreateNestedManyWithoutAcademicSemesterInput = {
    create?: XOR<StudentEnrolledCourseCreateWithoutAcademicSemesterInput, StudentEnrolledCourseUncheckedCreateWithoutAcademicSemesterInput> | StudentEnrolledCourseCreateWithoutAcademicSemesterInput[] | StudentEnrolledCourseUncheckedCreateWithoutAcademicSemesterInput[]
    connectOrCreate?: StudentEnrolledCourseCreateOrConnectWithoutAcademicSemesterInput | StudentEnrolledCourseCreateOrConnectWithoutAcademicSemesterInput[]
    createMany?: StudentEnrolledCourseCreateManyAcademicSemesterInputEnvelope
    connect?: StudentEnrolledCourseWhereUniqueInput | StudentEnrolledCourseWhereUniqueInput[]
  }

  export type StudentEnrolledCourseMarkUncheckedCreateNestedManyWithoutAcademicSemesterInput = {
    create?: XOR<StudentEnrolledCourseMarkCreateWithoutAcademicSemesterInput, StudentEnrolledCourseMarkUncheckedCreateWithoutAcademicSemesterInput> | StudentEnrolledCourseMarkCreateWithoutAcademicSemesterInput[] | StudentEnrolledCourseMarkUncheckedCreateWithoutAcademicSemesterInput[]
    connectOrCreate?: StudentEnrolledCourseMarkCreateOrConnectWithoutAcademicSemesterInput | StudentEnrolledCourseMarkCreateOrConnectWithoutAcademicSemesterInput[]
    createMany?: StudentEnrolledCourseMarkCreateManyAcademicSemesterInputEnvelope
    connect?: StudentEnrolledCourseMarkWhereUniqueInput | StudentEnrolledCourseMarkWhereUniqueInput[]
  }

  export type StudentSemesterPaymentUncheckedCreateNestedManyWithoutAcademicSemesterInput = {
    create?: XOR<StudentSemesterPaymentCreateWithoutAcademicSemesterInput, StudentSemesterPaymentUncheckedCreateWithoutAcademicSemesterInput> | StudentSemesterPaymentCreateWithoutAcademicSemesterInput[] | StudentSemesterPaymentUncheckedCreateWithoutAcademicSemesterInput[]
    connectOrCreate?: StudentSemesterPaymentCreateOrConnectWithoutAcademicSemesterInput | StudentSemesterPaymentCreateOrConnectWithoutAcademicSemesterInput[]
    createMany?: StudentSemesterPaymentCreateManyAcademicSemesterInputEnvelope
    connect?: StudentSemesterPaymentWhereUniqueInput | StudentSemesterPaymentWhereUniqueInput[]
  }

  export type StudentCarriedCourseUncheckedCreateNestedManyWithoutSemesterInput = {
    create?: XOR<StudentCarriedCourseCreateWithoutSemesterInput, StudentCarriedCourseUncheckedCreateWithoutSemesterInput> | StudentCarriedCourseCreateWithoutSemesterInput[] | StudentCarriedCourseUncheckedCreateWithoutSemesterInput[]
    connectOrCreate?: StudentCarriedCourseCreateOrConnectWithoutSemesterInput | StudentCarriedCourseCreateOrConnectWithoutSemesterInput[]
    createMany?: StudentCarriedCourseCreateManySemesterInputEnvelope
    connect?: StudentCarriedCourseWhereUniqueInput | StudentCarriedCourseWhereUniqueInput[]
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type CourseDisciplineUpdateManyWithoutSemesterNestedInput = {
    create?: XOR<CourseDisciplineCreateWithoutSemesterInput, CourseDisciplineUncheckedCreateWithoutSemesterInput> | CourseDisciplineCreateWithoutSemesterInput[] | CourseDisciplineUncheckedCreateWithoutSemesterInput[]
    connectOrCreate?: CourseDisciplineCreateOrConnectWithoutSemesterInput | CourseDisciplineCreateOrConnectWithoutSemesterInput[]
    upsert?: CourseDisciplineUpsertWithWhereUniqueWithoutSemesterInput | CourseDisciplineUpsertWithWhereUniqueWithoutSemesterInput[]
    createMany?: CourseDisciplineCreateManySemesterInputEnvelope
    set?: CourseDisciplineWhereUniqueInput | CourseDisciplineWhereUniqueInput[]
    disconnect?: CourseDisciplineWhereUniqueInput | CourseDisciplineWhereUniqueInput[]
    delete?: CourseDisciplineWhereUniqueInput | CourseDisciplineWhereUniqueInput[]
    connect?: CourseDisciplineWhereUniqueInput | CourseDisciplineWhereUniqueInput[]
    update?: CourseDisciplineUpdateWithWhereUniqueWithoutSemesterInput | CourseDisciplineUpdateWithWhereUniqueWithoutSemesterInput[]
    updateMany?: CourseDisciplineUpdateManyWithWhereWithoutSemesterInput | CourseDisciplineUpdateManyWithWhereWithoutSemesterInput[]
    deleteMany?: CourseDisciplineScalarWhereInput | CourseDisciplineScalarWhereInput[]
  }

  export type SemesterRegistrationUpdateManyWithoutAcademicSemesterNestedInput = {
    create?: XOR<SemesterRegistrationCreateWithoutAcademicSemesterInput, SemesterRegistrationUncheckedCreateWithoutAcademicSemesterInput> | SemesterRegistrationCreateWithoutAcademicSemesterInput[] | SemesterRegistrationUncheckedCreateWithoutAcademicSemesterInput[]
    connectOrCreate?: SemesterRegistrationCreateOrConnectWithoutAcademicSemesterInput | SemesterRegistrationCreateOrConnectWithoutAcademicSemesterInput[]
    upsert?: SemesterRegistrationUpsertWithWhereUniqueWithoutAcademicSemesterInput | SemesterRegistrationUpsertWithWhereUniqueWithoutAcademicSemesterInput[]
    createMany?: SemesterRegistrationCreateManyAcademicSemesterInputEnvelope
    set?: SemesterRegistrationWhereUniqueInput | SemesterRegistrationWhereUniqueInput[]
    disconnect?: SemesterRegistrationWhereUniqueInput | SemesterRegistrationWhereUniqueInput[]
    delete?: SemesterRegistrationWhereUniqueInput | SemesterRegistrationWhereUniqueInput[]
    connect?: SemesterRegistrationWhereUniqueInput | SemesterRegistrationWhereUniqueInput[]
    update?: SemesterRegistrationUpdateWithWhereUniqueWithoutAcademicSemesterInput | SemesterRegistrationUpdateWithWhereUniqueWithoutAcademicSemesterInput[]
    updateMany?: SemesterRegistrationUpdateManyWithWhereWithoutAcademicSemesterInput | SemesterRegistrationUpdateManyWithWhereWithoutAcademicSemesterInput[]
    deleteMany?: SemesterRegistrationScalarWhereInput | SemesterRegistrationScalarWhereInput[]
  }

  export type StudentUpdateManyWithoutAcademicSemesterNestedInput = {
    create?: XOR<StudentCreateWithoutAcademicSemesterInput, StudentUncheckedCreateWithoutAcademicSemesterInput> | StudentCreateWithoutAcademicSemesterInput[] | StudentUncheckedCreateWithoutAcademicSemesterInput[]
    connectOrCreate?: StudentCreateOrConnectWithoutAcademicSemesterInput | StudentCreateOrConnectWithoutAcademicSemesterInput[]
    upsert?: StudentUpsertWithWhereUniqueWithoutAcademicSemesterInput | StudentUpsertWithWhereUniqueWithoutAcademicSemesterInput[]
    createMany?: StudentCreateManyAcademicSemesterInputEnvelope
    set?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    disconnect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    delete?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    connect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    update?: StudentUpdateWithWhereUniqueWithoutAcademicSemesterInput | StudentUpdateWithWhereUniqueWithoutAcademicSemesterInput[]
    updateMany?: StudentUpdateManyWithWhereWithoutAcademicSemesterInput | StudentUpdateManyWithWhereWithoutAcademicSemesterInput[]
    deleteMany?: StudentScalarWhereInput | StudentScalarWhereInput[]
  }

  export type StudentEnrolledCourseUpdateManyWithoutAcademicSemesterNestedInput = {
    create?: XOR<StudentEnrolledCourseCreateWithoutAcademicSemesterInput, StudentEnrolledCourseUncheckedCreateWithoutAcademicSemesterInput> | StudentEnrolledCourseCreateWithoutAcademicSemesterInput[] | StudentEnrolledCourseUncheckedCreateWithoutAcademicSemesterInput[]
    connectOrCreate?: StudentEnrolledCourseCreateOrConnectWithoutAcademicSemesterInput | StudentEnrolledCourseCreateOrConnectWithoutAcademicSemesterInput[]
    upsert?: StudentEnrolledCourseUpsertWithWhereUniqueWithoutAcademicSemesterInput | StudentEnrolledCourseUpsertWithWhereUniqueWithoutAcademicSemesterInput[]
    createMany?: StudentEnrolledCourseCreateManyAcademicSemesterInputEnvelope
    set?: StudentEnrolledCourseWhereUniqueInput | StudentEnrolledCourseWhereUniqueInput[]
    disconnect?: StudentEnrolledCourseWhereUniqueInput | StudentEnrolledCourseWhereUniqueInput[]
    delete?: StudentEnrolledCourseWhereUniqueInput | StudentEnrolledCourseWhereUniqueInput[]
    connect?: StudentEnrolledCourseWhereUniqueInput | StudentEnrolledCourseWhereUniqueInput[]
    update?: StudentEnrolledCourseUpdateWithWhereUniqueWithoutAcademicSemesterInput | StudentEnrolledCourseUpdateWithWhereUniqueWithoutAcademicSemesterInput[]
    updateMany?: StudentEnrolledCourseUpdateManyWithWhereWithoutAcademicSemesterInput | StudentEnrolledCourseUpdateManyWithWhereWithoutAcademicSemesterInput[]
    deleteMany?: StudentEnrolledCourseScalarWhereInput | StudentEnrolledCourseScalarWhereInput[]
  }

  export type StudentEnrolledCourseMarkUpdateManyWithoutAcademicSemesterNestedInput = {
    create?: XOR<StudentEnrolledCourseMarkCreateWithoutAcademicSemesterInput, StudentEnrolledCourseMarkUncheckedCreateWithoutAcademicSemesterInput> | StudentEnrolledCourseMarkCreateWithoutAcademicSemesterInput[] | StudentEnrolledCourseMarkUncheckedCreateWithoutAcademicSemesterInput[]
    connectOrCreate?: StudentEnrolledCourseMarkCreateOrConnectWithoutAcademicSemesterInput | StudentEnrolledCourseMarkCreateOrConnectWithoutAcademicSemesterInput[]
    upsert?: StudentEnrolledCourseMarkUpsertWithWhereUniqueWithoutAcademicSemesterInput | StudentEnrolledCourseMarkUpsertWithWhereUniqueWithoutAcademicSemesterInput[]
    createMany?: StudentEnrolledCourseMarkCreateManyAcademicSemesterInputEnvelope
    set?: StudentEnrolledCourseMarkWhereUniqueInput | StudentEnrolledCourseMarkWhereUniqueInput[]
    disconnect?: StudentEnrolledCourseMarkWhereUniqueInput | StudentEnrolledCourseMarkWhereUniqueInput[]
    delete?: StudentEnrolledCourseMarkWhereUniqueInput | StudentEnrolledCourseMarkWhereUniqueInput[]
    connect?: StudentEnrolledCourseMarkWhereUniqueInput | StudentEnrolledCourseMarkWhereUniqueInput[]
    update?: StudentEnrolledCourseMarkUpdateWithWhereUniqueWithoutAcademicSemesterInput | StudentEnrolledCourseMarkUpdateWithWhereUniqueWithoutAcademicSemesterInput[]
    updateMany?: StudentEnrolledCourseMarkUpdateManyWithWhereWithoutAcademicSemesterInput | StudentEnrolledCourseMarkUpdateManyWithWhereWithoutAcademicSemesterInput[]
    deleteMany?: StudentEnrolledCourseMarkScalarWhereInput | StudentEnrolledCourseMarkScalarWhereInput[]
  }

  export type StudentSemesterPaymentUpdateManyWithoutAcademicSemesterNestedInput = {
    create?: XOR<StudentSemesterPaymentCreateWithoutAcademicSemesterInput, StudentSemesterPaymentUncheckedCreateWithoutAcademicSemesterInput> | StudentSemesterPaymentCreateWithoutAcademicSemesterInput[] | StudentSemesterPaymentUncheckedCreateWithoutAcademicSemesterInput[]
    connectOrCreate?: StudentSemesterPaymentCreateOrConnectWithoutAcademicSemesterInput | StudentSemesterPaymentCreateOrConnectWithoutAcademicSemesterInput[]
    upsert?: StudentSemesterPaymentUpsertWithWhereUniqueWithoutAcademicSemesterInput | StudentSemesterPaymentUpsertWithWhereUniqueWithoutAcademicSemesterInput[]
    createMany?: StudentSemesterPaymentCreateManyAcademicSemesterInputEnvelope
    set?: StudentSemesterPaymentWhereUniqueInput | StudentSemesterPaymentWhereUniqueInput[]
    disconnect?: StudentSemesterPaymentWhereUniqueInput | StudentSemesterPaymentWhereUniqueInput[]
    delete?: StudentSemesterPaymentWhereUniqueInput | StudentSemesterPaymentWhereUniqueInput[]
    connect?: StudentSemesterPaymentWhereUniqueInput | StudentSemesterPaymentWhereUniqueInput[]
    update?: StudentSemesterPaymentUpdateWithWhereUniqueWithoutAcademicSemesterInput | StudentSemesterPaymentUpdateWithWhereUniqueWithoutAcademicSemesterInput[]
    updateMany?: StudentSemesterPaymentUpdateManyWithWhereWithoutAcademicSemesterInput | StudentSemesterPaymentUpdateManyWithWhereWithoutAcademicSemesterInput[]
    deleteMany?: StudentSemesterPaymentScalarWhereInput | StudentSemesterPaymentScalarWhereInput[]
  }

  export type StudentCarriedCourseUpdateManyWithoutSemesterNestedInput = {
    create?: XOR<StudentCarriedCourseCreateWithoutSemesterInput, StudentCarriedCourseUncheckedCreateWithoutSemesterInput> | StudentCarriedCourseCreateWithoutSemesterInput[] | StudentCarriedCourseUncheckedCreateWithoutSemesterInput[]
    connectOrCreate?: StudentCarriedCourseCreateOrConnectWithoutSemesterInput | StudentCarriedCourseCreateOrConnectWithoutSemesterInput[]
    upsert?: StudentCarriedCourseUpsertWithWhereUniqueWithoutSemesterInput | StudentCarriedCourseUpsertWithWhereUniqueWithoutSemesterInput[]
    createMany?: StudentCarriedCourseCreateManySemesterInputEnvelope
    set?: StudentCarriedCourseWhereUniqueInput | StudentCarriedCourseWhereUniqueInput[]
    disconnect?: StudentCarriedCourseWhereUniqueInput | StudentCarriedCourseWhereUniqueInput[]
    delete?: StudentCarriedCourseWhereUniqueInput | StudentCarriedCourseWhereUniqueInput[]
    connect?: StudentCarriedCourseWhereUniqueInput | StudentCarriedCourseWhereUniqueInput[]
    update?: StudentCarriedCourseUpdateWithWhereUniqueWithoutSemesterInput | StudentCarriedCourseUpdateWithWhereUniqueWithoutSemesterInput[]
    updateMany?: StudentCarriedCourseUpdateManyWithWhereWithoutSemesterInput | StudentCarriedCourseUpdateManyWithWhereWithoutSemesterInput[]
    deleteMany?: StudentCarriedCourseScalarWhereInput | StudentCarriedCourseScalarWhereInput[]
  }

  export type CourseDisciplineUncheckedUpdateManyWithoutSemesterNestedInput = {
    create?: XOR<CourseDisciplineCreateWithoutSemesterInput, CourseDisciplineUncheckedCreateWithoutSemesterInput> | CourseDisciplineCreateWithoutSemesterInput[] | CourseDisciplineUncheckedCreateWithoutSemesterInput[]
    connectOrCreate?: CourseDisciplineCreateOrConnectWithoutSemesterInput | CourseDisciplineCreateOrConnectWithoutSemesterInput[]
    upsert?: CourseDisciplineUpsertWithWhereUniqueWithoutSemesterInput | CourseDisciplineUpsertWithWhereUniqueWithoutSemesterInput[]
    createMany?: CourseDisciplineCreateManySemesterInputEnvelope
    set?: CourseDisciplineWhereUniqueInput | CourseDisciplineWhereUniqueInput[]
    disconnect?: CourseDisciplineWhereUniqueInput | CourseDisciplineWhereUniqueInput[]
    delete?: CourseDisciplineWhereUniqueInput | CourseDisciplineWhereUniqueInput[]
    connect?: CourseDisciplineWhereUniqueInput | CourseDisciplineWhereUniqueInput[]
    update?: CourseDisciplineUpdateWithWhereUniqueWithoutSemesterInput | CourseDisciplineUpdateWithWhereUniqueWithoutSemesterInput[]
    updateMany?: CourseDisciplineUpdateManyWithWhereWithoutSemesterInput | CourseDisciplineUpdateManyWithWhereWithoutSemesterInput[]
    deleteMany?: CourseDisciplineScalarWhereInput | CourseDisciplineScalarWhereInput[]
  }

  export type SemesterRegistrationUncheckedUpdateManyWithoutAcademicSemesterNestedInput = {
    create?: XOR<SemesterRegistrationCreateWithoutAcademicSemesterInput, SemesterRegistrationUncheckedCreateWithoutAcademicSemesterInput> | SemesterRegistrationCreateWithoutAcademicSemesterInput[] | SemesterRegistrationUncheckedCreateWithoutAcademicSemesterInput[]
    connectOrCreate?: SemesterRegistrationCreateOrConnectWithoutAcademicSemesterInput | SemesterRegistrationCreateOrConnectWithoutAcademicSemesterInput[]
    upsert?: SemesterRegistrationUpsertWithWhereUniqueWithoutAcademicSemesterInput | SemesterRegistrationUpsertWithWhereUniqueWithoutAcademicSemesterInput[]
    createMany?: SemesterRegistrationCreateManyAcademicSemesterInputEnvelope
    set?: SemesterRegistrationWhereUniqueInput | SemesterRegistrationWhereUniqueInput[]
    disconnect?: SemesterRegistrationWhereUniqueInput | SemesterRegistrationWhereUniqueInput[]
    delete?: SemesterRegistrationWhereUniqueInput | SemesterRegistrationWhereUniqueInput[]
    connect?: SemesterRegistrationWhereUniqueInput | SemesterRegistrationWhereUniqueInput[]
    update?: SemesterRegistrationUpdateWithWhereUniqueWithoutAcademicSemesterInput | SemesterRegistrationUpdateWithWhereUniqueWithoutAcademicSemesterInput[]
    updateMany?: SemesterRegistrationUpdateManyWithWhereWithoutAcademicSemesterInput | SemesterRegistrationUpdateManyWithWhereWithoutAcademicSemesterInput[]
    deleteMany?: SemesterRegistrationScalarWhereInput | SemesterRegistrationScalarWhereInput[]
  }

  export type StudentUncheckedUpdateManyWithoutAcademicSemesterNestedInput = {
    create?: XOR<StudentCreateWithoutAcademicSemesterInput, StudentUncheckedCreateWithoutAcademicSemesterInput> | StudentCreateWithoutAcademicSemesterInput[] | StudentUncheckedCreateWithoutAcademicSemesterInput[]
    connectOrCreate?: StudentCreateOrConnectWithoutAcademicSemesterInput | StudentCreateOrConnectWithoutAcademicSemesterInput[]
    upsert?: StudentUpsertWithWhereUniqueWithoutAcademicSemesterInput | StudentUpsertWithWhereUniqueWithoutAcademicSemesterInput[]
    createMany?: StudentCreateManyAcademicSemesterInputEnvelope
    set?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    disconnect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    delete?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    connect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    update?: StudentUpdateWithWhereUniqueWithoutAcademicSemesterInput | StudentUpdateWithWhereUniqueWithoutAcademicSemesterInput[]
    updateMany?: StudentUpdateManyWithWhereWithoutAcademicSemesterInput | StudentUpdateManyWithWhereWithoutAcademicSemesterInput[]
    deleteMany?: StudentScalarWhereInput | StudentScalarWhereInput[]
  }

  export type StudentEnrolledCourseUncheckedUpdateManyWithoutAcademicSemesterNestedInput = {
    create?: XOR<StudentEnrolledCourseCreateWithoutAcademicSemesterInput, StudentEnrolledCourseUncheckedCreateWithoutAcademicSemesterInput> | StudentEnrolledCourseCreateWithoutAcademicSemesterInput[] | StudentEnrolledCourseUncheckedCreateWithoutAcademicSemesterInput[]
    connectOrCreate?: StudentEnrolledCourseCreateOrConnectWithoutAcademicSemesterInput | StudentEnrolledCourseCreateOrConnectWithoutAcademicSemesterInput[]
    upsert?: StudentEnrolledCourseUpsertWithWhereUniqueWithoutAcademicSemesterInput | StudentEnrolledCourseUpsertWithWhereUniqueWithoutAcademicSemesterInput[]
    createMany?: StudentEnrolledCourseCreateManyAcademicSemesterInputEnvelope
    set?: StudentEnrolledCourseWhereUniqueInput | StudentEnrolledCourseWhereUniqueInput[]
    disconnect?: StudentEnrolledCourseWhereUniqueInput | StudentEnrolledCourseWhereUniqueInput[]
    delete?: StudentEnrolledCourseWhereUniqueInput | StudentEnrolledCourseWhereUniqueInput[]
    connect?: StudentEnrolledCourseWhereUniqueInput | StudentEnrolledCourseWhereUniqueInput[]
    update?: StudentEnrolledCourseUpdateWithWhereUniqueWithoutAcademicSemesterInput | StudentEnrolledCourseUpdateWithWhereUniqueWithoutAcademicSemesterInput[]
    updateMany?: StudentEnrolledCourseUpdateManyWithWhereWithoutAcademicSemesterInput | StudentEnrolledCourseUpdateManyWithWhereWithoutAcademicSemesterInput[]
    deleteMany?: StudentEnrolledCourseScalarWhereInput | StudentEnrolledCourseScalarWhereInput[]
  }

  export type StudentEnrolledCourseMarkUncheckedUpdateManyWithoutAcademicSemesterNestedInput = {
    create?: XOR<StudentEnrolledCourseMarkCreateWithoutAcademicSemesterInput, StudentEnrolledCourseMarkUncheckedCreateWithoutAcademicSemesterInput> | StudentEnrolledCourseMarkCreateWithoutAcademicSemesterInput[] | StudentEnrolledCourseMarkUncheckedCreateWithoutAcademicSemesterInput[]
    connectOrCreate?: StudentEnrolledCourseMarkCreateOrConnectWithoutAcademicSemesterInput | StudentEnrolledCourseMarkCreateOrConnectWithoutAcademicSemesterInput[]
    upsert?: StudentEnrolledCourseMarkUpsertWithWhereUniqueWithoutAcademicSemesterInput | StudentEnrolledCourseMarkUpsertWithWhereUniqueWithoutAcademicSemesterInput[]
    createMany?: StudentEnrolledCourseMarkCreateManyAcademicSemesterInputEnvelope
    set?: StudentEnrolledCourseMarkWhereUniqueInput | StudentEnrolledCourseMarkWhereUniqueInput[]
    disconnect?: StudentEnrolledCourseMarkWhereUniqueInput | StudentEnrolledCourseMarkWhereUniqueInput[]
    delete?: StudentEnrolledCourseMarkWhereUniqueInput | StudentEnrolledCourseMarkWhereUniqueInput[]
    connect?: StudentEnrolledCourseMarkWhereUniqueInput | StudentEnrolledCourseMarkWhereUniqueInput[]
    update?: StudentEnrolledCourseMarkUpdateWithWhereUniqueWithoutAcademicSemesterInput | StudentEnrolledCourseMarkUpdateWithWhereUniqueWithoutAcademicSemesterInput[]
    updateMany?: StudentEnrolledCourseMarkUpdateManyWithWhereWithoutAcademicSemesterInput | StudentEnrolledCourseMarkUpdateManyWithWhereWithoutAcademicSemesterInput[]
    deleteMany?: StudentEnrolledCourseMarkScalarWhereInput | StudentEnrolledCourseMarkScalarWhereInput[]
  }

  export type StudentSemesterPaymentUncheckedUpdateManyWithoutAcademicSemesterNestedInput = {
    create?: XOR<StudentSemesterPaymentCreateWithoutAcademicSemesterInput, StudentSemesterPaymentUncheckedCreateWithoutAcademicSemesterInput> | StudentSemesterPaymentCreateWithoutAcademicSemesterInput[] | StudentSemesterPaymentUncheckedCreateWithoutAcademicSemesterInput[]
    connectOrCreate?: StudentSemesterPaymentCreateOrConnectWithoutAcademicSemesterInput | StudentSemesterPaymentCreateOrConnectWithoutAcademicSemesterInput[]
    upsert?: StudentSemesterPaymentUpsertWithWhereUniqueWithoutAcademicSemesterInput | StudentSemesterPaymentUpsertWithWhereUniqueWithoutAcademicSemesterInput[]
    createMany?: StudentSemesterPaymentCreateManyAcademicSemesterInputEnvelope
    set?: StudentSemesterPaymentWhereUniqueInput | StudentSemesterPaymentWhereUniqueInput[]
    disconnect?: StudentSemesterPaymentWhereUniqueInput | StudentSemesterPaymentWhereUniqueInput[]
    delete?: StudentSemesterPaymentWhereUniqueInput | StudentSemesterPaymentWhereUniqueInput[]
    connect?: StudentSemesterPaymentWhereUniqueInput | StudentSemesterPaymentWhereUniqueInput[]
    update?: StudentSemesterPaymentUpdateWithWhereUniqueWithoutAcademicSemesterInput | StudentSemesterPaymentUpdateWithWhereUniqueWithoutAcademicSemesterInput[]
    updateMany?: StudentSemesterPaymentUpdateManyWithWhereWithoutAcademicSemesterInput | StudentSemesterPaymentUpdateManyWithWhereWithoutAcademicSemesterInput[]
    deleteMany?: StudentSemesterPaymentScalarWhereInput | StudentSemesterPaymentScalarWhereInput[]
  }

  export type StudentCarriedCourseUncheckedUpdateManyWithoutSemesterNestedInput = {
    create?: XOR<StudentCarriedCourseCreateWithoutSemesterInput, StudentCarriedCourseUncheckedCreateWithoutSemesterInput> | StudentCarriedCourseCreateWithoutSemesterInput[] | StudentCarriedCourseUncheckedCreateWithoutSemesterInput[]
    connectOrCreate?: StudentCarriedCourseCreateOrConnectWithoutSemesterInput | StudentCarriedCourseCreateOrConnectWithoutSemesterInput[]
    upsert?: StudentCarriedCourseUpsertWithWhereUniqueWithoutSemesterInput | StudentCarriedCourseUpsertWithWhereUniqueWithoutSemesterInput[]
    createMany?: StudentCarriedCourseCreateManySemesterInputEnvelope
    set?: StudentCarriedCourseWhereUniqueInput | StudentCarriedCourseWhereUniqueInput[]
    disconnect?: StudentCarriedCourseWhereUniqueInput | StudentCarriedCourseWhereUniqueInput[]
    delete?: StudentCarriedCourseWhereUniqueInput | StudentCarriedCourseWhereUniqueInput[]
    connect?: StudentCarriedCourseWhereUniqueInput | StudentCarriedCourseWhereUniqueInput[]
    update?: StudentCarriedCourseUpdateWithWhereUniqueWithoutSemesterInput | StudentCarriedCourseUpdateWithWhereUniqueWithoutSemesterInput[]
    updateMany?: StudentCarriedCourseUpdateManyWithWhereWithoutSemesterInput | StudentCarriedCourseUpdateManyWithWhereWithoutSemesterInput[]
    deleteMany?: StudentCarriedCourseScalarWhereInput | StudentCarriedCourseScalarWhereInput[]
  }

  export type AcademicDepartmentCreateNestedManyWithoutAcademicFacultyInput = {
    create?: XOR<AcademicDepartmentCreateWithoutAcademicFacultyInput, AcademicDepartmentUncheckedCreateWithoutAcademicFacultyInput> | AcademicDepartmentCreateWithoutAcademicFacultyInput[] | AcademicDepartmentUncheckedCreateWithoutAcademicFacultyInput[]
    connectOrCreate?: AcademicDepartmentCreateOrConnectWithoutAcademicFacultyInput | AcademicDepartmentCreateOrConnectWithoutAcademicFacultyInput[]
    createMany?: AcademicDepartmentCreateManyAcademicFacultyInputEnvelope
    connect?: AcademicDepartmentWhereUniqueInput | AcademicDepartmentWhereUniqueInput[]
  }

  export type FacultyCreateNestedManyWithoutAcademicFacultyInput = {
    create?: XOR<FacultyCreateWithoutAcademicFacultyInput, FacultyUncheckedCreateWithoutAcademicFacultyInput> | FacultyCreateWithoutAcademicFacultyInput[] | FacultyUncheckedCreateWithoutAcademicFacultyInput[]
    connectOrCreate?: FacultyCreateOrConnectWithoutAcademicFacultyInput | FacultyCreateOrConnectWithoutAcademicFacultyInput[]
    createMany?: FacultyCreateManyAcademicFacultyInputEnvelope
    connect?: FacultyWhereUniqueInput | FacultyWhereUniqueInput[]
  }

  export type StudentCreateNestedManyWithoutAcademicFacultyInput = {
    create?: XOR<StudentCreateWithoutAcademicFacultyInput, StudentUncheckedCreateWithoutAcademicFacultyInput> | StudentCreateWithoutAcademicFacultyInput[] | StudentUncheckedCreateWithoutAcademicFacultyInput[]
    connectOrCreate?: StudentCreateOrConnectWithoutAcademicFacultyInput | StudentCreateOrConnectWithoutAcademicFacultyInput[]
    createMany?: StudentCreateManyAcademicFacultyInputEnvelope
    connect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
  }

  export type AdmitionExameRegistrationCreateNestedManyWithoutAcademicFalcultyInput = {
    create?: XOR<AdmitionExameRegistrationCreateWithoutAcademicFalcultyInput, AdmitionExameRegistrationUncheckedCreateWithoutAcademicFalcultyInput> | AdmitionExameRegistrationCreateWithoutAcademicFalcultyInput[] | AdmitionExameRegistrationUncheckedCreateWithoutAcademicFalcultyInput[]
    connectOrCreate?: AdmitionExameRegistrationCreateOrConnectWithoutAcademicFalcultyInput | AdmitionExameRegistrationCreateOrConnectWithoutAcademicFalcultyInput[]
    createMany?: AdmitionExameRegistrationCreateManyAcademicFalcultyInputEnvelope
    connect?: AdmitionExameRegistrationWhereUniqueInput | AdmitionExameRegistrationWhereUniqueInput[]
  }

  export type AdmitionExamePriceCreateNestedManyWithoutAcademicFacultyInput = {
    create?: XOR<AdmitionExamePriceCreateWithoutAcademicFacultyInput, AdmitionExamePriceUncheckedCreateWithoutAcademicFacultyInput> | AdmitionExamePriceCreateWithoutAcademicFacultyInput[] | AdmitionExamePriceUncheckedCreateWithoutAcademicFacultyInput[]
    connectOrCreate?: AdmitionExamePriceCreateOrConnectWithoutAcademicFacultyInput | AdmitionExamePriceCreateOrConnectWithoutAcademicFacultyInput[]
    createMany?: AdmitionExamePriceCreateManyAcademicFacultyInputEnvelope
    connect?: AdmitionExamePriceWhereUniqueInput | AdmitionExamePriceWhereUniqueInput[]
  }

  export type AdmitionExamePeriodCreateNestedManyWithoutAcademicFacultyInput = {
    create?: XOR<AdmitionExamePeriodCreateWithoutAcademicFacultyInput, AdmitionExamePeriodUncheckedCreateWithoutAcademicFacultyInput> | AdmitionExamePeriodCreateWithoutAcademicFacultyInput[] | AdmitionExamePeriodUncheckedCreateWithoutAcademicFacultyInput[]
    connectOrCreate?: AdmitionExamePeriodCreateOrConnectWithoutAcademicFacultyInput | AdmitionExamePeriodCreateOrConnectWithoutAcademicFacultyInput[]
    createMany?: AdmitionExamePeriodCreateManyAcademicFacultyInputEnvelope
    connect?: AdmitionExamePeriodWhereUniqueInput | AdmitionExamePeriodWhereUniqueInput[]
  }

  export type AcademicDepartmentUncheckedCreateNestedManyWithoutAcademicFacultyInput = {
    create?: XOR<AcademicDepartmentCreateWithoutAcademicFacultyInput, AcademicDepartmentUncheckedCreateWithoutAcademicFacultyInput> | AcademicDepartmentCreateWithoutAcademicFacultyInput[] | AcademicDepartmentUncheckedCreateWithoutAcademicFacultyInput[]
    connectOrCreate?: AcademicDepartmentCreateOrConnectWithoutAcademicFacultyInput | AcademicDepartmentCreateOrConnectWithoutAcademicFacultyInput[]
    createMany?: AcademicDepartmentCreateManyAcademicFacultyInputEnvelope
    connect?: AcademicDepartmentWhereUniqueInput | AcademicDepartmentWhereUniqueInput[]
  }

  export type FacultyUncheckedCreateNestedManyWithoutAcademicFacultyInput = {
    create?: XOR<FacultyCreateWithoutAcademicFacultyInput, FacultyUncheckedCreateWithoutAcademicFacultyInput> | FacultyCreateWithoutAcademicFacultyInput[] | FacultyUncheckedCreateWithoutAcademicFacultyInput[]
    connectOrCreate?: FacultyCreateOrConnectWithoutAcademicFacultyInput | FacultyCreateOrConnectWithoutAcademicFacultyInput[]
    createMany?: FacultyCreateManyAcademicFacultyInputEnvelope
    connect?: FacultyWhereUniqueInput | FacultyWhereUniqueInput[]
  }

  export type StudentUncheckedCreateNestedManyWithoutAcademicFacultyInput = {
    create?: XOR<StudentCreateWithoutAcademicFacultyInput, StudentUncheckedCreateWithoutAcademicFacultyInput> | StudentCreateWithoutAcademicFacultyInput[] | StudentUncheckedCreateWithoutAcademicFacultyInput[]
    connectOrCreate?: StudentCreateOrConnectWithoutAcademicFacultyInput | StudentCreateOrConnectWithoutAcademicFacultyInput[]
    createMany?: StudentCreateManyAcademicFacultyInputEnvelope
    connect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
  }

  export type AdmitionExameRegistrationUncheckedCreateNestedManyWithoutAcademicFalcultyInput = {
    create?: XOR<AdmitionExameRegistrationCreateWithoutAcademicFalcultyInput, AdmitionExameRegistrationUncheckedCreateWithoutAcademicFalcultyInput> | AdmitionExameRegistrationCreateWithoutAcademicFalcultyInput[] | AdmitionExameRegistrationUncheckedCreateWithoutAcademicFalcultyInput[]
    connectOrCreate?: AdmitionExameRegistrationCreateOrConnectWithoutAcademicFalcultyInput | AdmitionExameRegistrationCreateOrConnectWithoutAcademicFalcultyInput[]
    createMany?: AdmitionExameRegistrationCreateManyAcademicFalcultyInputEnvelope
    connect?: AdmitionExameRegistrationWhereUniqueInput | AdmitionExameRegistrationWhereUniqueInput[]
  }

  export type AdmitionExamePriceUncheckedCreateNestedManyWithoutAcademicFacultyInput = {
    create?: XOR<AdmitionExamePriceCreateWithoutAcademicFacultyInput, AdmitionExamePriceUncheckedCreateWithoutAcademicFacultyInput> | AdmitionExamePriceCreateWithoutAcademicFacultyInput[] | AdmitionExamePriceUncheckedCreateWithoutAcademicFacultyInput[]
    connectOrCreate?: AdmitionExamePriceCreateOrConnectWithoutAcademicFacultyInput | AdmitionExamePriceCreateOrConnectWithoutAcademicFacultyInput[]
    createMany?: AdmitionExamePriceCreateManyAcademicFacultyInputEnvelope
    connect?: AdmitionExamePriceWhereUniqueInput | AdmitionExamePriceWhereUniqueInput[]
  }

  export type AdmitionExamePeriodUncheckedCreateNestedManyWithoutAcademicFacultyInput = {
    create?: XOR<AdmitionExamePeriodCreateWithoutAcademicFacultyInput, AdmitionExamePeriodUncheckedCreateWithoutAcademicFacultyInput> | AdmitionExamePeriodCreateWithoutAcademicFacultyInput[] | AdmitionExamePeriodUncheckedCreateWithoutAcademicFacultyInput[]
    connectOrCreate?: AdmitionExamePeriodCreateOrConnectWithoutAcademicFacultyInput | AdmitionExamePeriodCreateOrConnectWithoutAcademicFacultyInput[]
    createMany?: AdmitionExamePeriodCreateManyAcademicFacultyInputEnvelope
    connect?: AdmitionExamePeriodWhereUniqueInput | AdmitionExamePeriodWhereUniqueInput[]
  }

  export type AcademicDepartmentUpdateManyWithoutAcademicFacultyNestedInput = {
    create?: XOR<AcademicDepartmentCreateWithoutAcademicFacultyInput, AcademicDepartmentUncheckedCreateWithoutAcademicFacultyInput> | AcademicDepartmentCreateWithoutAcademicFacultyInput[] | AcademicDepartmentUncheckedCreateWithoutAcademicFacultyInput[]
    connectOrCreate?: AcademicDepartmentCreateOrConnectWithoutAcademicFacultyInput | AcademicDepartmentCreateOrConnectWithoutAcademicFacultyInput[]
    upsert?: AcademicDepartmentUpsertWithWhereUniqueWithoutAcademicFacultyInput | AcademicDepartmentUpsertWithWhereUniqueWithoutAcademicFacultyInput[]
    createMany?: AcademicDepartmentCreateManyAcademicFacultyInputEnvelope
    set?: AcademicDepartmentWhereUniqueInput | AcademicDepartmentWhereUniqueInput[]
    disconnect?: AcademicDepartmentWhereUniqueInput | AcademicDepartmentWhereUniqueInput[]
    delete?: AcademicDepartmentWhereUniqueInput | AcademicDepartmentWhereUniqueInput[]
    connect?: AcademicDepartmentWhereUniqueInput | AcademicDepartmentWhereUniqueInput[]
    update?: AcademicDepartmentUpdateWithWhereUniqueWithoutAcademicFacultyInput | AcademicDepartmentUpdateWithWhereUniqueWithoutAcademicFacultyInput[]
    updateMany?: AcademicDepartmentUpdateManyWithWhereWithoutAcademicFacultyInput | AcademicDepartmentUpdateManyWithWhereWithoutAcademicFacultyInput[]
    deleteMany?: AcademicDepartmentScalarWhereInput | AcademicDepartmentScalarWhereInput[]
  }

  export type FacultyUpdateManyWithoutAcademicFacultyNestedInput = {
    create?: XOR<FacultyCreateWithoutAcademicFacultyInput, FacultyUncheckedCreateWithoutAcademicFacultyInput> | FacultyCreateWithoutAcademicFacultyInput[] | FacultyUncheckedCreateWithoutAcademicFacultyInput[]
    connectOrCreate?: FacultyCreateOrConnectWithoutAcademicFacultyInput | FacultyCreateOrConnectWithoutAcademicFacultyInput[]
    upsert?: FacultyUpsertWithWhereUniqueWithoutAcademicFacultyInput | FacultyUpsertWithWhereUniqueWithoutAcademicFacultyInput[]
    createMany?: FacultyCreateManyAcademicFacultyInputEnvelope
    set?: FacultyWhereUniqueInput | FacultyWhereUniqueInput[]
    disconnect?: FacultyWhereUniqueInput | FacultyWhereUniqueInput[]
    delete?: FacultyWhereUniqueInput | FacultyWhereUniqueInput[]
    connect?: FacultyWhereUniqueInput | FacultyWhereUniqueInput[]
    update?: FacultyUpdateWithWhereUniqueWithoutAcademicFacultyInput | FacultyUpdateWithWhereUniqueWithoutAcademicFacultyInput[]
    updateMany?: FacultyUpdateManyWithWhereWithoutAcademicFacultyInput | FacultyUpdateManyWithWhereWithoutAcademicFacultyInput[]
    deleteMany?: FacultyScalarWhereInput | FacultyScalarWhereInput[]
  }

  export type StudentUpdateManyWithoutAcademicFacultyNestedInput = {
    create?: XOR<StudentCreateWithoutAcademicFacultyInput, StudentUncheckedCreateWithoutAcademicFacultyInput> | StudentCreateWithoutAcademicFacultyInput[] | StudentUncheckedCreateWithoutAcademicFacultyInput[]
    connectOrCreate?: StudentCreateOrConnectWithoutAcademicFacultyInput | StudentCreateOrConnectWithoutAcademicFacultyInput[]
    upsert?: StudentUpsertWithWhereUniqueWithoutAcademicFacultyInput | StudentUpsertWithWhereUniqueWithoutAcademicFacultyInput[]
    createMany?: StudentCreateManyAcademicFacultyInputEnvelope
    set?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    disconnect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    delete?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    connect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    update?: StudentUpdateWithWhereUniqueWithoutAcademicFacultyInput | StudentUpdateWithWhereUniqueWithoutAcademicFacultyInput[]
    updateMany?: StudentUpdateManyWithWhereWithoutAcademicFacultyInput | StudentUpdateManyWithWhereWithoutAcademicFacultyInput[]
    deleteMany?: StudentScalarWhereInput | StudentScalarWhereInput[]
  }

  export type AdmitionExameRegistrationUpdateManyWithoutAcademicFalcultyNestedInput = {
    create?: XOR<AdmitionExameRegistrationCreateWithoutAcademicFalcultyInput, AdmitionExameRegistrationUncheckedCreateWithoutAcademicFalcultyInput> | AdmitionExameRegistrationCreateWithoutAcademicFalcultyInput[] | AdmitionExameRegistrationUncheckedCreateWithoutAcademicFalcultyInput[]
    connectOrCreate?: AdmitionExameRegistrationCreateOrConnectWithoutAcademicFalcultyInput | AdmitionExameRegistrationCreateOrConnectWithoutAcademicFalcultyInput[]
    upsert?: AdmitionExameRegistrationUpsertWithWhereUniqueWithoutAcademicFalcultyInput | AdmitionExameRegistrationUpsertWithWhereUniqueWithoutAcademicFalcultyInput[]
    createMany?: AdmitionExameRegistrationCreateManyAcademicFalcultyInputEnvelope
    set?: AdmitionExameRegistrationWhereUniqueInput | AdmitionExameRegistrationWhereUniqueInput[]
    disconnect?: AdmitionExameRegistrationWhereUniqueInput | AdmitionExameRegistrationWhereUniqueInput[]
    delete?: AdmitionExameRegistrationWhereUniqueInput | AdmitionExameRegistrationWhereUniqueInput[]
    connect?: AdmitionExameRegistrationWhereUniqueInput | AdmitionExameRegistrationWhereUniqueInput[]
    update?: AdmitionExameRegistrationUpdateWithWhereUniqueWithoutAcademicFalcultyInput | AdmitionExameRegistrationUpdateWithWhereUniqueWithoutAcademicFalcultyInput[]
    updateMany?: AdmitionExameRegistrationUpdateManyWithWhereWithoutAcademicFalcultyInput | AdmitionExameRegistrationUpdateManyWithWhereWithoutAcademicFalcultyInput[]
    deleteMany?: AdmitionExameRegistrationScalarWhereInput | AdmitionExameRegistrationScalarWhereInput[]
  }

  export type AdmitionExamePriceUpdateManyWithoutAcademicFacultyNestedInput = {
    create?: XOR<AdmitionExamePriceCreateWithoutAcademicFacultyInput, AdmitionExamePriceUncheckedCreateWithoutAcademicFacultyInput> | AdmitionExamePriceCreateWithoutAcademicFacultyInput[] | AdmitionExamePriceUncheckedCreateWithoutAcademicFacultyInput[]
    connectOrCreate?: AdmitionExamePriceCreateOrConnectWithoutAcademicFacultyInput | AdmitionExamePriceCreateOrConnectWithoutAcademicFacultyInput[]
    upsert?: AdmitionExamePriceUpsertWithWhereUniqueWithoutAcademicFacultyInput | AdmitionExamePriceUpsertWithWhereUniqueWithoutAcademicFacultyInput[]
    createMany?: AdmitionExamePriceCreateManyAcademicFacultyInputEnvelope
    set?: AdmitionExamePriceWhereUniqueInput | AdmitionExamePriceWhereUniqueInput[]
    disconnect?: AdmitionExamePriceWhereUniqueInput | AdmitionExamePriceWhereUniqueInput[]
    delete?: AdmitionExamePriceWhereUniqueInput | AdmitionExamePriceWhereUniqueInput[]
    connect?: AdmitionExamePriceWhereUniqueInput | AdmitionExamePriceWhereUniqueInput[]
    update?: AdmitionExamePriceUpdateWithWhereUniqueWithoutAcademicFacultyInput | AdmitionExamePriceUpdateWithWhereUniqueWithoutAcademicFacultyInput[]
    updateMany?: AdmitionExamePriceUpdateManyWithWhereWithoutAcademicFacultyInput | AdmitionExamePriceUpdateManyWithWhereWithoutAcademicFacultyInput[]
    deleteMany?: AdmitionExamePriceScalarWhereInput | AdmitionExamePriceScalarWhereInput[]
  }

  export type AdmitionExamePeriodUpdateManyWithoutAcademicFacultyNestedInput = {
    create?: XOR<AdmitionExamePeriodCreateWithoutAcademicFacultyInput, AdmitionExamePeriodUncheckedCreateWithoutAcademicFacultyInput> | AdmitionExamePeriodCreateWithoutAcademicFacultyInput[] | AdmitionExamePeriodUncheckedCreateWithoutAcademicFacultyInput[]
    connectOrCreate?: AdmitionExamePeriodCreateOrConnectWithoutAcademicFacultyInput | AdmitionExamePeriodCreateOrConnectWithoutAcademicFacultyInput[]
    upsert?: AdmitionExamePeriodUpsertWithWhereUniqueWithoutAcademicFacultyInput | AdmitionExamePeriodUpsertWithWhereUniqueWithoutAcademicFacultyInput[]
    createMany?: AdmitionExamePeriodCreateManyAcademicFacultyInputEnvelope
    set?: AdmitionExamePeriodWhereUniqueInput | AdmitionExamePeriodWhereUniqueInput[]
    disconnect?: AdmitionExamePeriodWhereUniqueInput | AdmitionExamePeriodWhereUniqueInput[]
    delete?: AdmitionExamePeriodWhereUniqueInput | AdmitionExamePeriodWhereUniqueInput[]
    connect?: AdmitionExamePeriodWhereUniqueInput | AdmitionExamePeriodWhereUniqueInput[]
    update?: AdmitionExamePeriodUpdateWithWhereUniqueWithoutAcademicFacultyInput | AdmitionExamePeriodUpdateWithWhereUniqueWithoutAcademicFacultyInput[]
    updateMany?: AdmitionExamePeriodUpdateManyWithWhereWithoutAcademicFacultyInput | AdmitionExamePeriodUpdateManyWithWhereWithoutAcademicFacultyInput[]
    deleteMany?: AdmitionExamePeriodScalarWhereInput | AdmitionExamePeriodScalarWhereInput[]
  }

  export type AcademicDepartmentUncheckedUpdateManyWithoutAcademicFacultyNestedInput = {
    create?: XOR<AcademicDepartmentCreateWithoutAcademicFacultyInput, AcademicDepartmentUncheckedCreateWithoutAcademicFacultyInput> | AcademicDepartmentCreateWithoutAcademicFacultyInput[] | AcademicDepartmentUncheckedCreateWithoutAcademicFacultyInput[]
    connectOrCreate?: AcademicDepartmentCreateOrConnectWithoutAcademicFacultyInput | AcademicDepartmentCreateOrConnectWithoutAcademicFacultyInput[]
    upsert?: AcademicDepartmentUpsertWithWhereUniqueWithoutAcademicFacultyInput | AcademicDepartmentUpsertWithWhereUniqueWithoutAcademicFacultyInput[]
    createMany?: AcademicDepartmentCreateManyAcademicFacultyInputEnvelope
    set?: AcademicDepartmentWhereUniqueInput | AcademicDepartmentWhereUniqueInput[]
    disconnect?: AcademicDepartmentWhereUniqueInput | AcademicDepartmentWhereUniqueInput[]
    delete?: AcademicDepartmentWhereUniqueInput | AcademicDepartmentWhereUniqueInput[]
    connect?: AcademicDepartmentWhereUniqueInput | AcademicDepartmentWhereUniqueInput[]
    update?: AcademicDepartmentUpdateWithWhereUniqueWithoutAcademicFacultyInput | AcademicDepartmentUpdateWithWhereUniqueWithoutAcademicFacultyInput[]
    updateMany?: AcademicDepartmentUpdateManyWithWhereWithoutAcademicFacultyInput | AcademicDepartmentUpdateManyWithWhereWithoutAcademicFacultyInput[]
    deleteMany?: AcademicDepartmentScalarWhereInput | AcademicDepartmentScalarWhereInput[]
  }

  export type FacultyUncheckedUpdateManyWithoutAcademicFacultyNestedInput = {
    create?: XOR<FacultyCreateWithoutAcademicFacultyInput, FacultyUncheckedCreateWithoutAcademicFacultyInput> | FacultyCreateWithoutAcademicFacultyInput[] | FacultyUncheckedCreateWithoutAcademicFacultyInput[]
    connectOrCreate?: FacultyCreateOrConnectWithoutAcademicFacultyInput | FacultyCreateOrConnectWithoutAcademicFacultyInput[]
    upsert?: FacultyUpsertWithWhereUniqueWithoutAcademicFacultyInput | FacultyUpsertWithWhereUniqueWithoutAcademicFacultyInput[]
    createMany?: FacultyCreateManyAcademicFacultyInputEnvelope
    set?: FacultyWhereUniqueInput | FacultyWhereUniqueInput[]
    disconnect?: FacultyWhereUniqueInput | FacultyWhereUniqueInput[]
    delete?: FacultyWhereUniqueInput | FacultyWhereUniqueInput[]
    connect?: FacultyWhereUniqueInput | FacultyWhereUniqueInput[]
    update?: FacultyUpdateWithWhereUniqueWithoutAcademicFacultyInput | FacultyUpdateWithWhereUniqueWithoutAcademicFacultyInput[]
    updateMany?: FacultyUpdateManyWithWhereWithoutAcademicFacultyInput | FacultyUpdateManyWithWhereWithoutAcademicFacultyInput[]
    deleteMany?: FacultyScalarWhereInput | FacultyScalarWhereInput[]
  }

  export type StudentUncheckedUpdateManyWithoutAcademicFacultyNestedInput = {
    create?: XOR<StudentCreateWithoutAcademicFacultyInput, StudentUncheckedCreateWithoutAcademicFacultyInput> | StudentCreateWithoutAcademicFacultyInput[] | StudentUncheckedCreateWithoutAcademicFacultyInput[]
    connectOrCreate?: StudentCreateOrConnectWithoutAcademicFacultyInput | StudentCreateOrConnectWithoutAcademicFacultyInput[]
    upsert?: StudentUpsertWithWhereUniqueWithoutAcademicFacultyInput | StudentUpsertWithWhereUniqueWithoutAcademicFacultyInput[]
    createMany?: StudentCreateManyAcademicFacultyInputEnvelope
    set?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    disconnect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    delete?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    connect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    update?: StudentUpdateWithWhereUniqueWithoutAcademicFacultyInput | StudentUpdateWithWhereUniqueWithoutAcademicFacultyInput[]
    updateMany?: StudentUpdateManyWithWhereWithoutAcademicFacultyInput | StudentUpdateManyWithWhereWithoutAcademicFacultyInput[]
    deleteMany?: StudentScalarWhereInput | StudentScalarWhereInput[]
  }

  export type AdmitionExameRegistrationUncheckedUpdateManyWithoutAcademicFalcultyNestedInput = {
    create?: XOR<AdmitionExameRegistrationCreateWithoutAcademicFalcultyInput, AdmitionExameRegistrationUncheckedCreateWithoutAcademicFalcultyInput> | AdmitionExameRegistrationCreateWithoutAcademicFalcultyInput[] | AdmitionExameRegistrationUncheckedCreateWithoutAcademicFalcultyInput[]
    connectOrCreate?: AdmitionExameRegistrationCreateOrConnectWithoutAcademicFalcultyInput | AdmitionExameRegistrationCreateOrConnectWithoutAcademicFalcultyInput[]
    upsert?: AdmitionExameRegistrationUpsertWithWhereUniqueWithoutAcademicFalcultyInput | AdmitionExameRegistrationUpsertWithWhereUniqueWithoutAcademicFalcultyInput[]
    createMany?: AdmitionExameRegistrationCreateManyAcademicFalcultyInputEnvelope
    set?: AdmitionExameRegistrationWhereUniqueInput | AdmitionExameRegistrationWhereUniqueInput[]
    disconnect?: AdmitionExameRegistrationWhereUniqueInput | AdmitionExameRegistrationWhereUniqueInput[]
    delete?: AdmitionExameRegistrationWhereUniqueInput | AdmitionExameRegistrationWhereUniqueInput[]
    connect?: AdmitionExameRegistrationWhereUniqueInput | AdmitionExameRegistrationWhereUniqueInput[]
    update?: AdmitionExameRegistrationUpdateWithWhereUniqueWithoutAcademicFalcultyInput | AdmitionExameRegistrationUpdateWithWhereUniqueWithoutAcademicFalcultyInput[]
    updateMany?: AdmitionExameRegistrationUpdateManyWithWhereWithoutAcademicFalcultyInput | AdmitionExameRegistrationUpdateManyWithWhereWithoutAcademicFalcultyInput[]
    deleteMany?: AdmitionExameRegistrationScalarWhereInput | AdmitionExameRegistrationScalarWhereInput[]
  }

  export type AdmitionExamePriceUncheckedUpdateManyWithoutAcademicFacultyNestedInput = {
    create?: XOR<AdmitionExamePriceCreateWithoutAcademicFacultyInput, AdmitionExamePriceUncheckedCreateWithoutAcademicFacultyInput> | AdmitionExamePriceCreateWithoutAcademicFacultyInput[] | AdmitionExamePriceUncheckedCreateWithoutAcademicFacultyInput[]
    connectOrCreate?: AdmitionExamePriceCreateOrConnectWithoutAcademicFacultyInput | AdmitionExamePriceCreateOrConnectWithoutAcademicFacultyInput[]
    upsert?: AdmitionExamePriceUpsertWithWhereUniqueWithoutAcademicFacultyInput | AdmitionExamePriceUpsertWithWhereUniqueWithoutAcademicFacultyInput[]
    createMany?: AdmitionExamePriceCreateManyAcademicFacultyInputEnvelope
    set?: AdmitionExamePriceWhereUniqueInput | AdmitionExamePriceWhereUniqueInput[]
    disconnect?: AdmitionExamePriceWhereUniqueInput | AdmitionExamePriceWhereUniqueInput[]
    delete?: AdmitionExamePriceWhereUniqueInput | AdmitionExamePriceWhereUniqueInput[]
    connect?: AdmitionExamePriceWhereUniqueInput | AdmitionExamePriceWhereUniqueInput[]
    update?: AdmitionExamePriceUpdateWithWhereUniqueWithoutAcademicFacultyInput | AdmitionExamePriceUpdateWithWhereUniqueWithoutAcademicFacultyInput[]
    updateMany?: AdmitionExamePriceUpdateManyWithWhereWithoutAcademicFacultyInput | AdmitionExamePriceUpdateManyWithWhereWithoutAcademicFacultyInput[]
    deleteMany?: AdmitionExamePriceScalarWhereInput | AdmitionExamePriceScalarWhereInput[]
  }

  export type AdmitionExamePeriodUncheckedUpdateManyWithoutAcademicFacultyNestedInput = {
    create?: XOR<AdmitionExamePeriodCreateWithoutAcademicFacultyInput, AdmitionExamePeriodUncheckedCreateWithoutAcademicFacultyInput> | AdmitionExamePeriodCreateWithoutAcademicFacultyInput[] | AdmitionExamePeriodUncheckedCreateWithoutAcademicFacultyInput[]
    connectOrCreate?: AdmitionExamePeriodCreateOrConnectWithoutAcademicFacultyInput | AdmitionExamePeriodCreateOrConnectWithoutAcademicFacultyInput[]
    upsert?: AdmitionExamePeriodUpsertWithWhereUniqueWithoutAcademicFacultyInput | AdmitionExamePeriodUpsertWithWhereUniqueWithoutAcademicFacultyInput[]
    createMany?: AdmitionExamePeriodCreateManyAcademicFacultyInputEnvelope
    set?: AdmitionExamePeriodWhereUniqueInput | AdmitionExamePeriodWhereUniqueInput[]
    disconnect?: AdmitionExamePeriodWhereUniqueInput | AdmitionExamePeriodWhereUniqueInput[]
    delete?: AdmitionExamePeriodWhereUniqueInput | AdmitionExamePeriodWhereUniqueInput[]
    connect?: AdmitionExamePeriodWhereUniqueInput | AdmitionExamePeriodWhereUniqueInput[]
    update?: AdmitionExamePeriodUpdateWithWhereUniqueWithoutAcademicFacultyInput | AdmitionExamePeriodUpdateWithWhereUniqueWithoutAcademicFacultyInput[]
    updateMany?: AdmitionExamePeriodUpdateManyWithWhereWithoutAcademicFacultyInput | AdmitionExamePeriodUpdateManyWithWhereWithoutAcademicFacultyInput[]
    deleteMany?: AdmitionExamePeriodScalarWhereInput | AdmitionExamePeriodScalarWhereInput[]
  }

  export type AcademicFacultyCreateNestedOneWithoutAcademicDepartmentsInput = {
    create?: XOR<AcademicFacultyCreateWithoutAcademicDepartmentsInput, AcademicFacultyUncheckedCreateWithoutAcademicDepartmentsInput>
    connectOrCreate?: AcademicFacultyCreateOrConnectWithoutAcademicDepartmentsInput
    connect?: AcademicFacultyWhereUniqueInput
  }

  export type FacultyCreateNestedManyWithoutAcademicDepartmentInput = {
    create?: XOR<FacultyCreateWithoutAcademicDepartmentInput, FacultyUncheckedCreateWithoutAcademicDepartmentInput> | FacultyCreateWithoutAcademicDepartmentInput[] | FacultyUncheckedCreateWithoutAcademicDepartmentInput[]
    connectOrCreate?: FacultyCreateOrConnectWithoutAcademicDepartmentInput | FacultyCreateOrConnectWithoutAcademicDepartmentInput[]
    createMany?: FacultyCreateManyAcademicDepartmentInputEnvelope
    connect?: FacultyWhereUniqueInput | FacultyWhereUniqueInput[]
  }

  export type CourseCreateNestedManyWithoutAcademicDepartmentInput = {
    create?: XOR<CourseCreateWithoutAcademicDepartmentInput, CourseUncheckedCreateWithoutAcademicDepartmentInput> | CourseCreateWithoutAcademicDepartmentInput[] | CourseUncheckedCreateWithoutAcademicDepartmentInput[]
    connectOrCreate?: CourseCreateOrConnectWithoutAcademicDepartmentInput | CourseCreateOrConnectWithoutAcademicDepartmentInput[]
    createMany?: CourseCreateManyAcademicDepartmentInputEnvelope
    connect?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
  }

  export type StudentCreateNestedManyWithoutAcademicDepartmentInput = {
    create?: XOR<StudentCreateWithoutAcademicDepartmentInput, StudentUncheckedCreateWithoutAcademicDepartmentInput> | StudentCreateWithoutAcademicDepartmentInput[] | StudentUncheckedCreateWithoutAcademicDepartmentInput[]
    connectOrCreate?: StudentCreateOrConnectWithoutAcademicDepartmentInput | StudentCreateOrConnectWithoutAcademicDepartmentInput[]
    createMany?: StudentCreateManyAcademicDepartmentInputEnvelope
    connect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
  }

  export type UsersCreateNestedOneWithoutAcademicDepartmentInput = {
    create?: XOR<UsersCreateWithoutAcademicDepartmentInput, UsersUncheckedCreateWithoutAcademicDepartmentInput>
    connectOrCreate?: UsersCreateOrConnectWithoutAcademicDepartmentInput
    connect?: UsersWhereUniqueInput
  }

  export type UsersCreateNestedManyWithoutStaffDepartmentsInput = {
    create?: XOR<UsersCreateWithoutStaffDepartmentsInput, UsersUncheckedCreateWithoutStaffDepartmentsInput> | UsersCreateWithoutStaffDepartmentsInput[] | UsersUncheckedCreateWithoutStaffDepartmentsInput[]
    connectOrCreate?: UsersCreateOrConnectWithoutStaffDepartmentsInput | UsersCreateOrConnectWithoutStaffDepartmentsInput[]
    connect?: UsersWhereUniqueInput | UsersWhereUniqueInput[]
  }

  export type OfferedCourseCreateNestedManyWithoutAcademicDepartmentInput = {
    create?: XOR<OfferedCourseCreateWithoutAcademicDepartmentInput, OfferedCourseUncheckedCreateWithoutAcademicDepartmentInput> | OfferedCourseCreateWithoutAcademicDepartmentInput[] | OfferedCourseUncheckedCreateWithoutAcademicDepartmentInput[]
    connectOrCreate?: OfferedCourseCreateOrConnectWithoutAcademicDepartmentInput | OfferedCourseCreateOrConnectWithoutAcademicDepartmentInput[]
    createMany?: OfferedCourseCreateManyAcademicDepartmentInputEnvelope
    connect?: OfferedCourseWhereUniqueInput | OfferedCourseWhereUniqueInput[]
  }

  export type FacultyUncheckedCreateNestedManyWithoutAcademicDepartmentInput = {
    create?: XOR<FacultyCreateWithoutAcademicDepartmentInput, FacultyUncheckedCreateWithoutAcademicDepartmentInput> | FacultyCreateWithoutAcademicDepartmentInput[] | FacultyUncheckedCreateWithoutAcademicDepartmentInput[]
    connectOrCreate?: FacultyCreateOrConnectWithoutAcademicDepartmentInput | FacultyCreateOrConnectWithoutAcademicDepartmentInput[]
    createMany?: FacultyCreateManyAcademicDepartmentInputEnvelope
    connect?: FacultyWhereUniqueInput | FacultyWhereUniqueInput[]
  }

  export type CourseUncheckedCreateNestedManyWithoutAcademicDepartmentInput = {
    create?: XOR<CourseCreateWithoutAcademicDepartmentInput, CourseUncheckedCreateWithoutAcademicDepartmentInput> | CourseCreateWithoutAcademicDepartmentInput[] | CourseUncheckedCreateWithoutAcademicDepartmentInput[]
    connectOrCreate?: CourseCreateOrConnectWithoutAcademicDepartmentInput | CourseCreateOrConnectWithoutAcademicDepartmentInput[]
    createMany?: CourseCreateManyAcademicDepartmentInputEnvelope
    connect?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
  }

  export type StudentUncheckedCreateNestedManyWithoutAcademicDepartmentInput = {
    create?: XOR<StudentCreateWithoutAcademicDepartmentInput, StudentUncheckedCreateWithoutAcademicDepartmentInput> | StudentCreateWithoutAcademicDepartmentInput[] | StudentUncheckedCreateWithoutAcademicDepartmentInput[]
    connectOrCreate?: StudentCreateOrConnectWithoutAcademicDepartmentInput | StudentCreateOrConnectWithoutAcademicDepartmentInput[]
    createMany?: StudentCreateManyAcademicDepartmentInputEnvelope
    connect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
  }

  export type UsersUncheckedCreateNestedManyWithoutStaffDepartmentsInput = {
    create?: XOR<UsersCreateWithoutStaffDepartmentsInput, UsersUncheckedCreateWithoutStaffDepartmentsInput> | UsersCreateWithoutStaffDepartmentsInput[] | UsersUncheckedCreateWithoutStaffDepartmentsInput[]
    connectOrCreate?: UsersCreateOrConnectWithoutStaffDepartmentsInput | UsersCreateOrConnectWithoutStaffDepartmentsInput[]
    connect?: UsersWhereUniqueInput | UsersWhereUniqueInput[]
  }

  export type OfferedCourseUncheckedCreateNestedManyWithoutAcademicDepartmentInput = {
    create?: XOR<OfferedCourseCreateWithoutAcademicDepartmentInput, OfferedCourseUncheckedCreateWithoutAcademicDepartmentInput> | OfferedCourseCreateWithoutAcademicDepartmentInput[] | OfferedCourseUncheckedCreateWithoutAcademicDepartmentInput[]
    connectOrCreate?: OfferedCourseCreateOrConnectWithoutAcademicDepartmentInput | OfferedCourseCreateOrConnectWithoutAcademicDepartmentInput[]
    createMany?: OfferedCourseCreateManyAcademicDepartmentInputEnvelope
    connect?: OfferedCourseWhereUniqueInput | OfferedCourseWhereUniqueInput[]
  }

  export type AcademicFacultyUpdateOneRequiredWithoutAcademicDepartmentsNestedInput = {
    create?: XOR<AcademicFacultyCreateWithoutAcademicDepartmentsInput, AcademicFacultyUncheckedCreateWithoutAcademicDepartmentsInput>
    connectOrCreate?: AcademicFacultyCreateOrConnectWithoutAcademicDepartmentsInput
    upsert?: AcademicFacultyUpsertWithoutAcademicDepartmentsInput
    connect?: AcademicFacultyWhereUniqueInput
    update?: XOR<XOR<AcademicFacultyUpdateToOneWithWhereWithoutAcademicDepartmentsInput, AcademicFacultyUpdateWithoutAcademicDepartmentsInput>, AcademicFacultyUncheckedUpdateWithoutAcademicDepartmentsInput>
  }

  export type FacultyUpdateManyWithoutAcademicDepartmentNestedInput = {
    create?: XOR<FacultyCreateWithoutAcademicDepartmentInput, FacultyUncheckedCreateWithoutAcademicDepartmentInput> | FacultyCreateWithoutAcademicDepartmentInput[] | FacultyUncheckedCreateWithoutAcademicDepartmentInput[]
    connectOrCreate?: FacultyCreateOrConnectWithoutAcademicDepartmentInput | FacultyCreateOrConnectWithoutAcademicDepartmentInput[]
    upsert?: FacultyUpsertWithWhereUniqueWithoutAcademicDepartmentInput | FacultyUpsertWithWhereUniqueWithoutAcademicDepartmentInput[]
    createMany?: FacultyCreateManyAcademicDepartmentInputEnvelope
    set?: FacultyWhereUniqueInput | FacultyWhereUniqueInput[]
    disconnect?: FacultyWhereUniqueInput | FacultyWhereUniqueInput[]
    delete?: FacultyWhereUniqueInput | FacultyWhereUniqueInput[]
    connect?: FacultyWhereUniqueInput | FacultyWhereUniqueInput[]
    update?: FacultyUpdateWithWhereUniqueWithoutAcademicDepartmentInput | FacultyUpdateWithWhereUniqueWithoutAcademicDepartmentInput[]
    updateMany?: FacultyUpdateManyWithWhereWithoutAcademicDepartmentInput | FacultyUpdateManyWithWhereWithoutAcademicDepartmentInput[]
    deleteMany?: FacultyScalarWhereInput | FacultyScalarWhereInput[]
  }

  export type CourseUpdateManyWithoutAcademicDepartmentNestedInput = {
    create?: XOR<CourseCreateWithoutAcademicDepartmentInput, CourseUncheckedCreateWithoutAcademicDepartmentInput> | CourseCreateWithoutAcademicDepartmentInput[] | CourseUncheckedCreateWithoutAcademicDepartmentInput[]
    connectOrCreate?: CourseCreateOrConnectWithoutAcademicDepartmentInput | CourseCreateOrConnectWithoutAcademicDepartmentInput[]
    upsert?: CourseUpsertWithWhereUniqueWithoutAcademicDepartmentInput | CourseUpsertWithWhereUniqueWithoutAcademicDepartmentInput[]
    createMany?: CourseCreateManyAcademicDepartmentInputEnvelope
    set?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
    disconnect?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
    delete?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
    connect?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
    update?: CourseUpdateWithWhereUniqueWithoutAcademicDepartmentInput | CourseUpdateWithWhereUniqueWithoutAcademicDepartmentInput[]
    updateMany?: CourseUpdateManyWithWhereWithoutAcademicDepartmentInput | CourseUpdateManyWithWhereWithoutAcademicDepartmentInput[]
    deleteMany?: CourseScalarWhereInput | CourseScalarWhereInput[]
  }

  export type StudentUpdateManyWithoutAcademicDepartmentNestedInput = {
    create?: XOR<StudentCreateWithoutAcademicDepartmentInput, StudentUncheckedCreateWithoutAcademicDepartmentInput> | StudentCreateWithoutAcademicDepartmentInput[] | StudentUncheckedCreateWithoutAcademicDepartmentInput[]
    connectOrCreate?: StudentCreateOrConnectWithoutAcademicDepartmentInput | StudentCreateOrConnectWithoutAcademicDepartmentInput[]
    upsert?: StudentUpsertWithWhereUniqueWithoutAcademicDepartmentInput | StudentUpsertWithWhereUniqueWithoutAcademicDepartmentInput[]
    createMany?: StudentCreateManyAcademicDepartmentInputEnvelope
    set?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    disconnect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    delete?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    connect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    update?: StudentUpdateWithWhereUniqueWithoutAcademicDepartmentInput | StudentUpdateWithWhereUniqueWithoutAcademicDepartmentInput[]
    updateMany?: StudentUpdateManyWithWhereWithoutAcademicDepartmentInput | StudentUpdateManyWithWhereWithoutAcademicDepartmentInput[]
    deleteMany?: StudentScalarWhereInput | StudentScalarWhereInput[]
  }

  export type UsersUpdateOneWithoutAcademicDepartmentNestedInput = {
    create?: XOR<UsersCreateWithoutAcademicDepartmentInput, UsersUncheckedCreateWithoutAcademicDepartmentInput>
    connectOrCreate?: UsersCreateOrConnectWithoutAcademicDepartmentInput
    upsert?: UsersUpsertWithoutAcademicDepartmentInput
    disconnect?: UsersWhereInput | boolean
    delete?: UsersWhereInput | boolean
    connect?: UsersWhereUniqueInput
    update?: XOR<XOR<UsersUpdateToOneWithWhereWithoutAcademicDepartmentInput, UsersUpdateWithoutAcademicDepartmentInput>, UsersUncheckedUpdateWithoutAcademicDepartmentInput>
  }

  export type UsersUpdateManyWithoutStaffDepartmentsNestedInput = {
    create?: XOR<UsersCreateWithoutStaffDepartmentsInput, UsersUncheckedCreateWithoutStaffDepartmentsInput> | UsersCreateWithoutStaffDepartmentsInput[] | UsersUncheckedCreateWithoutStaffDepartmentsInput[]
    connectOrCreate?: UsersCreateOrConnectWithoutStaffDepartmentsInput | UsersCreateOrConnectWithoutStaffDepartmentsInput[]
    upsert?: UsersUpsertWithWhereUniqueWithoutStaffDepartmentsInput | UsersUpsertWithWhereUniqueWithoutStaffDepartmentsInput[]
    set?: UsersWhereUniqueInput | UsersWhereUniqueInput[]
    disconnect?: UsersWhereUniqueInput | UsersWhereUniqueInput[]
    delete?: UsersWhereUniqueInput | UsersWhereUniqueInput[]
    connect?: UsersWhereUniqueInput | UsersWhereUniqueInput[]
    update?: UsersUpdateWithWhereUniqueWithoutStaffDepartmentsInput | UsersUpdateWithWhereUniqueWithoutStaffDepartmentsInput[]
    updateMany?: UsersUpdateManyWithWhereWithoutStaffDepartmentsInput | UsersUpdateManyWithWhereWithoutStaffDepartmentsInput[]
    deleteMany?: UsersScalarWhereInput | UsersScalarWhereInput[]
  }

  export type OfferedCourseUpdateManyWithoutAcademicDepartmentNestedInput = {
    create?: XOR<OfferedCourseCreateWithoutAcademicDepartmentInput, OfferedCourseUncheckedCreateWithoutAcademicDepartmentInput> | OfferedCourseCreateWithoutAcademicDepartmentInput[] | OfferedCourseUncheckedCreateWithoutAcademicDepartmentInput[]
    connectOrCreate?: OfferedCourseCreateOrConnectWithoutAcademicDepartmentInput | OfferedCourseCreateOrConnectWithoutAcademicDepartmentInput[]
    upsert?: OfferedCourseUpsertWithWhereUniqueWithoutAcademicDepartmentInput | OfferedCourseUpsertWithWhereUniqueWithoutAcademicDepartmentInput[]
    createMany?: OfferedCourseCreateManyAcademicDepartmentInputEnvelope
    set?: OfferedCourseWhereUniqueInput | OfferedCourseWhereUniqueInput[]
    disconnect?: OfferedCourseWhereUniqueInput | OfferedCourseWhereUniqueInput[]
    delete?: OfferedCourseWhereUniqueInput | OfferedCourseWhereUniqueInput[]
    connect?: OfferedCourseWhereUniqueInput | OfferedCourseWhereUniqueInput[]
    update?: OfferedCourseUpdateWithWhereUniqueWithoutAcademicDepartmentInput | OfferedCourseUpdateWithWhereUniqueWithoutAcademicDepartmentInput[]
    updateMany?: OfferedCourseUpdateManyWithWhereWithoutAcademicDepartmentInput | OfferedCourseUpdateManyWithWhereWithoutAcademicDepartmentInput[]
    deleteMany?: OfferedCourseScalarWhereInput | OfferedCourseScalarWhereInput[]
  }

  export type FacultyUncheckedUpdateManyWithoutAcademicDepartmentNestedInput = {
    create?: XOR<FacultyCreateWithoutAcademicDepartmentInput, FacultyUncheckedCreateWithoutAcademicDepartmentInput> | FacultyCreateWithoutAcademicDepartmentInput[] | FacultyUncheckedCreateWithoutAcademicDepartmentInput[]
    connectOrCreate?: FacultyCreateOrConnectWithoutAcademicDepartmentInput | FacultyCreateOrConnectWithoutAcademicDepartmentInput[]
    upsert?: FacultyUpsertWithWhereUniqueWithoutAcademicDepartmentInput | FacultyUpsertWithWhereUniqueWithoutAcademicDepartmentInput[]
    createMany?: FacultyCreateManyAcademicDepartmentInputEnvelope
    set?: FacultyWhereUniqueInput | FacultyWhereUniqueInput[]
    disconnect?: FacultyWhereUniqueInput | FacultyWhereUniqueInput[]
    delete?: FacultyWhereUniqueInput | FacultyWhereUniqueInput[]
    connect?: FacultyWhereUniqueInput | FacultyWhereUniqueInput[]
    update?: FacultyUpdateWithWhereUniqueWithoutAcademicDepartmentInput | FacultyUpdateWithWhereUniqueWithoutAcademicDepartmentInput[]
    updateMany?: FacultyUpdateManyWithWhereWithoutAcademicDepartmentInput | FacultyUpdateManyWithWhereWithoutAcademicDepartmentInput[]
    deleteMany?: FacultyScalarWhereInput | FacultyScalarWhereInput[]
  }

  export type CourseUncheckedUpdateManyWithoutAcademicDepartmentNestedInput = {
    create?: XOR<CourseCreateWithoutAcademicDepartmentInput, CourseUncheckedCreateWithoutAcademicDepartmentInput> | CourseCreateWithoutAcademicDepartmentInput[] | CourseUncheckedCreateWithoutAcademicDepartmentInput[]
    connectOrCreate?: CourseCreateOrConnectWithoutAcademicDepartmentInput | CourseCreateOrConnectWithoutAcademicDepartmentInput[]
    upsert?: CourseUpsertWithWhereUniqueWithoutAcademicDepartmentInput | CourseUpsertWithWhereUniqueWithoutAcademicDepartmentInput[]
    createMany?: CourseCreateManyAcademicDepartmentInputEnvelope
    set?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
    disconnect?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
    delete?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
    connect?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
    update?: CourseUpdateWithWhereUniqueWithoutAcademicDepartmentInput | CourseUpdateWithWhereUniqueWithoutAcademicDepartmentInput[]
    updateMany?: CourseUpdateManyWithWhereWithoutAcademicDepartmentInput | CourseUpdateManyWithWhereWithoutAcademicDepartmentInput[]
    deleteMany?: CourseScalarWhereInput | CourseScalarWhereInput[]
  }

  export type StudentUncheckedUpdateManyWithoutAcademicDepartmentNestedInput = {
    create?: XOR<StudentCreateWithoutAcademicDepartmentInput, StudentUncheckedCreateWithoutAcademicDepartmentInput> | StudentCreateWithoutAcademicDepartmentInput[] | StudentUncheckedCreateWithoutAcademicDepartmentInput[]
    connectOrCreate?: StudentCreateOrConnectWithoutAcademicDepartmentInput | StudentCreateOrConnectWithoutAcademicDepartmentInput[]
    upsert?: StudentUpsertWithWhereUniqueWithoutAcademicDepartmentInput | StudentUpsertWithWhereUniqueWithoutAcademicDepartmentInput[]
    createMany?: StudentCreateManyAcademicDepartmentInputEnvelope
    set?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    disconnect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    delete?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    connect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    update?: StudentUpdateWithWhereUniqueWithoutAcademicDepartmentInput | StudentUpdateWithWhereUniqueWithoutAcademicDepartmentInput[]
    updateMany?: StudentUpdateManyWithWhereWithoutAcademicDepartmentInput | StudentUpdateManyWithWhereWithoutAcademicDepartmentInput[]
    deleteMany?: StudentScalarWhereInput | StudentScalarWhereInput[]
  }

  export type UsersUncheckedUpdateManyWithoutStaffDepartmentsNestedInput = {
    create?: XOR<UsersCreateWithoutStaffDepartmentsInput, UsersUncheckedCreateWithoutStaffDepartmentsInput> | UsersCreateWithoutStaffDepartmentsInput[] | UsersUncheckedCreateWithoutStaffDepartmentsInput[]
    connectOrCreate?: UsersCreateOrConnectWithoutStaffDepartmentsInput | UsersCreateOrConnectWithoutStaffDepartmentsInput[]
    upsert?: UsersUpsertWithWhereUniqueWithoutStaffDepartmentsInput | UsersUpsertWithWhereUniqueWithoutStaffDepartmentsInput[]
    set?: UsersWhereUniqueInput | UsersWhereUniqueInput[]
    disconnect?: UsersWhereUniqueInput | UsersWhereUniqueInput[]
    delete?: UsersWhereUniqueInput | UsersWhereUniqueInput[]
    connect?: UsersWhereUniqueInput | UsersWhereUniqueInput[]
    update?: UsersUpdateWithWhereUniqueWithoutStaffDepartmentsInput | UsersUpdateWithWhereUniqueWithoutStaffDepartmentsInput[]
    updateMany?: UsersUpdateManyWithWhereWithoutStaffDepartmentsInput | UsersUpdateManyWithWhereWithoutStaffDepartmentsInput[]
    deleteMany?: UsersScalarWhereInput | UsersScalarWhereInput[]
  }

  export type OfferedCourseUncheckedUpdateManyWithoutAcademicDepartmentNestedInput = {
    create?: XOR<OfferedCourseCreateWithoutAcademicDepartmentInput, OfferedCourseUncheckedCreateWithoutAcademicDepartmentInput> | OfferedCourseCreateWithoutAcademicDepartmentInput[] | OfferedCourseUncheckedCreateWithoutAcademicDepartmentInput[]
    connectOrCreate?: OfferedCourseCreateOrConnectWithoutAcademicDepartmentInput | OfferedCourseCreateOrConnectWithoutAcademicDepartmentInput[]
    upsert?: OfferedCourseUpsertWithWhereUniqueWithoutAcademicDepartmentInput | OfferedCourseUpsertWithWhereUniqueWithoutAcademicDepartmentInput[]
    createMany?: OfferedCourseCreateManyAcademicDepartmentInputEnvelope
    set?: OfferedCourseWhereUniqueInput | OfferedCourseWhereUniqueInput[]
    disconnect?: OfferedCourseWhereUniqueInput | OfferedCourseWhereUniqueInput[]
    delete?: OfferedCourseWhereUniqueInput | OfferedCourseWhereUniqueInput[]
    connect?: OfferedCourseWhereUniqueInput | OfferedCourseWhereUniqueInput[]
    update?: OfferedCourseUpdateWithWhereUniqueWithoutAcademicDepartmentInput | OfferedCourseUpdateWithWhereUniqueWithoutAcademicDepartmentInput[]
    updateMany?: OfferedCourseUpdateManyWithWhereWithoutAcademicDepartmentInput | OfferedCourseUpdateManyWithWhereWithoutAcademicDepartmentInput[]
    deleteMany?: OfferedCourseScalarWhereInput | OfferedCourseScalarWhereInput[]
  }

  export type AcademicFacultyCreateNestedOneWithoutStudentsInput = {
    create?: XOR<AcademicFacultyCreateWithoutStudentsInput, AcademicFacultyUncheckedCreateWithoutStudentsInput>
    connectOrCreate?: AcademicFacultyCreateOrConnectWithoutStudentsInput
    connect?: AcademicFacultyWhereUniqueInput
  }

  export type AdmitionExameRegistrationCreateNestedOneWithoutStudentInput = {
    create?: XOR<AdmitionExameRegistrationCreateWithoutStudentInput, AdmitionExameRegistrationUncheckedCreateWithoutStudentInput>
    connectOrCreate?: AdmitionExameRegistrationCreateOrConnectWithoutStudentInput
    connect?: AdmitionExameRegistrationWhereUniqueInput
  }

  export type AcademicDepartmentCreateNestedOneWithoutStudentsInput = {
    create?: XOR<AcademicDepartmentCreateWithoutStudentsInput, AcademicDepartmentUncheckedCreateWithoutStudentsInput>
    connectOrCreate?: AcademicDepartmentCreateOrConnectWithoutStudentsInput
    connect?: AcademicDepartmentWhereUniqueInput
  }

  export type AcademicSemesterCreateNestedOneWithoutStudentsInput = {
    create?: XOR<AcademicSemesterCreateWithoutStudentsInput, AcademicSemesterUncheckedCreateWithoutStudentsInput>
    connectOrCreate?: AcademicSemesterCreateOrConnectWithoutStudentsInput
    connect?: AcademicSemesterWhereUniqueInput
  }

  export type StudentSemesterRegistrationCreateNestedManyWithoutStudentInput = {
    create?: XOR<StudentSemesterRegistrationCreateWithoutStudentInput, StudentSemesterRegistrationUncheckedCreateWithoutStudentInput> | StudentSemesterRegistrationCreateWithoutStudentInput[] | StudentSemesterRegistrationUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: StudentSemesterRegistrationCreateOrConnectWithoutStudentInput | StudentSemesterRegistrationCreateOrConnectWithoutStudentInput[]
    createMany?: StudentSemesterRegistrationCreateManyStudentInputEnvelope
    connect?: StudentSemesterRegistrationWhereUniqueInput | StudentSemesterRegistrationWhereUniqueInput[]
  }

  export type StudentSemesterRegistrationCourseCreateNestedManyWithoutStudentInput = {
    create?: XOR<StudentSemesterRegistrationCourseCreateWithoutStudentInput, StudentSemesterRegistrationCourseUncheckedCreateWithoutStudentInput> | StudentSemesterRegistrationCourseCreateWithoutStudentInput[] | StudentSemesterRegistrationCourseUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: StudentSemesterRegistrationCourseCreateOrConnectWithoutStudentInput | StudentSemesterRegistrationCourseCreateOrConnectWithoutStudentInput[]
    createMany?: StudentSemesterRegistrationCourseCreateManyStudentInputEnvelope
    connect?: StudentSemesterRegistrationCourseWhereUniqueInput | StudentSemesterRegistrationCourseWhereUniqueInput[]
  }

  export type StudentEnrolledCourseCreateNestedManyWithoutStudentInput = {
    create?: XOR<StudentEnrolledCourseCreateWithoutStudentInput, StudentEnrolledCourseUncheckedCreateWithoutStudentInput> | StudentEnrolledCourseCreateWithoutStudentInput[] | StudentEnrolledCourseUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: StudentEnrolledCourseCreateOrConnectWithoutStudentInput | StudentEnrolledCourseCreateOrConnectWithoutStudentInput[]
    createMany?: StudentEnrolledCourseCreateManyStudentInputEnvelope
    connect?: StudentEnrolledCourseWhereUniqueInput | StudentEnrolledCourseWhereUniqueInput[]
  }

  export type StudentEnrolledCourseMarkCreateNestedManyWithoutStudentInput = {
    create?: XOR<StudentEnrolledCourseMarkCreateWithoutStudentInput, StudentEnrolledCourseMarkUncheckedCreateWithoutStudentInput> | StudentEnrolledCourseMarkCreateWithoutStudentInput[] | StudentEnrolledCourseMarkUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: StudentEnrolledCourseMarkCreateOrConnectWithoutStudentInput | StudentEnrolledCourseMarkCreateOrConnectWithoutStudentInput[]
    createMany?: StudentEnrolledCourseMarkCreateManyStudentInputEnvelope
    connect?: StudentEnrolledCourseMarkWhereUniqueInput | StudentEnrolledCourseMarkWhereUniqueInput[]
  }

  export type StudentSemesterPaymentCreateNestedManyWithoutStudentInput = {
    create?: XOR<StudentSemesterPaymentCreateWithoutStudentInput, StudentSemesterPaymentUncheckedCreateWithoutStudentInput> | StudentSemesterPaymentCreateWithoutStudentInput[] | StudentSemesterPaymentUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: StudentSemesterPaymentCreateOrConnectWithoutStudentInput | StudentSemesterPaymentCreateOrConnectWithoutStudentInput[]
    createMany?: StudentSemesterPaymentCreateManyStudentInputEnvelope
    connect?: StudentSemesterPaymentWhereUniqueInput | StudentSemesterPaymentWhereUniqueInput[]
  }

  export type StudentAcademicInfoCreateNestedManyWithoutStudentInput = {
    create?: XOR<StudentAcademicInfoCreateWithoutStudentInput, StudentAcademicInfoUncheckedCreateWithoutStudentInput> | StudentAcademicInfoCreateWithoutStudentInput[] | StudentAcademicInfoUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: StudentAcademicInfoCreateOrConnectWithoutStudentInput | StudentAcademicInfoCreateOrConnectWithoutStudentInput[]
    createMany?: StudentAcademicInfoCreateManyStudentInputEnvelope
    connect?: StudentAcademicInfoWhereUniqueInput | StudentAcademicInfoWhereUniqueInput[]
  }

  export type StudentCarriedCourseCreateNestedManyWithoutStudentInput = {
    create?: XOR<StudentCarriedCourseCreateWithoutStudentInput, StudentCarriedCourseUncheckedCreateWithoutStudentInput> | StudentCarriedCourseCreateWithoutStudentInput[] | StudentCarriedCourseUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: StudentCarriedCourseCreateOrConnectWithoutStudentInput | StudentCarriedCourseCreateOrConnectWithoutStudentInput[]
    createMany?: StudentCarriedCourseCreateManyStudentInputEnvelope
    connect?: StudentCarriedCourseWhereUniqueInput | StudentCarriedCourseWhereUniqueInput[]
  }

  export type StudentSemesterRegistrationUncheckedCreateNestedManyWithoutStudentInput = {
    create?: XOR<StudentSemesterRegistrationCreateWithoutStudentInput, StudentSemesterRegistrationUncheckedCreateWithoutStudentInput> | StudentSemesterRegistrationCreateWithoutStudentInput[] | StudentSemesterRegistrationUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: StudentSemesterRegistrationCreateOrConnectWithoutStudentInput | StudentSemesterRegistrationCreateOrConnectWithoutStudentInput[]
    createMany?: StudentSemesterRegistrationCreateManyStudentInputEnvelope
    connect?: StudentSemesterRegistrationWhereUniqueInput | StudentSemesterRegistrationWhereUniqueInput[]
  }

  export type StudentSemesterRegistrationCourseUncheckedCreateNestedManyWithoutStudentInput = {
    create?: XOR<StudentSemesterRegistrationCourseCreateWithoutStudentInput, StudentSemesterRegistrationCourseUncheckedCreateWithoutStudentInput> | StudentSemesterRegistrationCourseCreateWithoutStudentInput[] | StudentSemesterRegistrationCourseUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: StudentSemesterRegistrationCourseCreateOrConnectWithoutStudentInput | StudentSemesterRegistrationCourseCreateOrConnectWithoutStudentInput[]
    createMany?: StudentSemesterRegistrationCourseCreateManyStudentInputEnvelope
    connect?: StudentSemesterRegistrationCourseWhereUniqueInput | StudentSemesterRegistrationCourseWhereUniqueInput[]
  }

  export type StudentEnrolledCourseUncheckedCreateNestedManyWithoutStudentInput = {
    create?: XOR<StudentEnrolledCourseCreateWithoutStudentInput, StudentEnrolledCourseUncheckedCreateWithoutStudentInput> | StudentEnrolledCourseCreateWithoutStudentInput[] | StudentEnrolledCourseUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: StudentEnrolledCourseCreateOrConnectWithoutStudentInput | StudentEnrolledCourseCreateOrConnectWithoutStudentInput[]
    createMany?: StudentEnrolledCourseCreateManyStudentInputEnvelope
    connect?: StudentEnrolledCourseWhereUniqueInput | StudentEnrolledCourseWhereUniqueInput[]
  }

  export type StudentEnrolledCourseMarkUncheckedCreateNestedManyWithoutStudentInput = {
    create?: XOR<StudentEnrolledCourseMarkCreateWithoutStudentInput, StudentEnrolledCourseMarkUncheckedCreateWithoutStudentInput> | StudentEnrolledCourseMarkCreateWithoutStudentInput[] | StudentEnrolledCourseMarkUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: StudentEnrolledCourseMarkCreateOrConnectWithoutStudentInput | StudentEnrolledCourseMarkCreateOrConnectWithoutStudentInput[]
    createMany?: StudentEnrolledCourseMarkCreateManyStudentInputEnvelope
    connect?: StudentEnrolledCourseMarkWhereUniqueInput | StudentEnrolledCourseMarkWhereUniqueInput[]
  }

  export type StudentSemesterPaymentUncheckedCreateNestedManyWithoutStudentInput = {
    create?: XOR<StudentSemesterPaymentCreateWithoutStudentInput, StudentSemesterPaymentUncheckedCreateWithoutStudentInput> | StudentSemesterPaymentCreateWithoutStudentInput[] | StudentSemesterPaymentUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: StudentSemesterPaymentCreateOrConnectWithoutStudentInput | StudentSemesterPaymentCreateOrConnectWithoutStudentInput[]
    createMany?: StudentSemesterPaymentCreateManyStudentInputEnvelope
    connect?: StudentSemesterPaymentWhereUniqueInput | StudentSemesterPaymentWhereUniqueInput[]
  }

  export type StudentAcademicInfoUncheckedCreateNestedManyWithoutStudentInput = {
    create?: XOR<StudentAcademicInfoCreateWithoutStudentInput, StudentAcademicInfoUncheckedCreateWithoutStudentInput> | StudentAcademicInfoCreateWithoutStudentInput[] | StudentAcademicInfoUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: StudentAcademicInfoCreateOrConnectWithoutStudentInput | StudentAcademicInfoCreateOrConnectWithoutStudentInput[]
    createMany?: StudentAcademicInfoCreateManyStudentInputEnvelope
    connect?: StudentAcademicInfoWhereUniqueInput | StudentAcademicInfoWhereUniqueInput[]
  }

  export type StudentCarriedCourseUncheckedCreateNestedManyWithoutStudentInput = {
    create?: XOR<StudentCarriedCourseCreateWithoutStudentInput, StudentCarriedCourseUncheckedCreateWithoutStudentInput> | StudentCarriedCourseCreateWithoutStudentInput[] | StudentCarriedCourseUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: StudentCarriedCourseCreateOrConnectWithoutStudentInput | StudentCarriedCourseCreateOrConnectWithoutStudentInput[]
    createMany?: StudentCarriedCourseCreateManyStudentInputEnvelope
    connect?: StudentCarriedCourseWhereUniqueInput | StudentCarriedCourseWhereUniqueInput[]
  }

  export type EnumStudentTypeFieldUpdateOperationsInput = {
    set?: $Enums.StudentType
  }

  export type EnumShiftFieldUpdateOperationsInput = {
    set?: $Enums.Shift
  }

  export type EnumYearLevelFieldUpdateOperationsInput = {
    set?: $Enums.YearLevel
  }

  export type AcademicFacultyUpdateOneRequiredWithoutStudentsNestedInput = {
    create?: XOR<AcademicFacultyCreateWithoutStudentsInput, AcademicFacultyUncheckedCreateWithoutStudentsInput>
    connectOrCreate?: AcademicFacultyCreateOrConnectWithoutStudentsInput
    upsert?: AcademicFacultyUpsertWithoutStudentsInput
    connect?: AcademicFacultyWhereUniqueInput
    update?: XOR<XOR<AcademicFacultyUpdateToOneWithWhereWithoutStudentsInput, AcademicFacultyUpdateWithoutStudentsInput>, AcademicFacultyUncheckedUpdateWithoutStudentsInput>
  }

  export type AdmitionExameRegistrationUpdateOneWithoutStudentNestedInput = {
    create?: XOR<AdmitionExameRegistrationCreateWithoutStudentInput, AdmitionExameRegistrationUncheckedCreateWithoutStudentInput>
    connectOrCreate?: AdmitionExameRegistrationCreateOrConnectWithoutStudentInput
    upsert?: AdmitionExameRegistrationUpsertWithoutStudentInput
    disconnect?: AdmitionExameRegistrationWhereInput | boolean
    delete?: AdmitionExameRegistrationWhereInput | boolean
    connect?: AdmitionExameRegistrationWhereUniqueInput
    update?: XOR<XOR<AdmitionExameRegistrationUpdateToOneWithWhereWithoutStudentInput, AdmitionExameRegistrationUpdateWithoutStudentInput>, AdmitionExameRegistrationUncheckedUpdateWithoutStudentInput>
  }

  export type AcademicDepartmentUpdateOneRequiredWithoutStudentsNestedInput = {
    create?: XOR<AcademicDepartmentCreateWithoutStudentsInput, AcademicDepartmentUncheckedCreateWithoutStudentsInput>
    connectOrCreate?: AcademicDepartmentCreateOrConnectWithoutStudentsInput
    upsert?: AcademicDepartmentUpsertWithoutStudentsInput
    connect?: AcademicDepartmentWhereUniqueInput
    update?: XOR<XOR<AcademicDepartmentUpdateToOneWithWhereWithoutStudentsInput, AcademicDepartmentUpdateWithoutStudentsInput>, AcademicDepartmentUncheckedUpdateWithoutStudentsInput>
  }

  export type AcademicSemesterUpdateOneRequiredWithoutStudentsNestedInput = {
    create?: XOR<AcademicSemesterCreateWithoutStudentsInput, AcademicSemesterUncheckedCreateWithoutStudentsInput>
    connectOrCreate?: AcademicSemesterCreateOrConnectWithoutStudentsInput
    upsert?: AcademicSemesterUpsertWithoutStudentsInput
    connect?: AcademicSemesterWhereUniqueInput
    update?: XOR<XOR<AcademicSemesterUpdateToOneWithWhereWithoutStudentsInput, AcademicSemesterUpdateWithoutStudentsInput>, AcademicSemesterUncheckedUpdateWithoutStudentsInput>
  }

  export type StudentSemesterRegistrationUpdateManyWithoutStudentNestedInput = {
    create?: XOR<StudentSemesterRegistrationCreateWithoutStudentInput, StudentSemesterRegistrationUncheckedCreateWithoutStudentInput> | StudentSemesterRegistrationCreateWithoutStudentInput[] | StudentSemesterRegistrationUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: StudentSemesterRegistrationCreateOrConnectWithoutStudentInput | StudentSemesterRegistrationCreateOrConnectWithoutStudentInput[]
    upsert?: StudentSemesterRegistrationUpsertWithWhereUniqueWithoutStudentInput | StudentSemesterRegistrationUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: StudentSemesterRegistrationCreateManyStudentInputEnvelope
    set?: StudentSemesterRegistrationWhereUniqueInput | StudentSemesterRegistrationWhereUniqueInput[]
    disconnect?: StudentSemesterRegistrationWhereUniqueInput | StudentSemesterRegistrationWhereUniqueInput[]
    delete?: StudentSemesterRegistrationWhereUniqueInput | StudentSemesterRegistrationWhereUniqueInput[]
    connect?: StudentSemesterRegistrationWhereUniqueInput | StudentSemesterRegistrationWhereUniqueInput[]
    update?: StudentSemesterRegistrationUpdateWithWhereUniqueWithoutStudentInput | StudentSemesterRegistrationUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: StudentSemesterRegistrationUpdateManyWithWhereWithoutStudentInput | StudentSemesterRegistrationUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: StudentSemesterRegistrationScalarWhereInput | StudentSemesterRegistrationScalarWhereInput[]
  }

  export type StudentSemesterRegistrationCourseUpdateManyWithoutStudentNestedInput = {
    create?: XOR<StudentSemesterRegistrationCourseCreateWithoutStudentInput, StudentSemesterRegistrationCourseUncheckedCreateWithoutStudentInput> | StudentSemesterRegistrationCourseCreateWithoutStudentInput[] | StudentSemesterRegistrationCourseUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: StudentSemesterRegistrationCourseCreateOrConnectWithoutStudentInput | StudentSemesterRegistrationCourseCreateOrConnectWithoutStudentInput[]
    upsert?: StudentSemesterRegistrationCourseUpsertWithWhereUniqueWithoutStudentInput | StudentSemesterRegistrationCourseUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: StudentSemesterRegistrationCourseCreateManyStudentInputEnvelope
    set?: StudentSemesterRegistrationCourseWhereUniqueInput | StudentSemesterRegistrationCourseWhereUniqueInput[]
    disconnect?: StudentSemesterRegistrationCourseWhereUniqueInput | StudentSemesterRegistrationCourseWhereUniqueInput[]
    delete?: StudentSemesterRegistrationCourseWhereUniqueInput | StudentSemesterRegistrationCourseWhereUniqueInput[]
    connect?: StudentSemesterRegistrationCourseWhereUniqueInput | StudentSemesterRegistrationCourseWhereUniqueInput[]
    update?: StudentSemesterRegistrationCourseUpdateWithWhereUniqueWithoutStudentInput | StudentSemesterRegistrationCourseUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: StudentSemesterRegistrationCourseUpdateManyWithWhereWithoutStudentInput | StudentSemesterRegistrationCourseUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: StudentSemesterRegistrationCourseScalarWhereInput | StudentSemesterRegistrationCourseScalarWhereInput[]
  }

  export type StudentEnrolledCourseUpdateManyWithoutStudentNestedInput = {
    create?: XOR<StudentEnrolledCourseCreateWithoutStudentInput, StudentEnrolledCourseUncheckedCreateWithoutStudentInput> | StudentEnrolledCourseCreateWithoutStudentInput[] | StudentEnrolledCourseUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: StudentEnrolledCourseCreateOrConnectWithoutStudentInput | StudentEnrolledCourseCreateOrConnectWithoutStudentInput[]
    upsert?: StudentEnrolledCourseUpsertWithWhereUniqueWithoutStudentInput | StudentEnrolledCourseUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: StudentEnrolledCourseCreateManyStudentInputEnvelope
    set?: StudentEnrolledCourseWhereUniqueInput | StudentEnrolledCourseWhereUniqueInput[]
    disconnect?: StudentEnrolledCourseWhereUniqueInput | StudentEnrolledCourseWhereUniqueInput[]
    delete?: StudentEnrolledCourseWhereUniqueInput | StudentEnrolledCourseWhereUniqueInput[]
    connect?: StudentEnrolledCourseWhereUniqueInput | StudentEnrolledCourseWhereUniqueInput[]
    update?: StudentEnrolledCourseUpdateWithWhereUniqueWithoutStudentInput | StudentEnrolledCourseUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: StudentEnrolledCourseUpdateManyWithWhereWithoutStudentInput | StudentEnrolledCourseUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: StudentEnrolledCourseScalarWhereInput | StudentEnrolledCourseScalarWhereInput[]
  }

  export type StudentEnrolledCourseMarkUpdateManyWithoutStudentNestedInput = {
    create?: XOR<StudentEnrolledCourseMarkCreateWithoutStudentInput, StudentEnrolledCourseMarkUncheckedCreateWithoutStudentInput> | StudentEnrolledCourseMarkCreateWithoutStudentInput[] | StudentEnrolledCourseMarkUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: StudentEnrolledCourseMarkCreateOrConnectWithoutStudentInput | StudentEnrolledCourseMarkCreateOrConnectWithoutStudentInput[]
    upsert?: StudentEnrolledCourseMarkUpsertWithWhereUniqueWithoutStudentInput | StudentEnrolledCourseMarkUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: StudentEnrolledCourseMarkCreateManyStudentInputEnvelope
    set?: StudentEnrolledCourseMarkWhereUniqueInput | StudentEnrolledCourseMarkWhereUniqueInput[]
    disconnect?: StudentEnrolledCourseMarkWhereUniqueInput | StudentEnrolledCourseMarkWhereUniqueInput[]
    delete?: StudentEnrolledCourseMarkWhereUniqueInput | StudentEnrolledCourseMarkWhereUniqueInput[]
    connect?: StudentEnrolledCourseMarkWhereUniqueInput | StudentEnrolledCourseMarkWhereUniqueInput[]
    update?: StudentEnrolledCourseMarkUpdateWithWhereUniqueWithoutStudentInput | StudentEnrolledCourseMarkUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: StudentEnrolledCourseMarkUpdateManyWithWhereWithoutStudentInput | StudentEnrolledCourseMarkUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: StudentEnrolledCourseMarkScalarWhereInput | StudentEnrolledCourseMarkScalarWhereInput[]
  }

  export type StudentSemesterPaymentUpdateManyWithoutStudentNestedInput = {
    create?: XOR<StudentSemesterPaymentCreateWithoutStudentInput, StudentSemesterPaymentUncheckedCreateWithoutStudentInput> | StudentSemesterPaymentCreateWithoutStudentInput[] | StudentSemesterPaymentUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: StudentSemesterPaymentCreateOrConnectWithoutStudentInput | StudentSemesterPaymentCreateOrConnectWithoutStudentInput[]
    upsert?: StudentSemesterPaymentUpsertWithWhereUniqueWithoutStudentInput | StudentSemesterPaymentUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: StudentSemesterPaymentCreateManyStudentInputEnvelope
    set?: StudentSemesterPaymentWhereUniqueInput | StudentSemesterPaymentWhereUniqueInput[]
    disconnect?: StudentSemesterPaymentWhereUniqueInput | StudentSemesterPaymentWhereUniqueInput[]
    delete?: StudentSemesterPaymentWhereUniqueInput | StudentSemesterPaymentWhereUniqueInput[]
    connect?: StudentSemesterPaymentWhereUniqueInput | StudentSemesterPaymentWhereUniqueInput[]
    update?: StudentSemesterPaymentUpdateWithWhereUniqueWithoutStudentInput | StudentSemesterPaymentUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: StudentSemesterPaymentUpdateManyWithWhereWithoutStudentInput | StudentSemesterPaymentUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: StudentSemesterPaymentScalarWhereInput | StudentSemesterPaymentScalarWhereInput[]
  }

  export type StudentAcademicInfoUpdateManyWithoutStudentNestedInput = {
    create?: XOR<StudentAcademicInfoCreateWithoutStudentInput, StudentAcademicInfoUncheckedCreateWithoutStudentInput> | StudentAcademicInfoCreateWithoutStudentInput[] | StudentAcademicInfoUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: StudentAcademicInfoCreateOrConnectWithoutStudentInput | StudentAcademicInfoCreateOrConnectWithoutStudentInput[]
    upsert?: StudentAcademicInfoUpsertWithWhereUniqueWithoutStudentInput | StudentAcademicInfoUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: StudentAcademicInfoCreateManyStudentInputEnvelope
    set?: StudentAcademicInfoWhereUniqueInput | StudentAcademicInfoWhereUniqueInput[]
    disconnect?: StudentAcademicInfoWhereUniqueInput | StudentAcademicInfoWhereUniqueInput[]
    delete?: StudentAcademicInfoWhereUniqueInput | StudentAcademicInfoWhereUniqueInput[]
    connect?: StudentAcademicInfoWhereUniqueInput | StudentAcademicInfoWhereUniqueInput[]
    update?: StudentAcademicInfoUpdateWithWhereUniqueWithoutStudentInput | StudentAcademicInfoUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: StudentAcademicInfoUpdateManyWithWhereWithoutStudentInput | StudentAcademicInfoUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: StudentAcademicInfoScalarWhereInput | StudentAcademicInfoScalarWhereInput[]
  }

  export type StudentCarriedCourseUpdateManyWithoutStudentNestedInput = {
    create?: XOR<StudentCarriedCourseCreateWithoutStudentInput, StudentCarriedCourseUncheckedCreateWithoutStudentInput> | StudentCarriedCourseCreateWithoutStudentInput[] | StudentCarriedCourseUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: StudentCarriedCourseCreateOrConnectWithoutStudentInput | StudentCarriedCourseCreateOrConnectWithoutStudentInput[]
    upsert?: StudentCarriedCourseUpsertWithWhereUniqueWithoutStudentInput | StudentCarriedCourseUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: StudentCarriedCourseCreateManyStudentInputEnvelope
    set?: StudentCarriedCourseWhereUniqueInput | StudentCarriedCourseWhereUniqueInput[]
    disconnect?: StudentCarriedCourseWhereUniqueInput | StudentCarriedCourseWhereUniqueInput[]
    delete?: StudentCarriedCourseWhereUniqueInput | StudentCarriedCourseWhereUniqueInput[]
    connect?: StudentCarriedCourseWhereUniqueInput | StudentCarriedCourseWhereUniqueInput[]
    update?: StudentCarriedCourseUpdateWithWhereUniqueWithoutStudentInput | StudentCarriedCourseUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: StudentCarriedCourseUpdateManyWithWhereWithoutStudentInput | StudentCarriedCourseUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: StudentCarriedCourseScalarWhereInput | StudentCarriedCourseScalarWhereInput[]
  }

  export type StudentSemesterRegistrationUncheckedUpdateManyWithoutStudentNestedInput = {
    create?: XOR<StudentSemesterRegistrationCreateWithoutStudentInput, StudentSemesterRegistrationUncheckedCreateWithoutStudentInput> | StudentSemesterRegistrationCreateWithoutStudentInput[] | StudentSemesterRegistrationUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: StudentSemesterRegistrationCreateOrConnectWithoutStudentInput | StudentSemesterRegistrationCreateOrConnectWithoutStudentInput[]
    upsert?: StudentSemesterRegistrationUpsertWithWhereUniqueWithoutStudentInput | StudentSemesterRegistrationUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: StudentSemesterRegistrationCreateManyStudentInputEnvelope
    set?: StudentSemesterRegistrationWhereUniqueInput | StudentSemesterRegistrationWhereUniqueInput[]
    disconnect?: StudentSemesterRegistrationWhereUniqueInput | StudentSemesterRegistrationWhereUniqueInput[]
    delete?: StudentSemesterRegistrationWhereUniqueInput | StudentSemesterRegistrationWhereUniqueInput[]
    connect?: StudentSemesterRegistrationWhereUniqueInput | StudentSemesterRegistrationWhereUniqueInput[]
    update?: StudentSemesterRegistrationUpdateWithWhereUniqueWithoutStudentInput | StudentSemesterRegistrationUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: StudentSemesterRegistrationUpdateManyWithWhereWithoutStudentInput | StudentSemesterRegistrationUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: StudentSemesterRegistrationScalarWhereInput | StudentSemesterRegistrationScalarWhereInput[]
  }

  export type StudentSemesterRegistrationCourseUncheckedUpdateManyWithoutStudentNestedInput = {
    create?: XOR<StudentSemesterRegistrationCourseCreateWithoutStudentInput, StudentSemesterRegistrationCourseUncheckedCreateWithoutStudentInput> | StudentSemesterRegistrationCourseCreateWithoutStudentInput[] | StudentSemesterRegistrationCourseUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: StudentSemesterRegistrationCourseCreateOrConnectWithoutStudentInput | StudentSemesterRegistrationCourseCreateOrConnectWithoutStudentInput[]
    upsert?: StudentSemesterRegistrationCourseUpsertWithWhereUniqueWithoutStudentInput | StudentSemesterRegistrationCourseUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: StudentSemesterRegistrationCourseCreateManyStudentInputEnvelope
    set?: StudentSemesterRegistrationCourseWhereUniqueInput | StudentSemesterRegistrationCourseWhereUniqueInput[]
    disconnect?: StudentSemesterRegistrationCourseWhereUniqueInput | StudentSemesterRegistrationCourseWhereUniqueInput[]
    delete?: StudentSemesterRegistrationCourseWhereUniqueInput | StudentSemesterRegistrationCourseWhereUniqueInput[]
    connect?: StudentSemesterRegistrationCourseWhereUniqueInput | StudentSemesterRegistrationCourseWhereUniqueInput[]
    update?: StudentSemesterRegistrationCourseUpdateWithWhereUniqueWithoutStudentInput | StudentSemesterRegistrationCourseUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: StudentSemesterRegistrationCourseUpdateManyWithWhereWithoutStudentInput | StudentSemesterRegistrationCourseUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: StudentSemesterRegistrationCourseScalarWhereInput | StudentSemesterRegistrationCourseScalarWhereInput[]
  }

  export type StudentEnrolledCourseUncheckedUpdateManyWithoutStudentNestedInput = {
    create?: XOR<StudentEnrolledCourseCreateWithoutStudentInput, StudentEnrolledCourseUncheckedCreateWithoutStudentInput> | StudentEnrolledCourseCreateWithoutStudentInput[] | StudentEnrolledCourseUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: StudentEnrolledCourseCreateOrConnectWithoutStudentInput | StudentEnrolledCourseCreateOrConnectWithoutStudentInput[]
    upsert?: StudentEnrolledCourseUpsertWithWhereUniqueWithoutStudentInput | StudentEnrolledCourseUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: StudentEnrolledCourseCreateManyStudentInputEnvelope
    set?: StudentEnrolledCourseWhereUniqueInput | StudentEnrolledCourseWhereUniqueInput[]
    disconnect?: StudentEnrolledCourseWhereUniqueInput | StudentEnrolledCourseWhereUniqueInput[]
    delete?: StudentEnrolledCourseWhereUniqueInput | StudentEnrolledCourseWhereUniqueInput[]
    connect?: StudentEnrolledCourseWhereUniqueInput | StudentEnrolledCourseWhereUniqueInput[]
    update?: StudentEnrolledCourseUpdateWithWhereUniqueWithoutStudentInput | StudentEnrolledCourseUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: StudentEnrolledCourseUpdateManyWithWhereWithoutStudentInput | StudentEnrolledCourseUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: StudentEnrolledCourseScalarWhereInput | StudentEnrolledCourseScalarWhereInput[]
  }

  export type StudentEnrolledCourseMarkUncheckedUpdateManyWithoutStudentNestedInput = {
    create?: XOR<StudentEnrolledCourseMarkCreateWithoutStudentInput, StudentEnrolledCourseMarkUncheckedCreateWithoutStudentInput> | StudentEnrolledCourseMarkCreateWithoutStudentInput[] | StudentEnrolledCourseMarkUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: StudentEnrolledCourseMarkCreateOrConnectWithoutStudentInput | StudentEnrolledCourseMarkCreateOrConnectWithoutStudentInput[]
    upsert?: StudentEnrolledCourseMarkUpsertWithWhereUniqueWithoutStudentInput | StudentEnrolledCourseMarkUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: StudentEnrolledCourseMarkCreateManyStudentInputEnvelope
    set?: StudentEnrolledCourseMarkWhereUniqueInput | StudentEnrolledCourseMarkWhereUniqueInput[]
    disconnect?: StudentEnrolledCourseMarkWhereUniqueInput | StudentEnrolledCourseMarkWhereUniqueInput[]
    delete?: StudentEnrolledCourseMarkWhereUniqueInput | StudentEnrolledCourseMarkWhereUniqueInput[]
    connect?: StudentEnrolledCourseMarkWhereUniqueInput | StudentEnrolledCourseMarkWhereUniqueInput[]
    update?: StudentEnrolledCourseMarkUpdateWithWhereUniqueWithoutStudentInput | StudentEnrolledCourseMarkUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: StudentEnrolledCourseMarkUpdateManyWithWhereWithoutStudentInput | StudentEnrolledCourseMarkUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: StudentEnrolledCourseMarkScalarWhereInput | StudentEnrolledCourseMarkScalarWhereInput[]
  }

  export type StudentSemesterPaymentUncheckedUpdateManyWithoutStudentNestedInput = {
    create?: XOR<StudentSemesterPaymentCreateWithoutStudentInput, StudentSemesterPaymentUncheckedCreateWithoutStudentInput> | StudentSemesterPaymentCreateWithoutStudentInput[] | StudentSemesterPaymentUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: StudentSemesterPaymentCreateOrConnectWithoutStudentInput | StudentSemesterPaymentCreateOrConnectWithoutStudentInput[]
    upsert?: StudentSemesterPaymentUpsertWithWhereUniqueWithoutStudentInput | StudentSemesterPaymentUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: StudentSemesterPaymentCreateManyStudentInputEnvelope
    set?: StudentSemesterPaymentWhereUniqueInput | StudentSemesterPaymentWhereUniqueInput[]
    disconnect?: StudentSemesterPaymentWhereUniqueInput | StudentSemesterPaymentWhereUniqueInput[]
    delete?: StudentSemesterPaymentWhereUniqueInput | StudentSemesterPaymentWhereUniqueInput[]
    connect?: StudentSemesterPaymentWhereUniqueInput | StudentSemesterPaymentWhereUniqueInput[]
    update?: StudentSemesterPaymentUpdateWithWhereUniqueWithoutStudentInput | StudentSemesterPaymentUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: StudentSemesterPaymentUpdateManyWithWhereWithoutStudentInput | StudentSemesterPaymentUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: StudentSemesterPaymentScalarWhereInput | StudentSemesterPaymentScalarWhereInput[]
  }

  export type StudentAcademicInfoUncheckedUpdateManyWithoutStudentNestedInput = {
    create?: XOR<StudentAcademicInfoCreateWithoutStudentInput, StudentAcademicInfoUncheckedCreateWithoutStudentInput> | StudentAcademicInfoCreateWithoutStudentInput[] | StudentAcademicInfoUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: StudentAcademicInfoCreateOrConnectWithoutStudentInput | StudentAcademicInfoCreateOrConnectWithoutStudentInput[]
    upsert?: StudentAcademicInfoUpsertWithWhereUniqueWithoutStudentInput | StudentAcademicInfoUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: StudentAcademicInfoCreateManyStudentInputEnvelope
    set?: StudentAcademicInfoWhereUniqueInput | StudentAcademicInfoWhereUniqueInput[]
    disconnect?: StudentAcademicInfoWhereUniqueInput | StudentAcademicInfoWhereUniqueInput[]
    delete?: StudentAcademicInfoWhereUniqueInput | StudentAcademicInfoWhereUniqueInput[]
    connect?: StudentAcademicInfoWhereUniqueInput | StudentAcademicInfoWhereUniqueInput[]
    update?: StudentAcademicInfoUpdateWithWhereUniqueWithoutStudentInput | StudentAcademicInfoUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: StudentAcademicInfoUpdateManyWithWhereWithoutStudentInput | StudentAcademicInfoUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: StudentAcademicInfoScalarWhereInput | StudentAcademicInfoScalarWhereInput[]
  }

  export type StudentCarriedCourseUncheckedUpdateManyWithoutStudentNestedInput = {
    create?: XOR<StudentCarriedCourseCreateWithoutStudentInput, StudentCarriedCourseUncheckedCreateWithoutStudentInput> | StudentCarriedCourseCreateWithoutStudentInput[] | StudentCarriedCourseUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: StudentCarriedCourseCreateOrConnectWithoutStudentInput | StudentCarriedCourseCreateOrConnectWithoutStudentInput[]
    upsert?: StudentCarriedCourseUpsertWithWhereUniqueWithoutStudentInput | StudentCarriedCourseUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: StudentCarriedCourseCreateManyStudentInputEnvelope
    set?: StudentCarriedCourseWhereUniqueInput | StudentCarriedCourseWhereUniqueInput[]
    disconnect?: StudentCarriedCourseWhereUniqueInput | StudentCarriedCourseWhereUniqueInput[]
    delete?: StudentCarriedCourseWhereUniqueInput | StudentCarriedCourseWhereUniqueInput[]
    connect?: StudentCarriedCourseWhereUniqueInput | StudentCarriedCourseWhereUniqueInput[]
    update?: StudentCarriedCourseUpdateWithWhereUniqueWithoutStudentInput | StudentCarriedCourseUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: StudentCarriedCourseUpdateManyWithWhereWithoutStudentInput | StudentCarriedCourseUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: StudentCarriedCourseScalarWhereInput | StudentCarriedCourseScalarWhereInput[]
  }

  export type CourseFacultyCreateNestedManyWithoutFacultyInput = {
    create?: XOR<CourseFacultyCreateWithoutFacultyInput, CourseFacultyUncheckedCreateWithoutFacultyInput> | CourseFacultyCreateWithoutFacultyInput[] | CourseFacultyUncheckedCreateWithoutFacultyInput[]
    connectOrCreate?: CourseFacultyCreateOrConnectWithoutFacultyInput | CourseFacultyCreateOrConnectWithoutFacultyInput[]
    createMany?: CourseFacultyCreateManyFacultyInputEnvelope
    connect?: CourseFacultyWhereUniqueInput | CourseFacultyWhereUniqueInput[]
  }

  export type AcademicDepartmentCreateNestedOneWithoutFacultiesInput = {
    create?: XOR<AcademicDepartmentCreateWithoutFacultiesInput, AcademicDepartmentUncheckedCreateWithoutFacultiesInput>
    connectOrCreate?: AcademicDepartmentCreateOrConnectWithoutFacultiesInput
    connect?: AcademicDepartmentWhereUniqueInput
  }

  export type AcademicFacultyCreateNestedOneWithoutFacultiesInput = {
    create?: XOR<AcademicFacultyCreateWithoutFacultiesInput, AcademicFacultyUncheckedCreateWithoutFacultiesInput>
    connectOrCreate?: AcademicFacultyCreateOrConnectWithoutFacultiesInput
    connect?: AcademicFacultyWhereUniqueInput
  }

  export type OfferedCourseClassScheduleCreateNestedManyWithoutFacultyInput = {
    create?: XOR<OfferedCourseClassScheduleCreateWithoutFacultyInput, OfferedCourseClassScheduleUncheckedCreateWithoutFacultyInput> | OfferedCourseClassScheduleCreateWithoutFacultyInput[] | OfferedCourseClassScheduleUncheckedCreateWithoutFacultyInput[]
    connectOrCreate?: OfferedCourseClassScheduleCreateOrConnectWithoutFacultyInput | OfferedCourseClassScheduleCreateOrConnectWithoutFacultyInput[]
    createMany?: OfferedCourseClassScheduleCreateManyFacultyInputEnvelope
    connect?: OfferedCourseClassScheduleWhereUniqueInput | OfferedCourseClassScheduleWhereUniqueInput[]
  }

  export type CourseFacultyUncheckedCreateNestedManyWithoutFacultyInput = {
    create?: XOR<CourseFacultyCreateWithoutFacultyInput, CourseFacultyUncheckedCreateWithoutFacultyInput> | CourseFacultyCreateWithoutFacultyInput[] | CourseFacultyUncheckedCreateWithoutFacultyInput[]
    connectOrCreate?: CourseFacultyCreateOrConnectWithoutFacultyInput | CourseFacultyCreateOrConnectWithoutFacultyInput[]
    createMany?: CourseFacultyCreateManyFacultyInputEnvelope
    connect?: CourseFacultyWhereUniqueInput | CourseFacultyWhereUniqueInput[]
  }

  export type OfferedCourseClassScheduleUncheckedCreateNestedManyWithoutFacultyInput = {
    create?: XOR<OfferedCourseClassScheduleCreateWithoutFacultyInput, OfferedCourseClassScheduleUncheckedCreateWithoutFacultyInput> | OfferedCourseClassScheduleCreateWithoutFacultyInput[] | OfferedCourseClassScheduleUncheckedCreateWithoutFacultyInput[]
    connectOrCreate?: OfferedCourseClassScheduleCreateOrConnectWithoutFacultyInput | OfferedCourseClassScheduleCreateOrConnectWithoutFacultyInput[]
    createMany?: OfferedCourseClassScheduleCreateManyFacultyInputEnvelope
    connect?: OfferedCourseClassScheduleWhereUniqueInput | OfferedCourseClassScheduleWhereUniqueInput[]
  }

  export type CourseFacultyUpdateManyWithoutFacultyNestedInput = {
    create?: XOR<CourseFacultyCreateWithoutFacultyInput, CourseFacultyUncheckedCreateWithoutFacultyInput> | CourseFacultyCreateWithoutFacultyInput[] | CourseFacultyUncheckedCreateWithoutFacultyInput[]
    connectOrCreate?: CourseFacultyCreateOrConnectWithoutFacultyInput | CourseFacultyCreateOrConnectWithoutFacultyInput[]
    upsert?: CourseFacultyUpsertWithWhereUniqueWithoutFacultyInput | CourseFacultyUpsertWithWhereUniqueWithoutFacultyInput[]
    createMany?: CourseFacultyCreateManyFacultyInputEnvelope
    set?: CourseFacultyWhereUniqueInput | CourseFacultyWhereUniqueInput[]
    disconnect?: CourseFacultyWhereUniqueInput | CourseFacultyWhereUniqueInput[]
    delete?: CourseFacultyWhereUniqueInput | CourseFacultyWhereUniqueInput[]
    connect?: CourseFacultyWhereUniqueInput | CourseFacultyWhereUniqueInput[]
    update?: CourseFacultyUpdateWithWhereUniqueWithoutFacultyInput | CourseFacultyUpdateWithWhereUniqueWithoutFacultyInput[]
    updateMany?: CourseFacultyUpdateManyWithWhereWithoutFacultyInput | CourseFacultyUpdateManyWithWhereWithoutFacultyInput[]
    deleteMany?: CourseFacultyScalarWhereInput | CourseFacultyScalarWhereInput[]
  }

  export type AcademicDepartmentUpdateOneRequiredWithoutFacultiesNestedInput = {
    create?: XOR<AcademicDepartmentCreateWithoutFacultiesInput, AcademicDepartmentUncheckedCreateWithoutFacultiesInput>
    connectOrCreate?: AcademicDepartmentCreateOrConnectWithoutFacultiesInput
    upsert?: AcademicDepartmentUpsertWithoutFacultiesInput
    connect?: AcademicDepartmentWhereUniqueInput
    update?: XOR<XOR<AcademicDepartmentUpdateToOneWithWhereWithoutFacultiesInput, AcademicDepartmentUpdateWithoutFacultiesInput>, AcademicDepartmentUncheckedUpdateWithoutFacultiesInput>
  }

  export type AcademicFacultyUpdateOneRequiredWithoutFacultiesNestedInput = {
    create?: XOR<AcademicFacultyCreateWithoutFacultiesInput, AcademicFacultyUncheckedCreateWithoutFacultiesInput>
    connectOrCreate?: AcademicFacultyCreateOrConnectWithoutFacultiesInput
    upsert?: AcademicFacultyUpsertWithoutFacultiesInput
    connect?: AcademicFacultyWhereUniqueInput
    update?: XOR<XOR<AcademicFacultyUpdateToOneWithWhereWithoutFacultiesInput, AcademicFacultyUpdateWithoutFacultiesInput>, AcademicFacultyUncheckedUpdateWithoutFacultiesInput>
  }

  export type OfferedCourseClassScheduleUpdateManyWithoutFacultyNestedInput = {
    create?: XOR<OfferedCourseClassScheduleCreateWithoutFacultyInput, OfferedCourseClassScheduleUncheckedCreateWithoutFacultyInput> | OfferedCourseClassScheduleCreateWithoutFacultyInput[] | OfferedCourseClassScheduleUncheckedCreateWithoutFacultyInput[]
    connectOrCreate?: OfferedCourseClassScheduleCreateOrConnectWithoutFacultyInput | OfferedCourseClassScheduleCreateOrConnectWithoutFacultyInput[]
    upsert?: OfferedCourseClassScheduleUpsertWithWhereUniqueWithoutFacultyInput | OfferedCourseClassScheduleUpsertWithWhereUniqueWithoutFacultyInput[]
    createMany?: OfferedCourseClassScheduleCreateManyFacultyInputEnvelope
    set?: OfferedCourseClassScheduleWhereUniqueInput | OfferedCourseClassScheduleWhereUniqueInput[]
    disconnect?: OfferedCourseClassScheduleWhereUniqueInput | OfferedCourseClassScheduleWhereUniqueInput[]
    delete?: OfferedCourseClassScheduleWhereUniqueInput | OfferedCourseClassScheduleWhereUniqueInput[]
    connect?: OfferedCourseClassScheduleWhereUniqueInput | OfferedCourseClassScheduleWhereUniqueInput[]
    update?: OfferedCourseClassScheduleUpdateWithWhereUniqueWithoutFacultyInput | OfferedCourseClassScheduleUpdateWithWhereUniqueWithoutFacultyInput[]
    updateMany?: OfferedCourseClassScheduleUpdateManyWithWhereWithoutFacultyInput | OfferedCourseClassScheduleUpdateManyWithWhereWithoutFacultyInput[]
    deleteMany?: OfferedCourseClassScheduleScalarWhereInput | OfferedCourseClassScheduleScalarWhereInput[]
  }

  export type CourseFacultyUncheckedUpdateManyWithoutFacultyNestedInput = {
    create?: XOR<CourseFacultyCreateWithoutFacultyInput, CourseFacultyUncheckedCreateWithoutFacultyInput> | CourseFacultyCreateWithoutFacultyInput[] | CourseFacultyUncheckedCreateWithoutFacultyInput[]
    connectOrCreate?: CourseFacultyCreateOrConnectWithoutFacultyInput | CourseFacultyCreateOrConnectWithoutFacultyInput[]
    upsert?: CourseFacultyUpsertWithWhereUniqueWithoutFacultyInput | CourseFacultyUpsertWithWhereUniqueWithoutFacultyInput[]
    createMany?: CourseFacultyCreateManyFacultyInputEnvelope
    set?: CourseFacultyWhereUniqueInput | CourseFacultyWhereUniqueInput[]
    disconnect?: CourseFacultyWhereUniqueInput | CourseFacultyWhereUniqueInput[]
    delete?: CourseFacultyWhereUniqueInput | CourseFacultyWhereUniqueInput[]
    connect?: CourseFacultyWhereUniqueInput | CourseFacultyWhereUniqueInput[]
    update?: CourseFacultyUpdateWithWhereUniqueWithoutFacultyInput | CourseFacultyUpdateWithWhereUniqueWithoutFacultyInput[]
    updateMany?: CourseFacultyUpdateManyWithWhereWithoutFacultyInput | CourseFacultyUpdateManyWithWhereWithoutFacultyInput[]
    deleteMany?: CourseFacultyScalarWhereInput | CourseFacultyScalarWhereInput[]
  }

  export type OfferedCourseClassScheduleUncheckedUpdateManyWithoutFacultyNestedInput = {
    create?: XOR<OfferedCourseClassScheduleCreateWithoutFacultyInput, OfferedCourseClassScheduleUncheckedCreateWithoutFacultyInput> | OfferedCourseClassScheduleCreateWithoutFacultyInput[] | OfferedCourseClassScheduleUncheckedCreateWithoutFacultyInput[]
    connectOrCreate?: OfferedCourseClassScheduleCreateOrConnectWithoutFacultyInput | OfferedCourseClassScheduleCreateOrConnectWithoutFacultyInput[]
    upsert?: OfferedCourseClassScheduleUpsertWithWhereUniqueWithoutFacultyInput | OfferedCourseClassScheduleUpsertWithWhereUniqueWithoutFacultyInput[]
    createMany?: OfferedCourseClassScheduleCreateManyFacultyInputEnvelope
    set?: OfferedCourseClassScheduleWhereUniqueInput | OfferedCourseClassScheduleWhereUniqueInput[]
    disconnect?: OfferedCourseClassScheduleWhereUniqueInput | OfferedCourseClassScheduleWhereUniqueInput[]
    delete?: OfferedCourseClassScheduleWhereUniqueInput | OfferedCourseClassScheduleWhereUniqueInput[]
    connect?: OfferedCourseClassScheduleWhereUniqueInput | OfferedCourseClassScheduleWhereUniqueInput[]
    update?: OfferedCourseClassScheduleUpdateWithWhereUniqueWithoutFacultyInput | OfferedCourseClassScheduleUpdateWithWhereUniqueWithoutFacultyInput[]
    updateMany?: OfferedCourseClassScheduleUpdateManyWithWhereWithoutFacultyInput | OfferedCourseClassScheduleUpdateManyWithWhereWithoutFacultyInput[]
    deleteMany?: OfferedCourseClassScheduleScalarWhereInput | OfferedCourseClassScheduleScalarWhereInput[]
  }

  export type RoomCreateNestedManyWithoutBuildingInput = {
    create?: XOR<RoomCreateWithoutBuildingInput, RoomUncheckedCreateWithoutBuildingInput> | RoomCreateWithoutBuildingInput[] | RoomUncheckedCreateWithoutBuildingInput[]
    connectOrCreate?: RoomCreateOrConnectWithoutBuildingInput | RoomCreateOrConnectWithoutBuildingInput[]
    createMany?: RoomCreateManyBuildingInputEnvelope
    connect?: RoomWhereUniqueInput | RoomWhereUniqueInput[]
  }

  export type RoomUncheckedCreateNestedManyWithoutBuildingInput = {
    create?: XOR<RoomCreateWithoutBuildingInput, RoomUncheckedCreateWithoutBuildingInput> | RoomCreateWithoutBuildingInput[] | RoomUncheckedCreateWithoutBuildingInput[]
    connectOrCreate?: RoomCreateOrConnectWithoutBuildingInput | RoomCreateOrConnectWithoutBuildingInput[]
    createMany?: RoomCreateManyBuildingInputEnvelope
    connect?: RoomWhereUniqueInput | RoomWhereUniqueInput[]
  }

  export type RoomUpdateManyWithoutBuildingNestedInput = {
    create?: XOR<RoomCreateWithoutBuildingInput, RoomUncheckedCreateWithoutBuildingInput> | RoomCreateWithoutBuildingInput[] | RoomUncheckedCreateWithoutBuildingInput[]
    connectOrCreate?: RoomCreateOrConnectWithoutBuildingInput | RoomCreateOrConnectWithoutBuildingInput[]
    upsert?: RoomUpsertWithWhereUniqueWithoutBuildingInput | RoomUpsertWithWhereUniqueWithoutBuildingInput[]
    createMany?: RoomCreateManyBuildingInputEnvelope
    set?: RoomWhereUniqueInput | RoomWhereUniqueInput[]
    disconnect?: RoomWhereUniqueInput | RoomWhereUniqueInput[]
    delete?: RoomWhereUniqueInput | RoomWhereUniqueInput[]
    connect?: RoomWhereUniqueInput | RoomWhereUniqueInput[]
    update?: RoomUpdateWithWhereUniqueWithoutBuildingInput | RoomUpdateWithWhereUniqueWithoutBuildingInput[]
    updateMany?: RoomUpdateManyWithWhereWithoutBuildingInput | RoomUpdateManyWithWhereWithoutBuildingInput[]
    deleteMany?: RoomScalarWhereInput | RoomScalarWhereInput[]
  }

  export type RoomUncheckedUpdateManyWithoutBuildingNestedInput = {
    create?: XOR<RoomCreateWithoutBuildingInput, RoomUncheckedCreateWithoutBuildingInput> | RoomCreateWithoutBuildingInput[] | RoomUncheckedCreateWithoutBuildingInput[]
    connectOrCreate?: RoomCreateOrConnectWithoutBuildingInput | RoomCreateOrConnectWithoutBuildingInput[]
    upsert?: RoomUpsertWithWhereUniqueWithoutBuildingInput | RoomUpsertWithWhereUniqueWithoutBuildingInput[]
    createMany?: RoomCreateManyBuildingInputEnvelope
    set?: RoomWhereUniqueInput | RoomWhereUniqueInput[]
    disconnect?: RoomWhereUniqueInput | RoomWhereUniqueInput[]
    delete?: RoomWhereUniqueInput | RoomWhereUniqueInput[]
    connect?: RoomWhereUniqueInput | RoomWhereUniqueInput[]
    update?: RoomUpdateWithWhereUniqueWithoutBuildingInput | RoomUpdateWithWhereUniqueWithoutBuildingInput[]
    updateMany?: RoomUpdateManyWithWhereWithoutBuildingInput | RoomUpdateManyWithWhereWithoutBuildingInput[]
    deleteMany?: RoomScalarWhereInput | RoomScalarWhereInput[]
  }

  export type BuildingCreateNestedOneWithoutRoomsInput = {
    create?: XOR<BuildingCreateWithoutRoomsInput, BuildingUncheckedCreateWithoutRoomsInput>
    connectOrCreate?: BuildingCreateOrConnectWithoutRoomsInput
    connect?: BuildingWhereUniqueInput
  }

  export type OfferedCourseClassScheduleCreateNestedManyWithoutRoomInput = {
    create?: XOR<OfferedCourseClassScheduleCreateWithoutRoomInput, OfferedCourseClassScheduleUncheckedCreateWithoutRoomInput> | OfferedCourseClassScheduleCreateWithoutRoomInput[] | OfferedCourseClassScheduleUncheckedCreateWithoutRoomInput[]
    connectOrCreate?: OfferedCourseClassScheduleCreateOrConnectWithoutRoomInput | OfferedCourseClassScheduleCreateOrConnectWithoutRoomInput[]
    createMany?: OfferedCourseClassScheduleCreateManyRoomInputEnvelope
    connect?: OfferedCourseClassScheduleWhereUniqueInput | OfferedCourseClassScheduleWhereUniqueInput[]
  }

  export type OfferedCourseClassScheduleUncheckedCreateNestedManyWithoutRoomInput = {
    create?: XOR<OfferedCourseClassScheduleCreateWithoutRoomInput, OfferedCourseClassScheduleUncheckedCreateWithoutRoomInput> | OfferedCourseClassScheduleCreateWithoutRoomInput[] | OfferedCourseClassScheduleUncheckedCreateWithoutRoomInput[]
    connectOrCreate?: OfferedCourseClassScheduleCreateOrConnectWithoutRoomInput | OfferedCourseClassScheduleCreateOrConnectWithoutRoomInput[]
    createMany?: OfferedCourseClassScheduleCreateManyRoomInputEnvelope
    connect?: OfferedCourseClassScheduleWhereUniqueInput | OfferedCourseClassScheduleWhereUniqueInput[]
  }

  export type BuildingUpdateOneRequiredWithoutRoomsNestedInput = {
    create?: XOR<BuildingCreateWithoutRoomsInput, BuildingUncheckedCreateWithoutRoomsInput>
    connectOrCreate?: BuildingCreateOrConnectWithoutRoomsInput
    upsert?: BuildingUpsertWithoutRoomsInput
    connect?: BuildingWhereUniqueInput
    update?: XOR<XOR<BuildingUpdateToOneWithWhereWithoutRoomsInput, BuildingUpdateWithoutRoomsInput>, BuildingUncheckedUpdateWithoutRoomsInput>
  }

  export type OfferedCourseClassScheduleUpdateManyWithoutRoomNestedInput = {
    create?: XOR<OfferedCourseClassScheduleCreateWithoutRoomInput, OfferedCourseClassScheduleUncheckedCreateWithoutRoomInput> | OfferedCourseClassScheduleCreateWithoutRoomInput[] | OfferedCourseClassScheduleUncheckedCreateWithoutRoomInput[]
    connectOrCreate?: OfferedCourseClassScheduleCreateOrConnectWithoutRoomInput | OfferedCourseClassScheduleCreateOrConnectWithoutRoomInput[]
    upsert?: OfferedCourseClassScheduleUpsertWithWhereUniqueWithoutRoomInput | OfferedCourseClassScheduleUpsertWithWhereUniqueWithoutRoomInput[]
    createMany?: OfferedCourseClassScheduleCreateManyRoomInputEnvelope
    set?: OfferedCourseClassScheduleWhereUniqueInput | OfferedCourseClassScheduleWhereUniqueInput[]
    disconnect?: OfferedCourseClassScheduleWhereUniqueInput | OfferedCourseClassScheduleWhereUniqueInput[]
    delete?: OfferedCourseClassScheduleWhereUniqueInput | OfferedCourseClassScheduleWhereUniqueInput[]
    connect?: OfferedCourseClassScheduleWhereUniqueInput | OfferedCourseClassScheduleWhereUniqueInput[]
    update?: OfferedCourseClassScheduleUpdateWithWhereUniqueWithoutRoomInput | OfferedCourseClassScheduleUpdateWithWhereUniqueWithoutRoomInput[]
    updateMany?: OfferedCourseClassScheduleUpdateManyWithWhereWithoutRoomInput | OfferedCourseClassScheduleUpdateManyWithWhereWithoutRoomInput[]
    deleteMany?: OfferedCourseClassScheduleScalarWhereInput | OfferedCourseClassScheduleScalarWhereInput[]
  }

  export type OfferedCourseClassScheduleUncheckedUpdateManyWithoutRoomNestedInput = {
    create?: XOR<OfferedCourseClassScheduleCreateWithoutRoomInput, OfferedCourseClassScheduleUncheckedCreateWithoutRoomInput> | OfferedCourseClassScheduleCreateWithoutRoomInput[] | OfferedCourseClassScheduleUncheckedCreateWithoutRoomInput[]
    connectOrCreate?: OfferedCourseClassScheduleCreateOrConnectWithoutRoomInput | OfferedCourseClassScheduleCreateOrConnectWithoutRoomInput[]
    upsert?: OfferedCourseClassScheduleUpsertWithWhereUniqueWithoutRoomInput | OfferedCourseClassScheduleUpsertWithWhereUniqueWithoutRoomInput[]
    createMany?: OfferedCourseClassScheduleCreateManyRoomInputEnvelope
    set?: OfferedCourseClassScheduleWhereUniqueInput | OfferedCourseClassScheduleWhereUniqueInput[]
    disconnect?: OfferedCourseClassScheduleWhereUniqueInput | OfferedCourseClassScheduleWhereUniqueInput[]
    delete?: OfferedCourseClassScheduleWhereUniqueInput | OfferedCourseClassScheduleWhereUniqueInput[]
    connect?: OfferedCourseClassScheduleWhereUniqueInput | OfferedCourseClassScheduleWhereUniqueInput[]
    update?: OfferedCourseClassScheduleUpdateWithWhereUniqueWithoutRoomInput | OfferedCourseClassScheduleUpdateWithWhereUniqueWithoutRoomInput[]
    updateMany?: OfferedCourseClassScheduleUpdateManyWithWhereWithoutRoomInput | OfferedCourseClassScheduleUpdateManyWithWhereWithoutRoomInput[]
    deleteMany?: OfferedCourseClassScheduleScalarWhereInput | OfferedCourseClassScheduleScalarWhereInput[]
  }

  export type CourseDisciplineCreateNestedManyWithoutCourseInput = {
    create?: XOR<CourseDisciplineCreateWithoutCourseInput, CourseDisciplineUncheckedCreateWithoutCourseInput> | CourseDisciplineCreateWithoutCourseInput[] | CourseDisciplineUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: CourseDisciplineCreateOrConnectWithoutCourseInput | CourseDisciplineCreateOrConnectWithoutCourseInput[]
    createMany?: CourseDisciplineCreateManyCourseInputEnvelope
    connect?: CourseDisciplineWhereUniqueInput | CourseDisciplineWhereUniqueInput[]
  }

  export type CoursePricingCreateNestedOneWithoutCourseInput = {
    create?: XOR<CoursePricingCreateWithoutCourseInput, CoursePricingUncheckedCreateWithoutCourseInput>
    connectOrCreate?: CoursePricingCreateOrConnectWithoutCourseInput
    connect?: CoursePricingWhereUniqueInput
  }

  export type AcademicDepartmentCreateNestedOneWithoutCoursesInput = {
    create?: XOR<AcademicDepartmentCreateWithoutCoursesInput, AcademicDepartmentUncheckedCreateWithoutCoursesInput>
    connectOrCreate?: AcademicDepartmentCreateOrConnectWithoutCoursesInput
    connect?: AcademicDepartmentWhereUniqueInput
  }

  export type StudentEnrolledCourseCreateNestedManyWithoutCourseInput = {
    create?: XOR<StudentEnrolledCourseCreateWithoutCourseInput, StudentEnrolledCourseUncheckedCreateWithoutCourseInput> | StudentEnrolledCourseCreateWithoutCourseInput[] | StudentEnrolledCourseUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: StudentEnrolledCourseCreateOrConnectWithoutCourseInput | StudentEnrolledCourseCreateOrConnectWithoutCourseInput[]
    createMany?: StudentEnrolledCourseCreateManyCourseInputEnvelope
    connect?: StudentEnrolledCourseWhereUniqueInput | StudentEnrolledCourseWhereUniqueInput[]
  }

  export type CourseToPreRequisiteCreateNestedManyWithoutCourseInput = {
    create?: XOR<CourseToPreRequisiteCreateWithoutCourseInput, CourseToPreRequisiteUncheckedCreateWithoutCourseInput> | CourseToPreRequisiteCreateWithoutCourseInput[] | CourseToPreRequisiteUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: CourseToPreRequisiteCreateOrConnectWithoutCourseInput | CourseToPreRequisiteCreateOrConnectWithoutCourseInput[]
    createMany?: CourseToPreRequisiteCreateManyCourseInputEnvelope
    connect?: CourseToPreRequisiteWhereUniqueInput | CourseToPreRequisiteWhereUniqueInput[]
  }

  export type CourseToPreRequisiteCreateNestedManyWithoutPreRequisiteInput = {
    create?: XOR<CourseToPreRequisiteCreateWithoutPreRequisiteInput, CourseToPreRequisiteUncheckedCreateWithoutPreRequisiteInput> | CourseToPreRequisiteCreateWithoutPreRequisiteInput[] | CourseToPreRequisiteUncheckedCreateWithoutPreRequisiteInput[]
    connectOrCreate?: CourseToPreRequisiteCreateOrConnectWithoutPreRequisiteInput | CourseToPreRequisiteCreateOrConnectWithoutPreRequisiteInput[]
    createMany?: CourseToPreRequisiteCreateManyPreRequisiteInputEnvelope
    connect?: CourseToPreRequisiteWhereUniqueInput | CourseToPreRequisiteWhereUniqueInput[]
  }

  export type CourseFacultyCreateNestedManyWithoutCourseInput = {
    create?: XOR<CourseFacultyCreateWithoutCourseInput, CourseFacultyUncheckedCreateWithoutCourseInput> | CourseFacultyCreateWithoutCourseInput[] | CourseFacultyUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: CourseFacultyCreateOrConnectWithoutCourseInput | CourseFacultyCreateOrConnectWithoutCourseInput[]
    createMany?: CourseFacultyCreateManyCourseInputEnvelope
    connect?: CourseFacultyWhereUniqueInput | CourseFacultyWhereUniqueInput[]
  }

  export type OfferedCourseCreateNestedManyWithoutCourseInput = {
    create?: XOR<OfferedCourseCreateWithoutCourseInput, OfferedCourseUncheckedCreateWithoutCourseInput> | OfferedCourseCreateWithoutCourseInput[] | OfferedCourseUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: OfferedCourseCreateOrConnectWithoutCourseInput | OfferedCourseCreateOrConnectWithoutCourseInput[]
    createMany?: OfferedCourseCreateManyCourseInputEnvelope
    connect?: OfferedCourseWhereUniqueInput | OfferedCourseWhereUniqueInput[]
  }

  export type CourseDisciplineUncheckedCreateNestedManyWithoutCourseInput = {
    create?: XOR<CourseDisciplineCreateWithoutCourseInput, CourseDisciplineUncheckedCreateWithoutCourseInput> | CourseDisciplineCreateWithoutCourseInput[] | CourseDisciplineUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: CourseDisciplineCreateOrConnectWithoutCourseInput | CourseDisciplineCreateOrConnectWithoutCourseInput[]
    createMany?: CourseDisciplineCreateManyCourseInputEnvelope
    connect?: CourseDisciplineWhereUniqueInput | CourseDisciplineWhereUniqueInput[]
  }

  export type CoursePricingUncheckedCreateNestedOneWithoutCourseInput = {
    create?: XOR<CoursePricingCreateWithoutCourseInput, CoursePricingUncheckedCreateWithoutCourseInput>
    connectOrCreate?: CoursePricingCreateOrConnectWithoutCourseInput
    connect?: CoursePricingWhereUniqueInput
  }

  export type StudentEnrolledCourseUncheckedCreateNestedManyWithoutCourseInput = {
    create?: XOR<StudentEnrolledCourseCreateWithoutCourseInput, StudentEnrolledCourseUncheckedCreateWithoutCourseInput> | StudentEnrolledCourseCreateWithoutCourseInput[] | StudentEnrolledCourseUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: StudentEnrolledCourseCreateOrConnectWithoutCourseInput | StudentEnrolledCourseCreateOrConnectWithoutCourseInput[]
    createMany?: StudentEnrolledCourseCreateManyCourseInputEnvelope
    connect?: StudentEnrolledCourseWhereUniqueInput | StudentEnrolledCourseWhereUniqueInput[]
  }

  export type CourseToPreRequisiteUncheckedCreateNestedManyWithoutCourseInput = {
    create?: XOR<CourseToPreRequisiteCreateWithoutCourseInput, CourseToPreRequisiteUncheckedCreateWithoutCourseInput> | CourseToPreRequisiteCreateWithoutCourseInput[] | CourseToPreRequisiteUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: CourseToPreRequisiteCreateOrConnectWithoutCourseInput | CourseToPreRequisiteCreateOrConnectWithoutCourseInput[]
    createMany?: CourseToPreRequisiteCreateManyCourseInputEnvelope
    connect?: CourseToPreRequisiteWhereUniqueInput | CourseToPreRequisiteWhereUniqueInput[]
  }

  export type CourseToPreRequisiteUncheckedCreateNestedManyWithoutPreRequisiteInput = {
    create?: XOR<CourseToPreRequisiteCreateWithoutPreRequisiteInput, CourseToPreRequisiteUncheckedCreateWithoutPreRequisiteInput> | CourseToPreRequisiteCreateWithoutPreRequisiteInput[] | CourseToPreRequisiteUncheckedCreateWithoutPreRequisiteInput[]
    connectOrCreate?: CourseToPreRequisiteCreateOrConnectWithoutPreRequisiteInput | CourseToPreRequisiteCreateOrConnectWithoutPreRequisiteInput[]
    createMany?: CourseToPreRequisiteCreateManyPreRequisiteInputEnvelope
    connect?: CourseToPreRequisiteWhereUniqueInput | CourseToPreRequisiteWhereUniqueInput[]
  }

  export type CourseFacultyUncheckedCreateNestedManyWithoutCourseInput = {
    create?: XOR<CourseFacultyCreateWithoutCourseInput, CourseFacultyUncheckedCreateWithoutCourseInput> | CourseFacultyCreateWithoutCourseInput[] | CourseFacultyUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: CourseFacultyCreateOrConnectWithoutCourseInput | CourseFacultyCreateOrConnectWithoutCourseInput[]
    createMany?: CourseFacultyCreateManyCourseInputEnvelope
    connect?: CourseFacultyWhereUniqueInput | CourseFacultyWhereUniqueInput[]
  }

  export type OfferedCourseUncheckedCreateNestedManyWithoutCourseInput = {
    create?: XOR<OfferedCourseCreateWithoutCourseInput, OfferedCourseUncheckedCreateWithoutCourseInput> | OfferedCourseCreateWithoutCourseInput[] | OfferedCourseUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: OfferedCourseCreateOrConnectWithoutCourseInput | OfferedCourseCreateOrConnectWithoutCourseInput[]
    createMany?: OfferedCourseCreateManyCourseInputEnvelope
    connect?: OfferedCourseWhereUniqueInput | OfferedCourseWhereUniqueInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type CourseDisciplineUpdateManyWithoutCourseNestedInput = {
    create?: XOR<CourseDisciplineCreateWithoutCourseInput, CourseDisciplineUncheckedCreateWithoutCourseInput> | CourseDisciplineCreateWithoutCourseInput[] | CourseDisciplineUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: CourseDisciplineCreateOrConnectWithoutCourseInput | CourseDisciplineCreateOrConnectWithoutCourseInput[]
    upsert?: CourseDisciplineUpsertWithWhereUniqueWithoutCourseInput | CourseDisciplineUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: CourseDisciplineCreateManyCourseInputEnvelope
    set?: CourseDisciplineWhereUniqueInput | CourseDisciplineWhereUniqueInput[]
    disconnect?: CourseDisciplineWhereUniqueInput | CourseDisciplineWhereUniqueInput[]
    delete?: CourseDisciplineWhereUniqueInput | CourseDisciplineWhereUniqueInput[]
    connect?: CourseDisciplineWhereUniqueInput | CourseDisciplineWhereUniqueInput[]
    update?: CourseDisciplineUpdateWithWhereUniqueWithoutCourseInput | CourseDisciplineUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: CourseDisciplineUpdateManyWithWhereWithoutCourseInput | CourseDisciplineUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: CourseDisciplineScalarWhereInput | CourseDisciplineScalarWhereInput[]
  }

  export type CoursePricingUpdateOneWithoutCourseNestedInput = {
    create?: XOR<CoursePricingCreateWithoutCourseInput, CoursePricingUncheckedCreateWithoutCourseInput>
    connectOrCreate?: CoursePricingCreateOrConnectWithoutCourseInput
    upsert?: CoursePricingUpsertWithoutCourseInput
    disconnect?: CoursePricingWhereInput | boolean
    delete?: CoursePricingWhereInput | boolean
    connect?: CoursePricingWhereUniqueInput
    update?: XOR<XOR<CoursePricingUpdateToOneWithWhereWithoutCourseInput, CoursePricingUpdateWithoutCourseInput>, CoursePricingUncheckedUpdateWithoutCourseInput>
  }

  export type AcademicDepartmentUpdateOneRequiredWithoutCoursesNestedInput = {
    create?: XOR<AcademicDepartmentCreateWithoutCoursesInput, AcademicDepartmentUncheckedCreateWithoutCoursesInput>
    connectOrCreate?: AcademicDepartmentCreateOrConnectWithoutCoursesInput
    upsert?: AcademicDepartmentUpsertWithoutCoursesInput
    connect?: AcademicDepartmentWhereUniqueInput
    update?: XOR<XOR<AcademicDepartmentUpdateToOneWithWhereWithoutCoursesInput, AcademicDepartmentUpdateWithoutCoursesInput>, AcademicDepartmentUncheckedUpdateWithoutCoursesInput>
  }

  export type StudentEnrolledCourseUpdateManyWithoutCourseNestedInput = {
    create?: XOR<StudentEnrolledCourseCreateWithoutCourseInput, StudentEnrolledCourseUncheckedCreateWithoutCourseInput> | StudentEnrolledCourseCreateWithoutCourseInput[] | StudentEnrolledCourseUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: StudentEnrolledCourseCreateOrConnectWithoutCourseInput | StudentEnrolledCourseCreateOrConnectWithoutCourseInput[]
    upsert?: StudentEnrolledCourseUpsertWithWhereUniqueWithoutCourseInput | StudentEnrolledCourseUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: StudentEnrolledCourseCreateManyCourseInputEnvelope
    set?: StudentEnrolledCourseWhereUniqueInput | StudentEnrolledCourseWhereUniqueInput[]
    disconnect?: StudentEnrolledCourseWhereUniqueInput | StudentEnrolledCourseWhereUniqueInput[]
    delete?: StudentEnrolledCourseWhereUniqueInput | StudentEnrolledCourseWhereUniqueInput[]
    connect?: StudentEnrolledCourseWhereUniqueInput | StudentEnrolledCourseWhereUniqueInput[]
    update?: StudentEnrolledCourseUpdateWithWhereUniqueWithoutCourseInput | StudentEnrolledCourseUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: StudentEnrolledCourseUpdateManyWithWhereWithoutCourseInput | StudentEnrolledCourseUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: StudentEnrolledCourseScalarWhereInput | StudentEnrolledCourseScalarWhereInput[]
  }

  export type CourseToPreRequisiteUpdateManyWithoutCourseNestedInput = {
    create?: XOR<CourseToPreRequisiteCreateWithoutCourseInput, CourseToPreRequisiteUncheckedCreateWithoutCourseInput> | CourseToPreRequisiteCreateWithoutCourseInput[] | CourseToPreRequisiteUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: CourseToPreRequisiteCreateOrConnectWithoutCourseInput | CourseToPreRequisiteCreateOrConnectWithoutCourseInput[]
    upsert?: CourseToPreRequisiteUpsertWithWhereUniqueWithoutCourseInput | CourseToPreRequisiteUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: CourseToPreRequisiteCreateManyCourseInputEnvelope
    set?: CourseToPreRequisiteWhereUniqueInput | CourseToPreRequisiteWhereUniqueInput[]
    disconnect?: CourseToPreRequisiteWhereUniqueInput | CourseToPreRequisiteWhereUniqueInput[]
    delete?: CourseToPreRequisiteWhereUniqueInput | CourseToPreRequisiteWhereUniqueInput[]
    connect?: CourseToPreRequisiteWhereUniqueInput | CourseToPreRequisiteWhereUniqueInput[]
    update?: CourseToPreRequisiteUpdateWithWhereUniqueWithoutCourseInput | CourseToPreRequisiteUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: CourseToPreRequisiteUpdateManyWithWhereWithoutCourseInput | CourseToPreRequisiteUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: CourseToPreRequisiteScalarWhereInput | CourseToPreRequisiteScalarWhereInput[]
  }

  export type CourseToPreRequisiteUpdateManyWithoutPreRequisiteNestedInput = {
    create?: XOR<CourseToPreRequisiteCreateWithoutPreRequisiteInput, CourseToPreRequisiteUncheckedCreateWithoutPreRequisiteInput> | CourseToPreRequisiteCreateWithoutPreRequisiteInput[] | CourseToPreRequisiteUncheckedCreateWithoutPreRequisiteInput[]
    connectOrCreate?: CourseToPreRequisiteCreateOrConnectWithoutPreRequisiteInput | CourseToPreRequisiteCreateOrConnectWithoutPreRequisiteInput[]
    upsert?: CourseToPreRequisiteUpsertWithWhereUniqueWithoutPreRequisiteInput | CourseToPreRequisiteUpsertWithWhereUniqueWithoutPreRequisiteInput[]
    createMany?: CourseToPreRequisiteCreateManyPreRequisiteInputEnvelope
    set?: CourseToPreRequisiteWhereUniqueInput | CourseToPreRequisiteWhereUniqueInput[]
    disconnect?: CourseToPreRequisiteWhereUniqueInput | CourseToPreRequisiteWhereUniqueInput[]
    delete?: CourseToPreRequisiteWhereUniqueInput | CourseToPreRequisiteWhereUniqueInput[]
    connect?: CourseToPreRequisiteWhereUniqueInput | CourseToPreRequisiteWhereUniqueInput[]
    update?: CourseToPreRequisiteUpdateWithWhereUniqueWithoutPreRequisiteInput | CourseToPreRequisiteUpdateWithWhereUniqueWithoutPreRequisiteInput[]
    updateMany?: CourseToPreRequisiteUpdateManyWithWhereWithoutPreRequisiteInput | CourseToPreRequisiteUpdateManyWithWhereWithoutPreRequisiteInput[]
    deleteMany?: CourseToPreRequisiteScalarWhereInput | CourseToPreRequisiteScalarWhereInput[]
  }

  export type CourseFacultyUpdateManyWithoutCourseNestedInput = {
    create?: XOR<CourseFacultyCreateWithoutCourseInput, CourseFacultyUncheckedCreateWithoutCourseInput> | CourseFacultyCreateWithoutCourseInput[] | CourseFacultyUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: CourseFacultyCreateOrConnectWithoutCourseInput | CourseFacultyCreateOrConnectWithoutCourseInput[]
    upsert?: CourseFacultyUpsertWithWhereUniqueWithoutCourseInput | CourseFacultyUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: CourseFacultyCreateManyCourseInputEnvelope
    set?: CourseFacultyWhereUniqueInput | CourseFacultyWhereUniqueInput[]
    disconnect?: CourseFacultyWhereUniqueInput | CourseFacultyWhereUniqueInput[]
    delete?: CourseFacultyWhereUniqueInput | CourseFacultyWhereUniqueInput[]
    connect?: CourseFacultyWhereUniqueInput | CourseFacultyWhereUniqueInput[]
    update?: CourseFacultyUpdateWithWhereUniqueWithoutCourseInput | CourseFacultyUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: CourseFacultyUpdateManyWithWhereWithoutCourseInput | CourseFacultyUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: CourseFacultyScalarWhereInput | CourseFacultyScalarWhereInput[]
  }

  export type OfferedCourseUpdateManyWithoutCourseNestedInput = {
    create?: XOR<OfferedCourseCreateWithoutCourseInput, OfferedCourseUncheckedCreateWithoutCourseInput> | OfferedCourseCreateWithoutCourseInput[] | OfferedCourseUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: OfferedCourseCreateOrConnectWithoutCourseInput | OfferedCourseCreateOrConnectWithoutCourseInput[]
    upsert?: OfferedCourseUpsertWithWhereUniqueWithoutCourseInput | OfferedCourseUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: OfferedCourseCreateManyCourseInputEnvelope
    set?: OfferedCourseWhereUniqueInput | OfferedCourseWhereUniqueInput[]
    disconnect?: OfferedCourseWhereUniqueInput | OfferedCourseWhereUniqueInput[]
    delete?: OfferedCourseWhereUniqueInput | OfferedCourseWhereUniqueInput[]
    connect?: OfferedCourseWhereUniqueInput | OfferedCourseWhereUniqueInput[]
    update?: OfferedCourseUpdateWithWhereUniqueWithoutCourseInput | OfferedCourseUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: OfferedCourseUpdateManyWithWhereWithoutCourseInput | OfferedCourseUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: OfferedCourseScalarWhereInput | OfferedCourseScalarWhereInput[]
  }

  export type CourseDisciplineUncheckedUpdateManyWithoutCourseNestedInput = {
    create?: XOR<CourseDisciplineCreateWithoutCourseInput, CourseDisciplineUncheckedCreateWithoutCourseInput> | CourseDisciplineCreateWithoutCourseInput[] | CourseDisciplineUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: CourseDisciplineCreateOrConnectWithoutCourseInput | CourseDisciplineCreateOrConnectWithoutCourseInput[]
    upsert?: CourseDisciplineUpsertWithWhereUniqueWithoutCourseInput | CourseDisciplineUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: CourseDisciplineCreateManyCourseInputEnvelope
    set?: CourseDisciplineWhereUniqueInput | CourseDisciplineWhereUniqueInput[]
    disconnect?: CourseDisciplineWhereUniqueInput | CourseDisciplineWhereUniqueInput[]
    delete?: CourseDisciplineWhereUniqueInput | CourseDisciplineWhereUniqueInput[]
    connect?: CourseDisciplineWhereUniqueInput | CourseDisciplineWhereUniqueInput[]
    update?: CourseDisciplineUpdateWithWhereUniqueWithoutCourseInput | CourseDisciplineUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: CourseDisciplineUpdateManyWithWhereWithoutCourseInput | CourseDisciplineUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: CourseDisciplineScalarWhereInput | CourseDisciplineScalarWhereInput[]
  }

  export type CoursePricingUncheckedUpdateOneWithoutCourseNestedInput = {
    create?: XOR<CoursePricingCreateWithoutCourseInput, CoursePricingUncheckedCreateWithoutCourseInput>
    connectOrCreate?: CoursePricingCreateOrConnectWithoutCourseInput
    upsert?: CoursePricingUpsertWithoutCourseInput
    disconnect?: CoursePricingWhereInput | boolean
    delete?: CoursePricingWhereInput | boolean
    connect?: CoursePricingWhereUniqueInput
    update?: XOR<XOR<CoursePricingUpdateToOneWithWhereWithoutCourseInput, CoursePricingUpdateWithoutCourseInput>, CoursePricingUncheckedUpdateWithoutCourseInput>
  }

  export type StudentEnrolledCourseUncheckedUpdateManyWithoutCourseNestedInput = {
    create?: XOR<StudentEnrolledCourseCreateWithoutCourseInput, StudentEnrolledCourseUncheckedCreateWithoutCourseInput> | StudentEnrolledCourseCreateWithoutCourseInput[] | StudentEnrolledCourseUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: StudentEnrolledCourseCreateOrConnectWithoutCourseInput | StudentEnrolledCourseCreateOrConnectWithoutCourseInput[]
    upsert?: StudentEnrolledCourseUpsertWithWhereUniqueWithoutCourseInput | StudentEnrolledCourseUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: StudentEnrolledCourseCreateManyCourseInputEnvelope
    set?: StudentEnrolledCourseWhereUniqueInput | StudentEnrolledCourseWhereUniqueInput[]
    disconnect?: StudentEnrolledCourseWhereUniqueInput | StudentEnrolledCourseWhereUniqueInput[]
    delete?: StudentEnrolledCourseWhereUniqueInput | StudentEnrolledCourseWhereUniqueInput[]
    connect?: StudentEnrolledCourseWhereUniqueInput | StudentEnrolledCourseWhereUniqueInput[]
    update?: StudentEnrolledCourseUpdateWithWhereUniqueWithoutCourseInput | StudentEnrolledCourseUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: StudentEnrolledCourseUpdateManyWithWhereWithoutCourseInput | StudentEnrolledCourseUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: StudentEnrolledCourseScalarWhereInput | StudentEnrolledCourseScalarWhereInput[]
  }

  export type CourseToPreRequisiteUncheckedUpdateManyWithoutCourseNestedInput = {
    create?: XOR<CourseToPreRequisiteCreateWithoutCourseInput, CourseToPreRequisiteUncheckedCreateWithoutCourseInput> | CourseToPreRequisiteCreateWithoutCourseInput[] | CourseToPreRequisiteUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: CourseToPreRequisiteCreateOrConnectWithoutCourseInput | CourseToPreRequisiteCreateOrConnectWithoutCourseInput[]
    upsert?: CourseToPreRequisiteUpsertWithWhereUniqueWithoutCourseInput | CourseToPreRequisiteUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: CourseToPreRequisiteCreateManyCourseInputEnvelope
    set?: CourseToPreRequisiteWhereUniqueInput | CourseToPreRequisiteWhereUniqueInput[]
    disconnect?: CourseToPreRequisiteWhereUniqueInput | CourseToPreRequisiteWhereUniqueInput[]
    delete?: CourseToPreRequisiteWhereUniqueInput | CourseToPreRequisiteWhereUniqueInput[]
    connect?: CourseToPreRequisiteWhereUniqueInput | CourseToPreRequisiteWhereUniqueInput[]
    update?: CourseToPreRequisiteUpdateWithWhereUniqueWithoutCourseInput | CourseToPreRequisiteUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: CourseToPreRequisiteUpdateManyWithWhereWithoutCourseInput | CourseToPreRequisiteUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: CourseToPreRequisiteScalarWhereInput | CourseToPreRequisiteScalarWhereInput[]
  }

  export type CourseToPreRequisiteUncheckedUpdateManyWithoutPreRequisiteNestedInput = {
    create?: XOR<CourseToPreRequisiteCreateWithoutPreRequisiteInput, CourseToPreRequisiteUncheckedCreateWithoutPreRequisiteInput> | CourseToPreRequisiteCreateWithoutPreRequisiteInput[] | CourseToPreRequisiteUncheckedCreateWithoutPreRequisiteInput[]
    connectOrCreate?: CourseToPreRequisiteCreateOrConnectWithoutPreRequisiteInput | CourseToPreRequisiteCreateOrConnectWithoutPreRequisiteInput[]
    upsert?: CourseToPreRequisiteUpsertWithWhereUniqueWithoutPreRequisiteInput | CourseToPreRequisiteUpsertWithWhereUniqueWithoutPreRequisiteInput[]
    createMany?: CourseToPreRequisiteCreateManyPreRequisiteInputEnvelope
    set?: CourseToPreRequisiteWhereUniqueInput | CourseToPreRequisiteWhereUniqueInput[]
    disconnect?: CourseToPreRequisiteWhereUniqueInput | CourseToPreRequisiteWhereUniqueInput[]
    delete?: CourseToPreRequisiteWhereUniqueInput | CourseToPreRequisiteWhereUniqueInput[]
    connect?: CourseToPreRequisiteWhereUniqueInput | CourseToPreRequisiteWhereUniqueInput[]
    update?: CourseToPreRequisiteUpdateWithWhereUniqueWithoutPreRequisiteInput | CourseToPreRequisiteUpdateWithWhereUniqueWithoutPreRequisiteInput[]
    updateMany?: CourseToPreRequisiteUpdateManyWithWhereWithoutPreRequisiteInput | CourseToPreRequisiteUpdateManyWithWhereWithoutPreRequisiteInput[]
    deleteMany?: CourseToPreRequisiteScalarWhereInput | CourseToPreRequisiteScalarWhereInput[]
  }

  export type CourseFacultyUncheckedUpdateManyWithoutCourseNestedInput = {
    create?: XOR<CourseFacultyCreateWithoutCourseInput, CourseFacultyUncheckedCreateWithoutCourseInput> | CourseFacultyCreateWithoutCourseInput[] | CourseFacultyUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: CourseFacultyCreateOrConnectWithoutCourseInput | CourseFacultyCreateOrConnectWithoutCourseInput[]
    upsert?: CourseFacultyUpsertWithWhereUniqueWithoutCourseInput | CourseFacultyUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: CourseFacultyCreateManyCourseInputEnvelope
    set?: CourseFacultyWhereUniqueInput | CourseFacultyWhereUniqueInput[]
    disconnect?: CourseFacultyWhereUniqueInput | CourseFacultyWhereUniqueInput[]
    delete?: CourseFacultyWhereUniqueInput | CourseFacultyWhereUniqueInput[]
    connect?: CourseFacultyWhereUniqueInput | CourseFacultyWhereUniqueInput[]
    update?: CourseFacultyUpdateWithWhereUniqueWithoutCourseInput | CourseFacultyUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: CourseFacultyUpdateManyWithWhereWithoutCourseInput | CourseFacultyUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: CourseFacultyScalarWhereInput | CourseFacultyScalarWhereInput[]
  }

  export type OfferedCourseUncheckedUpdateManyWithoutCourseNestedInput = {
    create?: XOR<OfferedCourseCreateWithoutCourseInput, OfferedCourseUncheckedCreateWithoutCourseInput> | OfferedCourseCreateWithoutCourseInput[] | OfferedCourseUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: OfferedCourseCreateOrConnectWithoutCourseInput | OfferedCourseCreateOrConnectWithoutCourseInput[]
    upsert?: OfferedCourseUpsertWithWhereUniqueWithoutCourseInput | OfferedCourseUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: OfferedCourseCreateManyCourseInputEnvelope
    set?: OfferedCourseWhereUniqueInput | OfferedCourseWhereUniqueInput[]
    disconnect?: OfferedCourseWhereUniqueInput | OfferedCourseWhereUniqueInput[]
    delete?: OfferedCourseWhereUniqueInput | OfferedCourseWhereUniqueInput[]
    connect?: OfferedCourseWhereUniqueInput | OfferedCourseWhereUniqueInput[]
    update?: OfferedCourseUpdateWithWhereUniqueWithoutCourseInput | OfferedCourseUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: OfferedCourseUpdateManyWithWhereWithoutCourseInput | OfferedCourseUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: OfferedCourseScalarWhereInput | OfferedCourseScalarWhereInput[]
  }

  export type CourseCreateNestedOneWithoutPreRequisiteInput = {
    create?: XOR<CourseCreateWithoutPreRequisiteInput, CourseUncheckedCreateWithoutPreRequisiteInput>
    connectOrCreate?: CourseCreateOrConnectWithoutPreRequisiteInput
    connect?: CourseWhereUniqueInput
  }

  export type CourseCreateNestedOneWithoutPreRequisiteForInput = {
    create?: XOR<CourseCreateWithoutPreRequisiteForInput, CourseUncheckedCreateWithoutPreRequisiteForInput>
    connectOrCreate?: CourseCreateOrConnectWithoutPreRequisiteForInput
    connect?: CourseWhereUniqueInput
  }

  export type CourseUpdateOneRequiredWithoutPreRequisiteNestedInput = {
    create?: XOR<CourseCreateWithoutPreRequisiteInput, CourseUncheckedCreateWithoutPreRequisiteInput>
    connectOrCreate?: CourseCreateOrConnectWithoutPreRequisiteInput
    upsert?: CourseUpsertWithoutPreRequisiteInput
    connect?: CourseWhereUniqueInput
    update?: XOR<XOR<CourseUpdateToOneWithWhereWithoutPreRequisiteInput, CourseUpdateWithoutPreRequisiteInput>, CourseUncheckedUpdateWithoutPreRequisiteInput>
  }

  export type CourseUpdateOneRequiredWithoutPreRequisiteForNestedInput = {
    create?: XOR<CourseCreateWithoutPreRequisiteForInput, CourseUncheckedCreateWithoutPreRequisiteForInput>
    connectOrCreate?: CourseCreateOrConnectWithoutPreRequisiteForInput
    upsert?: CourseUpsertWithoutPreRequisiteForInput
    connect?: CourseWhereUniqueInput
    update?: XOR<XOR<CourseUpdateToOneWithWhereWithoutPreRequisiteForInput, CourseUpdateWithoutPreRequisiteForInput>, CourseUncheckedUpdateWithoutPreRequisiteForInput>
  }

  export type CourseCreateNestedOneWithoutFacultiesInput = {
    create?: XOR<CourseCreateWithoutFacultiesInput, CourseUncheckedCreateWithoutFacultiesInput>
    connectOrCreate?: CourseCreateOrConnectWithoutFacultiesInput
    connect?: CourseWhereUniqueInput
  }

  export type FacultyCreateNestedOneWithoutCoursesInput = {
    create?: XOR<FacultyCreateWithoutCoursesInput, FacultyUncheckedCreateWithoutCoursesInput>
    connectOrCreate?: FacultyCreateOrConnectWithoutCoursesInput
    connect?: FacultyWhereUniqueInput
  }

  export type CourseUpdateOneRequiredWithoutFacultiesNestedInput = {
    create?: XOR<CourseCreateWithoutFacultiesInput, CourseUncheckedCreateWithoutFacultiesInput>
    connectOrCreate?: CourseCreateOrConnectWithoutFacultiesInput
    upsert?: CourseUpsertWithoutFacultiesInput
    connect?: CourseWhereUniqueInput
    update?: XOR<XOR<CourseUpdateToOneWithWhereWithoutFacultiesInput, CourseUpdateWithoutFacultiesInput>, CourseUncheckedUpdateWithoutFacultiesInput>
  }

  export type FacultyUpdateOneRequiredWithoutCoursesNestedInput = {
    create?: XOR<FacultyCreateWithoutCoursesInput, FacultyUncheckedCreateWithoutCoursesInput>
    connectOrCreate?: FacultyCreateOrConnectWithoutCoursesInput
    upsert?: FacultyUpsertWithoutCoursesInput
    connect?: FacultyWhereUniqueInput
    update?: XOR<XOR<FacultyUpdateToOneWithWhereWithoutCoursesInput, FacultyUpdateWithoutCoursesInput>, FacultyUncheckedUpdateWithoutCoursesInput>
  }

  export type AcademicSemesterCreateNestedOneWithoutSemesterRegistrationsInput = {
    create?: XOR<AcademicSemesterCreateWithoutSemesterRegistrationsInput, AcademicSemesterUncheckedCreateWithoutSemesterRegistrationsInput>
    connectOrCreate?: AcademicSemesterCreateOrConnectWithoutSemesterRegistrationsInput
    connect?: AcademicSemesterWhereUniqueInput
  }

  export type OfferedCourseCreateNestedManyWithoutSemesterRegistrationInput = {
    create?: XOR<OfferedCourseCreateWithoutSemesterRegistrationInput, OfferedCourseUncheckedCreateWithoutSemesterRegistrationInput> | OfferedCourseCreateWithoutSemesterRegistrationInput[] | OfferedCourseUncheckedCreateWithoutSemesterRegistrationInput[]
    connectOrCreate?: OfferedCourseCreateOrConnectWithoutSemesterRegistrationInput | OfferedCourseCreateOrConnectWithoutSemesterRegistrationInput[]
    createMany?: OfferedCourseCreateManySemesterRegistrationInputEnvelope
    connect?: OfferedCourseWhereUniqueInput | OfferedCourseWhereUniqueInput[]
  }

  export type OfferedCourseSectionCreateNestedManyWithoutSemesterRegistrationInput = {
    create?: XOR<OfferedCourseSectionCreateWithoutSemesterRegistrationInput, OfferedCourseSectionUncheckedCreateWithoutSemesterRegistrationInput> | OfferedCourseSectionCreateWithoutSemesterRegistrationInput[] | OfferedCourseSectionUncheckedCreateWithoutSemesterRegistrationInput[]
    connectOrCreate?: OfferedCourseSectionCreateOrConnectWithoutSemesterRegistrationInput | OfferedCourseSectionCreateOrConnectWithoutSemesterRegistrationInput[]
    createMany?: OfferedCourseSectionCreateManySemesterRegistrationInputEnvelope
    connect?: OfferedCourseSectionWhereUniqueInput | OfferedCourseSectionWhereUniqueInput[]
  }

  export type OfferedCourseClassScheduleCreateNestedManyWithoutSemesterRegistrationInput = {
    create?: XOR<OfferedCourseClassScheduleCreateWithoutSemesterRegistrationInput, OfferedCourseClassScheduleUncheckedCreateWithoutSemesterRegistrationInput> | OfferedCourseClassScheduleCreateWithoutSemesterRegistrationInput[] | OfferedCourseClassScheduleUncheckedCreateWithoutSemesterRegistrationInput[]
    connectOrCreate?: OfferedCourseClassScheduleCreateOrConnectWithoutSemesterRegistrationInput | OfferedCourseClassScheduleCreateOrConnectWithoutSemesterRegistrationInput[]
    createMany?: OfferedCourseClassScheduleCreateManySemesterRegistrationInputEnvelope
    connect?: OfferedCourseClassScheduleWhereUniqueInput | OfferedCourseClassScheduleWhereUniqueInput[]
  }

  export type StudentSemesterRegistrationCreateNestedManyWithoutSemesterRegistrationInput = {
    create?: XOR<StudentSemesterRegistrationCreateWithoutSemesterRegistrationInput, StudentSemesterRegistrationUncheckedCreateWithoutSemesterRegistrationInput> | StudentSemesterRegistrationCreateWithoutSemesterRegistrationInput[] | StudentSemesterRegistrationUncheckedCreateWithoutSemesterRegistrationInput[]
    connectOrCreate?: StudentSemesterRegistrationCreateOrConnectWithoutSemesterRegistrationInput | StudentSemesterRegistrationCreateOrConnectWithoutSemesterRegistrationInput[]
    createMany?: StudentSemesterRegistrationCreateManySemesterRegistrationInputEnvelope
    connect?: StudentSemesterRegistrationWhereUniqueInput | StudentSemesterRegistrationWhereUniqueInput[]
  }

  export type StudentSemesterRegistrationCourseCreateNestedManyWithoutSemesterRegistrationInput = {
    create?: XOR<StudentSemesterRegistrationCourseCreateWithoutSemesterRegistrationInput, StudentSemesterRegistrationCourseUncheckedCreateWithoutSemesterRegistrationInput> | StudentSemesterRegistrationCourseCreateWithoutSemesterRegistrationInput[] | StudentSemesterRegistrationCourseUncheckedCreateWithoutSemesterRegistrationInput[]
    connectOrCreate?: StudentSemesterRegistrationCourseCreateOrConnectWithoutSemesterRegistrationInput | StudentSemesterRegistrationCourseCreateOrConnectWithoutSemesterRegistrationInput[]
    createMany?: StudentSemesterRegistrationCourseCreateManySemesterRegistrationInputEnvelope
    connect?: StudentSemesterRegistrationCourseWhereUniqueInput | StudentSemesterRegistrationCourseWhereUniqueInput[]
  }

  export type OfferedCourseUncheckedCreateNestedManyWithoutSemesterRegistrationInput = {
    create?: XOR<OfferedCourseCreateWithoutSemesterRegistrationInput, OfferedCourseUncheckedCreateWithoutSemesterRegistrationInput> | OfferedCourseCreateWithoutSemesterRegistrationInput[] | OfferedCourseUncheckedCreateWithoutSemesterRegistrationInput[]
    connectOrCreate?: OfferedCourseCreateOrConnectWithoutSemesterRegistrationInput | OfferedCourseCreateOrConnectWithoutSemesterRegistrationInput[]
    createMany?: OfferedCourseCreateManySemesterRegistrationInputEnvelope
    connect?: OfferedCourseWhereUniqueInput | OfferedCourseWhereUniqueInput[]
  }

  export type OfferedCourseSectionUncheckedCreateNestedManyWithoutSemesterRegistrationInput = {
    create?: XOR<OfferedCourseSectionCreateWithoutSemesterRegistrationInput, OfferedCourseSectionUncheckedCreateWithoutSemesterRegistrationInput> | OfferedCourseSectionCreateWithoutSemesterRegistrationInput[] | OfferedCourseSectionUncheckedCreateWithoutSemesterRegistrationInput[]
    connectOrCreate?: OfferedCourseSectionCreateOrConnectWithoutSemesterRegistrationInput | OfferedCourseSectionCreateOrConnectWithoutSemesterRegistrationInput[]
    createMany?: OfferedCourseSectionCreateManySemesterRegistrationInputEnvelope
    connect?: OfferedCourseSectionWhereUniqueInput | OfferedCourseSectionWhereUniqueInput[]
  }

  export type OfferedCourseClassScheduleUncheckedCreateNestedManyWithoutSemesterRegistrationInput = {
    create?: XOR<OfferedCourseClassScheduleCreateWithoutSemesterRegistrationInput, OfferedCourseClassScheduleUncheckedCreateWithoutSemesterRegistrationInput> | OfferedCourseClassScheduleCreateWithoutSemesterRegistrationInput[] | OfferedCourseClassScheduleUncheckedCreateWithoutSemesterRegistrationInput[]
    connectOrCreate?: OfferedCourseClassScheduleCreateOrConnectWithoutSemesterRegistrationInput | OfferedCourseClassScheduleCreateOrConnectWithoutSemesterRegistrationInput[]
    createMany?: OfferedCourseClassScheduleCreateManySemesterRegistrationInputEnvelope
    connect?: OfferedCourseClassScheduleWhereUniqueInput | OfferedCourseClassScheduleWhereUniqueInput[]
  }

  export type StudentSemesterRegistrationUncheckedCreateNestedManyWithoutSemesterRegistrationInput = {
    create?: XOR<StudentSemesterRegistrationCreateWithoutSemesterRegistrationInput, StudentSemesterRegistrationUncheckedCreateWithoutSemesterRegistrationInput> | StudentSemesterRegistrationCreateWithoutSemesterRegistrationInput[] | StudentSemesterRegistrationUncheckedCreateWithoutSemesterRegistrationInput[]
    connectOrCreate?: StudentSemesterRegistrationCreateOrConnectWithoutSemesterRegistrationInput | StudentSemesterRegistrationCreateOrConnectWithoutSemesterRegistrationInput[]
    createMany?: StudentSemesterRegistrationCreateManySemesterRegistrationInputEnvelope
    connect?: StudentSemesterRegistrationWhereUniqueInput | StudentSemesterRegistrationWhereUniqueInput[]
  }

  export type StudentSemesterRegistrationCourseUncheckedCreateNestedManyWithoutSemesterRegistrationInput = {
    create?: XOR<StudentSemesterRegistrationCourseCreateWithoutSemesterRegistrationInput, StudentSemesterRegistrationCourseUncheckedCreateWithoutSemesterRegistrationInput> | StudentSemesterRegistrationCourseCreateWithoutSemesterRegistrationInput[] | StudentSemesterRegistrationCourseUncheckedCreateWithoutSemesterRegistrationInput[]
    connectOrCreate?: StudentSemesterRegistrationCourseCreateOrConnectWithoutSemesterRegistrationInput | StudentSemesterRegistrationCourseCreateOrConnectWithoutSemesterRegistrationInput[]
    createMany?: StudentSemesterRegistrationCourseCreateManySemesterRegistrationInputEnvelope
    connect?: StudentSemesterRegistrationCourseWhereUniqueInput | StudentSemesterRegistrationCourseWhereUniqueInput[]
  }

  export type NullableEnumSemesterRegistrationStatusFieldUpdateOperationsInput = {
    set?: $Enums.SemesterRegistrationStatus | null
  }

  export type AcademicSemesterUpdateOneRequiredWithoutSemesterRegistrationsNestedInput = {
    create?: XOR<AcademicSemesterCreateWithoutSemesterRegistrationsInput, AcademicSemesterUncheckedCreateWithoutSemesterRegistrationsInput>
    connectOrCreate?: AcademicSemesterCreateOrConnectWithoutSemesterRegistrationsInput
    upsert?: AcademicSemesterUpsertWithoutSemesterRegistrationsInput
    connect?: AcademicSemesterWhereUniqueInput
    update?: XOR<XOR<AcademicSemesterUpdateToOneWithWhereWithoutSemesterRegistrationsInput, AcademicSemesterUpdateWithoutSemesterRegistrationsInput>, AcademicSemesterUncheckedUpdateWithoutSemesterRegistrationsInput>
  }

  export type OfferedCourseUpdateManyWithoutSemesterRegistrationNestedInput = {
    create?: XOR<OfferedCourseCreateWithoutSemesterRegistrationInput, OfferedCourseUncheckedCreateWithoutSemesterRegistrationInput> | OfferedCourseCreateWithoutSemesterRegistrationInput[] | OfferedCourseUncheckedCreateWithoutSemesterRegistrationInput[]
    connectOrCreate?: OfferedCourseCreateOrConnectWithoutSemesterRegistrationInput | OfferedCourseCreateOrConnectWithoutSemesterRegistrationInput[]
    upsert?: OfferedCourseUpsertWithWhereUniqueWithoutSemesterRegistrationInput | OfferedCourseUpsertWithWhereUniqueWithoutSemesterRegistrationInput[]
    createMany?: OfferedCourseCreateManySemesterRegistrationInputEnvelope
    set?: OfferedCourseWhereUniqueInput | OfferedCourseWhereUniqueInput[]
    disconnect?: OfferedCourseWhereUniqueInput | OfferedCourseWhereUniqueInput[]
    delete?: OfferedCourseWhereUniqueInput | OfferedCourseWhereUniqueInput[]
    connect?: OfferedCourseWhereUniqueInput | OfferedCourseWhereUniqueInput[]
    update?: OfferedCourseUpdateWithWhereUniqueWithoutSemesterRegistrationInput | OfferedCourseUpdateWithWhereUniqueWithoutSemesterRegistrationInput[]
    updateMany?: OfferedCourseUpdateManyWithWhereWithoutSemesterRegistrationInput | OfferedCourseUpdateManyWithWhereWithoutSemesterRegistrationInput[]
    deleteMany?: OfferedCourseScalarWhereInput | OfferedCourseScalarWhereInput[]
  }

  export type OfferedCourseSectionUpdateManyWithoutSemesterRegistrationNestedInput = {
    create?: XOR<OfferedCourseSectionCreateWithoutSemesterRegistrationInput, OfferedCourseSectionUncheckedCreateWithoutSemesterRegistrationInput> | OfferedCourseSectionCreateWithoutSemesterRegistrationInput[] | OfferedCourseSectionUncheckedCreateWithoutSemesterRegistrationInput[]
    connectOrCreate?: OfferedCourseSectionCreateOrConnectWithoutSemesterRegistrationInput | OfferedCourseSectionCreateOrConnectWithoutSemesterRegistrationInput[]
    upsert?: OfferedCourseSectionUpsertWithWhereUniqueWithoutSemesterRegistrationInput | OfferedCourseSectionUpsertWithWhereUniqueWithoutSemesterRegistrationInput[]
    createMany?: OfferedCourseSectionCreateManySemesterRegistrationInputEnvelope
    set?: OfferedCourseSectionWhereUniqueInput | OfferedCourseSectionWhereUniqueInput[]
    disconnect?: OfferedCourseSectionWhereUniqueInput | OfferedCourseSectionWhereUniqueInput[]
    delete?: OfferedCourseSectionWhereUniqueInput | OfferedCourseSectionWhereUniqueInput[]
    connect?: OfferedCourseSectionWhereUniqueInput | OfferedCourseSectionWhereUniqueInput[]
    update?: OfferedCourseSectionUpdateWithWhereUniqueWithoutSemesterRegistrationInput | OfferedCourseSectionUpdateWithWhereUniqueWithoutSemesterRegistrationInput[]
    updateMany?: OfferedCourseSectionUpdateManyWithWhereWithoutSemesterRegistrationInput | OfferedCourseSectionUpdateManyWithWhereWithoutSemesterRegistrationInput[]
    deleteMany?: OfferedCourseSectionScalarWhereInput | OfferedCourseSectionScalarWhereInput[]
  }

  export type OfferedCourseClassScheduleUpdateManyWithoutSemesterRegistrationNestedInput = {
    create?: XOR<OfferedCourseClassScheduleCreateWithoutSemesterRegistrationInput, OfferedCourseClassScheduleUncheckedCreateWithoutSemesterRegistrationInput> | OfferedCourseClassScheduleCreateWithoutSemesterRegistrationInput[] | OfferedCourseClassScheduleUncheckedCreateWithoutSemesterRegistrationInput[]
    connectOrCreate?: OfferedCourseClassScheduleCreateOrConnectWithoutSemesterRegistrationInput | OfferedCourseClassScheduleCreateOrConnectWithoutSemesterRegistrationInput[]
    upsert?: OfferedCourseClassScheduleUpsertWithWhereUniqueWithoutSemesterRegistrationInput | OfferedCourseClassScheduleUpsertWithWhereUniqueWithoutSemesterRegistrationInput[]
    createMany?: OfferedCourseClassScheduleCreateManySemesterRegistrationInputEnvelope
    set?: OfferedCourseClassScheduleWhereUniqueInput | OfferedCourseClassScheduleWhereUniqueInput[]
    disconnect?: OfferedCourseClassScheduleWhereUniqueInput | OfferedCourseClassScheduleWhereUniqueInput[]
    delete?: OfferedCourseClassScheduleWhereUniqueInput | OfferedCourseClassScheduleWhereUniqueInput[]
    connect?: OfferedCourseClassScheduleWhereUniqueInput | OfferedCourseClassScheduleWhereUniqueInput[]
    update?: OfferedCourseClassScheduleUpdateWithWhereUniqueWithoutSemesterRegistrationInput | OfferedCourseClassScheduleUpdateWithWhereUniqueWithoutSemesterRegistrationInput[]
    updateMany?: OfferedCourseClassScheduleUpdateManyWithWhereWithoutSemesterRegistrationInput | OfferedCourseClassScheduleUpdateManyWithWhereWithoutSemesterRegistrationInput[]
    deleteMany?: OfferedCourseClassScheduleScalarWhereInput | OfferedCourseClassScheduleScalarWhereInput[]
  }

  export type StudentSemesterRegistrationUpdateManyWithoutSemesterRegistrationNestedInput = {
    create?: XOR<StudentSemesterRegistrationCreateWithoutSemesterRegistrationInput, StudentSemesterRegistrationUncheckedCreateWithoutSemesterRegistrationInput> | StudentSemesterRegistrationCreateWithoutSemesterRegistrationInput[] | StudentSemesterRegistrationUncheckedCreateWithoutSemesterRegistrationInput[]
    connectOrCreate?: StudentSemesterRegistrationCreateOrConnectWithoutSemesterRegistrationInput | StudentSemesterRegistrationCreateOrConnectWithoutSemesterRegistrationInput[]
    upsert?: StudentSemesterRegistrationUpsertWithWhereUniqueWithoutSemesterRegistrationInput | StudentSemesterRegistrationUpsertWithWhereUniqueWithoutSemesterRegistrationInput[]
    createMany?: StudentSemesterRegistrationCreateManySemesterRegistrationInputEnvelope
    set?: StudentSemesterRegistrationWhereUniqueInput | StudentSemesterRegistrationWhereUniqueInput[]
    disconnect?: StudentSemesterRegistrationWhereUniqueInput | StudentSemesterRegistrationWhereUniqueInput[]
    delete?: StudentSemesterRegistrationWhereUniqueInput | StudentSemesterRegistrationWhereUniqueInput[]
    connect?: StudentSemesterRegistrationWhereUniqueInput | StudentSemesterRegistrationWhereUniqueInput[]
    update?: StudentSemesterRegistrationUpdateWithWhereUniqueWithoutSemesterRegistrationInput | StudentSemesterRegistrationUpdateWithWhereUniqueWithoutSemesterRegistrationInput[]
    updateMany?: StudentSemesterRegistrationUpdateManyWithWhereWithoutSemesterRegistrationInput | StudentSemesterRegistrationUpdateManyWithWhereWithoutSemesterRegistrationInput[]
    deleteMany?: StudentSemesterRegistrationScalarWhereInput | StudentSemesterRegistrationScalarWhereInput[]
  }

  export type StudentSemesterRegistrationCourseUpdateManyWithoutSemesterRegistrationNestedInput = {
    create?: XOR<StudentSemesterRegistrationCourseCreateWithoutSemesterRegistrationInput, StudentSemesterRegistrationCourseUncheckedCreateWithoutSemesterRegistrationInput> | StudentSemesterRegistrationCourseCreateWithoutSemesterRegistrationInput[] | StudentSemesterRegistrationCourseUncheckedCreateWithoutSemesterRegistrationInput[]
    connectOrCreate?: StudentSemesterRegistrationCourseCreateOrConnectWithoutSemesterRegistrationInput | StudentSemesterRegistrationCourseCreateOrConnectWithoutSemesterRegistrationInput[]
    upsert?: StudentSemesterRegistrationCourseUpsertWithWhereUniqueWithoutSemesterRegistrationInput | StudentSemesterRegistrationCourseUpsertWithWhereUniqueWithoutSemesterRegistrationInput[]
    createMany?: StudentSemesterRegistrationCourseCreateManySemesterRegistrationInputEnvelope
    set?: StudentSemesterRegistrationCourseWhereUniqueInput | StudentSemesterRegistrationCourseWhereUniqueInput[]
    disconnect?: StudentSemesterRegistrationCourseWhereUniqueInput | StudentSemesterRegistrationCourseWhereUniqueInput[]
    delete?: StudentSemesterRegistrationCourseWhereUniqueInput | StudentSemesterRegistrationCourseWhereUniqueInput[]
    connect?: StudentSemesterRegistrationCourseWhereUniqueInput | StudentSemesterRegistrationCourseWhereUniqueInput[]
    update?: StudentSemesterRegistrationCourseUpdateWithWhereUniqueWithoutSemesterRegistrationInput | StudentSemesterRegistrationCourseUpdateWithWhereUniqueWithoutSemesterRegistrationInput[]
    updateMany?: StudentSemesterRegistrationCourseUpdateManyWithWhereWithoutSemesterRegistrationInput | StudentSemesterRegistrationCourseUpdateManyWithWhereWithoutSemesterRegistrationInput[]
    deleteMany?: StudentSemesterRegistrationCourseScalarWhereInput | StudentSemesterRegistrationCourseScalarWhereInput[]
  }

  export type OfferedCourseUncheckedUpdateManyWithoutSemesterRegistrationNestedInput = {
    create?: XOR<OfferedCourseCreateWithoutSemesterRegistrationInput, OfferedCourseUncheckedCreateWithoutSemesterRegistrationInput> | OfferedCourseCreateWithoutSemesterRegistrationInput[] | OfferedCourseUncheckedCreateWithoutSemesterRegistrationInput[]
    connectOrCreate?: OfferedCourseCreateOrConnectWithoutSemesterRegistrationInput | OfferedCourseCreateOrConnectWithoutSemesterRegistrationInput[]
    upsert?: OfferedCourseUpsertWithWhereUniqueWithoutSemesterRegistrationInput | OfferedCourseUpsertWithWhereUniqueWithoutSemesterRegistrationInput[]
    createMany?: OfferedCourseCreateManySemesterRegistrationInputEnvelope
    set?: OfferedCourseWhereUniqueInput | OfferedCourseWhereUniqueInput[]
    disconnect?: OfferedCourseWhereUniqueInput | OfferedCourseWhereUniqueInput[]
    delete?: OfferedCourseWhereUniqueInput | OfferedCourseWhereUniqueInput[]
    connect?: OfferedCourseWhereUniqueInput | OfferedCourseWhereUniqueInput[]
    update?: OfferedCourseUpdateWithWhereUniqueWithoutSemesterRegistrationInput | OfferedCourseUpdateWithWhereUniqueWithoutSemesterRegistrationInput[]
    updateMany?: OfferedCourseUpdateManyWithWhereWithoutSemesterRegistrationInput | OfferedCourseUpdateManyWithWhereWithoutSemesterRegistrationInput[]
    deleteMany?: OfferedCourseScalarWhereInput | OfferedCourseScalarWhereInput[]
  }

  export type OfferedCourseSectionUncheckedUpdateManyWithoutSemesterRegistrationNestedInput = {
    create?: XOR<OfferedCourseSectionCreateWithoutSemesterRegistrationInput, OfferedCourseSectionUncheckedCreateWithoutSemesterRegistrationInput> | OfferedCourseSectionCreateWithoutSemesterRegistrationInput[] | OfferedCourseSectionUncheckedCreateWithoutSemesterRegistrationInput[]
    connectOrCreate?: OfferedCourseSectionCreateOrConnectWithoutSemesterRegistrationInput | OfferedCourseSectionCreateOrConnectWithoutSemesterRegistrationInput[]
    upsert?: OfferedCourseSectionUpsertWithWhereUniqueWithoutSemesterRegistrationInput | OfferedCourseSectionUpsertWithWhereUniqueWithoutSemesterRegistrationInput[]
    createMany?: OfferedCourseSectionCreateManySemesterRegistrationInputEnvelope
    set?: OfferedCourseSectionWhereUniqueInput | OfferedCourseSectionWhereUniqueInput[]
    disconnect?: OfferedCourseSectionWhereUniqueInput | OfferedCourseSectionWhereUniqueInput[]
    delete?: OfferedCourseSectionWhereUniqueInput | OfferedCourseSectionWhereUniqueInput[]
    connect?: OfferedCourseSectionWhereUniqueInput | OfferedCourseSectionWhereUniqueInput[]
    update?: OfferedCourseSectionUpdateWithWhereUniqueWithoutSemesterRegistrationInput | OfferedCourseSectionUpdateWithWhereUniqueWithoutSemesterRegistrationInput[]
    updateMany?: OfferedCourseSectionUpdateManyWithWhereWithoutSemesterRegistrationInput | OfferedCourseSectionUpdateManyWithWhereWithoutSemesterRegistrationInput[]
    deleteMany?: OfferedCourseSectionScalarWhereInput | OfferedCourseSectionScalarWhereInput[]
  }

  export type OfferedCourseClassScheduleUncheckedUpdateManyWithoutSemesterRegistrationNestedInput = {
    create?: XOR<OfferedCourseClassScheduleCreateWithoutSemesterRegistrationInput, OfferedCourseClassScheduleUncheckedCreateWithoutSemesterRegistrationInput> | OfferedCourseClassScheduleCreateWithoutSemesterRegistrationInput[] | OfferedCourseClassScheduleUncheckedCreateWithoutSemesterRegistrationInput[]
    connectOrCreate?: OfferedCourseClassScheduleCreateOrConnectWithoutSemesterRegistrationInput | OfferedCourseClassScheduleCreateOrConnectWithoutSemesterRegistrationInput[]
    upsert?: OfferedCourseClassScheduleUpsertWithWhereUniqueWithoutSemesterRegistrationInput | OfferedCourseClassScheduleUpsertWithWhereUniqueWithoutSemesterRegistrationInput[]
    createMany?: OfferedCourseClassScheduleCreateManySemesterRegistrationInputEnvelope
    set?: OfferedCourseClassScheduleWhereUniqueInput | OfferedCourseClassScheduleWhereUniqueInput[]
    disconnect?: OfferedCourseClassScheduleWhereUniqueInput | OfferedCourseClassScheduleWhereUniqueInput[]
    delete?: OfferedCourseClassScheduleWhereUniqueInput | OfferedCourseClassScheduleWhereUniqueInput[]
    connect?: OfferedCourseClassScheduleWhereUniqueInput | OfferedCourseClassScheduleWhereUniqueInput[]
    update?: OfferedCourseClassScheduleUpdateWithWhereUniqueWithoutSemesterRegistrationInput | OfferedCourseClassScheduleUpdateWithWhereUniqueWithoutSemesterRegistrationInput[]
    updateMany?: OfferedCourseClassScheduleUpdateManyWithWhereWithoutSemesterRegistrationInput | OfferedCourseClassScheduleUpdateManyWithWhereWithoutSemesterRegistrationInput[]
    deleteMany?: OfferedCourseClassScheduleScalarWhereInput | OfferedCourseClassScheduleScalarWhereInput[]
  }

  export type StudentSemesterRegistrationUncheckedUpdateManyWithoutSemesterRegistrationNestedInput = {
    create?: XOR<StudentSemesterRegistrationCreateWithoutSemesterRegistrationInput, StudentSemesterRegistrationUncheckedCreateWithoutSemesterRegistrationInput> | StudentSemesterRegistrationCreateWithoutSemesterRegistrationInput[] | StudentSemesterRegistrationUncheckedCreateWithoutSemesterRegistrationInput[]
    connectOrCreate?: StudentSemesterRegistrationCreateOrConnectWithoutSemesterRegistrationInput | StudentSemesterRegistrationCreateOrConnectWithoutSemesterRegistrationInput[]
    upsert?: StudentSemesterRegistrationUpsertWithWhereUniqueWithoutSemesterRegistrationInput | StudentSemesterRegistrationUpsertWithWhereUniqueWithoutSemesterRegistrationInput[]
    createMany?: StudentSemesterRegistrationCreateManySemesterRegistrationInputEnvelope
    set?: StudentSemesterRegistrationWhereUniqueInput | StudentSemesterRegistrationWhereUniqueInput[]
    disconnect?: StudentSemesterRegistrationWhereUniqueInput | StudentSemesterRegistrationWhereUniqueInput[]
    delete?: StudentSemesterRegistrationWhereUniqueInput | StudentSemesterRegistrationWhereUniqueInput[]
    connect?: StudentSemesterRegistrationWhereUniqueInput | StudentSemesterRegistrationWhereUniqueInput[]
    update?: StudentSemesterRegistrationUpdateWithWhereUniqueWithoutSemesterRegistrationInput | StudentSemesterRegistrationUpdateWithWhereUniqueWithoutSemesterRegistrationInput[]
    updateMany?: StudentSemesterRegistrationUpdateManyWithWhereWithoutSemesterRegistrationInput | StudentSemesterRegistrationUpdateManyWithWhereWithoutSemesterRegistrationInput[]
    deleteMany?: StudentSemesterRegistrationScalarWhereInput | StudentSemesterRegistrationScalarWhereInput[]
  }

  export type StudentSemesterRegistrationCourseUncheckedUpdateManyWithoutSemesterRegistrationNestedInput = {
    create?: XOR<StudentSemesterRegistrationCourseCreateWithoutSemesterRegistrationInput, StudentSemesterRegistrationCourseUncheckedCreateWithoutSemesterRegistrationInput> | StudentSemesterRegistrationCourseCreateWithoutSemesterRegistrationInput[] | StudentSemesterRegistrationCourseUncheckedCreateWithoutSemesterRegistrationInput[]
    connectOrCreate?: StudentSemesterRegistrationCourseCreateOrConnectWithoutSemesterRegistrationInput | StudentSemesterRegistrationCourseCreateOrConnectWithoutSemesterRegistrationInput[]
    upsert?: StudentSemesterRegistrationCourseUpsertWithWhereUniqueWithoutSemesterRegistrationInput | StudentSemesterRegistrationCourseUpsertWithWhereUniqueWithoutSemesterRegistrationInput[]
    createMany?: StudentSemesterRegistrationCourseCreateManySemesterRegistrationInputEnvelope
    set?: StudentSemesterRegistrationCourseWhereUniqueInput | StudentSemesterRegistrationCourseWhereUniqueInput[]
    disconnect?: StudentSemesterRegistrationCourseWhereUniqueInput | StudentSemesterRegistrationCourseWhereUniqueInput[]
    delete?: StudentSemesterRegistrationCourseWhereUniqueInput | StudentSemesterRegistrationCourseWhereUniqueInput[]
    connect?: StudentSemesterRegistrationCourseWhereUniqueInput | StudentSemesterRegistrationCourseWhereUniqueInput[]
    update?: StudentSemesterRegistrationCourseUpdateWithWhereUniqueWithoutSemesterRegistrationInput | StudentSemesterRegistrationCourseUpdateWithWhereUniqueWithoutSemesterRegistrationInput[]
    updateMany?: StudentSemesterRegistrationCourseUpdateManyWithWhereWithoutSemesterRegistrationInput | StudentSemesterRegistrationCourseUpdateManyWithWhereWithoutSemesterRegistrationInput[]
    deleteMany?: StudentSemesterRegistrationCourseScalarWhereInput | StudentSemesterRegistrationCourseScalarWhereInput[]
  }

  export type ExameFaseCreateNestedOneWithoutRegistrationsInput = {
    create?: XOR<ExameFaseCreateWithoutRegistrationsInput, ExameFaseUncheckedCreateWithoutRegistrationsInput>
    connectOrCreate?: ExameFaseCreateOrConnectWithoutRegistrationsInput
    connect?: ExameFaseWhereUniqueInput
  }

  export type AcademicFacultyCreateNestedOneWithoutAdmitionExameInput = {
    create?: XOR<AcademicFacultyCreateWithoutAdmitionExameInput, AcademicFacultyUncheckedCreateWithoutAdmitionExameInput>
    connectOrCreate?: AcademicFacultyCreateOrConnectWithoutAdmitionExameInput
    connect?: AcademicFacultyWhereUniqueInput
  }

  export type StudentCreateNestedOneWithoutAdmissionRegistrationInput = {
    create?: XOR<StudentCreateWithoutAdmissionRegistrationInput, StudentUncheckedCreateWithoutAdmissionRegistrationInput>
    connectOrCreate?: StudentCreateOrConnectWithoutAdmissionRegistrationInput
    connect?: StudentWhereUniqueInput
  }

  export type StudentUncheckedCreateNestedOneWithoutAdmissionRegistrationInput = {
    create?: XOR<StudentCreateWithoutAdmissionRegistrationInput, StudentUncheckedCreateWithoutAdmissionRegistrationInput>
    connectOrCreate?: StudentCreateOrConnectWithoutAdmissionRegistrationInput
    connect?: StudentWhereUniqueInput
  }

  export type EnumStatusFieldUpdateOperationsInput = {
    set?: $Enums.Status
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
  }

  export type ExameFaseUpdateOneRequiredWithoutRegistrationsNestedInput = {
    create?: XOR<ExameFaseCreateWithoutRegistrationsInput, ExameFaseUncheckedCreateWithoutRegistrationsInput>
    connectOrCreate?: ExameFaseCreateOrConnectWithoutRegistrationsInput
    upsert?: ExameFaseUpsertWithoutRegistrationsInput
    connect?: ExameFaseWhereUniqueInput
    update?: XOR<XOR<ExameFaseUpdateToOneWithWhereWithoutRegistrationsInput, ExameFaseUpdateWithoutRegistrationsInput>, ExameFaseUncheckedUpdateWithoutRegistrationsInput>
  }

  export type AcademicFacultyUpdateOneRequiredWithoutAdmitionExameNestedInput = {
    create?: XOR<AcademicFacultyCreateWithoutAdmitionExameInput, AcademicFacultyUncheckedCreateWithoutAdmitionExameInput>
    connectOrCreate?: AcademicFacultyCreateOrConnectWithoutAdmitionExameInput
    upsert?: AcademicFacultyUpsertWithoutAdmitionExameInput
    connect?: AcademicFacultyWhereUniqueInput
    update?: XOR<XOR<AcademicFacultyUpdateToOneWithWhereWithoutAdmitionExameInput, AcademicFacultyUpdateWithoutAdmitionExameInput>, AcademicFacultyUncheckedUpdateWithoutAdmitionExameInput>
  }

  export type StudentUpdateOneWithoutAdmissionRegistrationNestedInput = {
    create?: XOR<StudentCreateWithoutAdmissionRegistrationInput, StudentUncheckedCreateWithoutAdmissionRegistrationInput>
    connectOrCreate?: StudentCreateOrConnectWithoutAdmissionRegistrationInput
    upsert?: StudentUpsertWithoutAdmissionRegistrationInput
    disconnect?: StudentWhereInput | boolean
    delete?: StudentWhereInput | boolean
    connect?: StudentWhereUniqueInput
    update?: XOR<XOR<StudentUpdateToOneWithWhereWithoutAdmissionRegistrationInput, StudentUpdateWithoutAdmissionRegistrationInput>, StudentUncheckedUpdateWithoutAdmissionRegistrationInput>
  }

  export type StudentUncheckedUpdateOneWithoutAdmissionRegistrationNestedInput = {
    create?: XOR<StudentCreateWithoutAdmissionRegistrationInput, StudentUncheckedCreateWithoutAdmissionRegistrationInput>
    connectOrCreate?: StudentCreateOrConnectWithoutAdmissionRegistrationInput
    upsert?: StudentUpsertWithoutAdmissionRegistrationInput
    disconnect?: StudentWhereInput | boolean
    delete?: StudentWhereInput | boolean
    connect?: StudentWhereUniqueInput
    update?: XOR<XOR<StudentUpdateToOneWithWhereWithoutAdmissionRegistrationInput, StudentUpdateWithoutAdmissionRegistrationInput>, StudentUncheckedUpdateWithoutAdmissionRegistrationInput>
  }

  export type AcademicFacultyCreateNestedOneWithoutAdmitionExamePriceInput = {
    create?: XOR<AcademicFacultyCreateWithoutAdmitionExamePriceInput, AcademicFacultyUncheckedCreateWithoutAdmitionExamePriceInput>
    connectOrCreate?: AcademicFacultyCreateOrConnectWithoutAdmitionExamePriceInput
    connect?: AcademicFacultyWhereUniqueInput
  }

  export type AcademicFacultyUpdateOneRequiredWithoutAdmitionExamePriceNestedInput = {
    create?: XOR<AcademicFacultyCreateWithoutAdmitionExamePriceInput, AcademicFacultyUncheckedCreateWithoutAdmitionExamePriceInput>
    connectOrCreate?: AcademicFacultyCreateOrConnectWithoutAdmitionExamePriceInput
    upsert?: AcademicFacultyUpsertWithoutAdmitionExamePriceInput
    connect?: AcademicFacultyWhereUniqueInput
    update?: XOR<XOR<AcademicFacultyUpdateToOneWithWhereWithoutAdmitionExamePriceInput, AcademicFacultyUpdateWithoutAdmitionExamePriceInput>, AcademicFacultyUncheckedUpdateWithoutAdmitionExamePriceInput>
  }

  export type AcademicFacultyCreateNestedOneWithoutAdmitionExamePeriodInput = {
    create?: XOR<AcademicFacultyCreateWithoutAdmitionExamePeriodInput, AcademicFacultyUncheckedCreateWithoutAdmitionExamePeriodInput>
    connectOrCreate?: AcademicFacultyCreateOrConnectWithoutAdmitionExamePeriodInput
    connect?: AcademicFacultyWhereUniqueInput
  }

  export type AcademicFacultyUpdateOneRequiredWithoutAdmitionExamePeriodNestedInput = {
    create?: XOR<AcademicFacultyCreateWithoutAdmitionExamePeriodInput, AcademicFacultyUncheckedCreateWithoutAdmitionExamePeriodInput>
    connectOrCreate?: AcademicFacultyCreateOrConnectWithoutAdmitionExamePeriodInput
    upsert?: AcademicFacultyUpsertWithoutAdmitionExamePeriodInput
    connect?: AcademicFacultyWhereUniqueInput
    update?: XOR<XOR<AcademicFacultyUpdateToOneWithWhereWithoutAdmitionExamePeriodInput, AcademicFacultyUpdateWithoutAdmitionExamePeriodInput>, AcademicFacultyUncheckedUpdateWithoutAdmitionExamePeriodInput>
  }

  export type AdmitionExameRegistrationCreateNestedManyWithoutFaseInput = {
    create?: XOR<AdmitionExameRegistrationCreateWithoutFaseInput, AdmitionExameRegistrationUncheckedCreateWithoutFaseInput> | AdmitionExameRegistrationCreateWithoutFaseInput[] | AdmitionExameRegistrationUncheckedCreateWithoutFaseInput[]
    connectOrCreate?: AdmitionExameRegistrationCreateOrConnectWithoutFaseInput | AdmitionExameRegistrationCreateOrConnectWithoutFaseInput[]
    createMany?: AdmitionExameRegistrationCreateManyFaseInputEnvelope
    connect?: AdmitionExameRegistrationWhereUniqueInput | AdmitionExameRegistrationWhereUniqueInput[]
  }

  export type AdmitionExameRegistrationUncheckedCreateNestedManyWithoutFaseInput = {
    create?: XOR<AdmitionExameRegistrationCreateWithoutFaseInput, AdmitionExameRegistrationUncheckedCreateWithoutFaseInput> | AdmitionExameRegistrationCreateWithoutFaseInput[] | AdmitionExameRegistrationUncheckedCreateWithoutFaseInput[]
    connectOrCreate?: AdmitionExameRegistrationCreateOrConnectWithoutFaseInput | AdmitionExameRegistrationCreateOrConnectWithoutFaseInput[]
    createMany?: AdmitionExameRegistrationCreateManyFaseInputEnvelope
    connect?: AdmitionExameRegistrationWhereUniqueInput | AdmitionExameRegistrationWhereUniqueInput[]
  }

  export type AdmitionExameRegistrationUpdateManyWithoutFaseNestedInput = {
    create?: XOR<AdmitionExameRegistrationCreateWithoutFaseInput, AdmitionExameRegistrationUncheckedCreateWithoutFaseInput> | AdmitionExameRegistrationCreateWithoutFaseInput[] | AdmitionExameRegistrationUncheckedCreateWithoutFaseInput[]
    connectOrCreate?: AdmitionExameRegistrationCreateOrConnectWithoutFaseInput | AdmitionExameRegistrationCreateOrConnectWithoutFaseInput[]
    upsert?: AdmitionExameRegistrationUpsertWithWhereUniqueWithoutFaseInput | AdmitionExameRegistrationUpsertWithWhereUniqueWithoutFaseInput[]
    createMany?: AdmitionExameRegistrationCreateManyFaseInputEnvelope
    set?: AdmitionExameRegistrationWhereUniqueInput | AdmitionExameRegistrationWhereUniqueInput[]
    disconnect?: AdmitionExameRegistrationWhereUniqueInput | AdmitionExameRegistrationWhereUniqueInput[]
    delete?: AdmitionExameRegistrationWhereUniqueInput | AdmitionExameRegistrationWhereUniqueInput[]
    connect?: AdmitionExameRegistrationWhereUniqueInput | AdmitionExameRegistrationWhereUniqueInput[]
    update?: AdmitionExameRegistrationUpdateWithWhereUniqueWithoutFaseInput | AdmitionExameRegistrationUpdateWithWhereUniqueWithoutFaseInput[]
    updateMany?: AdmitionExameRegistrationUpdateManyWithWhereWithoutFaseInput | AdmitionExameRegistrationUpdateManyWithWhereWithoutFaseInput[]
    deleteMany?: AdmitionExameRegistrationScalarWhereInput | AdmitionExameRegistrationScalarWhereInput[]
  }

  export type AdmitionExameRegistrationUncheckedUpdateManyWithoutFaseNestedInput = {
    create?: XOR<AdmitionExameRegistrationCreateWithoutFaseInput, AdmitionExameRegistrationUncheckedCreateWithoutFaseInput> | AdmitionExameRegistrationCreateWithoutFaseInput[] | AdmitionExameRegistrationUncheckedCreateWithoutFaseInput[]
    connectOrCreate?: AdmitionExameRegistrationCreateOrConnectWithoutFaseInput | AdmitionExameRegistrationCreateOrConnectWithoutFaseInput[]
    upsert?: AdmitionExameRegistrationUpsertWithWhereUniqueWithoutFaseInput | AdmitionExameRegistrationUpsertWithWhereUniqueWithoutFaseInput[]
    createMany?: AdmitionExameRegistrationCreateManyFaseInputEnvelope
    set?: AdmitionExameRegistrationWhereUniqueInput | AdmitionExameRegistrationWhereUniqueInput[]
    disconnect?: AdmitionExameRegistrationWhereUniqueInput | AdmitionExameRegistrationWhereUniqueInput[]
    delete?: AdmitionExameRegistrationWhereUniqueInput | AdmitionExameRegistrationWhereUniqueInput[]
    connect?: AdmitionExameRegistrationWhereUniqueInput | AdmitionExameRegistrationWhereUniqueInput[]
    update?: AdmitionExameRegistrationUpdateWithWhereUniqueWithoutFaseInput | AdmitionExameRegistrationUpdateWithWhereUniqueWithoutFaseInput[]
    updateMany?: AdmitionExameRegistrationUpdateManyWithWhereWithoutFaseInput | AdmitionExameRegistrationUpdateManyWithWhereWithoutFaseInput[]
    deleteMany?: AdmitionExameRegistrationScalarWhereInput | AdmitionExameRegistrationScalarWhereInput[]
  }

  export type AcademicDepartmentCreateNestedOneWithoutOfferedCoursesInput = {
    create?: XOR<AcademicDepartmentCreateWithoutOfferedCoursesInput, AcademicDepartmentUncheckedCreateWithoutOfferedCoursesInput>
    connectOrCreate?: AcademicDepartmentCreateOrConnectWithoutOfferedCoursesInput
    connect?: AcademicDepartmentWhereUniqueInput
  }

  export type SemesterRegistrationCreateNestedOneWithoutOfferedCoursesInput = {
    create?: XOR<SemesterRegistrationCreateWithoutOfferedCoursesInput, SemesterRegistrationUncheckedCreateWithoutOfferedCoursesInput>
    connectOrCreate?: SemesterRegistrationCreateOrConnectWithoutOfferedCoursesInput
    connect?: SemesterRegistrationWhereUniqueInput
  }

  export type CourseCreateNestedOneWithoutOfferedCoursesInput = {
    create?: XOR<CourseCreateWithoutOfferedCoursesInput, CourseUncheckedCreateWithoutOfferedCoursesInput>
    connectOrCreate?: CourseCreateOrConnectWithoutOfferedCoursesInput
    connect?: CourseWhereUniqueInput
  }

  export type OfferedCourseSectionCreateNestedManyWithoutOfferedCourseInput = {
    create?: XOR<OfferedCourseSectionCreateWithoutOfferedCourseInput, OfferedCourseSectionUncheckedCreateWithoutOfferedCourseInput> | OfferedCourseSectionCreateWithoutOfferedCourseInput[] | OfferedCourseSectionUncheckedCreateWithoutOfferedCourseInput[]
    connectOrCreate?: OfferedCourseSectionCreateOrConnectWithoutOfferedCourseInput | OfferedCourseSectionCreateOrConnectWithoutOfferedCourseInput[]
    createMany?: OfferedCourseSectionCreateManyOfferedCourseInputEnvelope
    connect?: OfferedCourseSectionWhereUniqueInput | OfferedCourseSectionWhereUniqueInput[]
  }

  export type StudentSemesterRegistrationCourseCreateNestedManyWithoutOfferedCourseInput = {
    create?: XOR<StudentSemesterRegistrationCourseCreateWithoutOfferedCourseInput, StudentSemesterRegistrationCourseUncheckedCreateWithoutOfferedCourseInput> | StudentSemesterRegistrationCourseCreateWithoutOfferedCourseInput[] | StudentSemesterRegistrationCourseUncheckedCreateWithoutOfferedCourseInput[]
    connectOrCreate?: StudentSemesterRegistrationCourseCreateOrConnectWithoutOfferedCourseInput | StudentSemesterRegistrationCourseCreateOrConnectWithoutOfferedCourseInput[]
    createMany?: StudentSemesterRegistrationCourseCreateManyOfferedCourseInputEnvelope
    connect?: StudentSemesterRegistrationCourseWhereUniqueInput | StudentSemesterRegistrationCourseWhereUniqueInput[]
  }

  export type OfferedCourseSectionUncheckedCreateNestedManyWithoutOfferedCourseInput = {
    create?: XOR<OfferedCourseSectionCreateWithoutOfferedCourseInput, OfferedCourseSectionUncheckedCreateWithoutOfferedCourseInput> | OfferedCourseSectionCreateWithoutOfferedCourseInput[] | OfferedCourseSectionUncheckedCreateWithoutOfferedCourseInput[]
    connectOrCreate?: OfferedCourseSectionCreateOrConnectWithoutOfferedCourseInput | OfferedCourseSectionCreateOrConnectWithoutOfferedCourseInput[]
    createMany?: OfferedCourseSectionCreateManyOfferedCourseInputEnvelope
    connect?: OfferedCourseSectionWhereUniqueInput | OfferedCourseSectionWhereUniqueInput[]
  }

  export type StudentSemesterRegistrationCourseUncheckedCreateNestedManyWithoutOfferedCourseInput = {
    create?: XOR<StudentSemesterRegistrationCourseCreateWithoutOfferedCourseInput, StudentSemesterRegistrationCourseUncheckedCreateWithoutOfferedCourseInput> | StudentSemesterRegistrationCourseCreateWithoutOfferedCourseInput[] | StudentSemesterRegistrationCourseUncheckedCreateWithoutOfferedCourseInput[]
    connectOrCreate?: StudentSemesterRegistrationCourseCreateOrConnectWithoutOfferedCourseInput | StudentSemesterRegistrationCourseCreateOrConnectWithoutOfferedCourseInput[]
    createMany?: StudentSemesterRegistrationCourseCreateManyOfferedCourseInputEnvelope
    connect?: StudentSemesterRegistrationCourseWhereUniqueInput | StudentSemesterRegistrationCourseWhereUniqueInput[]
  }

  export type AcademicDepartmentUpdateOneRequiredWithoutOfferedCoursesNestedInput = {
    create?: XOR<AcademicDepartmentCreateWithoutOfferedCoursesInput, AcademicDepartmentUncheckedCreateWithoutOfferedCoursesInput>
    connectOrCreate?: AcademicDepartmentCreateOrConnectWithoutOfferedCoursesInput
    upsert?: AcademicDepartmentUpsertWithoutOfferedCoursesInput
    connect?: AcademicDepartmentWhereUniqueInput
    update?: XOR<XOR<AcademicDepartmentUpdateToOneWithWhereWithoutOfferedCoursesInput, AcademicDepartmentUpdateWithoutOfferedCoursesInput>, AcademicDepartmentUncheckedUpdateWithoutOfferedCoursesInput>
  }

  export type SemesterRegistrationUpdateOneRequiredWithoutOfferedCoursesNestedInput = {
    create?: XOR<SemesterRegistrationCreateWithoutOfferedCoursesInput, SemesterRegistrationUncheckedCreateWithoutOfferedCoursesInput>
    connectOrCreate?: SemesterRegistrationCreateOrConnectWithoutOfferedCoursesInput
    upsert?: SemesterRegistrationUpsertWithoutOfferedCoursesInput
    connect?: SemesterRegistrationWhereUniqueInput
    update?: XOR<XOR<SemesterRegistrationUpdateToOneWithWhereWithoutOfferedCoursesInput, SemesterRegistrationUpdateWithoutOfferedCoursesInput>, SemesterRegistrationUncheckedUpdateWithoutOfferedCoursesInput>
  }

  export type CourseUpdateOneRequiredWithoutOfferedCoursesNestedInput = {
    create?: XOR<CourseCreateWithoutOfferedCoursesInput, CourseUncheckedCreateWithoutOfferedCoursesInput>
    connectOrCreate?: CourseCreateOrConnectWithoutOfferedCoursesInput
    upsert?: CourseUpsertWithoutOfferedCoursesInput
    connect?: CourseWhereUniqueInput
    update?: XOR<XOR<CourseUpdateToOneWithWhereWithoutOfferedCoursesInput, CourseUpdateWithoutOfferedCoursesInput>, CourseUncheckedUpdateWithoutOfferedCoursesInput>
  }

  export type OfferedCourseSectionUpdateManyWithoutOfferedCourseNestedInput = {
    create?: XOR<OfferedCourseSectionCreateWithoutOfferedCourseInput, OfferedCourseSectionUncheckedCreateWithoutOfferedCourseInput> | OfferedCourseSectionCreateWithoutOfferedCourseInput[] | OfferedCourseSectionUncheckedCreateWithoutOfferedCourseInput[]
    connectOrCreate?: OfferedCourseSectionCreateOrConnectWithoutOfferedCourseInput | OfferedCourseSectionCreateOrConnectWithoutOfferedCourseInput[]
    upsert?: OfferedCourseSectionUpsertWithWhereUniqueWithoutOfferedCourseInput | OfferedCourseSectionUpsertWithWhereUniqueWithoutOfferedCourseInput[]
    createMany?: OfferedCourseSectionCreateManyOfferedCourseInputEnvelope
    set?: OfferedCourseSectionWhereUniqueInput | OfferedCourseSectionWhereUniqueInput[]
    disconnect?: OfferedCourseSectionWhereUniqueInput | OfferedCourseSectionWhereUniqueInput[]
    delete?: OfferedCourseSectionWhereUniqueInput | OfferedCourseSectionWhereUniqueInput[]
    connect?: OfferedCourseSectionWhereUniqueInput | OfferedCourseSectionWhereUniqueInput[]
    update?: OfferedCourseSectionUpdateWithWhereUniqueWithoutOfferedCourseInput | OfferedCourseSectionUpdateWithWhereUniqueWithoutOfferedCourseInput[]
    updateMany?: OfferedCourseSectionUpdateManyWithWhereWithoutOfferedCourseInput | OfferedCourseSectionUpdateManyWithWhereWithoutOfferedCourseInput[]
    deleteMany?: OfferedCourseSectionScalarWhereInput | OfferedCourseSectionScalarWhereInput[]
  }

  export type StudentSemesterRegistrationCourseUpdateManyWithoutOfferedCourseNestedInput = {
    create?: XOR<StudentSemesterRegistrationCourseCreateWithoutOfferedCourseInput, StudentSemesterRegistrationCourseUncheckedCreateWithoutOfferedCourseInput> | StudentSemesterRegistrationCourseCreateWithoutOfferedCourseInput[] | StudentSemesterRegistrationCourseUncheckedCreateWithoutOfferedCourseInput[]
    connectOrCreate?: StudentSemesterRegistrationCourseCreateOrConnectWithoutOfferedCourseInput | StudentSemesterRegistrationCourseCreateOrConnectWithoutOfferedCourseInput[]
    upsert?: StudentSemesterRegistrationCourseUpsertWithWhereUniqueWithoutOfferedCourseInput | StudentSemesterRegistrationCourseUpsertWithWhereUniqueWithoutOfferedCourseInput[]
    createMany?: StudentSemesterRegistrationCourseCreateManyOfferedCourseInputEnvelope
    set?: StudentSemesterRegistrationCourseWhereUniqueInput | StudentSemesterRegistrationCourseWhereUniqueInput[]
    disconnect?: StudentSemesterRegistrationCourseWhereUniqueInput | StudentSemesterRegistrationCourseWhereUniqueInput[]
    delete?: StudentSemesterRegistrationCourseWhereUniqueInput | StudentSemesterRegistrationCourseWhereUniqueInput[]
    connect?: StudentSemesterRegistrationCourseWhereUniqueInput | StudentSemesterRegistrationCourseWhereUniqueInput[]
    update?: StudentSemesterRegistrationCourseUpdateWithWhereUniqueWithoutOfferedCourseInput | StudentSemesterRegistrationCourseUpdateWithWhereUniqueWithoutOfferedCourseInput[]
    updateMany?: StudentSemesterRegistrationCourseUpdateManyWithWhereWithoutOfferedCourseInput | StudentSemesterRegistrationCourseUpdateManyWithWhereWithoutOfferedCourseInput[]
    deleteMany?: StudentSemesterRegistrationCourseScalarWhereInput | StudentSemesterRegistrationCourseScalarWhereInput[]
  }

  export type OfferedCourseSectionUncheckedUpdateManyWithoutOfferedCourseNestedInput = {
    create?: XOR<OfferedCourseSectionCreateWithoutOfferedCourseInput, OfferedCourseSectionUncheckedCreateWithoutOfferedCourseInput> | OfferedCourseSectionCreateWithoutOfferedCourseInput[] | OfferedCourseSectionUncheckedCreateWithoutOfferedCourseInput[]
    connectOrCreate?: OfferedCourseSectionCreateOrConnectWithoutOfferedCourseInput | OfferedCourseSectionCreateOrConnectWithoutOfferedCourseInput[]
    upsert?: OfferedCourseSectionUpsertWithWhereUniqueWithoutOfferedCourseInput | OfferedCourseSectionUpsertWithWhereUniqueWithoutOfferedCourseInput[]
    createMany?: OfferedCourseSectionCreateManyOfferedCourseInputEnvelope
    set?: OfferedCourseSectionWhereUniqueInput | OfferedCourseSectionWhereUniqueInput[]
    disconnect?: OfferedCourseSectionWhereUniqueInput | OfferedCourseSectionWhereUniqueInput[]
    delete?: OfferedCourseSectionWhereUniqueInput | OfferedCourseSectionWhereUniqueInput[]
    connect?: OfferedCourseSectionWhereUniqueInput | OfferedCourseSectionWhereUniqueInput[]
    update?: OfferedCourseSectionUpdateWithWhereUniqueWithoutOfferedCourseInput | OfferedCourseSectionUpdateWithWhereUniqueWithoutOfferedCourseInput[]
    updateMany?: OfferedCourseSectionUpdateManyWithWhereWithoutOfferedCourseInput | OfferedCourseSectionUpdateManyWithWhereWithoutOfferedCourseInput[]
    deleteMany?: OfferedCourseSectionScalarWhereInput | OfferedCourseSectionScalarWhereInput[]
  }

  export type StudentSemesterRegistrationCourseUncheckedUpdateManyWithoutOfferedCourseNestedInput = {
    create?: XOR<StudentSemesterRegistrationCourseCreateWithoutOfferedCourseInput, StudentSemesterRegistrationCourseUncheckedCreateWithoutOfferedCourseInput> | StudentSemesterRegistrationCourseCreateWithoutOfferedCourseInput[] | StudentSemesterRegistrationCourseUncheckedCreateWithoutOfferedCourseInput[]
    connectOrCreate?: StudentSemesterRegistrationCourseCreateOrConnectWithoutOfferedCourseInput | StudentSemesterRegistrationCourseCreateOrConnectWithoutOfferedCourseInput[]
    upsert?: StudentSemesterRegistrationCourseUpsertWithWhereUniqueWithoutOfferedCourseInput | StudentSemesterRegistrationCourseUpsertWithWhereUniqueWithoutOfferedCourseInput[]
    createMany?: StudentSemesterRegistrationCourseCreateManyOfferedCourseInputEnvelope
    set?: StudentSemesterRegistrationCourseWhereUniqueInput | StudentSemesterRegistrationCourseWhereUniqueInput[]
    disconnect?: StudentSemesterRegistrationCourseWhereUniqueInput | StudentSemesterRegistrationCourseWhereUniqueInput[]
    delete?: StudentSemesterRegistrationCourseWhereUniqueInput | StudentSemesterRegistrationCourseWhereUniqueInput[]
    connect?: StudentSemesterRegistrationCourseWhereUniqueInput | StudentSemesterRegistrationCourseWhereUniqueInput[]
    update?: StudentSemesterRegistrationCourseUpdateWithWhereUniqueWithoutOfferedCourseInput | StudentSemesterRegistrationCourseUpdateWithWhereUniqueWithoutOfferedCourseInput[]
    updateMany?: StudentSemesterRegistrationCourseUpdateManyWithWhereWithoutOfferedCourseInput | StudentSemesterRegistrationCourseUpdateManyWithWhereWithoutOfferedCourseInput[]
    deleteMany?: StudentSemesterRegistrationCourseScalarWhereInput | StudentSemesterRegistrationCourseScalarWhereInput[]
  }

  export type SemesterRegistrationCreateNestedOneWithoutOfferedCourseSectionsInput = {
    create?: XOR<SemesterRegistrationCreateWithoutOfferedCourseSectionsInput, SemesterRegistrationUncheckedCreateWithoutOfferedCourseSectionsInput>
    connectOrCreate?: SemesterRegistrationCreateOrConnectWithoutOfferedCourseSectionsInput
    connect?: SemesterRegistrationWhereUniqueInput
  }

  export type OfferedCourseCreateNestedOneWithoutOfferedCourseSectionsInput = {
    create?: XOR<OfferedCourseCreateWithoutOfferedCourseSectionsInput, OfferedCourseUncheckedCreateWithoutOfferedCourseSectionsInput>
    connectOrCreate?: OfferedCourseCreateOrConnectWithoutOfferedCourseSectionsInput
    connect?: OfferedCourseWhereUniqueInput
  }

  export type OfferedCourseClassScheduleCreateNestedManyWithoutOfferedCourseSectionInput = {
    create?: XOR<OfferedCourseClassScheduleCreateWithoutOfferedCourseSectionInput, OfferedCourseClassScheduleUncheckedCreateWithoutOfferedCourseSectionInput> | OfferedCourseClassScheduleCreateWithoutOfferedCourseSectionInput[] | OfferedCourseClassScheduleUncheckedCreateWithoutOfferedCourseSectionInput[]
    connectOrCreate?: OfferedCourseClassScheduleCreateOrConnectWithoutOfferedCourseSectionInput | OfferedCourseClassScheduleCreateOrConnectWithoutOfferedCourseSectionInput[]
    createMany?: OfferedCourseClassScheduleCreateManyOfferedCourseSectionInputEnvelope
    connect?: OfferedCourseClassScheduleWhereUniqueInput | OfferedCourseClassScheduleWhereUniqueInput[]
  }

  export type StudentSemesterRegistrationCourseCreateNestedManyWithoutOfferedCourseSectionInput = {
    create?: XOR<StudentSemesterRegistrationCourseCreateWithoutOfferedCourseSectionInput, StudentSemesterRegistrationCourseUncheckedCreateWithoutOfferedCourseSectionInput> | StudentSemesterRegistrationCourseCreateWithoutOfferedCourseSectionInput[] | StudentSemesterRegistrationCourseUncheckedCreateWithoutOfferedCourseSectionInput[]
    connectOrCreate?: StudentSemesterRegistrationCourseCreateOrConnectWithoutOfferedCourseSectionInput | StudentSemesterRegistrationCourseCreateOrConnectWithoutOfferedCourseSectionInput[]
    createMany?: StudentSemesterRegistrationCourseCreateManyOfferedCourseSectionInputEnvelope
    connect?: StudentSemesterRegistrationCourseWhereUniqueInput | StudentSemesterRegistrationCourseWhereUniqueInput[]
  }

  export type OfferedCourseClassScheduleUncheckedCreateNestedManyWithoutOfferedCourseSectionInput = {
    create?: XOR<OfferedCourseClassScheduleCreateWithoutOfferedCourseSectionInput, OfferedCourseClassScheduleUncheckedCreateWithoutOfferedCourseSectionInput> | OfferedCourseClassScheduleCreateWithoutOfferedCourseSectionInput[] | OfferedCourseClassScheduleUncheckedCreateWithoutOfferedCourseSectionInput[]
    connectOrCreate?: OfferedCourseClassScheduleCreateOrConnectWithoutOfferedCourseSectionInput | OfferedCourseClassScheduleCreateOrConnectWithoutOfferedCourseSectionInput[]
    createMany?: OfferedCourseClassScheduleCreateManyOfferedCourseSectionInputEnvelope
    connect?: OfferedCourseClassScheduleWhereUniqueInput | OfferedCourseClassScheduleWhereUniqueInput[]
  }

  export type StudentSemesterRegistrationCourseUncheckedCreateNestedManyWithoutOfferedCourseSectionInput = {
    create?: XOR<StudentSemesterRegistrationCourseCreateWithoutOfferedCourseSectionInput, StudentSemesterRegistrationCourseUncheckedCreateWithoutOfferedCourseSectionInput> | StudentSemesterRegistrationCourseCreateWithoutOfferedCourseSectionInput[] | StudentSemesterRegistrationCourseUncheckedCreateWithoutOfferedCourseSectionInput[]
    connectOrCreate?: StudentSemesterRegistrationCourseCreateOrConnectWithoutOfferedCourseSectionInput | StudentSemesterRegistrationCourseCreateOrConnectWithoutOfferedCourseSectionInput[]
    createMany?: StudentSemesterRegistrationCourseCreateManyOfferedCourseSectionInputEnvelope
    connect?: StudentSemesterRegistrationCourseWhereUniqueInput | StudentSemesterRegistrationCourseWhereUniqueInput[]
  }

  export type SemesterRegistrationUpdateOneRequiredWithoutOfferedCourseSectionsNestedInput = {
    create?: XOR<SemesterRegistrationCreateWithoutOfferedCourseSectionsInput, SemesterRegistrationUncheckedCreateWithoutOfferedCourseSectionsInput>
    connectOrCreate?: SemesterRegistrationCreateOrConnectWithoutOfferedCourseSectionsInput
    upsert?: SemesterRegistrationUpsertWithoutOfferedCourseSectionsInput
    connect?: SemesterRegistrationWhereUniqueInput
    update?: XOR<XOR<SemesterRegistrationUpdateToOneWithWhereWithoutOfferedCourseSectionsInput, SemesterRegistrationUpdateWithoutOfferedCourseSectionsInput>, SemesterRegistrationUncheckedUpdateWithoutOfferedCourseSectionsInput>
  }

  export type OfferedCourseUpdateOneRequiredWithoutOfferedCourseSectionsNestedInput = {
    create?: XOR<OfferedCourseCreateWithoutOfferedCourseSectionsInput, OfferedCourseUncheckedCreateWithoutOfferedCourseSectionsInput>
    connectOrCreate?: OfferedCourseCreateOrConnectWithoutOfferedCourseSectionsInput
    upsert?: OfferedCourseUpsertWithoutOfferedCourseSectionsInput
    connect?: OfferedCourseWhereUniqueInput
    update?: XOR<XOR<OfferedCourseUpdateToOneWithWhereWithoutOfferedCourseSectionsInput, OfferedCourseUpdateWithoutOfferedCourseSectionsInput>, OfferedCourseUncheckedUpdateWithoutOfferedCourseSectionsInput>
  }

  export type OfferedCourseClassScheduleUpdateManyWithoutOfferedCourseSectionNestedInput = {
    create?: XOR<OfferedCourseClassScheduleCreateWithoutOfferedCourseSectionInput, OfferedCourseClassScheduleUncheckedCreateWithoutOfferedCourseSectionInput> | OfferedCourseClassScheduleCreateWithoutOfferedCourseSectionInput[] | OfferedCourseClassScheduleUncheckedCreateWithoutOfferedCourseSectionInput[]
    connectOrCreate?: OfferedCourseClassScheduleCreateOrConnectWithoutOfferedCourseSectionInput | OfferedCourseClassScheduleCreateOrConnectWithoutOfferedCourseSectionInput[]
    upsert?: OfferedCourseClassScheduleUpsertWithWhereUniqueWithoutOfferedCourseSectionInput | OfferedCourseClassScheduleUpsertWithWhereUniqueWithoutOfferedCourseSectionInput[]
    createMany?: OfferedCourseClassScheduleCreateManyOfferedCourseSectionInputEnvelope
    set?: OfferedCourseClassScheduleWhereUniqueInput | OfferedCourseClassScheduleWhereUniqueInput[]
    disconnect?: OfferedCourseClassScheduleWhereUniqueInput | OfferedCourseClassScheduleWhereUniqueInput[]
    delete?: OfferedCourseClassScheduleWhereUniqueInput | OfferedCourseClassScheduleWhereUniqueInput[]
    connect?: OfferedCourseClassScheduleWhereUniqueInput | OfferedCourseClassScheduleWhereUniqueInput[]
    update?: OfferedCourseClassScheduleUpdateWithWhereUniqueWithoutOfferedCourseSectionInput | OfferedCourseClassScheduleUpdateWithWhereUniqueWithoutOfferedCourseSectionInput[]
    updateMany?: OfferedCourseClassScheduleUpdateManyWithWhereWithoutOfferedCourseSectionInput | OfferedCourseClassScheduleUpdateManyWithWhereWithoutOfferedCourseSectionInput[]
    deleteMany?: OfferedCourseClassScheduleScalarWhereInput | OfferedCourseClassScheduleScalarWhereInput[]
  }

  export type StudentSemesterRegistrationCourseUpdateManyWithoutOfferedCourseSectionNestedInput = {
    create?: XOR<StudentSemesterRegistrationCourseCreateWithoutOfferedCourseSectionInput, StudentSemesterRegistrationCourseUncheckedCreateWithoutOfferedCourseSectionInput> | StudentSemesterRegistrationCourseCreateWithoutOfferedCourseSectionInput[] | StudentSemesterRegistrationCourseUncheckedCreateWithoutOfferedCourseSectionInput[]
    connectOrCreate?: StudentSemesterRegistrationCourseCreateOrConnectWithoutOfferedCourseSectionInput | StudentSemesterRegistrationCourseCreateOrConnectWithoutOfferedCourseSectionInput[]
    upsert?: StudentSemesterRegistrationCourseUpsertWithWhereUniqueWithoutOfferedCourseSectionInput | StudentSemesterRegistrationCourseUpsertWithWhereUniqueWithoutOfferedCourseSectionInput[]
    createMany?: StudentSemesterRegistrationCourseCreateManyOfferedCourseSectionInputEnvelope
    set?: StudentSemesterRegistrationCourseWhereUniqueInput | StudentSemesterRegistrationCourseWhereUniqueInput[]
    disconnect?: StudentSemesterRegistrationCourseWhereUniqueInput | StudentSemesterRegistrationCourseWhereUniqueInput[]
    delete?: StudentSemesterRegistrationCourseWhereUniqueInput | StudentSemesterRegistrationCourseWhereUniqueInput[]
    connect?: StudentSemesterRegistrationCourseWhereUniqueInput | StudentSemesterRegistrationCourseWhereUniqueInput[]
    update?: StudentSemesterRegistrationCourseUpdateWithWhereUniqueWithoutOfferedCourseSectionInput | StudentSemesterRegistrationCourseUpdateWithWhereUniqueWithoutOfferedCourseSectionInput[]
    updateMany?: StudentSemesterRegistrationCourseUpdateManyWithWhereWithoutOfferedCourseSectionInput | StudentSemesterRegistrationCourseUpdateManyWithWhereWithoutOfferedCourseSectionInput[]
    deleteMany?: StudentSemesterRegistrationCourseScalarWhereInput | StudentSemesterRegistrationCourseScalarWhereInput[]
  }

  export type OfferedCourseClassScheduleUncheckedUpdateManyWithoutOfferedCourseSectionNestedInput = {
    create?: XOR<OfferedCourseClassScheduleCreateWithoutOfferedCourseSectionInput, OfferedCourseClassScheduleUncheckedCreateWithoutOfferedCourseSectionInput> | OfferedCourseClassScheduleCreateWithoutOfferedCourseSectionInput[] | OfferedCourseClassScheduleUncheckedCreateWithoutOfferedCourseSectionInput[]
    connectOrCreate?: OfferedCourseClassScheduleCreateOrConnectWithoutOfferedCourseSectionInput | OfferedCourseClassScheduleCreateOrConnectWithoutOfferedCourseSectionInput[]
    upsert?: OfferedCourseClassScheduleUpsertWithWhereUniqueWithoutOfferedCourseSectionInput | OfferedCourseClassScheduleUpsertWithWhereUniqueWithoutOfferedCourseSectionInput[]
    createMany?: OfferedCourseClassScheduleCreateManyOfferedCourseSectionInputEnvelope
    set?: OfferedCourseClassScheduleWhereUniqueInput | OfferedCourseClassScheduleWhereUniqueInput[]
    disconnect?: OfferedCourseClassScheduleWhereUniqueInput | OfferedCourseClassScheduleWhereUniqueInput[]
    delete?: OfferedCourseClassScheduleWhereUniqueInput | OfferedCourseClassScheduleWhereUniqueInput[]
    connect?: OfferedCourseClassScheduleWhereUniqueInput | OfferedCourseClassScheduleWhereUniqueInput[]
    update?: OfferedCourseClassScheduleUpdateWithWhereUniqueWithoutOfferedCourseSectionInput | OfferedCourseClassScheduleUpdateWithWhereUniqueWithoutOfferedCourseSectionInput[]
    updateMany?: OfferedCourseClassScheduleUpdateManyWithWhereWithoutOfferedCourseSectionInput | OfferedCourseClassScheduleUpdateManyWithWhereWithoutOfferedCourseSectionInput[]
    deleteMany?: OfferedCourseClassScheduleScalarWhereInput | OfferedCourseClassScheduleScalarWhereInput[]
  }

  export type StudentSemesterRegistrationCourseUncheckedUpdateManyWithoutOfferedCourseSectionNestedInput = {
    create?: XOR<StudentSemesterRegistrationCourseCreateWithoutOfferedCourseSectionInput, StudentSemesterRegistrationCourseUncheckedCreateWithoutOfferedCourseSectionInput> | StudentSemesterRegistrationCourseCreateWithoutOfferedCourseSectionInput[] | StudentSemesterRegistrationCourseUncheckedCreateWithoutOfferedCourseSectionInput[]
    connectOrCreate?: StudentSemesterRegistrationCourseCreateOrConnectWithoutOfferedCourseSectionInput | StudentSemesterRegistrationCourseCreateOrConnectWithoutOfferedCourseSectionInput[]
    upsert?: StudentSemesterRegistrationCourseUpsertWithWhereUniqueWithoutOfferedCourseSectionInput | StudentSemesterRegistrationCourseUpsertWithWhereUniqueWithoutOfferedCourseSectionInput[]
    createMany?: StudentSemesterRegistrationCourseCreateManyOfferedCourseSectionInputEnvelope
    set?: StudentSemesterRegistrationCourseWhereUniqueInput | StudentSemesterRegistrationCourseWhereUniqueInput[]
    disconnect?: StudentSemesterRegistrationCourseWhereUniqueInput | StudentSemesterRegistrationCourseWhereUniqueInput[]
    delete?: StudentSemesterRegistrationCourseWhereUniqueInput | StudentSemesterRegistrationCourseWhereUniqueInput[]
    connect?: StudentSemesterRegistrationCourseWhereUniqueInput | StudentSemesterRegistrationCourseWhereUniqueInput[]
    update?: StudentSemesterRegistrationCourseUpdateWithWhereUniqueWithoutOfferedCourseSectionInput | StudentSemesterRegistrationCourseUpdateWithWhereUniqueWithoutOfferedCourseSectionInput[]
    updateMany?: StudentSemesterRegistrationCourseUpdateManyWithWhereWithoutOfferedCourseSectionInput | StudentSemesterRegistrationCourseUpdateManyWithWhereWithoutOfferedCourseSectionInput[]
    deleteMany?: StudentSemesterRegistrationCourseScalarWhereInput | StudentSemesterRegistrationCourseScalarWhereInput[]
  }

  export type OfferedCourseSectionCreateNestedOneWithoutOfferedCourseClassSchedulesInput = {
    create?: XOR<OfferedCourseSectionCreateWithoutOfferedCourseClassSchedulesInput, OfferedCourseSectionUncheckedCreateWithoutOfferedCourseClassSchedulesInput>
    connectOrCreate?: OfferedCourseSectionCreateOrConnectWithoutOfferedCourseClassSchedulesInput
    connect?: OfferedCourseSectionWhereUniqueInput
  }

  export type SemesterRegistrationCreateNestedOneWithoutOfferedCourseClassSchedulesInput = {
    create?: XOR<SemesterRegistrationCreateWithoutOfferedCourseClassSchedulesInput, SemesterRegistrationUncheckedCreateWithoutOfferedCourseClassSchedulesInput>
    connectOrCreate?: SemesterRegistrationCreateOrConnectWithoutOfferedCourseClassSchedulesInput
    connect?: SemesterRegistrationWhereUniqueInput
  }

  export type RoomCreateNestedOneWithoutOfferedCourseClassSchedulesInput = {
    create?: XOR<RoomCreateWithoutOfferedCourseClassSchedulesInput, RoomUncheckedCreateWithoutOfferedCourseClassSchedulesInput>
    connectOrCreate?: RoomCreateOrConnectWithoutOfferedCourseClassSchedulesInput
    connect?: RoomWhereUniqueInput
  }

  export type FacultyCreateNestedOneWithoutOfferedCourseClassSchedulesInput = {
    create?: XOR<FacultyCreateWithoutOfferedCourseClassSchedulesInput, FacultyUncheckedCreateWithoutOfferedCourseClassSchedulesInput>
    connectOrCreate?: FacultyCreateOrConnectWithoutOfferedCourseClassSchedulesInput
    connect?: FacultyWhereUniqueInput
  }

  export type EnumWeekDaysFieldUpdateOperationsInput = {
    set?: $Enums.WeekDays
  }

  export type OfferedCourseSectionUpdateOneRequiredWithoutOfferedCourseClassSchedulesNestedInput = {
    create?: XOR<OfferedCourseSectionCreateWithoutOfferedCourseClassSchedulesInput, OfferedCourseSectionUncheckedCreateWithoutOfferedCourseClassSchedulesInput>
    connectOrCreate?: OfferedCourseSectionCreateOrConnectWithoutOfferedCourseClassSchedulesInput
    upsert?: OfferedCourseSectionUpsertWithoutOfferedCourseClassSchedulesInput
    connect?: OfferedCourseSectionWhereUniqueInput
    update?: XOR<XOR<OfferedCourseSectionUpdateToOneWithWhereWithoutOfferedCourseClassSchedulesInput, OfferedCourseSectionUpdateWithoutOfferedCourseClassSchedulesInput>, OfferedCourseSectionUncheckedUpdateWithoutOfferedCourseClassSchedulesInput>
  }

  export type SemesterRegistrationUpdateOneRequiredWithoutOfferedCourseClassSchedulesNestedInput = {
    create?: XOR<SemesterRegistrationCreateWithoutOfferedCourseClassSchedulesInput, SemesterRegistrationUncheckedCreateWithoutOfferedCourseClassSchedulesInput>
    connectOrCreate?: SemesterRegistrationCreateOrConnectWithoutOfferedCourseClassSchedulesInput
    upsert?: SemesterRegistrationUpsertWithoutOfferedCourseClassSchedulesInput
    connect?: SemesterRegistrationWhereUniqueInput
    update?: XOR<XOR<SemesterRegistrationUpdateToOneWithWhereWithoutOfferedCourseClassSchedulesInput, SemesterRegistrationUpdateWithoutOfferedCourseClassSchedulesInput>, SemesterRegistrationUncheckedUpdateWithoutOfferedCourseClassSchedulesInput>
  }

  export type RoomUpdateOneRequiredWithoutOfferedCourseClassSchedulesNestedInput = {
    create?: XOR<RoomCreateWithoutOfferedCourseClassSchedulesInput, RoomUncheckedCreateWithoutOfferedCourseClassSchedulesInput>
    connectOrCreate?: RoomCreateOrConnectWithoutOfferedCourseClassSchedulesInput
    upsert?: RoomUpsertWithoutOfferedCourseClassSchedulesInput
    connect?: RoomWhereUniqueInput
    update?: XOR<XOR<RoomUpdateToOneWithWhereWithoutOfferedCourseClassSchedulesInput, RoomUpdateWithoutOfferedCourseClassSchedulesInput>, RoomUncheckedUpdateWithoutOfferedCourseClassSchedulesInput>
  }

  export type FacultyUpdateOneRequiredWithoutOfferedCourseClassSchedulesNestedInput = {
    create?: XOR<FacultyCreateWithoutOfferedCourseClassSchedulesInput, FacultyUncheckedCreateWithoutOfferedCourseClassSchedulesInput>
    connectOrCreate?: FacultyCreateOrConnectWithoutOfferedCourseClassSchedulesInput
    upsert?: FacultyUpsertWithoutOfferedCourseClassSchedulesInput
    connect?: FacultyWhereUniqueInput
    update?: XOR<XOR<FacultyUpdateToOneWithWhereWithoutOfferedCourseClassSchedulesInput, FacultyUpdateWithoutOfferedCourseClassSchedulesInput>, FacultyUncheckedUpdateWithoutOfferedCourseClassSchedulesInput>
  }

  export type StudentCreateNestedOneWithoutStudentSemesterRegistrationsInput = {
    create?: XOR<StudentCreateWithoutStudentSemesterRegistrationsInput, StudentUncheckedCreateWithoutStudentSemesterRegistrationsInput>
    connectOrCreate?: StudentCreateOrConnectWithoutStudentSemesterRegistrationsInput
    connect?: StudentWhereUniqueInput
  }

  export type SemesterRegistrationCreateNestedOneWithoutStudentSemesterRegistrationsInput = {
    create?: XOR<SemesterRegistrationCreateWithoutStudentSemesterRegistrationsInput, SemesterRegistrationUncheckedCreateWithoutStudentSemesterRegistrationsInput>
    connectOrCreate?: SemesterRegistrationCreateOrConnectWithoutStudentSemesterRegistrationsInput
    connect?: SemesterRegistrationWhereUniqueInput
  }

  export type StudentUpdateOneRequiredWithoutStudentSemesterRegistrationsNestedInput = {
    create?: XOR<StudentCreateWithoutStudentSemesterRegistrationsInput, StudentUncheckedCreateWithoutStudentSemesterRegistrationsInput>
    connectOrCreate?: StudentCreateOrConnectWithoutStudentSemesterRegistrationsInput
    upsert?: StudentUpsertWithoutStudentSemesterRegistrationsInput
    connect?: StudentWhereUniqueInput
    update?: XOR<XOR<StudentUpdateToOneWithWhereWithoutStudentSemesterRegistrationsInput, StudentUpdateWithoutStudentSemesterRegistrationsInput>, StudentUncheckedUpdateWithoutStudentSemesterRegistrationsInput>
  }

  export type SemesterRegistrationUpdateOneRequiredWithoutStudentSemesterRegistrationsNestedInput = {
    create?: XOR<SemesterRegistrationCreateWithoutStudentSemesterRegistrationsInput, SemesterRegistrationUncheckedCreateWithoutStudentSemesterRegistrationsInput>
    connectOrCreate?: SemesterRegistrationCreateOrConnectWithoutStudentSemesterRegistrationsInput
    upsert?: SemesterRegistrationUpsertWithoutStudentSemesterRegistrationsInput
    connect?: SemesterRegistrationWhereUniqueInput
    update?: XOR<XOR<SemesterRegistrationUpdateToOneWithWhereWithoutStudentSemesterRegistrationsInput, SemesterRegistrationUpdateWithoutStudentSemesterRegistrationsInput>, SemesterRegistrationUncheckedUpdateWithoutStudentSemesterRegistrationsInput>
  }

  export type SemesterRegistrationCreateNestedOneWithoutStudentSemesterRegistrationCoursesInput = {
    create?: XOR<SemesterRegistrationCreateWithoutStudentSemesterRegistrationCoursesInput, SemesterRegistrationUncheckedCreateWithoutStudentSemesterRegistrationCoursesInput>
    connectOrCreate?: SemesterRegistrationCreateOrConnectWithoutStudentSemesterRegistrationCoursesInput
    connect?: SemesterRegistrationWhereUniqueInput
  }

  export type StudentCreateNestedOneWithoutStudentSemesterRegistrationCoursesInput = {
    create?: XOR<StudentCreateWithoutStudentSemesterRegistrationCoursesInput, StudentUncheckedCreateWithoutStudentSemesterRegistrationCoursesInput>
    connectOrCreate?: StudentCreateOrConnectWithoutStudentSemesterRegistrationCoursesInput
    connect?: StudentWhereUniqueInput
  }

  export type OfferedCourseCreateNestedOneWithoutStudentSemesterRegistrationCoursesInput = {
    create?: XOR<OfferedCourseCreateWithoutStudentSemesterRegistrationCoursesInput, OfferedCourseUncheckedCreateWithoutStudentSemesterRegistrationCoursesInput>
    connectOrCreate?: OfferedCourseCreateOrConnectWithoutStudentSemesterRegistrationCoursesInput
    connect?: OfferedCourseWhereUniqueInput
  }

  export type OfferedCourseSectionCreateNestedOneWithoutStudentSemesterRegistrationCoursesInput = {
    create?: XOR<OfferedCourseSectionCreateWithoutStudentSemesterRegistrationCoursesInput, OfferedCourseSectionUncheckedCreateWithoutStudentSemesterRegistrationCoursesInput>
    connectOrCreate?: OfferedCourseSectionCreateOrConnectWithoutStudentSemesterRegistrationCoursesInput
    connect?: OfferedCourseSectionWhereUniqueInput
  }

  export type SemesterRegistrationUpdateOneRequiredWithoutStudentSemesterRegistrationCoursesNestedInput = {
    create?: XOR<SemesterRegistrationCreateWithoutStudentSemesterRegistrationCoursesInput, SemesterRegistrationUncheckedCreateWithoutStudentSemesterRegistrationCoursesInput>
    connectOrCreate?: SemesterRegistrationCreateOrConnectWithoutStudentSemesterRegistrationCoursesInput
    upsert?: SemesterRegistrationUpsertWithoutStudentSemesterRegistrationCoursesInput
    connect?: SemesterRegistrationWhereUniqueInput
    update?: XOR<XOR<SemesterRegistrationUpdateToOneWithWhereWithoutStudentSemesterRegistrationCoursesInput, SemesterRegistrationUpdateWithoutStudentSemesterRegistrationCoursesInput>, SemesterRegistrationUncheckedUpdateWithoutStudentSemesterRegistrationCoursesInput>
  }

  export type StudentUpdateOneRequiredWithoutStudentSemesterRegistrationCoursesNestedInput = {
    create?: XOR<StudentCreateWithoutStudentSemesterRegistrationCoursesInput, StudentUncheckedCreateWithoutStudentSemesterRegistrationCoursesInput>
    connectOrCreate?: StudentCreateOrConnectWithoutStudentSemesterRegistrationCoursesInput
    upsert?: StudentUpsertWithoutStudentSemesterRegistrationCoursesInput
    connect?: StudentWhereUniqueInput
    update?: XOR<XOR<StudentUpdateToOneWithWhereWithoutStudentSemesterRegistrationCoursesInput, StudentUpdateWithoutStudentSemesterRegistrationCoursesInput>, StudentUncheckedUpdateWithoutStudentSemesterRegistrationCoursesInput>
  }

  export type OfferedCourseUpdateOneRequiredWithoutStudentSemesterRegistrationCoursesNestedInput = {
    create?: XOR<OfferedCourseCreateWithoutStudentSemesterRegistrationCoursesInput, OfferedCourseUncheckedCreateWithoutStudentSemesterRegistrationCoursesInput>
    connectOrCreate?: OfferedCourseCreateOrConnectWithoutStudentSemesterRegistrationCoursesInput
    upsert?: OfferedCourseUpsertWithoutStudentSemesterRegistrationCoursesInput
    connect?: OfferedCourseWhereUniqueInput
    update?: XOR<XOR<OfferedCourseUpdateToOneWithWhereWithoutStudentSemesterRegistrationCoursesInput, OfferedCourseUpdateWithoutStudentSemesterRegistrationCoursesInput>, OfferedCourseUncheckedUpdateWithoutStudentSemesterRegistrationCoursesInput>
  }

  export type OfferedCourseSectionUpdateOneRequiredWithoutStudentSemesterRegistrationCoursesNestedInput = {
    create?: XOR<OfferedCourseSectionCreateWithoutStudentSemesterRegistrationCoursesInput, OfferedCourseSectionUncheckedCreateWithoutStudentSemesterRegistrationCoursesInput>
    connectOrCreate?: OfferedCourseSectionCreateOrConnectWithoutStudentSemesterRegistrationCoursesInput
    upsert?: OfferedCourseSectionUpsertWithoutStudentSemesterRegistrationCoursesInput
    connect?: OfferedCourseSectionWhereUniqueInput
    update?: XOR<XOR<OfferedCourseSectionUpdateToOneWithWhereWithoutStudentSemesterRegistrationCoursesInput, OfferedCourseSectionUpdateWithoutStudentSemesterRegistrationCoursesInput>, OfferedCourseSectionUncheckedUpdateWithoutStudentSemesterRegistrationCoursesInput>
  }

  export type StudentCreateNestedOneWithoutStudentEnrolledCoursesInput = {
    create?: XOR<StudentCreateWithoutStudentEnrolledCoursesInput, StudentUncheckedCreateWithoutStudentEnrolledCoursesInput>
    connectOrCreate?: StudentCreateOrConnectWithoutStudentEnrolledCoursesInput
    connect?: StudentWhereUniqueInput
  }

  export type CourseCreateNestedOneWithoutStudentCoursesInput = {
    create?: XOR<CourseCreateWithoutStudentCoursesInput, CourseUncheckedCreateWithoutStudentCoursesInput>
    connectOrCreate?: CourseCreateOrConnectWithoutStudentCoursesInput
    connect?: CourseWhereUniqueInput
  }

  export type StudentEnrolledCourseMarkCreateNestedManyWithoutStudentEnrolledCourseInput = {
    create?: XOR<StudentEnrolledCourseMarkCreateWithoutStudentEnrolledCourseInput, StudentEnrolledCourseMarkUncheckedCreateWithoutStudentEnrolledCourseInput> | StudentEnrolledCourseMarkCreateWithoutStudentEnrolledCourseInput[] | StudentEnrolledCourseMarkUncheckedCreateWithoutStudentEnrolledCourseInput[]
    connectOrCreate?: StudentEnrolledCourseMarkCreateOrConnectWithoutStudentEnrolledCourseInput | StudentEnrolledCourseMarkCreateOrConnectWithoutStudentEnrolledCourseInput[]
    createMany?: StudentEnrolledCourseMarkCreateManyStudentEnrolledCourseInputEnvelope
    connect?: StudentEnrolledCourseMarkWhereUniqueInput | StudentEnrolledCourseMarkWhereUniqueInput[]
  }

  export type AcademicSemesterCreateNestedOneWithoutStudentEnrolledCoursesInput = {
    create?: XOR<AcademicSemesterCreateWithoutStudentEnrolledCoursesInput, AcademicSemesterUncheckedCreateWithoutStudentEnrolledCoursesInput>
    connectOrCreate?: AcademicSemesterCreateOrConnectWithoutStudentEnrolledCoursesInput
    connect?: AcademicSemesterWhereUniqueInput
  }

  export type StudentEnrolledCourseMarkUncheckedCreateNestedManyWithoutStudentEnrolledCourseInput = {
    create?: XOR<StudentEnrolledCourseMarkCreateWithoutStudentEnrolledCourseInput, StudentEnrolledCourseMarkUncheckedCreateWithoutStudentEnrolledCourseInput> | StudentEnrolledCourseMarkCreateWithoutStudentEnrolledCourseInput[] | StudentEnrolledCourseMarkUncheckedCreateWithoutStudentEnrolledCourseInput[]
    connectOrCreate?: StudentEnrolledCourseMarkCreateOrConnectWithoutStudentEnrolledCourseInput | StudentEnrolledCourseMarkCreateOrConnectWithoutStudentEnrolledCourseInput[]
    createMany?: StudentEnrolledCourseMarkCreateManyStudentEnrolledCourseInputEnvelope
    connect?: StudentEnrolledCourseMarkWhereUniqueInput | StudentEnrolledCourseMarkWhereUniqueInput[]
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableEnumStudentEnrolledCourseStatusFieldUpdateOperationsInput = {
    set?: $Enums.StudentEnrolledCourseStatus | null
  }

  export type StudentUpdateOneRequiredWithoutStudentEnrolledCoursesNestedInput = {
    create?: XOR<StudentCreateWithoutStudentEnrolledCoursesInput, StudentUncheckedCreateWithoutStudentEnrolledCoursesInput>
    connectOrCreate?: StudentCreateOrConnectWithoutStudentEnrolledCoursesInput
    upsert?: StudentUpsertWithoutStudentEnrolledCoursesInput
    connect?: StudentWhereUniqueInput
    update?: XOR<XOR<StudentUpdateToOneWithWhereWithoutStudentEnrolledCoursesInput, StudentUpdateWithoutStudentEnrolledCoursesInput>, StudentUncheckedUpdateWithoutStudentEnrolledCoursesInput>
  }

  export type CourseUpdateOneRequiredWithoutStudentCoursesNestedInput = {
    create?: XOR<CourseCreateWithoutStudentCoursesInput, CourseUncheckedCreateWithoutStudentCoursesInput>
    connectOrCreate?: CourseCreateOrConnectWithoutStudentCoursesInput
    upsert?: CourseUpsertWithoutStudentCoursesInput
    connect?: CourseWhereUniqueInput
    update?: XOR<XOR<CourseUpdateToOneWithWhereWithoutStudentCoursesInput, CourseUpdateWithoutStudentCoursesInput>, CourseUncheckedUpdateWithoutStudentCoursesInput>
  }

  export type StudentEnrolledCourseMarkUpdateManyWithoutStudentEnrolledCourseNestedInput = {
    create?: XOR<StudentEnrolledCourseMarkCreateWithoutStudentEnrolledCourseInput, StudentEnrolledCourseMarkUncheckedCreateWithoutStudentEnrolledCourseInput> | StudentEnrolledCourseMarkCreateWithoutStudentEnrolledCourseInput[] | StudentEnrolledCourseMarkUncheckedCreateWithoutStudentEnrolledCourseInput[]
    connectOrCreate?: StudentEnrolledCourseMarkCreateOrConnectWithoutStudentEnrolledCourseInput | StudentEnrolledCourseMarkCreateOrConnectWithoutStudentEnrolledCourseInput[]
    upsert?: StudentEnrolledCourseMarkUpsertWithWhereUniqueWithoutStudentEnrolledCourseInput | StudentEnrolledCourseMarkUpsertWithWhereUniqueWithoutStudentEnrolledCourseInput[]
    createMany?: StudentEnrolledCourseMarkCreateManyStudentEnrolledCourseInputEnvelope
    set?: StudentEnrolledCourseMarkWhereUniqueInput | StudentEnrolledCourseMarkWhereUniqueInput[]
    disconnect?: StudentEnrolledCourseMarkWhereUniqueInput | StudentEnrolledCourseMarkWhereUniqueInput[]
    delete?: StudentEnrolledCourseMarkWhereUniqueInput | StudentEnrolledCourseMarkWhereUniqueInput[]
    connect?: StudentEnrolledCourseMarkWhereUniqueInput | StudentEnrolledCourseMarkWhereUniqueInput[]
    update?: StudentEnrolledCourseMarkUpdateWithWhereUniqueWithoutStudentEnrolledCourseInput | StudentEnrolledCourseMarkUpdateWithWhereUniqueWithoutStudentEnrolledCourseInput[]
    updateMany?: StudentEnrolledCourseMarkUpdateManyWithWhereWithoutStudentEnrolledCourseInput | StudentEnrolledCourseMarkUpdateManyWithWhereWithoutStudentEnrolledCourseInput[]
    deleteMany?: StudentEnrolledCourseMarkScalarWhereInput | StudentEnrolledCourseMarkScalarWhereInput[]
  }

  export type AcademicSemesterUpdateOneRequiredWithoutStudentEnrolledCoursesNestedInput = {
    create?: XOR<AcademicSemesterCreateWithoutStudentEnrolledCoursesInput, AcademicSemesterUncheckedCreateWithoutStudentEnrolledCoursesInput>
    connectOrCreate?: AcademicSemesterCreateOrConnectWithoutStudentEnrolledCoursesInput
    upsert?: AcademicSemesterUpsertWithoutStudentEnrolledCoursesInput
    connect?: AcademicSemesterWhereUniqueInput
    update?: XOR<XOR<AcademicSemesterUpdateToOneWithWhereWithoutStudentEnrolledCoursesInput, AcademicSemesterUpdateWithoutStudentEnrolledCoursesInput>, AcademicSemesterUncheckedUpdateWithoutStudentEnrolledCoursesInput>
  }

  export type StudentEnrolledCourseMarkUncheckedUpdateManyWithoutStudentEnrolledCourseNestedInput = {
    create?: XOR<StudentEnrolledCourseMarkCreateWithoutStudentEnrolledCourseInput, StudentEnrolledCourseMarkUncheckedCreateWithoutStudentEnrolledCourseInput> | StudentEnrolledCourseMarkCreateWithoutStudentEnrolledCourseInput[] | StudentEnrolledCourseMarkUncheckedCreateWithoutStudentEnrolledCourseInput[]
    connectOrCreate?: StudentEnrolledCourseMarkCreateOrConnectWithoutStudentEnrolledCourseInput | StudentEnrolledCourseMarkCreateOrConnectWithoutStudentEnrolledCourseInput[]
    upsert?: StudentEnrolledCourseMarkUpsertWithWhereUniqueWithoutStudentEnrolledCourseInput | StudentEnrolledCourseMarkUpsertWithWhereUniqueWithoutStudentEnrolledCourseInput[]
    createMany?: StudentEnrolledCourseMarkCreateManyStudentEnrolledCourseInputEnvelope
    set?: StudentEnrolledCourseMarkWhereUniqueInput | StudentEnrolledCourseMarkWhereUniqueInput[]
    disconnect?: StudentEnrolledCourseMarkWhereUniqueInput | StudentEnrolledCourseMarkWhereUniqueInput[]
    delete?: StudentEnrolledCourseMarkWhereUniqueInput | StudentEnrolledCourseMarkWhereUniqueInput[]
    connect?: StudentEnrolledCourseMarkWhereUniqueInput | StudentEnrolledCourseMarkWhereUniqueInput[]
    update?: StudentEnrolledCourseMarkUpdateWithWhereUniqueWithoutStudentEnrolledCourseInput | StudentEnrolledCourseMarkUpdateWithWhereUniqueWithoutStudentEnrolledCourseInput[]
    updateMany?: StudentEnrolledCourseMarkUpdateManyWithWhereWithoutStudentEnrolledCourseInput | StudentEnrolledCourseMarkUpdateManyWithWhereWithoutStudentEnrolledCourseInput[]
    deleteMany?: StudentEnrolledCourseMarkScalarWhereInput | StudentEnrolledCourseMarkScalarWhereInput[]
  }

  export type StudentCreateNestedOneWithoutStudentEnrolledCourseMarksInput = {
    create?: XOR<StudentCreateWithoutStudentEnrolledCourseMarksInput, StudentUncheckedCreateWithoutStudentEnrolledCourseMarksInput>
    connectOrCreate?: StudentCreateOrConnectWithoutStudentEnrolledCourseMarksInput
    connect?: StudentWhereUniqueInput
  }

  export type StudentEnrolledCourseCreateNestedOneWithoutStudentEnrolledCourseMarksInput = {
    create?: XOR<StudentEnrolledCourseCreateWithoutStudentEnrolledCourseMarksInput, StudentEnrolledCourseUncheckedCreateWithoutStudentEnrolledCourseMarksInput>
    connectOrCreate?: StudentEnrolledCourseCreateOrConnectWithoutStudentEnrolledCourseMarksInput
    connect?: StudentEnrolledCourseWhereUniqueInput
  }

  export type AcademicSemesterCreateNestedOneWithoutStudentEnrolledCourseMarksInput = {
    create?: XOR<AcademicSemesterCreateWithoutStudentEnrolledCourseMarksInput, AcademicSemesterUncheckedCreateWithoutStudentEnrolledCourseMarksInput>
    connectOrCreate?: AcademicSemesterCreateOrConnectWithoutStudentEnrolledCourseMarksInput
    connect?: AcademicSemesterWhereUniqueInput
  }

  export type NullableEnumExamTypeFieldUpdateOperationsInput = {
    set?: $Enums.ExamType | null
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type StudentUpdateOneRequiredWithoutStudentEnrolledCourseMarksNestedInput = {
    create?: XOR<StudentCreateWithoutStudentEnrolledCourseMarksInput, StudentUncheckedCreateWithoutStudentEnrolledCourseMarksInput>
    connectOrCreate?: StudentCreateOrConnectWithoutStudentEnrolledCourseMarksInput
    upsert?: StudentUpsertWithoutStudentEnrolledCourseMarksInput
    connect?: StudentWhereUniqueInput
    update?: XOR<XOR<StudentUpdateToOneWithWhereWithoutStudentEnrolledCourseMarksInput, StudentUpdateWithoutStudentEnrolledCourseMarksInput>, StudentUncheckedUpdateWithoutStudentEnrolledCourseMarksInput>
  }

  export type StudentEnrolledCourseUpdateOneRequiredWithoutStudentEnrolledCourseMarksNestedInput = {
    create?: XOR<StudentEnrolledCourseCreateWithoutStudentEnrolledCourseMarksInput, StudentEnrolledCourseUncheckedCreateWithoutStudentEnrolledCourseMarksInput>
    connectOrCreate?: StudentEnrolledCourseCreateOrConnectWithoutStudentEnrolledCourseMarksInput
    upsert?: StudentEnrolledCourseUpsertWithoutStudentEnrolledCourseMarksInput
    connect?: StudentEnrolledCourseWhereUniqueInput
    update?: XOR<XOR<StudentEnrolledCourseUpdateToOneWithWhereWithoutStudentEnrolledCourseMarksInput, StudentEnrolledCourseUpdateWithoutStudentEnrolledCourseMarksInput>, StudentEnrolledCourseUncheckedUpdateWithoutStudentEnrolledCourseMarksInput>
  }

  export type AcademicSemesterUpdateOneRequiredWithoutStudentEnrolledCourseMarksNestedInput = {
    create?: XOR<AcademicSemesterCreateWithoutStudentEnrolledCourseMarksInput, AcademicSemesterUncheckedCreateWithoutStudentEnrolledCourseMarksInput>
    connectOrCreate?: AcademicSemesterCreateOrConnectWithoutStudentEnrolledCourseMarksInput
    upsert?: AcademicSemesterUpsertWithoutStudentEnrolledCourseMarksInput
    connect?: AcademicSemesterWhereUniqueInput
    update?: XOR<XOR<AcademicSemesterUpdateToOneWithWhereWithoutStudentEnrolledCourseMarksInput, AcademicSemesterUpdateWithoutStudentEnrolledCourseMarksInput>, AcademicSemesterUncheckedUpdateWithoutStudentEnrolledCourseMarksInput>
  }

  export type CourseCreateNestedOneWithoutCourseDisciplinesInput = {
    create?: XOR<CourseCreateWithoutCourseDisciplinesInput, CourseUncheckedCreateWithoutCourseDisciplinesInput>
    connectOrCreate?: CourseCreateOrConnectWithoutCourseDisciplinesInput
    connect?: CourseWhereUniqueInput
  }

  export type DisciplineCreateNestedOneWithoutCourseDisciplinesInput = {
    create?: XOR<DisciplineCreateWithoutCourseDisciplinesInput, DisciplineUncheckedCreateWithoutCourseDisciplinesInput>
    connectOrCreate?: DisciplineCreateOrConnectWithoutCourseDisciplinesInput
    connect?: DisciplineWhereUniqueInput
  }

  export type AcademicSemesterCreateNestedOneWithoutCourseDisciplinesInput = {
    create?: XOR<AcademicSemesterCreateWithoutCourseDisciplinesInput, AcademicSemesterUncheckedCreateWithoutCourseDisciplinesInput>
    connectOrCreate?: AcademicSemesterCreateOrConnectWithoutCourseDisciplinesInput
    connect?: AcademicSemesterWhereUniqueInput
  }

  export type CourseUpdateOneRequiredWithoutCourseDisciplinesNestedInput = {
    create?: XOR<CourseCreateWithoutCourseDisciplinesInput, CourseUncheckedCreateWithoutCourseDisciplinesInput>
    connectOrCreate?: CourseCreateOrConnectWithoutCourseDisciplinesInput
    upsert?: CourseUpsertWithoutCourseDisciplinesInput
    connect?: CourseWhereUniqueInput
    update?: XOR<XOR<CourseUpdateToOneWithWhereWithoutCourseDisciplinesInput, CourseUpdateWithoutCourseDisciplinesInput>, CourseUncheckedUpdateWithoutCourseDisciplinesInput>
  }

  export type DisciplineUpdateOneRequiredWithoutCourseDisciplinesNestedInput = {
    create?: XOR<DisciplineCreateWithoutCourseDisciplinesInput, DisciplineUncheckedCreateWithoutCourseDisciplinesInput>
    connectOrCreate?: DisciplineCreateOrConnectWithoutCourseDisciplinesInput
    upsert?: DisciplineUpsertWithoutCourseDisciplinesInput
    connect?: DisciplineWhereUniqueInput
    update?: XOR<XOR<DisciplineUpdateToOneWithWhereWithoutCourseDisciplinesInput, DisciplineUpdateWithoutCourseDisciplinesInput>, DisciplineUncheckedUpdateWithoutCourseDisciplinesInput>
  }

  export type AcademicSemesterUpdateOneRequiredWithoutCourseDisciplinesNestedInput = {
    create?: XOR<AcademicSemesterCreateWithoutCourseDisciplinesInput, AcademicSemesterUncheckedCreateWithoutCourseDisciplinesInput>
    connectOrCreate?: AcademicSemesterCreateOrConnectWithoutCourseDisciplinesInput
    upsert?: AcademicSemesterUpsertWithoutCourseDisciplinesInput
    connect?: AcademicSemesterWhereUniqueInput
    update?: XOR<XOR<AcademicSemesterUpdateToOneWithWhereWithoutCourseDisciplinesInput, AcademicSemesterUpdateWithoutCourseDisciplinesInput>, AcademicSemesterUncheckedUpdateWithoutCourseDisciplinesInput>
  }

  export type StudentCreateNestedOneWithoutStudentCarriedCourseInput = {
    create?: XOR<StudentCreateWithoutStudentCarriedCourseInput, StudentUncheckedCreateWithoutStudentCarriedCourseInput>
    connectOrCreate?: StudentCreateOrConnectWithoutStudentCarriedCourseInput
    connect?: StudentWhereUniqueInput
  }

  export type DisciplineCreateNestedOneWithoutStudentCarriedCourseInput = {
    create?: XOR<DisciplineCreateWithoutStudentCarriedCourseInput, DisciplineUncheckedCreateWithoutStudentCarriedCourseInput>
    connectOrCreate?: DisciplineCreateOrConnectWithoutStudentCarriedCourseInput
    connect?: DisciplineWhereUniqueInput
  }

  export type AcademicSemesterCreateNestedOneWithoutStudentCarriedCourseInput = {
    create?: XOR<AcademicSemesterCreateWithoutStudentCarriedCourseInput, AcademicSemesterUncheckedCreateWithoutStudentCarriedCourseInput>
    connectOrCreate?: AcademicSemesterCreateOrConnectWithoutStudentCarriedCourseInput
    connect?: AcademicSemesterWhereUniqueInput
  }

  export type EnumCarriedCourseStatusFieldUpdateOperationsInput = {
    set?: $Enums.CarriedCourseStatus
  }

  export type StudentUpdateOneRequiredWithoutStudentCarriedCourseNestedInput = {
    create?: XOR<StudentCreateWithoutStudentCarriedCourseInput, StudentUncheckedCreateWithoutStudentCarriedCourseInput>
    connectOrCreate?: StudentCreateOrConnectWithoutStudentCarriedCourseInput
    upsert?: StudentUpsertWithoutStudentCarriedCourseInput
    connect?: StudentWhereUniqueInput
    update?: XOR<XOR<StudentUpdateToOneWithWhereWithoutStudentCarriedCourseInput, StudentUpdateWithoutStudentCarriedCourseInput>, StudentUncheckedUpdateWithoutStudentCarriedCourseInput>
  }

  export type DisciplineUpdateOneRequiredWithoutStudentCarriedCourseNestedInput = {
    create?: XOR<DisciplineCreateWithoutStudentCarriedCourseInput, DisciplineUncheckedCreateWithoutStudentCarriedCourseInput>
    connectOrCreate?: DisciplineCreateOrConnectWithoutStudentCarriedCourseInput
    upsert?: DisciplineUpsertWithoutStudentCarriedCourseInput
    connect?: DisciplineWhereUniqueInput
    update?: XOR<XOR<DisciplineUpdateToOneWithWhereWithoutStudentCarriedCourseInput, DisciplineUpdateWithoutStudentCarriedCourseInput>, DisciplineUncheckedUpdateWithoutStudentCarriedCourseInput>
  }

  export type AcademicSemesterUpdateOneRequiredWithoutStudentCarriedCourseNestedInput = {
    create?: XOR<AcademicSemesterCreateWithoutStudentCarriedCourseInput, AcademicSemesterUncheckedCreateWithoutStudentCarriedCourseInput>
    connectOrCreate?: AcademicSemesterCreateOrConnectWithoutStudentCarriedCourseInput
    upsert?: AcademicSemesterUpsertWithoutStudentCarriedCourseInput
    connect?: AcademicSemesterWhereUniqueInput
    update?: XOR<XOR<AcademicSemesterUpdateToOneWithWhereWithoutStudentCarriedCourseInput, AcademicSemesterUpdateWithoutStudentCarriedCourseInput>, AcademicSemesterUncheckedUpdateWithoutStudentCarriedCourseInput>
  }

  export type CourseCreateNestedOneWithoutCoursePricingInput = {
    create?: XOR<CourseCreateWithoutCoursePricingInput, CourseUncheckedCreateWithoutCoursePricingInput>
    connectOrCreate?: CourseCreateOrConnectWithoutCoursePricingInput
    connect?: CourseWhereUniqueInput
  }

  export type CourseUpdateOneRequiredWithoutCoursePricingNestedInput = {
    create?: XOR<CourseCreateWithoutCoursePricingInput, CourseUncheckedCreateWithoutCoursePricingInput>
    connectOrCreate?: CourseCreateOrConnectWithoutCoursePricingInput
    upsert?: CourseUpsertWithoutCoursePricingInput
    connect?: CourseWhereUniqueInput
    update?: XOR<XOR<CourseUpdateToOneWithWhereWithoutCoursePricingInput, CourseUpdateWithoutCoursePricingInput>, CourseUncheckedUpdateWithoutCoursePricingInput>
  }

  export type CourseDisciplineCreateNestedManyWithoutDisciplineInput = {
    create?: XOR<CourseDisciplineCreateWithoutDisciplineInput, CourseDisciplineUncheckedCreateWithoutDisciplineInput> | CourseDisciplineCreateWithoutDisciplineInput[] | CourseDisciplineUncheckedCreateWithoutDisciplineInput[]
    connectOrCreate?: CourseDisciplineCreateOrConnectWithoutDisciplineInput | CourseDisciplineCreateOrConnectWithoutDisciplineInput[]
    createMany?: CourseDisciplineCreateManyDisciplineInputEnvelope
    connect?: CourseDisciplineWhereUniqueInput | CourseDisciplineWhereUniqueInput[]
  }

  export type StudentCarriedCourseCreateNestedManyWithoutDisciplineInput = {
    create?: XOR<StudentCarriedCourseCreateWithoutDisciplineInput, StudentCarriedCourseUncheckedCreateWithoutDisciplineInput> | StudentCarriedCourseCreateWithoutDisciplineInput[] | StudentCarriedCourseUncheckedCreateWithoutDisciplineInput[]
    connectOrCreate?: StudentCarriedCourseCreateOrConnectWithoutDisciplineInput | StudentCarriedCourseCreateOrConnectWithoutDisciplineInput[]
    createMany?: StudentCarriedCourseCreateManyDisciplineInputEnvelope
    connect?: StudentCarriedCourseWhereUniqueInput | StudentCarriedCourseWhereUniqueInput[]
  }

  export type CourseDisciplineUncheckedCreateNestedManyWithoutDisciplineInput = {
    create?: XOR<CourseDisciplineCreateWithoutDisciplineInput, CourseDisciplineUncheckedCreateWithoutDisciplineInput> | CourseDisciplineCreateWithoutDisciplineInput[] | CourseDisciplineUncheckedCreateWithoutDisciplineInput[]
    connectOrCreate?: CourseDisciplineCreateOrConnectWithoutDisciplineInput | CourseDisciplineCreateOrConnectWithoutDisciplineInput[]
    createMany?: CourseDisciplineCreateManyDisciplineInputEnvelope
    connect?: CourseDisciplineWhereUniqueInput | CourseDisciplineWhereUniqueInput[]
  }

  export type StudentCarriedCourseUncheckedCreateNestedManyWithoutDisciplineInput = {
    create?: XOR<StudentCarriedCourseCreateWithoutDisciplineInput, StudentCarriedCourseUncheckedCreateWithoutDisciplineInput> | StudentCarriedCourseCreateWithoutDisciplineInput[] | StudentCarriedCourseUncheckedCreateWithoutDisciplineInput[]
    connectOrCreate?: StudentCarriedCourseCreateOrConnectWithoutDisciplineInput | StudentCarriedCourseCreateOrConnectWithoutDisciplineInput[]
    createMany?: StudentCarriedCourseCreateManyDisciplineInputEnvelope
    connect?: StudentCarriedCourseWhereUniqueInput | StudentCarriedCourseWhereUniqueInput[]
  }

  export type CourseDisciplineUpdateManyWithoutDisciplineNestedInput = {
    create?: XOR<CourseDisciplineCreateWithoutDisciplineInput, CourseDisciplineUncheckedCreateWithoutDisciplineInput> | CourseDisciplineCreateWithoutDisciplineInput[] | CourseDisciplineUncheckedCreateWithoutDisciplineInput[]
    connectOrCreate?: CourseDisciplineCreateOrConnectWithoutDisciplineInput | CourseDisciplineCreateOrConnectWithoutDisciplineInput[]
    upsert?: CourseDisciplineUpsertWithWhereUniqueWithoutDisciplineInput | CourseDisciplineUpsertWithWhereUniqueWithoutDisciplineInput[]
    createMany?: CourseDisciplineCreateManyDisciplineInputEnvelope
    set?: CourseDisciplineWhereUniqueInput | CourseDisciplineWhereUniqueInput[]
    disconnect?: CourseDisciplineWhereUniqueInput | CourseDisciplineWhereUniqueInput[]
    delete?: CourseDisciplineWhereUniqueInput | CourseDisciplineWhereUniqueInput[]
    connect?: CourseDisciplineWhereUniqueInput | CourseDisciplineWhereUniqueInput[]
    update?: CourseDisciplineUpdateWithWhereUniqueWithoutDisciplineInput | CourseDisciplineUpdateWithWhereUniqueWithoutDisciplineInput[]
    updateMany?: CourseDisciplineUpdateManyWithWhereWithoutDisciplineInput | CourseDisciplineUpdateManyWithWhereWithoutDisciplineInput[]
    deleteMany?: CourseDisciplineScalarWhereInput | CourseDisciplineScalarWhereInput[]
  }

  export type StudentCarriedCourseUpdateManyWithoutDisciplineNestedInput = {
    create?: XOR<StudentCarriedCourseCreateWithoutDisciplineInput, StudentCarriedCourseUncheckedCreateWithoutDisciplineInput> | StudentCarriedCourseCreateWithoutDisciplineInput[] | StudentCarriedCourseUncheckedCreateWithoutDisciplineInput[]
    connectOrCreate?: StudentCarriedCourseCreateOrConnectWithoutDisciplineInput | StudentCarriedCourseCreateOrConnectWithoutDisciplineInput[]
    upsert?: StudentCarriedCourseUpsertWithWhereUniqueWithoutDisciplineInput | StudentCarriedCourseUpsertWithWhereUniqueWithoutDisciplineInput[]
    createMany?: StudentCarriedCourseCreateManyDisciplineInputEnvelope
    set?: StudentCarriedCourseWhereUniqueInput | StudentCarriedCourseWhereUniqueInput[]
    disconnect?: StudentCarriedCourseWhereUniqueInput | StudentCarriedCourseWhereUniqueInput[]
    delete?: StudentCarriedCourseWhereUniqueInput | StudentCarriedCourseWhereUniqueInput[]
    connect?: StudentCarriedCourseWhereUniqueInput | StudentCarriedCourseWhereUniqueInput[]
    update?: StudentCarriedCourseUpdateWithWhereUniqueWithoutDisciplineInput | StudentCarriedCourseUpdateWithWhereUniqueWithoutDisciplineInput[]
    updateMany?: StudentCarriedCourseUpdateManyWithWhereWithoutDisciplineInput | StudentCarriedCourseUpdateManyWithWhereWithoutDisciplineInput[]
    deleteMany?: StudentCarriedCourseScalarWhereInput | StudentCarriedCourseScalarWhereInput[]
  }

  export type CourseDisciplineUncheckedUpdateManyWithoutDisciplineNestedInput = {
    create?: XOR<CourseDisciplineCreateWithoutDisciplineInput, CourseDisciplineUncheckedCreateWithoutDisciplineInput> | CourseDisciplineCreateWithoutDisciplineInput[] | CourseDisciplineUncheckedCreateWithoutDisciplineInput[]
    connectOrCreate?: CourseDisciplineCreateOrConnectWithoutDisciplineInput | CourseDisciplineCreateOrConnectWithoutDisciplineInput[]
    upsert?: CourseDisciplineUpsertWithWhereUniqueWithoutDisciplineInput | CourseDisciplineUpsertWithWhereUniqueWithoutDisciplineInput[]
    createMany?: CourseDisciplineCreateManyDisciplineInputEnvelope
    set?: CourseDisciplineWhereUniqueInput | CourseDisciplineWhereUniqueInput[]
    disconnect?: CourseDisciplineWhereUniqueInput | CourseDisciplineWhereUniqueInput[]
    delete?: CourseDisciplineWhereUniqueInput | CourseDisciplineWhereUniqueInput[]
    connect?: CourseDisciplineWhereUniqueInput | CourseDisciplineWhereUniqueInput[]
    update?: CourseDisciplineUpdateWithWhereUniqueWithoutDisciplineInput | CourseDisciplineUpdateWithWhereUniqueWithoutDisciplineInput[]
    updateMany?: CourseDisciplineUpdateManyWithWhereWithoutDisciplineInput | CourseDisciplineUpdateManyWithWhereWithoutDisciplineInput[]
    deleteMany?: CourseDisciplineScalarWhereInput | CourseDisciplineScalarWhereInput[]
  }

  export type StudentCarriedCourseUncheckedUpdateManyWithoutDisciplineNestedInput = {
    create?: XOR<StudentCarriedCourseCreateWithoutDisciplineInput, StudentCarriedCourseUncheckedCreateWithoutDisciplineInput> | StudentCarriedCourseCreateWithoutDisciplineInput[] | StudentCarriedCourseUncheckedCreateWithoutDisciplineInput[]
    connectOrCreate?: StudentCarriedCourseCreateOrConnectWithoutDisciplineInput | StudentCarriedCourseCreateOrConnectWithoutDisciplineInput[]
    upsert?: StudentCarriedCourseUpsertWithWhereUniqueWithoutDisciplineInput | StudentCarriedCourseUpsertWithWhereUniqueWithoutDisciplineInput[]
    createMany?: StudentCarriedCourseCreateManyDisciplineInputEnvelope
    set?: StudentCarriedCourseWhereUniqueInput | StudentCarriedCourseWhereUniqueInput[]
    disconnect?: StudentCarriedCourseWhereUniqueInput | StudentCarriedCourseWhereUniqueInput[]
    delete?: StudentCarriedCourseWhereUniqueInput | StudentCarriedCourseWhereUniqueInput[]
    connect?: StudentCarriedCourseWhereUniqueInput | StudentCarriedCourseWhereUniqueInput[]
    update?: StudentCarriedCourseUpdateWithWhereUniqueWithoutDisciplineInput | StudentCarriedCourseUpdateWithWhereUniqueWithoutDisciplineInput[]
    updateMany?: StudentCarriedCourseUpdateManyWithWhereWithoutDisciplineInput | StudentCarriedCourseUpdateManyWithWhereWithoutDisciplineInput[]
    deleteMany?: StudentCarriedCourseScalarWhereInput | StudentCarriedCourseScalarWhereInput[]
  }

  export type PaymentCreateNestedOneWithoutStudentSemesterPaymentInput = {
    create?: XOR<PaymentCreateWithoutStudentSemesterPaymentInput, PaymentUncheckedCreateWithoutStudentSemesterPaymentInput>
    connectOrCreate?: PaymentCreateOrConnectWithoutStudentSemesterPaymentInput
    connect?: PaymentWhereUniqueInput
  }

  export type StudentCreateNestedOneWithoutStudentSemesterPaymentsInput = {
    create?: XOR<StudentCreateWithoutStudentSemesterPaymentsInput, StudentUncheckedCreateWithoutStudentSemesterPaymentsInput>
    connectOrCreate?: StudentCreateOrConnectWithoutStudentSemesterPaymentsInput
    connect?: StudentWhereUniqueInput
  }

  export type AcademicSemesterCreateNestedOneWithoutStudentSemesterPaymentsInput = {
    create?: XOR<AcademicSemesterCreateWithoutStudentSemesterPaymentsInput, AcademicSemesterUncheckedCreateWithoutStudentSemesterPaymentsInput>
    connectOrCreate?: AcademicSemesterCreateOrConnectWithoutStudentSemesterPaymentsInput
    connect?: AcademicSemesterWhereUniqueInput
  }

  export type PaymentUpdateOneRequiredWithoutStudentSemesterPaymentNestedInput = {
    create?: XOR<PaymentCreateWithoutStudentSemesterPaymentInput, PaymentUncheckedCreateWithoutStudentSemesterPaymentInput>
    connectOrCreate?: PaymentCreateOrConnectWithoutStudentSemesterPaymentInput
    upsert?: PaymentUpsertWithoutStudentSemesterPaymentInput
    connect?: PaymentWhereUniqueInput
    update?: XOR<XOR<PaymentUpdateToOneWithWhereWithoutStudentSemesterPaymentInput, PaymentUpdateWithoutStudentSemesterPaymentInput>, PaymentUncheckedUpdateWithoutStudentSemesterPaymentInput>
  }

  export type StudentUpdateOneRequiredWithoutStudentSemesterPaymentsNestedInput = {
    create?: XOR<StudentCreateWithoutStudentSemesterPaymentsInput, StudentUncheckedCreateWithoutStudentSemesterPaymentsInput>
    connectOrCreate?: StudentCreateOrConnectWithoutStudentSemesterPaymentsInput
    upsert?: StudentUpsertWithoutStudentSemesterPaymentsInput
    connect?: StudentWhereUniqueInput
    update?: XOR<XOR<StudentUpdateToOneWithWhereWithoutStudentSemesterPaymentsInput, StudentUpdateWithoutStudentSemesterPaymentsInput>, StudentUncheckedUpdateWithoutStudentSemesterPaymentsInput>
  }

  export type AcademicSemesterUpdateOneRequiredWithoutStudentSemesterPaymentsNestedInput = {
    create?: XOR<AcademicSemesterCreateWithoutStudentSemesterPaymentsInput, AcademicSemesterUncheckedCreateWithoutStudentSemesterPaymentsInput>
    connectOrCreate?: AcademicSemesterCreateOrConnectWithoutStudentSemesterPaymentsInput
    upsert?: AcademicSemesterUpsertWithoutStudentSemesterPaymentsInput
    connect?: AcademicSemesterWhereUniqueInput
    update?: XOR<XOR<AcademicSemesterUpdateToOneWithWhereWithoutStudentSemesterPaymentsInput, AcademicSemesterUpdateWithoutStudentSemesterPaymentsInput>, AcademicSemesterUncheckedUpdateWithoutStudentSemesterPaymentsInput>
  }

  export type StudentCreateNestedOneWithoutStudentAcademicInfosInput = {
    create?: XOR<StudentCreateWithoutStudentAcademicInfosInput, StudentUncheckedCreateWithoutStudentAcademicInfosInput>
    connectOrCreate?: StudentCreateOrConnectWithoutStudentAcademicInfosInput
    connect?: StudentWhereUniqueInput
  }

  export type StudentUpdateOneRequiredWithoutStudentAcademicInfosNestedInput = {
    create?: XOR<StudentCreateWithoutStudentAcademicInfosInput, StudentUncheckedCreateWithoutStudentAcademicInfosInput>
    connectOrCreate?: StudentCreateOrConnectWithoutStudentAcademicInfosInput
    upsert?: StudentUpsertWithoutStudentAcademicInfosInput
    connect?: StudentWhereUniqueInput
    update?: XOR<XOR<StudentUpdateToOneWithWhereWithoutStudentAcademicInfosInput, StudentUpdateWithoutStudentAcademicInfosInput>, StudentUncheckedUpdateWithoutStudentAcademicInfosInput>
  }

  export type StudentSemesterPaymentCreateNestedManyWithoutPaymentInput = {
    create?: XOR<StudentSemesterPaymentCreateWithoutPaymentInput, StudentSemesterPaymentUncheckedCreateWithoutPaymentInput> | StudentSemesterPaymentCreateWithoutPaymentInput[] | StudentSemesterPaymentUncheckedCreateWithoutPaymentInput[]
    connectOrCreate?: StudentSemesterPaymentCreateOrConnectWithoutPaymentInput | StudentSemesterPaymentCreateOrConnectWithoutPaymentInput[]
    createMany?: StudentSemesterPaymentCreateManyPaymentInputEnvelope
    connect?: StudentSemesterPaymentWhereUniqueInput | StudentSemesterPaymentWhereUniqueInput[]
  }

  export type PaymentReferenceCreateNestedManyWithoutPaymentInput = {
    create?: XOR<PaymentReferenceCreateWithoutPaymentInput, PaymentReferenceUncheckedCreateWithoutPaymentInput> | PaymentReferenceCreateWithoutPaymentInput[] | PaymentReferenceUncheckedCreateWithoutPaymentInput[]
    connectOrCreate?: PaymentReferenceCreateOrConnectWithoutPaymentInput | PaymentReferenceCreateOrConnectWithoutPaymentInput[]
    createMany?: PaymentReferenceCreateManyPaymentInputEnvelope
    connect?: PaymentReferenceWhereUniqueInput | PaymentReferenceWhereUniqueInput[]
  }

  export type StudentSemesterPaymentUncheckedCreateNestedManyWithoutPaymentInput = {
    create?: XOR<StudentSemesterPaymentCreateWithoutPaymentInput, StudentSemesterPaymentUncheckedCreateWithoutPaymentInput> | StudentSemesterPaymentCreateWithoutPaymentInput[] | StudentSemesterPaymentUncheckedCreateWithoutPaymentInput[]
    connectOrCreate?: StudentSemesterPaymentCreateOrConnectWithoutPaymentInput | StudentSemesterPaymentCreateOrConnectWithoutPaymentInput[]
    createMany?: StudentSemesterPaymentCreateManyPaymentInputEnvelope
    connect?: StudentSemesterPaymentWhereUniqueInput | StudentSemesterPaymentWhereUniqueInput[]
  }

  export type PaymentReferenceUncheckedCreateNestedManyWithoutPaymentInput = {
    create?: XOR<PaymentReferenceCreateWithoutPaymentInput, PaymentReferenceUncheckedCreateWithoutPaymentInput> | PaymentReferenceCreateWithoutPaymentInput[] | PaymentReferenceUncheckedCreateWithoutPaymentInput[]
    connectOrCreate?: PaymentReferenceCreateOrConnectWithoutPaymentInput | PaymentReferenceCreateOrConnectWithoutPaymentInput[]
    createMany?: PaymentReferenceCreateManyPaymentInputEnvelope
    connect?: PaymentReferenceWhereUniqueInput | PaymentReferenceWhereUniqueInput[]
  }

  export type EnumPAYMENTTYPEFieldUpdateOperationsInput = {
    set?: $Enums.PAYMENTTYPE
  }

  export type EnumPAYMENTSTATUSFieldUpdateOperationsInput = {
    set?: $Enums.PAYMENTSTATUS
  }

  export type EnumPAYMENTMETHODFieldUpdateOperationsInput = {
    set?: $Enums.PAYMENTMETHOD
  }

  export type StudentSemesterPaymentUpdateManyWithoutPaymentNestedInput = {
    create?: XOR<StudentSemesterPaymentCreateWithoutPaymentInput, StudentSemesterPaymentUncheckedCreateWithoutPaymentInput> | StudentSemesterPaymentCreateWithoutPaymentInput[] | StudentSemesterPaymentUncheckedCreateWithoutPaymentInput[]
    connectOrCreate?: StudentSemesterPaymentCreateOrConnectWithoutPaymentInput | StudentSemesterPaymentCreateOrConnectWithoutPaymentInput[]
    upsert?: StudentSemesterPaymentUpsertWithWhereUniqueWithoutPaymentInput | StudentSemesterPaymentUpsertWithWhereUniqueWithoutPaymentInput[]
    createMany?: StudentSemesterPaymentCreateManyPaymentInputEnvelope
    set?: StudentSemesterPaymentWhereUniqueInput | StudentSemesterPaymentWhereUniqueInput[]
    disconnect?: StudentSemesterPaymentWhereUniqueInput | StudentSemesterPaymentWhereUniqueInput[]
    delete?: StudentSemesterPaymentWhereUniqueInput | StudentSemesterPaymentWhereUniqueInput[]
    connect?: StudentSemesterPaymentWhereUniqueInput | StudentSemesterPaymentWhereUniqueInput[]
    update?: StudentSemesterPaymentUpdateWithWhereUniqueWithoutPaymentInput | StudentSemesterPaymentUpdateWithWhereUniqueWithoutPaymentInput[]
    updateMany?: StudentSemesterPaymentUpdateManyWithWhereWithoutPaymentInput | StudentSemesterPaymentUpdateManyWithWhereWithoutPaymentInput[]
    deleteMany?: StudentSemesterPaymentScalarWhereInput | StudentSemesterPaymentScalarWhereInput[]
  }

  export type PaymentReferenceUpdateManyWithoutPaymentNestedInput = {
    create?: XOR<PaymentReferenceCreateWithoutPaymentInput, PaymentReferenceUncheckedCreateWithoutPaymentInput> | PaymentReferenceCreateWithoutPaymentInput[] | PaymentReferenceUncheckedCreateWithoutPaymentInput[]
    connectOrCreate?: PaymentReferenceCreateOrConnectWithoutPaymentInput | PaymentReferenceCreateOrConnectWithoutPaymentInput[]
    upsert?: PaymentReferenceUpsertWithWhereUniqueWithoutPaymentInput | PaymentReferenceUpsertWithWhereUniqueWithoutPaymentInput[]
    createMany?: PaymentReferenceCreateManyPaymentInputEnvelope
    set?: PaymentReferenceWhereUniqueInput | PaymentReferenceWhereUniqueInput[]
    disconnect?: PaymentReferenceWhereUniqueInput | PaymentReferenceWhereUniqueInput[]
    delete?: PaymentReferenceWhereUniqueInput | PaymentReferenceWhereUniqueInput[]
    connect?: PaymentReferenceWhereUniqueInput | PaymentReferenceWhereUniqueInput[]
    update?: PaymentReferenceUpdateWithWhereUniqueWithoutPaymentInput | PaymentReferenceUpdateWithWhereUniqueWithoutPaymentInput[]
    updateMany?: PaymentReferenceUpdateManyWithWhereWithoutPaymentInput | PaymentReferenceUpdateManyWithWhereWithoutPaymentInput[]
    deleteMany?: PaymentReferenceScalarWhereInput | PaymentReferenceScalarWhereInput[]
  }

  export type StudentSemesterPaymentUncheckedUpdateManyWithoutPaymentNestedInput = {
    create?: XOR<StudentSemesterPaymentCreateWithoutPaymentInput, StudentSemesterPaymentUncheckedCreateWithoutPaymentInput> | StudentSemesterPaymentCreateWithoutPaymentInput[] | StudentSemesterPaymentUncheckedCreateWithoutPaymentInput[]
    connectOrCreate?: StudentSemesterPaymentCreateOrConnectWithoutPaymentInput | StudentSemesterPaymentCreateOrConnectWithoutPaymentInput[]
    upsert?: StudentSemesterPaymentUpsertWithWhereUniqueWithoutPaymentInput | StudentSemesterPaymentUpsertWithWhereUniqueWithoutPaymentInput[]
    createMany?: StudentSemesterPaymentCreateManyPaymentInputEnvelope
    set?: StudentSemesterPaymentWhereUniqueInput | StudentSemesterPaymentWhereUniqueInput[]
    disconnect?: StudentSemesterPaymentWhereUniqueInput | StudentSemesterPaymentWhereUniqueInput[]
    delete?: StudentSemesterPaymentWhereUniqueInput | StudentSemesterPaymentWhereUniqueInput[]
    connect?: StudentSemesterPaymentWhereUniqueInput | StudentSemesterPaymentWhereUniqueInput[]
    update?: StudentSemesterPaymentUpdateWithWhereUniqueWithoutPaymentInput | StudentSemesterPaymentUpdateWithWhereUniqueWithoutPaymentInput[]
    updateMany?: StudentSemesterPaymentUpdateManyWithWhereWithoutPaymentInput | StudentSemesterPaymentUpdateManyWithWhereWithoutPaymentInput[]
    deleteMany?: StudentSemesterPaymentScalarWhereInput | StudentSemesterPaymentScalarWhereInput[]
  }

  export type PaymentReferenceUncheckedUpdateManyWithoutPaymentNestedInput = {
    create?: XOR<PaymentReferenceCreateWithoutPaymentInput, PaymentReferenceUncheckedCreateWithoutPaymentInput> | PaymentReferenceCreateWithoutPaymentInput[] | PaymentReferenceUncheckedCreateWithoutPaymentInput[]
    connectOrCreate?: PaymentReferenceCreateOrConnectWithoutPaymentInput | PaymentReferenceCreateOrConnectWithoutPaymentInput[]
    upsert?: PaymentReferenceUpsertWithWhereUniqueWithoutPaymentInput | PaymentReferenceUpsertWithWhereUniqueWithoutPaymentInput[]
    createMany?: PaymentReferenceCreateManyPaymentInputEnvelope
    set?: PaymentReferenceWhereUniqueInput | PaymentReferenceWhereUniqueInput[]
    disconnect?: PaymentReferenceWhereUniqueInput | PaymentReferenceWhereUniqueInput[]
    delete?: PaymentReferenceWhereUniqueInput | PaymentReferenceWhereUniqueInput[]
    connect?: PaymentReferenceWhereUniqueInput | PaymentReferenceWhereUniqueInput[]
    update?: PaymentReferenceUpdateWithWhereUniqueWithoutPaymentInput | PaymentReferenceUpdateWithWhereUniqueWithoutPaymentInput[]
    updateMany?: PaymentReferenceUpdateManyWithWhereWithoutPaymentInput | PaymentReferenceUpdateManyWithWhereWithoutPaymentInput[]
    deleteMany?: PaymentReferenceScalarWhereInput | PaymentReferenceScalarWhereInput[]
  }

  export type PaymentCreateNestedOneWithoutPaymentReferenceInput = {
    create?: XOR<PaymentCreateWithoutPaymentReferenceInput, PaymentUncheckedCreateWithoutPaymentReferenceInput>
    connectOrCreate?: PaymentCreateOrConnectWithoutPaymentReferenceInput
    connect?: PaymentWhereUniqueInput
  }

  export type PaymentUpdateOneRequiredWithoutPaymentReferenceNestedInput = {
    create?: XOR<PaymentCreateWithoutPaymentReferenceInput, PaymentUncheckedCreateWithoutPaymentReferenceInput>
    connectOrCreate?: PaymentCreateOrConnectWithoutPaymentReferenceInput
    upsert?: PaymentUpsertWithoutPaymentReferenceInput
    connect?: PaymentWhereUniqueInput
    update?: XOR<XOR<PaymentUpdateToOneWithWhereWithoutPaymentReferenceInput, PaymentUpdateWithoutPaymentReferenceInput>, PaymentUncheckedUpdateWithoutPaymentReferenceInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedEnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[]
    notIn?: $Enums.UserRole[]
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[]
    notIn?: $Enums.UserRole[]
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedEnumStudentTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.StudentType | EnumStudentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.StudentType[]
    notIn?: $Enums.StudentType[]
    not?: NestedEnumStudentTypeFilter<$PrismaModel> | $Enums.StudentType
  }

  export type NestedEnumShiftFilter<$PrismaModel = never> = {
    equals?: $Enums.Shift | EnumShiftFieldRefInput<$PrismaModel>
    in?: $Enums.Shift[]
    notIn?: $Enums.Shift[]
    not?: NestedEnumShiftFilter<$PrismaModel> | $Enums.Shift
  }

  export type NestedEnumYearLevelFilter<$PrismaModel = never> = {
    equals?: $Enums.YearLevel | EnumYearLevelFieldRefInput<$PrismaModel>
    in?: $Enums.YearLevel[]
    notIn?: $Enums.YearLevel[]
    not?: NestedEnumYearLevelFilter<$PrismaModel> | $Enums.YearLevel
  }

  export type NestedEnumStudentTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.StudentType | EnumStudentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.StudentType[]
    notIn?: $Enums.StudentType[]
    not?: NestedEnumStudentTypeWithAggregatesFilter<$PrismaModel> | $Enums.StudentType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStudentTypeFilter<$PrismaModel>
    _max?: NestedEnumStudentTypeFilter<$PrismaModel>
  }

  export type NestedEnumShiftWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Shift | EnumShiftFieldRefInput<$PrismaModel>
    in?: $Enums.Shift[]
    notIn?: $Enums.Shift[]
    not?: NestedEnumShiftWithAggregatesFilter<$PrismaModel> | $Enums.Shift
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumShiftFilter<$PrismaModel>
    _max?: NestedEnumShiftFilter<$PrismaModel>
  }

  export type NestedEnumYearLevelWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.YearLevel | EnumYearLevelFieldRefInput<$PrismaModel>
    in?: $Enums.YearLevel[]
    notIn?: $Enums.YearLevel[]
    not?: NestedEnumYearLevelWithAggregatesFilter<$PrismaModel> | $Enums.YearLevel
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumYearLevelFilter<$PrismaModel>
    _max?: NestedEnumYearLevelFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedEnumSemesterRegistrationStatusNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.SemesterRegistrationStatus | EnumSemesterRegistrationStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.SemesterRegistrationStatus[] | null
    notIn?: $Enums.SemesterRegistrationStatus[] | null
    not?: NestedEnumSemesterRegistrationStatusNullableFilter<$PrismaModel> | $Enums.SemesterRegistrationStatus | null
  }

  export type NestedEnumSemesterRegistrationStatusNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SemesterRegistrationStatus | EnumSemesterRegistrationStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.SemesterRegistrationStatus[] | null
    notIn?: $Enums.SemesterRegistrationStatus[] | null
    not?: NestedEnumSemesterRegistrationStatusNullableWithAggregatesFilter<$PrismaModel> | $Enums.SemesterRegistrationStatus | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumSemesterRegistrationStatusNullableFilter<$PrismaModel>
    _max?: NestedEnumSemesterRegistrationStatusNullableFilter<$PrismaModel>
  }

  export type NestedEnumStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.Status | EnumStatusFieldRefInput<$PrismaModel>
    in?: $Enums.Status[]
    notIn?: $Enums.Status[]
    not?: NestedEnumStatusFilter<$PrismaModel> | $Enums.Status
  }

  export type NestedBoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type NestedEnumStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Status | EnumStatusFieldRefInput<$PrismaModel>
    in?: $Enums.Status[]
    notIn?: $Enums.Status[]
    not?: NestedEnumStatusWithAggregatesFilter<$PrismaModel> | $Enums.Status
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStatusFilter<$PrismaModel>
    _max?: NestedEnumStatusFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type NestedEnumWeekDaysFilter<$PrismaModel = never> = {
    equals?: $Enums.WeekDays | EnumWeekDaysFieldRefInput<$PrismaModel>
    in?: $Enums.WeekDays[]
    notIn?: $Enums.WeekDays[]
    not?: NestedEnumWeekDaysFilter<$PrismaModel> | $Enums.WeekDays
  }

  export type NestedEnumWeekDaysWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.WeekDays | EnumWeekDaysFieldRefInput<$PrismaModel>
    in?: $Enums.WeekDays[]
    notIn?: $Enums.WeekDays[]
    not?: NestedEnumWeekDaysWithAggregatesFilter<$PrismaModel> | $Enums.WeekDays
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumWeekDaysFilter<$PrismaModel>
    _max?: NestedEnumWeekDaysFilter<$PrismaModel>
  }

  export type NestedEnumStudentEnrolledCourseStatusNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.StudentEnrolledCourseStatus | EnumStudentEnrolledCourseStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.StudentEnrolledCourseStatus[] | null
    notIn?: $Enums.StudentEnrolledCourseStatus[] | null
    not?: NestedEnumStudentEnrolledCourseStatusNullableFilter<$PrismaModel> | $Enums.StudentEnrolledCourseStatus | null
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedEnumStudentEnrolledCourseStatusNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.StudentEnrolledCourseStatus | EnumStudentEnrolledCourseStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.StudentEnrolledCourseStatus[] | null
    notIn?: $Enums.StudentEnrolledCourseStatus[] | null
    not?: NestedEnumStudentEnrolledCourseStatusNullableWithAggregatesFilter<$PrismaModel> | $Enums.StudentEnrolledCourseStatus | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumStudentEnrolledCourseStatusNullableFilter<$PrismaModel>
    _max?: NestedEnumStudentEnrolledCourseStatusNullableFilter<$PrismaModel>
  }

  export type NestedEnumExamTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.ExamType | EnumExamTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.ExamType[] | null
    notIn?: $Enums.ExamType[] | null
    not?: NestedEnumExamTypeNullableFilter<$PrismaModel> | $Enums.ExamType | null
  }

  export type NestedEnumExamTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ExamType | EnumExamTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.ExamType[] | null
    notIn?: $Enums.ExamType[] | null
    not?: NestedEnumExamTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.ExamType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumExamTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumExamTypeNullableFilter<$PrismaModel>
  }
  export type NestedJsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedEnumCarriedCourseStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.CarriedCourseStatus | EnumCarriedCourseStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CarriedCourseStatus[]
    notIn?: $Enums.CarriedCourseStatus[]
    not?: NestedEnumCarriedCourseStatusFilter<$PrismaModel> | $Enums.CarriedCourseStatus
  }

  export type NestedEnumCarriedCourseStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CarriedCourseStatus | EnumCarriedCourseStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CarriedCourseStatus[]
    notIn?: $Enums.CarriedCourseStatus[]
    not?: NestedEnumCarriedCourseStatusWithAggregatesFilter<$PrismaModel> | $Enums.CarriedCourseStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCarriedCourseStatusFilter<$PrismaModel>
    _max?: NestedEnumCarriedCourseStatusFilter<$PrismaModel>
  }

  export type NestedEnumPAYMENTTYPEFilter<$PrismaModel = never> = {
    equals?: $Enums.PAYMENTTYPE | EnumPAYMENTTYPEFieldRefInput<$PrismaModel>
    in?: $Enums.PAYMENTTYPE[]
    notIn?: $Enums.PAYMENTTYPE[]
    not?: NestedEnumPAYMENTTYPEFilter<$PrismaModel> | $Enums.PAYMENTTYPE
  }

  export type NestedEnumPAYMENTSTATUSFilter<$PrismaModel = never> = {
    equals?: $Enums.PAYMENTSTATUS | EnumPAYMENTSTATUSFieldRefInput<$PrismaModel>
    in?: $Enums.PAYMENTSTATUS[]
    notIn?: $Enums.PAYMENTSTATUS[]
    not?: NestedEnumPAYMENTSTATUSFilter<$PrismaModel> | $Enums.PAYMENTSTATUS
  }

  export type NestedEnumPAYMENTMETHODFilter<$PrismaModel = never> = {
    equals?: $Enums.PAYMENTMETHOD | EnumPAYMENTMETHODFieldRefInput<$PrismaModel>
    in?: $Enums.PAYMENTMETHOD[]
    notIn?: $Enums.PAYMENTMETHOD[]
    not?: NestedEnumPAYMENTMETHODFilter<$PrismaModel> | $Enums.PAYMENTMETHOD
  }

  export type NestedEnumPAYMENTTYPEWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PAYMENTTYPE | EnumPAYMENTTYPEFieldRefInput<$PrismaModel>
    in?: $Enums.PAYMENTTYPE[]
    notIn?: $Enums.PAYMENTTYPE[]
    not?: NestedEnumPAYMENTTYPEWithAggregatesFilter<$PrismaModel> | $Enums.PAYMENTTYPE
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPAYMENTTYPEFilter<$PrismaModel>
    _max?: NestedEnumPAYMENTTYPEFilter<$PrismaModel>
  }

  export type NestedEnumPAYMENTSTATUSWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PAYMENTSTATUS | EnumPAYMENTSTATUSFieldRefInput<$PrismaModel>
    in?: $Enums.PAYMENTSTATUS[]
    notIn?: $Enums.PAYMENTSTATUS[]
    not?: NestedEnumPAYMENTSTATUSWithAggregatesFilter<$PrismaModel> | $Enums.PAYMENTSTATUS
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPAYMENTSTATUSFilter<$PrismaModel>
    _max?: NestedEnumPAYMENTSTATUSFilter<$PrismaModel>
  }

  export type NestedEnumPAYMENTMETHODWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PAYMENTMETHOD | EnumPAYMENTMETHODFieldRefInput<$PrismaModel>
    in?: $Enums.PAYMENTMETHOD[]
    notIn?: $Enums.PAYMENTMETHOD[]
    not?: NestedEnumPAYMENTMETHODWithAggregatesFilter<$PrismaModel> | $Enums.PAYMENTMETHOD
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPAYMENTMETHODFilter<$PrismaModel>
    _max?: NestedEnumPAYMENTMETHODFilter<$PrismaModel>
  }

  export type AcademicDepartmentCreateWithoutDepartmentHeadInput = {
    id?: string
    title: string
    createdAt?: Date | string
    updatedAt?: Date | string
    academicFaculty: AcademicFacultyCreateNestedOneWithoutAcademicDepartmentsInput
    faculties?: FacultyCreateNestedManyWithoutAcademicDepartmentInput
    courses?: CourseCreateNestedManyWithoutAcademicDepartmentInput
    students?: StudentCreateNestedManyWithoutAcademicDepartmentInput
    staffMembers?: UsersCreateNestedManyWithoutStaffDepartmentsInput
    offeredCourses?: OfferedCourseCreateNestedManyWithoutAcademicDepartmentInput
  }

  export type AcademicDepartmentUncheckedCreateWithoutDepartmentHeadInput = {
    id?: string
    title: string
    academicFacultyId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    faculties?: FacultyUncheckedCreateNestedManyWithoutAcademicDepartmentInput
    courses?: CourseUncheckedCreateNestedManyWithoutAcademicDepartmentInput
    students?: StudentUncheckedCreateNestedManyWithoutAcademicDepartmentInput
    staffMembers?: UsersUncheckedCreateNestedManyWithoutStaffDepartmentsInput
    offeredCourses?: OfferedCourseUncheckedCreateNestedManyWithoutAcademicDepartmentInput
  }

  export type AcademicDepartmentCreateOrConnectWithoutDepartmentHeadInput = {
    where: AcademicDepartmentWhereUniqueInput
    create: XOR<AcademicDepartmentCreateWithoutDepartmentHeadInput, AcademicDepartmentUncheckedCreateWithoutDepartmentHeadInput>
  }

  export type AcademicDepartmentCreateWithoutStaffMembersInput = {
    id?: string
    title: string
    createdAt?: Date | string
    updatedAt?: Date | string
    academicFaculty: AcademicFacultyCreateNestedOneWithoutAcademicDepartmentsInput
    faculties?: FacultyCreateNestedManyWithoutAcademicDepartmentInput
    courses?: CourseCreateNestedManyWithoutAcademicDepartmentInput
    students?: StudentCreateNestedManyWithoutAcademicDepartmentInput
    departmentHead?: UsersCreateNestedOneWithoutAcademicDepartmentInput
    offeredCourses?: OfferedCourseCreateNestedManyWithoutAcademicDepartmentInput
  }

  export type AcademicDepartmentUncheckedCreateWithoutStaffMembersInput = {
    id?: string
    title: string
    academicFacultyId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    departmentHeadId?: string | null
    faculties?: FacultyUncheckedCreateNestedManyWithoutAcademicDepartmentInput
    courses?: CourseUncheckedCreateNestedManyWithoutAcademicDepartmentInput
    students?: StudentUncheckedCreateNestedManyWithoutAcademicDepartmentInput
    offeredCourses?: OfferedCourseUncheckedCreateNestedManyWithoutAcademicDepartmentInput
  }

  export type AcademicDepartmentCreateOrConnectWithoutStaffMembersInput = {
    where: AcademicDepartmentWhereUniqueInput
    create: XOR<AcademicDepartmentCreateWithoutStaffMembersInput, AcademicDepartmentUncheckedCreateWithoutStaffMembersInput>
  }

  export type AcademicDepartmentUpsertWithoutDepartmentHeadInput = {
    update: XOR<AcademicDepartmentUpdateWithoutDepartmentHeadInput, AcademicDepartmentUncheckedUpdateWithoutDepartmentHeadInput>
    create: XOR<AcademicDepartmentCreateWithoutDepartmentHeadInput, AcademicDepartmentUncheckedCreateWithoutDepartmentHeadInput>
    where?: AcademicDepartmentWhereInput
  }

  export type AcademicDepartmentUpdateToOneWithWhereWithoutDepartmentHeadInput = {
    where?: AcademicDepartmentWhereInput
    data: XOR<AcademicDepartmentUpdateWithoutDepartmentHeadInput, AcademicDepartmentUncheckedUpdateWithoutDepartmentHeadInput>
  }

  export type AcademicDepartmentUpdateWithoutDepartmentHeadInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    academicFaculty?: AcademicFacultyUpdateOneRequiredWithoutAcademicDepartmentsNestedInput
    faculties?: FacultyUpdateManyWithoutAcademicDepartmentNestedInput
    courses?: CourseUpdateManyWithoutAcademicDepartmentNestedInput
    students?: StudentUpdateManyWithoutAcademicDepartmentNestedInput
    staffMembers?: UsersUpdateManyWithoutStaffDepartmentsNestedInput
    offeredCourses?: OfferedCourseUpdateManyWithoutAcademicDepartmentNestedInput
  }

  export type AcademicDepartmentUncheckedUpdateWithoutDepartmentHeadInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    academicFacultyId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    faculties?: FacultyUncheckedUpdateManyWithoutAcademicDepartmentNestedInput
    courses?: CourseUncheckedUpdateManyWithoutAcademicDepartmentNestedInput
    students?: StudentUncheckedUpdateManyWithoutAcademicDepartmentNestedInput
    staffMembers?: UsersUncheckedUpdateManyWithoutStaffDepartmentsNestedInput
    offeredCourses?: OfferedCourseUncheckedUpdateManyWithoutAcademicDepartmentNestedInput
  }

  export type AcademicDepartmentUpsertWithWhereUniqueWithoutStaffMembersInput = {
    where: AcademicDepartmentWhereUniqueInput
    update: XOR<AcademicDepartmentUpdateWithoutStaffMembersInput, AcademicDepartmentUncheckedUpdateWithoutStaffMembersInput>
    create: XOR<AcademicDepartmentCreateWithoutStaffMembersInput, AcademicDepartmentUncheckedCreateWithoutStaffMembersInput>
  }

  export type AcademicDepartmentUpdateWithWhereUniqueWithoutStaffMembersInput = {
    where: AcademicDepartmentWhereUniqueInput
    data: XOR<AcademicDepartmentUpdateWithoutStaffMembersInput, AcademicDepartmentUncheckedUpdateWithoutStaffMembersInput>
  }

  export type AcademicDepartmentUpdateManyWithWhereWithoutStaffMembersInput = {
    where: AcademicDepartmentScalarWhereInput
    data: XOR<AcademicDepartmentUpdateManyMutationInput, AcademicDepartmentUncheckedUpdateManyWithoutStaffMembersInput>
  }

  export type AcademicDepartmentScalarWhereInput = {
    AND?: AcademicDepartmentScalarWhereInput | AcademicDepartmentScalarWhereInput[]
    OR?: AcademicDepartmentScalarWhereInput[]
    NOT?: AcademicDepartmentScalarWhereInput | AcademicDepartmentScalarWhereInput[]
    id?: StringFilter<"AcademicDepartment"> | string
    title?: StringFilter<"AcademicDepartment"> | string
    academicFacultyId?: StringFilter<"AcademicDepartment"> | string
    createdAt?: DateTimeFilter<"AcademicDepartment"> | Date | string
    updatedAt?: DateTimeFilter<"AcademicDepartment"> | Date | string
    departmentHeadId?: StringNullableFilter<"AcademicDepartment"> | string | null
  }

  export type CourseDisciplineCreateWithoutSemesterInput = {
    id?: string
    credits: number
    course: CourseCreateNestedOneWithoutCourseDisciplinesInput
    discipline: DisciplineCreateNestedOneWithoutCourseDisciplinesInput
  }

  export type CourseDisciplineUncheckedCreateWithoutSemesterInput = {
    id?: string
    courseId: string
    disciplineId: string
    credits: number
  }

  export type CourseDisciplineCreateOrConnectWithoutSemesterInput = {
    where: CourseDisciplineWhereUniqueInput
    create: XOR<CourseDisciplineCreateWithoutSemesterInput, CourseDisciplineUncheckedCreateWithoutSemesterInput>
  }

  export type CourseDisciplineCreateManySemesterInputEnvelope = {
    data: CourseDisciplineCreateManySemesterInput | CourseDisciplineCreateManySemesterInput[]
    skipDuplicates?: boolean
  }

  export type SemesterRegistrationCreateWithoutAcademicSemesterInput = {
    id?: string
    startDate: Date | string
    endDate: Date | string
    status?: $Enums.SemesterRegistrationStatus | null
    createdAt?: Date | string
    updateAt?: Date | string
    offeredCourses?: OfferedCourseCreateNestedManyWithoutSemesterRegistrationInput
    offeredCourseSections?: OfferedCourseSectionCreateNestedManyWithoutSemesterRegistrationInput
    offeredCourseClassSchedules?: OfferedCourseClassScheduleCreateNestedManyWithoutSemesterRegistrationInput
    studentSemesterRegistrations?: StudentSemesterRegistrationCreateNestedManyWithoutSemesterRegistrationInput
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseCreateNestedManyWithoutSemesterRegistrationInput
  }

  export type SemesterRegistrationUncheckedCreateWithoutAcademicSemesterInput = {
    id?: string
    startDate: Date | string
    endDate: Date | string
    status?: $Enums.SemesterRegistrationStatus | null
    createdAt?: Date | string
    updateAt?: Date | string
    offeredCourses?: OfferedCourseUncheckedCreateNestedManyWithoutSemesterRegistrationInput
    offeredCourseSections?: OfferedCourseSectionUncheckedCreateNestedManyWithoutSemesterRegistrationInput
    offeredCourseClassSchedules?: OfferedCourseClassScheduleUncheckedCreateNestedManyWithoutSemesterRegistrationInput
    studentSemesterRegistrations?: StudentSemesterRegistrationUncheckedCreateNestedManyWithoutSemesterRegistrationInput
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseUncheckedCreateNestedManyWithoutSemesterRegistrationInput
  }

  export type SemesterRegistrationCreateOrConnectWithoutAcademicSemesterInput = {
    where: SemesterRegistrationWhereUniqueInput
    create: XOR<SemesterRegistrationCreateWithoutAcademicSemesterInput, SemesterRegistrationUncheckedCreateWithoutAcademicSemesterInput>
  }

  export type SemesterRegistrationCreateManyAcademicSemesterInputEnvelope = {
    data: SemesterRegistrationCreateManyAcademicSemesterInput | SemesterRegistrationCreateManyAcademicSemesterInput[]
    skipDuplicates?: boolean
  }

  export type StudentCreateWithoutAcademicSemesterInput = {
    id?: string
    studentId: string
    studentType?: $Enums.StudentType
    firstName: string
    middleName?: string | null
    lastName: string
    profileImage?: string | null
    email?: string | null
    contactNo?: string | null
    gender: string
    isWoker?: boolean
    shift?: $Enums.Shift
    yearLevel?: $Enums.YearLevel
    isActive?: boolean
    password: string
    gradeDeclarationFile: string
    biFile: string
    presentAddress: string
    permanentAddress?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    academicFaculty: AcademicFacultyCreateNestedOneWithoutStudentsInput
    admissionRegistration?: AdmitionExameRegistrationCreateNestedOneWithoutStudentInput
    academicDepartment: AcademicDepartmentCreateNestedOneWithoutStudentsInput
    studentSemesterRegistrations?: StudentSemesterRegistrationCreateNestedManyWithoutStudentInput
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseCreateNestedManyWithoutStudentInput
    studentEnrolledCourses?: StudentEnrolledCourseCreateNestedManyWithoutStudentInput
    studentEnrolledCourseMarks?: StudentEnrolledCourseMarkCreateNestedManyWithoutStudentInput
    studentSemesterPayments?: StudentSemesterPaymentCreateNestedManyWithoutStudentInput
    studentAcademicInfos?: StudentAcademicInfoCreateNestedManyWithoutStudentInput
    StudentCarriedCourse?: StudentCarriedCourseCreateNestedManyWithoutStudentInput
  }

  export type StudentUncheckedCreateWithoutAcademicSemesterInput = {
    id?: string
    studentId: string
    studentType?: $Enums.StudentType
    firstName: string
    middleName?: string | null
    lastName: string
    profileImage?: string | null
    email?: string | null
    contactNo?: string | null
    gender: string
    isWoker?: boolean
    shift?: $Enums.Shift
    yearLevel?: $Enums.YearLevel
    isActive?: boolean
    password: string
    gradeDeclarationFile: string
    biFile: string
    presentAddress: string
    permanentAddress?: string | null
    academicFacultyId: string
    academicDepartmentId: string
    admissionRegistrationId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    studentSemesterRegistrations?: StudentSemesterRegistrationUncheckedCreateNestedManyWithoutStudentInput
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseUncheckedCreateNestedManyWithoutStudentInput
    studentEnrolledCourses?: StudentEnrolledCourseUncheckedCreateNestedManyWithoutStudentInput
    studentEnrolledCourseMarks?: StudentEnrolledCourseMarkUncheckedCreateNestedManyWithoutStudentInput
    studentSemesterPayments?: StudentSemesterPaymentUncheckedCreateNestedManyWithoutStudentInput
    studentAcademicInfos?: StudentAcademicInfoUncheckedCreateNestedManyWithoutStudentInput
    StudentCarriedCourse?: StudentCarriedCourseUncheckedCreateNestedManyWithoutStudentInput
  }

  export type StudentCreateOrConnectWithoutAcademicSemesterInput = {
    where: StudentWhereUniqueInput
    create: XOR<StudentCreateWithoutAcademicSemesterInput, StudentUncheckedCreateWithoutAcademicSemesterInput>
  }

  export type StudentCreateManyAcademicSemesterInputEnvelope = {
    data: StudentCreateManyAcademicSemesterInput | StudentCreateManyAcademicSemesterInput[]
    skipDuplicates?: boolean
  }

  export type StudentEnrolledCourseCreateWithoutAcademicSemesterInput = {
    id?: string
    grade?: string | null
    point?: number | null
    totalMarks?: number | null
    status?: $Enums.StudentEnrolledCourseStatus | null
    createdAt?: Date | string
    updatedAt?: Date | string
    student: StudentCreateNestedOneWithoutStudentEnrolledCoursesInput
    course: CourseCreateNestedOneWithoutStudentCoursesInput
    studentEnrolledCourseMarks?: StudentEnrolledCourseMarkCreateNestedManyWithoutStudentEnrolledCourseInput
  }

  export type StudentEnrolledCourseUncheckedCreateWithoutAcademicSemesterInput = {
    id?: string
    grade?: string | null
    point?: number | null
    totalMarks?: number | null
    status?: $Enums.StudentEnrolledCourseStatus | null
    createdAt?: Date | string
    updatedAt?: Date | string
    studentId: string
    courseId: string
    studentEnrolledCourseMarks?: StudentEnrolledCourseMarkUncheckedCreateNestedManyWithoutStudentEnrolledCourseInput
  }

  export type StudentEnrolledCourseCreateOrConnectWithoutAcademicSemesterInput = {
    where: StudentEnrolledCourseWhereUniqueInput
    create: XOR<StudentEnrolledCourseCreateWithoutAcademicSemesterInput, StudentEnrolledCourseUncheckedCreateWithoutAcademicSemesterInput>
  }

  export type StudentEnrolledCourseCreateManyAcademicSemesterInputEnvelope = {
    data: StudentEnrolledCourseCreateManyAcademicSemesterInput | StudentEnrolledCourseCreateManyAcademicSemesterInput[]
    skipDuplicates?: boolean
  }

  export type StudentEnrolledCourseMarkCreateWithoutAcademicSemesterInput = {
    id?: string
    examType?: $Enums.ExamType | null
    createdAt?: Date | string
    updatedAt?: Date | string
    continuousAssessments: JsonNullValueInput | InputJsonValue
    frequencyExam?: number | null
    finalExam?: number | null
    resourceExam?: number | null
    specialExam?: number | null
    recoveryExam?: number | null
    totalMarks?: number
    grade?: number
    student: StudentCreateNestedOneWithoutStudentEnrolledCourseMarksInput
    studentEnrolledCourse: StudentEnrolledCourseCreateNestedOneWithoutStudentEnrolledCourseMarksInput
  }

  export type StudentEnrolledCourseMarkUncheckedCreateWithoutAcademicSemesterInput = {
    id?: string
    examType?: $Enums.ExamType | null
    createdAt?: Date | string
    updatedAt?: Date | string
    studentId: string
    studentEnrolledCourseId: string
    continuousAssessments: JsonNullValueInput | InputJsonValue
    frequencyExam?: number | null
    finalExam?: number | null
    resourceExam?: number | null
    specialExam?: number | null
    recoveryExam?: number | null
    totalMarks?: number
    grade?: number
  }

  export type StudentEnrolledCourseMarkCreateOrConnectWithoutAcademicSemesterInput = {
    where: StudentEnrolledCourseMarkWhereUniqueInput
    create: XOR<StudentEnrolledCourseMarkCreateWithoutAcademicSemesterInput, StudentEnrolledCourseMarkUncheckedCreateWithoutAcademicSemesterInput>
  }

  export type StudentEnrolledCourseMarkCreateManyAcademicSemesterInputEnvelope = {
    data: StudentEnrolledCourseMarkCreateManyAcademicSemesterInput | StudentEnrolledCourseMarkCreateManyAcademicSemesterInput[]
    skipDuplicates?: boolean
  }

  export type StudentSemesterPaymentCreateWithoutAcademicSemesterInput = {
    id?: string
    totalPayment: number
    baseAmount: number
    lateFee?: number
    paymentMonth: number
    paymentYear: number
    createdAt?: Date | string
    updatedAt?: Date | string
    payment: PaymentCreateNestedOneWithoutStudentSemesterPaymentInput
    student: StudentCreateNestedOneWithoutStudentSemesterPaymentsInput
  }

  export type StudentSemesterPaymentUncheckedCreateWithoutAcademicSemesterInput = {
    id?: string
    paymentId: string
    totalPayment: number
    baseAmount: number
    lateFee?: number
    paymentMonth: number
    paymentYear: number
    createdAt?: Date | string
    updatedAt?: Date | string
    studentId: string
  }

  export type StudentSemesterPaymentCreateOrConnectWithoutAcademicSemesterInput = {
    where: StudentSemesterPaymentWhereUniqueInput
    create: XOR<StudentSemesterPaymentCreateWithoutAcademicSemesterInput, StudentSemesterPaymentUncheckedCreateWithoutAcademicSemesterInput>
  }

  export type StudentSemesterPaymentCreateManyAcademicSemesterInputEnvelope = {
    data: StudentSemesterPaymentCreateManyAcademicSemesterInput | StudentSemesterPaymentCreateManyAcademicSemesterInput[]
    skipDuplicates?: boolean
  }

  export type StudentCarriedCourseCreateWithoutSemesterInput = {
    id?: string
    shift: $Enums.Shift
    price: number
    status?: $Enums.CarriedCourseStatus
    createdAt?: Date | string
    student: StudentCreateNestedOneWithoutStudentCarriedCourseInput
    discipline: DisciplineCreateNestedOneWithoutStudentCarriedCourseInput
  }

  export type StudentCarriedCourseUncheckedCreateWithoutSemesterInput = {
    id?: string
    studentId: string
    disciplineId: string
    shift: $Enums.Shift
    price: number
    status?: $Enums.CarriedCourseStatus
    createdAt?: Date | string
  }

  export type StudentCarriedCourseCreateOrConnectWithoutSemesterInput = {
    where: StudentCarriedCourseWhereUniqueInput
    create: XOR<StudentCarriedCourseCreateWithoutSemesterInput, StudentCarriedCourseUncheckedCreateWithoutSemesterInput>
  }

  export type StudentCarriedCourseCreateManySemesterInputEnvelope = {
    data: StudentCarriedCourseCreateManySemesterInput | StudentCarriedCourseCreateManySemesterInput[]
    skipDuplicates?: boolean
  }

  export type CourseDisciplineUpsertWithWhereUniqueWithoutSemesterInput = {
    where: CourseDisciplineWhereUniqueInput
    update: XOR<CourseDisciplineUpdateWithoutSemesterInput, CourseDisciplineUncheckedUpdateWithoutSemesterInput>
    create: XOR<CourseDisciplineCreateWithoutSemesterInput, CourseDisciplineUncheckedCreateWithoutSemesterInput>
  }

  export type CourseDisciplineUpdateWithWhereUniqueWithoutSemesterInput = {
    where: CourseDisciplineWhereUniqueInput
    data: XOR<CourseDisciplineUpdateWithoutSemesterInput, CourseDisciplineUncheckedUpdateWithoutSemesterInput>
  }

  export type CourseDisciplineUpdateManyWithWhereWithoutSemesterInput = {
    where: CourseDisciplineScalarWhereInput
    data: XOR<CourseDisciplineUpdateManyMutationInput, CourseDisciplineUncheckedUpdateManyWithoutSemesterInput>
  }

  export type CourseDisciplineScalarWhereInput = {
    AND?: CourseDisciplineScalarWhereInput | CourseDisciplineScalarWhereInput[]
    OR?: CourseDisciplineScalarWhereInput[]
    NOT?: CourseDisciplineScalarWhereInput | CourseDisciplineScalarWhereInput[]
    id?: StringFilter<"CourseDiscipline"> | string
    courseId?: StringFilter<"CourseDiscipline"> | string
    disciplineId?: StringFilter<"CourseDiscipline"> | string
    semesterId?: StringFilter<"CourseDiscipline"> | string
    credits?: IntFilter<"CourseDiscipline"> | number
  }

  export type SemesterRegistrationUpsertWithWhereUniqueWithoutAcademicSemesterInput = {
    where: SemesterRegistrationWhereUniqueInput
    update: XOR<SemesterRegistrationUpdateWithoutAcademicSemesterInput, SemesterRegistrationUncheckedUpdateWithoutAcademicSemesterInput>
    create: XOR<SemesterRegistrationCreateWithoutAcademicSemesterInput, SemesterRegistrationUncheckedCreateWithoutAcademicSemesterInput>
  }

  export type SemesterRegistrationUpdateWithWhereUniqueWithoutAcademicSemesterInput = {
    where: SemesterRegistrationWhereUniqueInput
    data: XOR<SemesterRegistrationUpdateWithoutAcademicSemesterInput, SemesterRegistrationUncheckedUpdateWithoutAcademicSemesterInput>
  }

  export type SemesterRegistrationUpdateManyWithWhereWithoutAcademicSemesterInput = {
    where: SemesterRegistrationScalarWhereInput
    data: XOR<SemesterRegistrationUpdateManyMutationInput, SemesterRegistrationUncheckedUpdateManyWithoutAcademicSemesterInput>
  }

  export type SemesterRegistrationScalarWhereInput = {
    AND?: SemesterRegistrationScalarWhereInput | SemesterRegistrationScalarWhereInput[]
    OR?: SemesterRegistrationScalarWhereInput[]
    NOT?: SemesterRegistrationScalarWhereInput | SemesterRegistrationScalarWhereInput[]
    id?: StringFilter<"SemesterRegistration"> | string
    startDate?: DateTimeFilter<"SemesterRegistration"> | Date | string
    endDate?: DateTimeFilter<"SemesterRegistration"> | Date | string
    status?: EnumSemesterRegistrationStatusNullableFilter<"SemesterRegistration"> | $Enums.SemesterRegistrationStatus | null
    createdAt?: DateTimeFilter<"SemesterRegistration"> | Date | string
    updateAt?: DateTimeFilter<"SemesterRegistration"> | Date | string
    academicSemesterId?: StringFilter<"SemesterRegistration"> | string
  }

  export type StudentUpsertWithWhereUniqueWithoutAcademicSemesterInput = {
    where: StudentWhereUniqueInput
    update: XOR<StudentUpdateWithoutAcademicSemesterInput, StudentUncheckedUpdateWithoutAcademicSemesterInput>
    create: XOR<StudentCreateWithoutAcademicSemesterInput, StudentUncheckedCreateWithoutAcademicSemesterInput>
  }

  export type StudentUpdateWithWhereUniqueWithoutAcademicSemesterInput = {
    where: StudentWhereUniqueInput
    data: XOR<StudentUpdateWithoutAcademicSemesterInput, StudentUncheckedUpdateWithoutAcademicSemesterInput>
  }

  export type StudentUpdateManyWithWhereWithoutAcademicSemesterInput = {
    where: StudentScalarWhereInput
    data: XOR<StudentUpdateManyMutationInput, StudentUncheckedUpdateManyWithoutAcademicSemesterInput>
  }

  export type StudentScalarWhereInput = {
    AND?: StudentScalarWhereInput | StudentScalarWhereInput[]
    OR?: StudentScalarWhereInput[]
    NOT?: StudentScalarWhereInput | StudentScalarWhereInput[]
    id?: StringFilter<"Student"> | string
    studentId?: StringFilter<"Student"> | string
    studentType?: EnumStudentTypeFilter<"Student"> | $Enums.StudentType
    firstName?: StringFilter<"Student"> | string
    middleName?: StringNullableFilter<"Student"> | string | null
    lastName?: StringFilter<"Student"> | string
    profileImage?: StringNullableFilter<"Student"> | string | null
    email?: StringNullableFilter<"Student"> | string | null
    contactNo?: StringNullableFilter<"Student"> | string | null
    gender?: StringFilter<"Student"> | string
    isWoker?: BoolFilter<"Student"> | boolean
    shift?: EnumShiftFilter<"Student"> | $Enums.Shift
    yearLevel?: EnumYearLevelFilter<"Student"> | $Enums.YearLevel
    isActive?: BoolFilter<"Student"> | boolean
    password?: StringFilter<"Student"> | string
    gradeDeclarationFile?: StringFilter<"Student"> | string
    biFile?: StringFilter<"Student"> | string
    presentAddress?: StringFilter<"Student"> | string
    permanentAddress?: StringNullableFilter<"Student"> | string | null
    academicSemesterId?: StringFilter<"Student"> | string
    academicFacultyId?: StringFilter<"Student"> | string
    academicDepartmentId?: StringFilter<"Student"> | string
    admissionRegistrationId?: StringNullableFilter<"Student"> | string | null
    createdAt?: DateTimeFilter<"Student"> | Date | string
    updatedAt?: DateTimeFilter<"Student"> | Date | string
  }

  export type StudentEnrolledCourseUpsertWithWhereUniqueWithoutAcademicSemesterInput = {
    where: StudentEnrolledCourseWhereUniqueInput
    update: XOR<StudentEnrolledCourseUpdateWithoutAcademicSemesterInput, StudentEnrolledCourseUncheckedUpdateWithoutAcademicSemesterInput>
    create: XOR<StudentEnrolledCourseCreateWithoutAcademicSemesterInput, StudentEnrolledCourseUncheckedCreateWithoutAcademicSemesterInput>
  }

  export type StudentEnrolledCourseUpdateWithWhereUniqueWithoutAcademicSemesterInput = {
    where: StudentEnrolledCourseWhereUniqueInput
    data: XOR<StudentEnrolledCourseUpdateWithoutAcademicSemesterInput, StudentEnrolledCourseUncheckedUpdateWithoutAcademicSemesterInput>
  }

  export type StudentEnrolledCourseUpdateManyWithWhereWithoutAcademicSemesterInput = {
    where: StudentEnrolledCourseScalarWhereInput
    data: XOR<StudentEnrolledCourseUpdateManyMutationInput, StudentEnrolledCourseUncheckedUpdateManyWithoutAcademicSemesterInput>
  }

  export type StudentEnrolledCourseScalarWhereInput = {
    AND?: StudentEnrolledCourseScalarWhereInput | StudentEnrolledCourseScalarWhereInput[]
    OR?: StudentEnrolledCourseScalarWhereInput[]
    NOT?: StudentEnrolledCourseScalarWhereInput | StudentEnrolledCourseScalarWhereInput[]
    id?: StringFilter<"StudentEnrolledCourse"> | string
    grade?: StringNullableFilter<"StudentEnrolledCourse"> | string | null
    point?: FloatNullableFilter<"StudentEnrolledCourse"> | number | null
    totalMarks?: IntNullableFilter<"StudentEnrolledCourse"> | number | null
    status?: EnumStudentEnrolledCourseStatusNullableFilter<"StudentEnrolledCourse"> | $Enums.StudentEnrolledCourseStatus | null
    createdAt?: DateTimeFilter<"StudentEnrolledCourse"> | Date | string
    updatedAt?: DateTimeFilter<"StudentEnrolledCourse"> | Date | string
    studentId?: StringFilter<"StudentEnrolledCourse"> | string
    academicSemesterId?: StringFilter<"StudentEnrolledCourse"> | string
    courseId?: StringFilter<"StudentEnrolledCourse"> | string
  }

  export type StudentEnrolledCourseMarkUpsertWithWhereUniqueWithoutAcademicSemesterInput = {
    where: StudentEnrolledCourseMarkWhereUniqueInput
    update: XOR<StudentEnrolledCourseMarkUpdateWithoutAcademicSemesterInput, StudentEnrolledCourseMarkUncheckedUpdateWithoutAcademicSemesterInput>
    create: XOR<StudentEnrolledCourseMarkCreateWithoutAcademicSemesterInput, StudentEnrolledCourseMarkUncheckedCreateWithoutAcademicSemesterInput>
  }

  export type StudentEnrolledCourseMarkUpdateWithWhereUniqueWithoutAcademicSemesterInput = {
    where: StudentEnrolledCourseMarkWhereUniqueInput
    data: XOR<StudentEnrolledCourseMarkUpdateWithoutAcademicSemesterInput, StudentEnrolledCourseMarkUncheckedUpdateWithoutAcademicSemesterInput>
  }

  export type StudentEnrolledCourseMarkUpdateManyWithWhereWithoutAcademicSemesterInput = {
    where: StudentEnrolledCourseMarkScalarWhereInput
    data: XOR<StudentEnrolledCourseMarkUpdateManyMutationInput, StudentEnrolledCourseMarkUncheckedUpdateManyWithoutAcademicSemesterInput>
  }

  export type StudentEnrolledCourseMarkScalarWhereInput = {
    AND?: StudentEnrolledCourseMarkScalarWhereInput | StudentEnrolledCourseMarkScalarWhereInput[]
    OR?: StudentEnrolledCourseMarkScalarWhereInput[]
    NOT?: StudentEnrolledCourseMarkScalarWhereInput | StudentEnrolledCourseMarkScalarWhereInput[]
    id?: StringFilter<"StudentEnrolledCourseMark"> | string
    examType?: EnumExamTypeNullableFilter<"StudentEnrolledCourseMark"> | $Enums.ExamType | null
    createdAt?: DateTimeFilter<"StudentEnrolledCourseMark"> | Date | string
    updatedAt?: DateTimeFilter<"StudentEnrolledCourseMark"> | Date | string
    studentId?: StringFilter<"StudentEnrolledCourseMark"> | string
    studentEnrolledCourseId?: StringFilter<"StudentEnrolledCourseMark"> | string
    academicSemesterId?: StringFilter<"StudentEnrolledCourseMark"> | string
    continuousAssessments?: JsonFilter<"StudentEnrolledCourseMark">
    frequencyExam?: FloatNullableFilter<"StudentEnrolledCourseMark"> | number | null
    finalExam?: FloatNullableFilter<"StudentEnrolledCourseMark"> | number | null
    resourceExam?: FloatNullableFilter<"StudentEnrolledCourseMark"> | number | null
    specialExam?: FloatNullableFilter<"StudentEnrolledCourseMark"> | number | null
    recoveryExam?: FloatNullableFilter<"StudentEnrolledCourseMark"> | number | null
    totalMarks?: FloatFilter<"StudentEnrolledCourseMark"> | number
    grade?: FloatFilter<"StudentEnrolledCourseMark"> | number
  }

  export type StudentSemesterPaymentUpsertWithWhereUniqueWithoutAcademicSemesterInput = {
    where: StudentSemesterPaymentWhereUniqueInput
    update: XOR<StudentSemesterPaymentUpdateWithoutAcademicSemesterInput, StudentSemesterPaymentUncheckedUpdateWithoutAcademicSemesterInput>
    create: XOR<StudentSemesterPaymentCreateWithoutAcademicSemesterInput, StudentSemesterPaymentUncheckedCreateWithoutAcademicSemesterInput>
  }

  export type StudentSemesterPaymentUpdateWithWhereUniqueWithoutAcademicSemesterInput = {
    where: StudentSemesterPaymentWhereUniqueInput
    data: XOR<StudentSemesterPaymentUpdateWithoutAcademicSemesterInput, StudentSemesterPaymentUncheckedUpdateWithoutAcademicSemesterInput>
  }

  export type StudentSemesterPaymentUpdateManyWithWhereWithoutAcademicSemesterInput = {
    where: StudentSemesterPaymentScalarWhereInput
    data: XOR<StudentSemesterPaymentUpdateManyMutationInput, StudentSemesterPaymentUncheckedUpdateManyWithoutAcademicSemesterInput>
  }

  export type StudentSemesterPaymentScalarWhereInput = {
    AND?: StudentSemesterPaymentScalarWhereInput | StudentSemesterPaymentScalarWhereInput[]
    OR?: StudentSemesterPaymentScalarWhereInput[]
    NOT?: StudentSemesterPaymentScalarWhereInput | StudentSemesterPaymentScalarWhereInput[]
    id?: StringFilter<"StudentSemesterPayment"> | string
    paymentId?: StringFilter<"StudentSemesterPayment"> | string
    totalPayment?: IntFilter<"StudentSemesterPayment"> | number
    baseAmount?: IntFilter<"StudentSemesterPayment"> | number
    lateFee?: IntFilter<"StudentSemesterPayment"> | number
    paymentMonth?: IntFilter<"StudentSemesterPayment"> | number
    paymentYear?: IntFilter<"StudentSemesterPayment"> | number
    createdAt?: DateTimeFilter<"StudentSemesterPayment"> | Date | string
    updatedAt?: DateTimeFilter<"StudentSemesterPayment"> | Date | string
    studentId?: StringFilter<"StudentSemesterPayment"> | string
    academicSemesterId?: StringFilter<"StudentSemesterPayment"> | string
  }

  export type StudentCarriedCourseUpsertWithWhereUniqueWithoutSemesterInput = {
    where: StudentCarriedCourseWhereUniqueInput
    update: XOR<StudentCarriedCourseUpdateWithoutSemesterInput, StudentCarriedCourseUncheckedUpdateWithoutSemesterInput>
    create: XOR<StudentCarriedCourseCreateWithoutSemesterInput, StudentCarriedCourseUncheckedCreateWithoutSemesterInput>
  }

  export type StudentCarriedCourseUpdateWithWhereUniqueWithoutSemesterInput = {
    where: StudentCarriedCourseWhereUniqueInput
    data: XOR<StudentCarriedCourseUpdateWithoutSemesterInput, StudentCarriedCourseUncheckedUpdateWithoutSemesterInput>
  }

  export type StudentCarriedCourseUpdateManyWithWhereWithoutSemesterInput = {
    where: StudentCarriedCourseScalarWhereInput
    data: XOR<StudentCarriedCourseUpdateManyMutationInput, StudentCarriedCourseUncheckedUpdateManyWithoutSemesterInput>
  }

  export type StudentCarriedCourseScalarWhereInput = {
    AND?: StudentCarriedCourseScalarWhereInput | StudentCarriedCourseScalarWhereInput[]
    OR?: StudentCarriedCourseScalarWhereInput[]
    NOT?: StudentCarriedCourseScalarWhereInput | StudentCarriedCourseScalarWhereInput[]
    id?: StringFilter<"StudentCarriedCourse"> | string
    studentId?: StringFilter<"StudentCarriedCourse"> | string
    disciplineId?: StringFilter<"StudentCarriedCourse"> | string
    semesterId?: StringFilter<"StudentCarriedCourse"> | string
    shift?: EnumShiftFilter<"StudentCarriedCourse"> | $Enums.Shift
    price?: IntFilter<"StudentCarriedCourse"> | number
    status?: EnumCarriedCourseStatusFilter<"StudentCarriedCourse"> | $Enums.CarriedCourseStatus
    createdAt?: DateTimeFilter<"StudentCarriedCourse"> | Date | string
  }

  export type AcademicDepartmentCreateWithoutAcademicFacultyInput = {
    id?: string
    title: string
    createdAt?: Date | string
    updatedAt?: Date | string
    faculties?: FacultyCreateNestedManyWithoutAcademicDepartmentInput
    courses?: CourseCreateNestedManyWithoutAcademicDepartmentInput
    students?: StudentCreateNestedManyWithoutAcademicDepartmentInput
    departmentHead?: UsersCreateNestedOneWithoutAcademicDepartmentInput
    staffMembers?: UsersCreateNestedManyWithoutStaffDepartmentsInput
    offeredCourses?: OfferedCourseCreateNestedManyWithoutAcademicDepartmentInput
  }

  export type AcademicDepartmentUncheckedCreateWithoutAcademicFacultyInput = {
    id?: string
    title: string
    createdAt?: Date | string
    updatedAt?: Date | string
    departmentHeadId?: string | null
    faculties?: FacultyUncheckedCreateNestedManyWithoutAcademicDepartmentInput
    courses?: CourseUncheckedCreateNestedManyWithoutAcademicDepartmentInput
    students?: StudentUncheckedCreateNestedManyWithoutAcademicDepartmentInput
    staffMembers?: UsersUncheckedCreateNestedManyWithoutStaffDepartmentsInput
    offeredCourses?: OfferedCourseUncheckedCreateNestedManyWithoutAcademicDepartmentInput
  }

  export type AcademicDepartmentCreateOrConnectWithoutAcademicFacultyInput = {
    where: AcademicDepartmentWhereUniqueInput
    create: XOR<AcademicDepartmentCreateWithoutAcademicFacultyInput, AcademicDepartmentUncheckedCreateWithoutAcademicFacultyInput>
  }

  export type AcademicDepartmentCreateManyAcademicFacultyInputEnvelope = {
    data: AcademicDepartmentCreateManyAcademicFacultyInput | AcademicDepartmentCreateManyAcademicFacultyInput[]
    skipDuplicates?: boolean
  }

  export type FacultyCreateWithoutAcademicFacultyInput = {
    id?: string
    facultyId: string
    firstName: string
    middleName?: string | null
    lastName: string
    profileImage?: string | null
    email?: string | null
    contactNo?: string | null
    shift?: $Enums.Shift
    gender: string
    designation: string
    password: string
    createdAt?: Date | string
    updatedAt?: Date | string
    courses?: CourseFacultyCreateNestedManyWithoutFacultyInput
    academicDepartment: AcademicDepartmentCreateNestedOneWithoutFacultiesInput
    offeredCourseClassSchedules?: OfferedCourseClassScheduleCreateNestedManyWithoutFacultyInput
  }

  export type FacultyUncheckedCreateWithoutAcademicFacultyInput = {
    id?: string
    facultyId: string
    firstName: string
    middleName?: string | null
    lastName: string
    profileImage?: string | null
    email?: string | null
    contactNo?: string | null
    shift?: $Enums.Shift
    gender: string
    designation: string
    password: string
    academicDepartmentId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    courses?: CourseFacultyUncheckedCreateNestedManyWithoutFacultyInput
    offeredCourseClassSchedules?: OfferedCourseClassScheduleUncheckedCreateNestedManyWithoutFacultyInput
  }

  export type FacultyCreateOrConnectWithoutAcademicFacultyInput = {
    where: FacultyWhereUniqueInput
    create: XOR<FacultyCreateWithoutAcademicFacultyInput, FacultyUncheckedCreateWithoutAcademicFacultyInput>
  }

  export type FacultyCreateManyAcademicFacultyInputEnvelope = {
    data: FacultyCreateManyAcademicFacultyInput | FacultyCreateManyAcademicFacultyInput[]
    skipDuplicates?: boolean
  }

  export type StudentCreateWithoutAcademicFacultyInput = {
    id?: string
    studentId: string
    studentType?: $Enums.StudentType
    firstName: string
    middleName?: string | null
    lastName: string
    profileImage?: string | null
    email?: string | null
    contactNo?: string | null
    gender: string
    isWoker?: boolean
    shift?: $Enums.Shift
    yearLevel?: $Enums.YearLevel
    isActive?: boolean
    password: string
    gradeDeclarationFile: string
    biFile: string
    presentAddress: string
    permanentAddress?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    admissionRegistration?: AdmitionExameRegistrationCreateNestedOneWithoutStudentInput
    academicDepartment: AcademicDepartmentCreateNestedOneWithoutStudentsInput
    academicSemester: AcademicSemesterCreateNestedOneWithoutStudentsInput
    studentSemesterRegistrations?: StudentSemesterRegistrationCreateNestedManyWithoutStudentInput
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseCreateNestedManyWithoutStudentInput
    studentEnrolledCourses?: StudentEnrolledCourseCreateNestedManyWithoutStudentInput
    studentEnrolledCourseMarks?: StudentEnrolledCourseMarkCreateNestedManyWithoutStudentInput
    studentSemesterPayments?: StudentSemesterPaymentCreateNestedManyWithoutStudentInput
    studentAcademicInfos?: StudentAcademicInfoCreateNestedManyWithoutStudentInput
    StudentCarriedCourse?: StudentCarriedCourseCreateNestedManyWithoutStudentInput
  }

  export type StudentUncheckedCreateWithoutAcademicFacultyInput = {
    id?: string
    studentId: string
    studentType?: $Enums.StudentType
    firstName: string
    middleName?: string | null
    lastName: string
    profileImage?: string | null
    email?: string | null
    contactNo?: string | null
    gender: string
    isWoker?: boolean
    shift?: $Enums.Shift
    yearLevel?: $Enums.YearLevel
    isActive?: boolean
    password: string
    gradeDeclarationFile: string
    biFile: string
    presentAddress: string
    permanentAddress?: string | null
    academicSemesterId: string
    academicDepartmentId: string
    admissionRegistrationId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    studentSemesterRegistrations?: StudentSemesterRegistrationUncheckedCreateNestedManyWithoutStudentInput
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseUncheckedCreateNestedManyWithoutStudentInput
    studentEnrolledCourses?: StudentEnrolledCourseUncheckedCreateNestedManyWithoutStudentInput
    studentEnrolledCourseMarks?: StudentEnrolledCourseMarkUncheckedCreateNestedManyWithoutStudentInput
    studentSemesterPayments?: StudentSemesterPaymentUncheckedCreateNestedManyWithoutStudentInput
    studentAcademicInfos?: StudentAcademicInfoUncheckedCreateNestedManyWithoutStudentInput
    StudentCarriedCourse?: StudentCarriedCourseUncheckedCreateNestedManyWithoutStudentInput
  }

  export type StudentCreateOrConnectWithoutAcademicFacultyInput = {
    where: StudentWhereUniqueInput
    create: XOR<StudentCreateWithoutAcademicFacultyInput, StudentUncheckedCreateWithoutAcademicFacultyInput>
  }

  export type StudentCreateManyAcademicFacultyInputEnvelope = {
    data: StudentCreateManyAcademicFacultyInput | StudentCreateManyAcademicFacultyInput[]
    skipDuplicates?: boolean
  }

  export type AdmitionExameRegistrationCreateWithoutAcademicFalcultyInput = {
    id?: string
    applicantName: string
    paymentRecipt: string
    status?: $Enums.Status
    document: string
    paymentAmoute?: number | null
    aprovePayment?: boolean | null
    exameResults?: number | null
    passed?: boolean | null
    exameDate: Date | string
    rejectionReason?: string | null
    phoneNumber: string
    email: string
    createdAt?: Date | string
    updateAt?: Date | string
    fase: ExameFaseCreateNestedOneWithoutRegistrationsInput
    Student?: StudentCreateNestedOneWithoutAdmissionRegistrationInput
  }

  export type AdmitionExameRegistrationUncheckedCreateWithoutAcademicFalcultyInput = {
    id?: string
    applicantName: string
    paymentRecipt: string
    status?: $Enums.Status
    document: string
    paymentAmoute?: number | null
    aprovePayment?: boolean | null
    exameResults?: number | null
    passed?: boolean | null
    faseId: string
    exameDate: Date | string
    rejectionReason?: string | null
    phoneNumber: string
    email: string
    createdAt?: Date | string
    updateAt?: Date | string
    Student?: StudentUncheckedCreateNestedOneWithoutAdmissionRegistrationInput
  }

  export type AdmitionExameRegistrationCreateOrConnectWithoutAcademicFalcultyInput = {
    where: AdmitionExameRegistrationWhereUniqueInput
    create: XOR<AdmitionExameRegistrationCreateWithoutAcademicFalcultyInput, AdmitionExameRegistrationUncheckedCreateWithoutAcademicFalcultyInput>
  }

  export type AdmitionExameRegistrationCreateManyAcademicFalcultyInputEnvelope = {
    data: AdmitionExameRegistrationCreateManyAcademicFalcultyInput | AdmitionExameRegistrationCreateManyAcademicFalcultyInput[]
    skipDuplicates?: boolean
  }

  export type AdmitionExamePriceCreateWithoutAcademicFacultyInput = {
    id?: string
    price: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AdmitionExamePriceUncheckedCreateWithoutAcademicFacultyInput = {
    id?: string
    price: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AdmitionExamePriceCreateOrConnectWithoutAcademicFacultyInput = {
    where: AdmitionExamePriceWhereUniqueInput
    create: XOR<AdmitionExamePriceCreateWithoutAcademicFacultyInput, AdmitionExamePriceUncheckedCreateWithoutAcademicFacultyInput>
  }

  export type AdmitionExamePriceCreateManyAcademicFacultyInputEnvelope = {
    data: AdmitionExamePriceCreateManyAcademicFacultyInput | AdmitionExamePriceCreateManyAcademicFacultyInput[]
    skipDuplicates?: boolean
  }

  export type AdmitionExamePeriodCreateWithoutAcademicFacultyInput = {
    id?: string
    startDate: Date | string
    endDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AdmitionExamePeriodUncheckedCreateWithoutAcademicFacultyInput = {
    id?: string
    startDate: Date | string
    endDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AdmitionExamePeriodCreateOrConnectWithoutAcademicFacultyInput = {
    where: AdmitionExamePeriodWhereUniqueInput
    create: XOR<AdmitionExamePeriodCreateWithoutAcademicFacultyInput, AdmitionExamePeriodUncheckedCreateWithoutAcademicFacultyInput>
  }

  export type AdmitionExamePeriodCreateManyAcademicFacultyInputEnvelope = {
    data: AdmitionExamePeriodCreateManyAcademicFacultyInput | AdmitionExamePeriodCreateManyAcademicFacultyInput[]
    skipDuplicates?: boolean
  }

  export type AcademicDepartmentUpsertWithWhereUniqueWithoutAcademicFacultyInput = {
    where: AcademicDepartmentWhereUniqueInput
    update: XOR<AcademicDepartmentUpdateWithoutAcademicFacultyInput, AcademicDepartmentUncheckedUpdateWithoutAcademicFacultyInput>
    create: XOR<AcademicDepartmentCreateWithoutAcademicFacultyInput, AcademicDepartmentUncheckedCreateWithoutAcademicFacultyInput>
  }

  export type AcademicDepartmentUpdateWithWhereUniqueWithoutAcademicFacultyInput = {
    where: AcademicDepartmentWhereUniqueInput
    data: XOR<AcademicDepartmentUpdateWithoutAcademicFacultyInput, AcademicDepartmentUncheckedUpdateWithoutAcademicFacultyInput>
  }

  export type AcademicDepartmentUpdateManyWithWhereWithoutAcademicFacultyInput = {
    where: AcademicDepartmentScalarWhereInput
    data: XOR<AcademicDepartmentUpdateManyMutationInput, AcademicDepartmentUncheckedUpdateManyWithoutAcademicFacultyInput>
  }

  export type FacultyUpsertWithWhereUniqueWithoutAcademicFacultyInput = {
    where: FacultyWhereUniqueInput
    update: XOR<FacultyUpdateWithoutAcademicFacultyInput, FacultyUncheckedUpdateWithoutAcademicFacultyInput>
    create: XOR<FacultyCreateWithoutAcademicFacultyInput, FacultyUncheckedCreateWithoutAcademicFacultyInput>
  }

  export type FacultyUpdateWithWhereUniqueWithoutAcademicFacultyInput = {
    where: FacultyWhereUniqueInput
    data: XOR<FacultyUpdateWithoutAcademicFacultyInput, FacultyUncheckedUpdateWithoutAcademicFacultyInput>
  }

  export type FacultyUpdateManyWithWhereWithoutAcademicFacultyInput = {
    where: FacultyScalarWhereInput
    data: XOR<FacultyUpdateManyMutationInput, FacultyUncheckedUpdateManyWithoutAcademicFacultyInput>
  }

  export type FacultyScalarWhereInput = {
    AND?: FacultyScalarWhereInput | FacultyScalarWhereInput[]
    OR?: FacultyScalarWhereInput[]
    NOT?: FacultyScalarWhereInput | FacultyScalarWhereInput[]
    id?: StringFilter<"Faculty"> | string
    facultyId?: StringFilter<"Faculty"> | string
    firstName?: StringFilter<"Faculty"> | string
    middleName?: StringNullableFilter<"Faculty"> | string | null
    lastName?: StringFilter<"Faculty"> | string
    profileImage?: StringNullableFilter<"Faculty"> | string | null
    email?: StringNullableFilter<"Faculty"> | string | null
    contactNo?: StringNullableFilter<"Faculty"> | string | null
    shift?: EnumShiftFilter<"Faculty"> | $Enums.Shift
    gender?: StringFilter<"Faculty"> | string
    designation?: StringFilter<"Faculty"> | string
    password?: StringFilter<"Faculty"> | string
    academicFacultyId?: StringFilter<"Faculty"> | string
    academicDepartmentId?: StringFilter<"Faculty"> | string
    createdAt?: DateTimeFilter<"Faculty"> | Date | string
    updatedAt?: DateTimeFilter<"Faculty"> | Date | string
  }

  export type StudentUpsertWithWhereUniqueWithoutAcademicFacultyInput = {
    where: StudentWhereUniqueInput
    update: XOR<StudentUpdateWithoutAcademicFacultyInput, StudentUncheckedUpdateWithoutAcademicFacultyInput>
    create: XOR<StudentCreateWithoutAcademicFacultyInput, StudentUncheckedCreateWithoutAcademicFacultyInput>
  }

  export type StudentUpdateWithWhereUniqueWithoutAcademicFacultyInput = {
    where: StudentWhereUniqueInput
    data: XOR<StudentUpdateWithoutAcademicFacultyInput, StudentUncheckedUpdateWithoutAcademicFacultyInput>
  }

  export type StudentUpdateManyWithWhereWithoutAcademicFacultyInput = {
    where: StudentScalarWhereInput
    data: XOR<StudentUpdateManyMutationInput, StudentUncheckedUpdateManyWithoutAcademicFacultyInput>
  }

  export type AdmitionExameRegistrationUpsertWithWhereUniqueWithoutAcademicFalcultyInput = {
    where: AdmitionExameRegistrationWhereUniqueInput
    update: XOR<AdmitionExameRegistrationUpdateWithoutAcademicFalcultyInput, AdmitionExameRegistrationUncheckedUpdateWithoutAcademicFalcultyInput>
    create: XOR<AdmitionExameRegistrationCreateWithoutAcademicFalcultyInput, AdmitionExameRegistrationUncheckedCreateWithoutAcademicFalcultyInput>
  }

  export type AdmitionExameRegistrationUpdateWithWhereUniqueWithoutAcademicFalcultyInput = {
    where: AdmitionExameRegistrationWhereUniqueInput
    data: XOR<AdmitionExameRegistrationUpdateWithoutAcademicFalcultyInput, AdmitionExameRegistrationUncheckedUpdateWithoutAcademicFalcultyInput>
  }

  export type AdmitionExameRegistrationUpdateManyWithWhereWithoutAcademicFalcultyInput = {
    where: AdmitionExameRegistrationScalarWhereInput
    data: XOR<AdmitionExameRegistrationUpdateManyMutationInput, AdmitionExameRegistrationUncheckedUpdateManyWithoutAcademicFalcultyInput>
  }

  export type AdmitionExameRegistrationScalarWhereInput = {
    AND?: AdmitionExameRegistrationScalarWhereInput | AdmitionExameRegistrationScalarWhereInput[]
    OR?: AdmitionExameRegistrationScalarWhereInput[]
    NOT?: AdmitionExameRegistrationScalarWhereInput | AdmitionExameRegistrationScalarWhereInput[]
    id?: StringFilter<"AdmitionExameRegistration"> | string
    applicantName?: StringFilter<"AdmitionExameRegistration"> | string
    paymentRecipt?: StringFilter<"AdmitionExameRegistration"> | string
    status?: EnumStatusFilter<"AdmitionExameRegistration"> | $Enums.Status
    document?: StringFilter<"AdmitionExameRegistration"> | string
    paymentAmoute?: IntNullableFilter<"AdmitionExameRegistration"> | number | null
    aprovePayment?: BoolNullableFilter<"AdmitionExameRegistration"> | boolean | null
    exameResults?: IntNullableFilter<"AdmitionExameRegistration"> | number | null
    passed?: BoolNullableFilter<"AdmitionExameRegistration"> | boolean | null
    faseId?: StringFilter<"AdmitionExameRegistration"> | string
    exameDate?: DateTimeFilter<"AdmitionExameRegistration"> | Date | string
    rejectionReason?: StringNullableFilter<"AdmitionExameRegistration"> | string | null
    phoneNumber?: StringFilter<"AdmitionExameRegistration"> | string
    email?: StringFilter<"AdmitionExameRegistration"> | string
    createdAt?: DateTimeFilter<"AdmitionExameRegistration"> | Date | string
    updateAt?: DateTimeFilter<"AdmitionExameRegistration"> | Date | string
    academicFalcultyId?: StringFilter<"AdmitionExameRegistration"> | string
  }

  export type AdmitionExamePriceUpsertWithWhereUniqueWithoutAcademicFacultyInput = {
    where: AdmitionExamePriceWhereUniqueInput
    update: XOR<AdmitionExamePriceUpdateWithoutAcademicFacultyInput, AdmitionExamePriceUncheckedUpdateWithoutAcademicFacultyInput>
    create: XOR<AdmitionExamePriceCreateWithoutAcademicFacultyInput, AdmitionExamePriceUncheckedCreateWithoutAcademicFacultyInput>
  }

  export type AdmitionExamePriceUpdateWithWhereUniqueWithoutAcademicFacultyInput = {
    where: AdmitionExamePriceWhereUniqueInput
    data: XOR<AdmitionExamePriceUpdateWithoutAcademicFacultyInput, AdmitionExamePriceUncheckedUpdateWithoutAcademicFacultyInput>
  }

  export type AdmitionExamePriceUpdateManyWithWhereWithoutAcademicFacultyInput = {
    where: AdmitionExamePriceScalarWhereInput
    data: XOR<AdmitionExamePriceUpdateManyMutationInput, AdmitionExamePriceUncheckedUpdateManyWithoutAcademicFacultyInput>
  }

  export type AdmitionExamePriceScalarWhereInput = {
    AND?: AdmitionExamePriceScalarWhereInput | AdmitionExamePriceScalarWhereInput[]
    OR?: AdmitionExamePriceScalarWhereInput[]
    NOT?: AdmitionExamePriceScalarWhereInput | AdmitionExamePriceScalarWhereInput[]
    id?: StringFilter<"AdmitionExamePrice"> | string
    academicFacultyId?: StringFilter<"AdmitionExamePrice"> | string
    price?: IntFilter<"AdmitionExamePrice"> | number
    createdAt?: DateTimeFilter<"AdmitionExamePrice"> | Date | string
    updatedAt?: DateTimeFilter<"AdmitionExamePrice"> | Date | string
  }

  export type AdmitionExamePeriodUpsertWithWhereUniqueWithoutAcademicFacultyInput = {
    where: AdmitionExamePeriodWhereUniqueInput
    update: XOR<AdmitionExamePeriodUpdateWithoutAcademicFacultyInput, AdmitionExamePeriodUncheckedUpdateWithoutAcademicFacultyInput>
    create: XOR<AdmitionExamePeriodCreateWithoutAcademicFacultyInput, AdmitionExamePeriodUncheckedCreateWithoutAcademicFacultyInput>
  }

  export type AdmitionExamePeriodUpdateWithWhereUniqueWithoutAcademicFacultyInput = {
    where: AdmitionExamePeriodWhereUniqueInput
    data: XOR<AdmitionExamePeriodUpdateWithoutAcademicFacultyInput, AdmitionExamePeriodUncheckedUpdateWithoutAcademicFacultyInput>
  }

  export type AdmitionExamePeriodUpdateManyWithWhereWithoutAcademicFacultyInput = {
    where: AdmitionExamePeriodScalarWhereInput
    data: XOR<AdmitionExamePeriodUpdateManyMutationInput, AdmitionExamePeriodUncheckedUpdateManyWithoutAcademicFacultyInput>
  }

  export type AdmitionExamePeriodScalarWhereInput = {
    AND?: AdmitionExamePeriodScalarWhereInput | AdmitionExamePeriodScalarWhereInput[]
    OR?: AdmitionExamePeriodScalarWhereInput[]
    NOT?: AdmitionExamePeriodScalarWhereInput | AdmitionExamePeriodScalarWhereInput[]
    id?: StringFilter<"AdmitionExamePeriod"> | string
    startDate?: DateTimeFilter<"AdmitionExamePeriod"> | Date | string
    endDate?: DateTimeFilter<"AdmitionExamePeriod"> | Date | string
    academicFacultyId?: StringFilter<"AdmitionExamePeriod"> | string
    createdAt?: DateTimeFilter<"AdmitionExamePeriod"> | Date | string
    updatedAt?: DateTimeFilter<"AdmitionExamePeriod"> | Date | string
  }

  export type AcademicFacultyCreateWithoutAcademicDepartmentsInput = {
    id?: string
    title: string
    createdAt?: Date | string
    updatedAt?: Date | string
    faculties?: FacultyCreateNestedManyWithoutAcademicFacultyInput
    students?: StudentCreateNestedManyWithoutAcademicFacultyInput
    admitionExame?: AdmitionExameRegistrationCreateNestedManyWithoutAcademicFalcultyInput
    AdmitionExamePrice?: AdmitionExamePriceCreateNestedManyWithoutAcademicFacultyInput
    AdmitionExamePeriod?: AdmitionExamePeriodCreateNestedManyWithoutAcademicFacultyInput
  }

  export type AcademicFacultyUncheckedCreateWithoutAcademicDepartmentsInput = {
    id?: string
    title: string
    createdAt?: Date | string
    updatedAt?: Date | string
    faculties?: FacultyUncheckedCreateNestedManyWithoutAcademicFacultyInput
    students?: StudentUncheckedCreateNestedManyWithoutAcademicFacultyInput
    admitionExame?: AdmitionExameRegistrationUncheckedCreateNestedManyWithoutAcademicFalcultyInput
    AdmitionExamePrice?: AdmitionExamePriceUncheckedCreateNestedManyWithoutAcademicFacultyInput
    AdmitionExamePeriod?: AdmitionExamePeriodUncheckedCreateNestedManyWithoutAcademicFacultyInput
  }

  export type AcademicFacultyCreateOrConnectWithoutAcademicDepartmentsInput = {
    where: AcademicFacultyWhereUniqueInput
    create: XOR<AcademicFacultyCreateWithoutAcademicDepartmentsInput, AcademicFacultyUncheckedCreateWithoutAcademicDepartmentsInput>
  }

  export type FacultyCreateWithoutAcademicDepartmentInput = {
    id?: string
    facultyId: string
    firstName: string
    middleName?: string | null
    lastName: string
    profileImage?: string | null
    email?: string | null
    contactNo?: string | null
    shift?: $Enums.Shift
    gender: string
    designation: string
    password: string
    createdAt?: Date | string
    updatedAt?: Date | string
    courses?: CourseFacultyCreateNestedManyWithoutFacultyInput
    academicFaculty: AcademicFacultyCreateNestedOneWithoutFacultiesInput
    offeredCourseClassSchedules?: OfferedCourseClassScheduleCreateNestedManyWithoutFacultyInput
  }

  export type FacultyUncheckedCreateWithoutAcademicDepartmentInput = {
    id?: string
    facultyId: string
    firstName: string
    middleName?: string | null
    lastName: string
    profileImage?: string | null
    email?: string | null
    contactNo?: string | null
    shift?: $Enums.Shift
    gender: string
    designation: string
    password: string
    academicFacultyId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    courses?: CourseFacultyUncheckedCreateNestedManyWithoutFacultyInput
    offeredCourseClassSchedules?: OfferedCourseClassScheduleUncheckedCreateNestedManyWithoutFacultyInput
  }

  export type FacultyCreateOrConnectWithoutAcademicDepartmentInput = {
    where: FacultyWhereUniqueInput
    create: XOR<FacultyCreateWithoutAcademicDepartmentInput, FacultyUncheckedCreateWithoutAcademicDepartmentInput>
  }

  export type FacultyCreateManyAcademicDepartmentInputEnvelope = {
    data: FacultyCreateManyAcademicDepartmentInput | FacultyCreateManyAcademicDepartmentInput[]
    skipDuplicates?: boolean
  }

  export type CourseCreateWithoutAcademicDepartmentInput = {
    id?: string
    title: string
    code: string
    durationInYears: number
    yearLevel?: $Enums.YearLevel
    shift?: $Enums.Shift
    createdAt?: Date | string
    updatedAt?: Date | string
    courseDisciplines?: CourseDisciplineCreateNestedManyWithoutCourseInput
    coursePricing?: CoursePricingCreateNestedOneWithoutCourseInput
    studentCourses?: StudentEnrolledCourseCreateNestedManyWithoutCourseInput
    preRequisite?: CourseToPreRequisiteCreateNestedManyWithoutCourseInput
    preRequisiteFor?: CourseToPreRequisiteCreateNestedManyWithoutPreRequisiteInput
    faculties?: CourseFacultyCreateNestedManyWithoutCourseInput
    offeredCourses?: OfferedCourseCreateNestedManyWithoutCourseInput
  }

  export type CourseUncheckedCreateWithoutAcademicDepartmentInput = {
    id?: string
    title: string
    code: string
    durationInYears: number
    yearLevel?: $Enums.YearLevel
    shift?: $Enums.Shift
    createdAt?: Date | string
    updatedAt?: Date | string
    courseDisciplines?: CourseDisciplineUncheckedCreateNestedManyWithoutCourseInput
    coursePricing?: CoursePricingUncheckedCreateNestedOneWithoutCourseInput
    studentCourses?: StudentEnrolledCourseUncheckedCreateNestedManyWithoutCourseInput
    preRequisite?: CourseToPreRequisiteUncheckedCreateNestedManyWithoutCourseInput
    preRequisiteFor?: CourseToPreRequisiteUncheckedCreateNestedManyWithoutPreRequisiteInput
    faculties?: CourseFacultyUncheckedCreateNestedManyWithoutCourseInput
    offeredCourses?: OfferedCourseUncheckedCreateNestedManyWithoutCourseInput
  }

  export type CourseCreateOrConnectWithoutAcademicDepartmentInput = {
    where: CourseWhereUniqueInput
    create: XOR<CourseCreateWithoutAcademicDepartmentInput, CourseUncheckedCreateWithoutAcademicDepartmentInput>
  }

  export type CourseCreateManyAcademicDepartmentInputEnvelope = {
    data: CourseCreateManyAcademicDepartmentInput | CourseCreateManyAcademicDepartmentInput[]
    skipDuplicates?: boolean
  }

  export type StudentCreateWithoutAcademicDepartmentInput = {
    id?: string
    studentId: string
    studentType?: $Enums.StudentType
    firstName: string
    middleName?: string | null
    lastName: string
    profileImage?: string | null
    email?: string | null
    contactNo?: string | null
    gender: string
    isWoker?: boolean
    shift?: $Enums.Shift
    yearLevel?: $Enums.YearLevel
    isActive?: boolean
    password: string
    gradeDeclarationFile: string
    biFile: string
    presentAddress: string
    permanentAddress?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    academicFaculty: AcademicFacultyCreateNestedOneWithoutStudentsInput
    admissionRegistration?: AdmitionExameRegistrationCreateNestedOneWithoutStudentInput
    academicSemester: AcademicSemesterCreateNestedOneWithoutStudentsInput
    studentSemesterRegistrations?: StudentSemesterRegistrationCreateNestedManyWithoutStudentInput
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseCreateNestedManyWithoutStudentInput
    studentEnrolledCourses?: StudentEnrolledCourseCreateNestedManyWithoutStudentInput
    studentEnrolledCourseMarks?: StudentEnrolledCourseMarkCreateNestedManyWithoutStudentInput
    studentSemesterPayments?: StudentSemesterPaymentCreateNestedManyWithoutStudentInput
    studentAcademicInfos?: StudentAcademicInfoCreateNestedManyWithoutStudentInput
    StudentCarriedCourse?: StudentCarriedCourseCreateNestedManyWithoutStudentInput
  }

  export type StudentUncheckedCreateWithoutAcademicDepartmentInput = {
    id?: string
    studentId: string
    studentType?: $Enums.StudentType
    firstName: string
    middleName?: string | null
    lastName: string
    profileImage?: string | null
    email?: string | null
    contactNo?: string | null
    gender: string
    isWoker?: boolean
    shift?: $Enums.Shift
    yearLevel?: $Enums.YearLevel
    isActive?: boolean
    password: string
    gradeDeclarationFile: string
    biFile: string
    presentAddress: string
    permanentAddress?: string | null
    academicSemesterId: string
    academicFacultyId: string
    admissionRegistrationId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    studentSemesterRegistrations?: StudentSemesterRegistrationUncheckedCreateNestedManyWithoutStudentInput
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseUncheckedCreateNestedManyWithoutStudentInput
    studentEnrolledCourses?: StudentEnrolledCourseUncheckedCreateNestedManyWithoutStudentInput
    studentEnrolledCourseMarks?: StudentEnrolledCourseMarkUncheckedCreateNestedManyWithoutStudentInput
    studentSemesterPayments?: StudentSemesterPaymentUncheckedCreateNestedManyWithoutStudentInput
    studentAcademicInfos?: StudentAcademicInfoUncheckedCreateNestedManyWithoutStudentInput
    StudentCarriedCourse?: StudentCarriedCourseUncheckedCreateNestedManyWithoutStudentInput
  }

  export type StudentCreateOrConnectWithoutAcademicDepartmentInput = {
    where: StudentWhereUniqueInput
    create: XOR<StudentCreateWithoutAcademicDepartmentInput, StudentUncheckedCreateWithoutAcademicDepartmentInput>
  }

  export type StudentCreateManyAcademicDepartmentInputEnvelope = {
    data: StudentCreateManyAcademicDepartmentInput | StudentCreateManyAcademicDepartmentInput[]
    skipDuplicates?: boolean
  }

  export type UsersCreateWithoutAcademicDepartmentInput = {
    id?: string
    name: string
    email: string
    password: string
    avatar?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    staffDepartments?: AcademicDepartmentCreateNestedManyWithoutStaffMembersInput
  }

  export type UsersUncheckedCreateWithoutAcademicDepartmentInput = {
    id?: string
    name: string
    email: string
    password: string
    avatar?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    staffDepartments?: AcademicDepartmentUncheckedCreateNestedManyWithoutStaffMembersInput
  }

  export type UsersCreateOrConnectWithoutAcademicDepartmentInput = {
    where: UsersWhereUniqueInput
    create: XOR<UsersCreateWithoutAcademicDepartmentInput, UsersUncheckedCreateWithoutAcademicDepartmentInput>
  }

  export type UsersCreateWithoutStaffDepartmentsInput = {
    id?: string
    name: string
    email: string
    password: string
    avatar?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    academicDepartment?: AcademicDepartmentCreateNestedOneWithoutDepartmentHeadInput
  }

  export type UsersUncheckedCreateWithoutStaffDepartmentsInput = {
    id?: string
    name: string
    email: string
    password: string
    avatar?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    academicDepartment?: AcademicDepartmentUncheckedCreateNestedOneWithoutDepartmentHeadInput
  }

  export type UsersCreateOrConnectWithoutStaffDepartmentsInput = {
    where: UsersWhereUniqueInput
    create: XOR<UsersCreateWithoutStaffDepartmentsInput, UsersUncheckedCreateWithoutStaffDepartmentsInput>
  }

  export type OfferedCourseCreateWithoutAcademicDepartmentInput = {
    id?: string
    suspendGrade?: number
    semesterRegistration: SemesterRegistrationCreateNestedOneWithoutOfferedCoursesInput
    course: CourseCreateNestedOneWithoutOfferedCoursesInput
    offeredCourseSections?: OfferedCourseSectionCreateNestedManyWithoutOfferedCourseInput
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseCreateNestedManyWithoutOfferedCourseInput
  }

  export type OfferedCourseUncheckedCreateWithoutAcademicDepartmentInput = {
    id?: string
    courseId: string
    semesterRegistrationId: string
    suspendGrade?: number
    offeredCourseSections?: OfferedCourseSectionUncheckedCreateNestedManyWithoutOfferedCourseInput
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseUncheckedCreateNestedManyWithoutOfferedCourseInput
  }

  export type OfferedCourseCreateOrConnectWithoutAcademicDepartmentInput = {
    where: OfferedCourseWhereUniqueInput
    create: XOR<OfferedCourseCreateWithoutAcademicDepartmentInput, OfferedCourseUncheckedCreateWithoutAcademicDepartmentInput>
  }

  export type OfferedCourseCreateManyAcademicDepartmentInputEnvelope = {
    data: OfferedCourseCreateManyAcademicDepartmentInput | OfferedCourseCreateManyAcademicDepartmentInput[]
    skipDuplicates?: boolean
  }

  export type AcademicFacultyUpsertWithoutAcademicDepartmentsInput = {
    update: XOR<AcademicFacultyUpdateWithoutAcademicDepartmentsInput, AcademicFacultyUncheckedUpdateWithoutAcademicDepartmentsInput>
    create: XOR<AcademicFacultyCreateWithoutAcademicDepartmentsInput, AcademicFacultyUncheckedCreateWithoutAcademicDepartmentsInput>
    where?: AcademicFacultyWhereInput
  }

  export type AcademicFacultyUpdateToOneWithWhereWithoutAcademicDepartmentsInput = {
    where?: AcademicFacultyWhereInput
    data: XOR<AcademicFacultyUpdateWithoutAcademicDepartmentsInput, AcademicFacultyUncheckedUpdateWithoutAcademicDepartmentsInput>
  }

  export type AcademicFacultyUpdateWithoutAcademicDepartmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    faculties?: FacultyUpdateManyWithoutAcademicFacultyNestedInput
    students?: StudentUpdateManyWithoutAcademicFacultyNestedInput
    admitionExame?: AdmitionExameRegistrationUpdateManyWithoutAcademicFalcultyNestedInput
    AdmitionExamePrice?: AdmitionExamePriceUpdateManyWithoutAcademicFacultyNestedInput
    AdmitionExamePeriod?: AdmitionExamePeriodUpdateManyWithoutAcademicFacultyNestedInput
  }

  export type AcademicFacultyUncheckedUpdateWithoutAcademicDepartmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    faculties?: FacultyUncheckedUpdateManyWithoutAcademicFacultyNestedInput
    students?: StudentUncheckedUpdateManyWithoutAcademicFacultyNestedInput
    admitionExame?: AdmitionExameRegistrationUncheckedUpdateManyWithoutAcademicFalcultyNestedInput
    AdmitionExamePrice?: AdmitionExamePriceUncheckedUpdateManyWithoutAcademicFacultyNestedInput
    AdmitionExamePeriod?: AdmitionExamePeriodUncheckedUpdateManyWithoutAcademicFacultyNestedInput
  }

  export type FacultyUpsertWithWhereUniqueWithoutAcademicDepartmentInput = {
    where: FacultyWhereUniqueInput
    update: XOR<FacultyUpdateWithoutAcademicDepartmentInput, FacultyUncheckedUpdateWithoutAcademicDepartmentInput>
    create: XOR<FacultyCreateWithoutAcademicDepartmentInput, FacultyUncheckedCreateWithoutAcademicDepartmentInput>
  }

  export type FacultyUpdateWithWhereUniqueWithoutAcademicDepartmentInput = {
    where: FacultyWhereUniqueInput
    data: XOR<FacultyUpdateWithoutAcademicDepartmentInput, FacultyUncheckedUpdateWithoutAcademicDepartmentInput>
  }

  export type FacultyUpdateManyWithWhereWithoutAcademicDepartmentInput = {
    where: FacultyScalarWhereInput
    data: XOR<FacultyUpdateManyMutationInput, FacultyUncheckedUpdateManyWithoutAcademicDepartmentInput>
  }

  export type CourseUpsertWithWhereUniqueWithoutAcademicDepartmentInput = {
    where: CourseWhereUniqueInput
    update: XOR<CourseUpdateWithoutAcademicDepartmentInput, CourseUncheckedUpdateWithoutAcademicDepartmentInput>
    create: XOR<CourseCreateWithoutAcademicDepartmentInput, CourseUncheckedCreateWithoutAcademicDepartmentInput>
  }

  export type CourseUpdateWithWhereUniqueWithoutAcademicDepartmentInput = {
    where: CourseWhereUniqueInput
    data: XOR<CourseUpdateWithoutAcademicDepartmentInput, CourseUncheckedUpdateWithoutAcademicDepartmentInput>
  }

  export type CourseUpdateManyWithWhereWithoutAcademicDepartmentInput = {
    where: CourseScalarWhereInput
    data: XOR<CourseUpdateManyMutationInput, CourseUncheckedUpdateManyWithoutAcademicDepartmentInput>
  }

  export type CourseScalarWhereInput = {
    AND?: CourseScalarWhereInput | CourseScalarWhereInput[]
    OR?: CourseScalarWhereInput[]
    NOT?: CourseScalarWhereInput | CourseScalarWhereInput[]
    id?: StringFilter<"Course"> | string
    title?: StringFilter<"Course"> | string
    code?: StringFilter<"Course"> | string
    durationInYears?: IntFilter<"Course"> | number
    yearLevel?: EnumYearLevelFilter<"Course"> | $Enums.YearLevel
    shift?: EnumShiftFilter<"Course"> | $Enums.Shift
    academicDepartmentId?: StringFilter<"Course"> | string
    createdAt?: DateTimeFilter<"Course"> | Date | string
    updatedAt?: DateTimeFilter<"Course"> | Date | string
  }

  export type StudentUpsertWithWhereUniqueWithoutAcademicDepartmentInput = {
    where: StudentWhereUniqueInput
    update: XOR<StudentUpdateWithoutAcademicDepartmentInput, StudentUncheckedUpdateWithoutAcademicDepartmentInput>
    create: XOR<StudentCreateWithoutAcademicDepartmentInput, StudentUncheckedCreateWithoutAcademicDepartmentInput>
  }

  export type StudentUpdateWithWhereUniqueWithoutAcademicDepartmentInput = {
    where: StudentWhereUniqueInput
    data: XOR<StudentUpdateWithoutAcademicDepartmentInput, StudentUncheckedUpdateWithoutAcademicDepartmentInput>
  }

  export type StudentUpdateManyWithWhereWithoutAcademicDepartmentInput = {
    where: StudentScalarWhereInput
    data: XOR<StudentUpdateManyMutationInput, StudentUncheckedUpdateManyWithoutAcademicDepartmentInput>
  }

  export type UsersUpsertWithoutAcademicDepartmentInput = {
    update: XOR<UsersUpdateWithoutAcademicDepartmentInput, UsersUncheckedUpdateWithoutAcademicDepartmentInput>
    create: XOR<UsersCreateWithoutAcademicDepartmentInput, UsersUncheckedCreateWithoutAcademicDepartmentInput>
    where?: UsersWhereInput
  }

  export type UsersUpdateToOneWithWhereWithoutAcademicDepartmentInput = {
    where?: UsersWhereInput
    data: XOR<UsersUpdateWithoutAcademicDepartmentInput, UsersUncheckedUpdateWithoutAcademicDepartmentInput>
  }

  export type UsersUpdateWithoutAcademicDepartmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    staffDepartments?: AcademicDepartmentUpdateManyWithoutStaffMembersNestedInput
  }

  export type UsersUncheckedUpdateWithoutAcademicDepartmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    staffDepartments?: AcademicDepartmentUncheckedUpdateManyWithoutStaffMembersNestedInput
  }

  export type UsersUpsertWithWhereUniqueWithoutStaffDepartmentsInput = {
    where: UsersWhereUniqueInput
    update: XOR<UsersUpdateWithoutStaffDepartmentsInput, UsersUncheckedUpdateWithoutStaffDepartmentsInput>
    create: XOR<UsersCreateWithoutStaffDepartmentsInput, UsersUncheckedCreateWithoutStaffDepartmentsInput>
  }

  export type UsersUpdateWithWhereUniqueWithoutStaffDepartmentsInput = {
    where: UsersWhereUniqueInput
    data: XOR<UsersUpdateWithoutStaffDepartmentsInput, UsersUncheckedUpdateWithoutStaffDepartmentsInput>
  }

  export type UsersUpdateManyWithWhereWithoutStaffDepartmentsInput = {
    where: UsersScalarWhereInput
    data: XOR<UsersUpdateManyMutationInput, UsersUncheckedUpdateManyWithoutStaffDepartmentsInput>
  }

  export type UsersScalarWhereInput = {
    AND?: UsersScalarWhereInput | UsersScalarWhereInput[]
    OR?: UsersScalarWhereInput[]
    NOT?: UsersScalarWhereInput | UsersScalarWhereInput[]
    id?: StringFilter<"Users"> | string
    name?: StringFilter<"Users"> | string
    email?: StringFilter<"Users"> | string
    password?: StringFilter<"Users"> | string
    avatar?: StringNullableFilter<"Users"> | string | null
    role?: EnumUserRoleFilter<"Users"> | $Enums.UserRole
    createdAt?: DateTimeFilter<"Users"> | Date | string
    updatedAt?: DateTimeFilter<"Users"> | Date | string
  }

  export type OfferedCourseUpsertWithWhereUniqueWithoutAcademicDepartmentInput = {
    where: OfferedCourseWhereUniqueInput
    update: XOR<OfferedCourseUpdateWithoutAcademicDepartmentInput, OfferedCourseUncheckedUpdateWithoutAcademicDepartmentInput>
    create: XOR<OfferedCourseCreateWithoutAcademicDepartmentInput, OfferedCourseUncheckedCreateWithoutAcademicDepartmentInput>
  }

  export type OfferedCourseUpdateWithWhereUniqueWithoutAcademicDepartmentInput = {
    where: OfferedCourseWhereUniqueInput
    data: XOR<OfferedCourseUpdateWithoutAcademicDepartmentInput, OfferedCourseUncheckedUpdateWithoutAcademicDepartmentInput>
  }

  export type OfferedCourseUpdateManyWithWhereWithoutAcademicDepartmentInput = {
    where: OfferedCourseScalarWhereInput
    data: XOR<OfferedCourseUpdateManyMutationInput, OfferedCourseUncheckedUpdateManyWithoutAcademicDepartmentInput>
  }

  export type OfferedCourseScalarWhereInput = {
    AND?: OfferedCourseScalarWhereInput | OfferedCourseScalarWhereInput[]
    OR?: OfferedCourseScalarWhereInput[]
    NOT?: OfferedCourseScalarWhereInput | OfferedCourseScalarWhereInput[]
    id?: StringFilter<"OfferedCourse"> | string
    academicDepartmentId?: StringFilter<"OfferedCourse"> | string
    courseId?: StringFilter<"OfferedCourse"> | string
    semesterRegistrationId?: StringFilter<"OfferedCourse"> | string
    suspendGrade?: IntFilter<"OfferedCourse"> | number
  }

  export type AcademicFacultyCreateWithoutStudentsInput = {
    id?: string
    title: string
    createdAt?: Date | string
    updatedAt?: Date | string
    academicDepartments?: AcademicDepartmentCreateNestedManyWithoutAcademicFacultyInput
    faculties?: FacultyCreateNestedManyWithoutAcademicFacultyInput
    admitionExame?: AdmitionExameRegistrationCreateNestedManyWithoutAcademicFalcultyInput
    AdmitionExamePrice?: AdmitionExamePriceCreateNestedManyWithoutAcademicFacultyInput
    AdmitionExamePeriod?: AdmitionExamePeriodCreateNestedManyWithoutAcademicFacultyInput
  }

  export type AcademicFacultyUncheckedCreateWithoutStudentsInput = {
    id?: string
    title: string
    createdAt?: Date | string
    updatedAt?: Date | string
    academicDepartments?: AcademicDepartmentUncheckedCreateNestedManyWithoutAcademicFacultyInput
    faculties?: FacultyUncheckedCreateNestedManyWithoutAcademicFacultyInput
    admitionExame?: AdmitionExameRegistrationUncheckedCreateNestedManyWithoutAcademicFalcultyInput
    AdmitionExamePrice?: AdmitionExamePriceUncheckedCreateNestedManyWithoutAcademicFacultyInput
    AdmitionExamePeriod?: AdmitionExamePeriodUncheckedCreateNestedManyWithoutAcademicFacultyInput
  }

  export type AcademicFacultyCreateOrConnectWithoutStudentsInput = {
    where: AcademicFacultyWhereUniqueInput
    create: XOR<AcademicFacultyCreateWithoutStudentsInput, AcademicFacultyUncheckedCreateWithoutStudentsInput>
  }

  export type AdmitionExameRegistrationCreateWithoutStudentInput = {
    id?: string
    applicantName: string
    paymentRecipt: string
    status?: $Enums.Status
    document: string
    paymentAmoute?: number | null
    aprovePayment?: boolean | null
    exameResults?: number | null
    passed?: boolean | null
    exameDate: Date | string
    rejectionReason?: string | null
    phoneNumber: string
    email: string
    createdAt?: Date | string
    updateAt?: Date | string
    fase: ExameFaseCreateNestedOneWithoutRegistrationsInput
    academicFalculty: AcademicFacultyCreateNestedOneWithoutAdmitionExameInput
  }

  export type AdmitionExameRegistrationUncheckedCreateWithoutStudentInput = {
    id?: string
    applicantName: string
    paymentRecipt: string
    status?: $Enums.Status
    document: string
    paymentAmoute?: number | null
    aprovePayment?: boolean | null
    exameResults?: number | null
    passed?: boolean | null
    faseId: string
    exameDate: Date | string
    rejectionReason?: string | null
    phoneNumber: string
    email: string
    createdAt?: Date | string
    updateAt?: Date | string
    academicFalcultyId: string
  }

  export type AdmitionExameRegistrationCreateOrConnectWithoutStudentInput = {
    where: AdmitionExameRegistrationWhereUniqueInput
    create: XOR<AdmitionExameRegistrationCreateWithoutStudentInput, AdmitionExameRegistrationUncheckedCreateWithoutStudentInput>
  }

  export type AcademicDepartmentCreateWithoutStudentsInput = {
    id?: string
    title: string
    createdAt?: Date | string
    updatedAt?: Date | string
    academicFaculty: AcademicFacultyCreateNestedOneWithoutAcademicDepartmentsInput
    faculties?: FacultyCreateNestedManyWithoutAcademicDepartmentInput
    courses?: CourseCreateNestedManyWithoutAcademicDepartmentInput
    departmentHead?: UsersCreateNestedOneWithoutAcademicDepartmentInput
    staffMembers?: UsersCreateNestedManyWithoutStaffDepartmentsInput
    offeredCourses?: OfferedCourseCreateNestedManyWithoutAcademicDepartmentInput
  }

  export type AcademicDepartmentUncheckedCreateWithoutStudentsInput = {
    id?: string
    title: string
    academicFacultyId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    departmentHeadId?: string | null
    faculties?: FacultyUncheckedCreateNestedManyWithoutAcademicDepartmentInput
    courses?: CourseUncheckedCreateNestedManyWithoutAcademicDepartmentInput
    staffMembers?: UsersUncheckedCreateNestedManyWithoutStaffDepartmentsInput
    offeredCourses?: OfferedCourseUncheckedCreateNestedManyWithoutAcademicDepartmentInput
  }

  export type AcademicDepartmentCreateOrConnectWithoutStudentsInput = {
    where: AcademicDepartmentWhereUniqueInput
    create: XOR<AcademicDepartmentCreateWithoutStudentsInput, AcademicDepartmentUncheckedCreateWithoutStudentsInput>
  }

  export type AcademicSemesterCreateWithoutStudentsInput = {
    id?: string
    title: string
    year: string
    code: string
    startMonth: string
    endMonth: string
    isCurrent?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    courseDisciplines?: CourseDisciplineCreateNestedManyWithoutSemesterInput
    semesterRegistrations?: SemesterRegistrationCreateNestedManyWithoutAcademicSemesterInput
    studentEnrolledCourses?: StudentEnrolledCourseCreateNestedManyWithoutAcademicSemesterInput
    studentEnrolledCourseMarks?: StudentEnrolledCourseMarkCreateNestedManyWithoutAcademicSemesterInput
    studentSemesterPayments?: StudentSemesterPaymentCreateNestedManyWithoutAcademicSemesterInput
    StudentCarriedCourse?: StudentCarriedCourseCreateNestedManyWithoutSemesterInput
  }

  export type AcademicSemesterUncheckedCreateWithoutStudentsInput = {
    id?: string
    title: string
    year: string
    code: string
    startMonth: string
    endMonth: string
    isCurrent?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    courseDisciplines?: CourseDisciplineUncheckedCreateNestedManyWithoutSemesterInput
    semesterRegistrations?: SemesterRegistrationUncheckedCreateNestedManyWithoutAcademicSemesterInput
    studentEnrolledCourses?: StudentEnrolledCourseUncheckedCreateNestedManyWithoutAcademicSemesterInput
    studentEnrolledCourseMarks?: StudentEnrolledCourseMarkUncheckedCreateNestedManyWithoutAcademicSemesterInput
    studentSemesterPayments?: StudentSemesterPaymentUncheckedCreateNestedManyWithoutAcademicSemesterInput
    StudentCarriedCourse?: StudentCarriedCourseUncheckedCreateNestedManyWithoutSemesterInput
  }

  export type AcademicSemesterCreateOrConnectWithoutStudentsInput = {
    where: AcademicSemesterWhereUniqueInput
    create: XOR<AcademicSemesterCreateWithoutStudentsInput, AcademicSemesterUncheckedCreateWithoutStudentsInput>
  }

  export type StudentSemesterRegistrationCreateWithoutStudentInput = {
    id?: string
    isConfirmed?: boolean | null
    totalCreditsTaken?: number | null
    paymentRecipt?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    semesterRegistration: SemesterRegistrationCreateNestedOneWithoutStudentSemesterRegistrationsInput
  }

  export type StudentSemesterRegistrationUncheckedCreateWithoutStudentInput = {
    id?: string
    isConfirmed?: boolean | null
    totalCreditsTaken?: number | null
    paymentRecipt?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    semesterRegistrationId: string
  }

  export type StudentSemesterRegistrationCreateOrConnectWithoutStudentInput = {
    where: StudentSemesterRegistrationWhereUniqueInput
    create: XOR<StudentSemesterRegistrationCreateWithoutStudentInput, StudentSemesterRegistrationUncheckedCreateWithoutStudentInput>
  }

  export type StudentSemesterRegistrationCreateManyStudentInputEnvelope = {
    data: StudentSemesterRegistrationCreateManyStudentInput | StudentSemesterRegistrationCreateManyStudentInput[]
    skipDuplicates?: boolean
  }

  export type StudentSemesterRegistrationCourseCreateWithoutStudentInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    semesterRegistration: SemesterRegistrationCreateNestedOneWithoutStudentSemesterRegistrationCoursesInput
    offeredCourse: OfferedCourseCreateNestedOneWithoutStudentSemesterRegistrationCoursesInput
    offeredCourseSection: OfferedCourseSectionCreateNestedOneWithoutStudentSemesterRegistrationCoursesInput
  }

  export type StudentSemesterRegistrationCourseUncheckedCreateWithoutStudentInput = {
    semesterRegistrationId: string
    offeredCourseId: string
    offeredCourseSectionId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StudentSemesterRegistrationCourseCreateOrConnectWithoutStudentInput = {
    where: StudentSemesterRegistrationCourseWhereUniqueInput
    create: XOR<StudentSemesterRegistrationCourseCreateWithoutStudentInput, StudentSemesterRegistrationCourseUncheckedCreateWithoutStudentInput>
  }

  export type StudentSemesterRegistrationCourseCreateManyStudentInputEnvelope = {
    data: StudentSemesterRegistrationCourseCreateManyStudentInput | StudentSemesterRegistrationCourseCreateManyStudentInput[]
    skipDuplicates?: boolean
  }

  export type StudentEnrolledCourseCreateWithoutStudentInput = {
    id?: string
    grade?: string | null
    point?: number | null
    totalMarks?: number | null
    status?: $Enums.StudentEnrolledCourseStatus | null
    createdAt?: Date | string
    updatedAt?: Date | string
    course: CourseCreateNestedOneWithoutStudentCoursesInput
    studentEnrolledCourseMarks?: StudentEnrolledCourseMarkCreateNestedManyWithoutStudentEnrolledCourseInput
    academicSemester: AcademicSemesterCreateNestedOneWithoutStudentEnrolledCoursesInput
  }

  export type StudentEnrolledCourseUncheckedCreateWithoutStudentInput = {
    id?: string
    grade?: string | null
    point?: number | null
    totalMarks?: number | null
    status?: $Enums.StudentEnrolledCourseStatus | null
    createdAt?: Date | string
    updatedAt?: Date | string
    academicSemesterId: string
    courseId: string
    studentEnrolledCourseMarks?: StudentEnrolledCourseMarkUncheckedCreateNestedManyWithoutStudentEnrolledCourseInput
  }

  export type StudentEnrolledCourseCreateOrConnectWithoutStudentInput = {
    where: StudentEnrolledCourseWhereUniqueInput
    create: XOR<StudentEnrolledCourseCreateWithoutStudentInput, StudentEnrolledCourseUncheckedCreateWithoutStudentInput>
  }

  export type StudentEnrolledCourseCreateManyStudentInputEnvelope = {
    data: StudentEnrolledCourseCreateManyStudentInput | StudentEnrolledCourseCreateManyStudentInput[]
    skipDuplicates?: boolean
  }

  export type StudentEnrolledCourseMarkCreateWithoutStudentInput = {
    id?: string
    examType?: $Enums.ExamType | null
    createdAt?: Date | string
    updatedAt?: Date | string
    continuousAssessments: JsonNullValueInput | InputJsonValue
    frequencyExam?: number | null
    finalExam?: number | null
    resourceExam?: number | null
    specialExam?: number | null
    recoveryExam?: number | null
    totalMarks?: number
    grade?: number
    studentEnrolledCourse: StudentEnrolledCourseCreateNestedOneWithoutStudentEnrolledCourseMarksInput
    academicSemester: AcademicSemesterCreateNestedOneWithoutStudentEnrolledCourseMarksInput
  }

  export type StudentEnrolledCourseMarkUncheckedCreateWithoutStudentInput = {
    id?: string
    examType?: $Enums.ExamType | null
    createdAt?: Date | string
    updatedAt?: Date | string
    studentEnrolledCourseId: string
    academicSemesterId: string
    continuousAssessments: JsonNullValueInput | InputJsonValue
    frequencyExam?: number | null
    finalExam?: number | null
    resourceExam?: number | null
    specialExam?: number | null
    recoveryExam?: number | null
    totalMarks?: number
    grade?: number
  }

  export type StudentEnrolledCourseMarkCreateOrConnectWithoutStudentInput = {
    where: StudentEnrolledCourseMarkWhereUniqueInput
    create: XOR<StudentEnrolledCourseMarkCreateWithoutStudentInput, StudentEnrolledCourseMarkUncheckedCreateWithoutStudentInput>
  }

  export type StudentEnrolledCourseMarkCreateManyStudentInputEnvelope = {
    data: StudentEnrolledCourseMarkCreateManyStudentInput | StudentEnrolledCourseMarkCreateManyStudentInput[]
    skipDuplicates?: boolean
  }

  export type StudentSemesterPaymentCreateWithoutStudentInput = {
    id?: string
    totalPayment: number
    baseAmount: number
    lateFee?: number
    paymentMonth: number
    paymentYear: number
    createdAt?: Date | string
    updatedAt?: Date | string
    payment: PaymentCreateNestedOneWithoutStudentSemesterPaymentInput
    academicSemester: AcademicSemesterCreateNestedOneWithoutStudentSemesterPaymentsInput
  }

  export type StudentSemesterPaymentUncheckedCreateWithoutStudentInput = {
    id?: string
    paymentId: string
    totalPayment: number
    baseAmount: number
    lateFee?: number
    paymentMonth: number
    paymentYear: number
    createdAt?: Date | string
    updatedAt?: Date | string
    academicSemesterId: string
  }

  export type StudentSemesterPaymentCreateOrConnectWithoutStudentInput = {
    where: StudentSemesterPaymentWhereUniqueInput
    create: XOR<StudentSemesterPaymentCreateWithoutStudentInput, StudentSemesterPaymentUncheckedCreateWithoutStudentInput>
  }

  export type StudentSemesterPaymentCreateManyStudentInputEnvelope = {
    data: StudentSemesterPaymentCreateManyStudentInput | StudentSemesterPaymentCreateManyStudentInput[]
    skipDuplicates?: boolean
  }

  export type StudentAcademicInfoCreateWithoutStudentInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    totalCompletedCredits?: number | null
    cgpa?: number | null
  }

  export type StudentAcademicInfoUncheckedCreateWithoutStudentInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    totalCompletedCredits?: number | null
    cgpa?: number | null
  }

  export type StudentAcademicInfoCreateOrConnectWithoutStudentInput = {
    where: StudentAcademicInfoWhereUniqueInput
    create: XOR<StudentAcademicInfoCreateWithoutStudentInput, StudentAcademicInfoUncheckedCreateWithoutStudentInput>
  }

  export type StudentAcademicInfoCreateManyStudentInputEnvelope = {
    data: StudentAcademicInfoCreateManyStudentInput | StudentAcademicInfoCreateManyStudentInput[]
    skipDuplicates?: boolean
  }

  export type StudentCarriedCourseCreateWithoutStudentInput = {
    id?: string
    shift: $Enums.Shift
    price: number
    status?: $Enums.CarriedCourseStatus
    createdAt?: Date | string
    discipline: DisciplineCreateNestedOneWithoutStudentCarriedCourseInput
    semester: AcademicSemesterCreateNestedOneWithoutStudentCarriedCourseInput
  }

  export type StudentCarriedCourseUncheckedCreateWithoutStudentInput = {
    id?: string
    disciplineId: string
    semesterId: string
    shift: $Enums.Shift
    price: number
    status?: $Enums.CarriedCourseStatus
    createdAt?: Date | string
  }

  export type StudentCarriedCourseCreateOrConnectWithoutStudentInput = {
    where: StudentCarriedCourseWhereUniqueInput
    create: XOR<StudentCarriedCourseCreateWithoutStudentInput, StudentCarriedCourseUncheckedCreateWithoutStudentInput>
  }

  export type StudentCarriedCourseCreateManyStudentInputEnvelope = {
    data: StudentCarriedCourseCreateManyStudentInput | StudentCarriedCourseCreateManyStudentInput[]
    skipDuplicates?: boolean
  }

  export type AcademicFacultyUpsertWithoutStudentsInput = {
    update: XOR<AcademicFacultyUpdateWithoutStudentsInput, AcademicFacultyUncheckedUpdateWithoutStudentsInput>
    create: XOR<AcademicFacultyCreateWithoutStudentsInput, AcademicFacultyUncheckedCreateWithoutStudentsInput>
    where?: AcademicFacultyWhereInput
  }

  export type AcademicFacultyUpdateToOneWithWhereWithoutStudentsInput = {
    where?: AcademicFacultyWhereInput
    data: XOR<AcademicFacultyUpdateWithoutStudentsInput, AcademicFacultyUncheckedUpdateWithoutStudentsInput>
  }

  export type AcademicFacultyUpdateWithoutStudentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    academicDepartments?: AcademicDepartmentUpdateManyWithoutAcademicFacultyNestedInput
    faculties?: FacultyUpdateManyWithoutAcademicFacultyNestedInput
    admitionExame?: AdmitionExameRegistrationUpdateManyWithoutAcademicFalcultyNestedInput
    AdmitionExamePrice?: AdmitionExamePriceUpdateManyWithoutAcademicFacultyNestedInput
    AdmitionExamePeriod?: AdmitionExamePeriodUpdateManyWithoutAcademicFacultyNestedInput
  }

  export type AcademicFacultyUncheckedUpdateWithoutStudentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    academicDepartments?: AcademicDepartmentUncheckedUpdateManyWithoutAcademicFacultyNestedInput
    faculties?: FacultyUncheckedUpdateManyWithoutAcademicFacultyNestedInput
    admitionExame?: AdmitionExameRegistrationUncheckedUpdateManyWithoutAcademicFalcultyNestedInput
    AdmitionExamePrice?: AdmitionExamePriceUncheckedUpdateManyWithoutAcademicFacultyNestedInput
    AdmitionExamePeriod?: AdmitionExamePeriodUncheckedUpdateManyWithoutAcademicFacultyNestedInput
  }

  export type AdmitionExameRegistrationUpsertWithoutStudentInput = {
    update: XOR<AdmitionExameRegistrationUpdateWithoutStudentInput, AdmitionExameRegistrationUncheckedUpdateWithoutStudentInput>
    create: XOR<AdmitionExameRegistrationCreateWithoutStudentInput, AdmitionExameRegistrationUncheckedCreateWithoutStudentInput>
    where?: AdmitionExameRegistrationWhereInput
  }

  export type AdmitionExameRegistrationUpdateToOneWithWhereWithoutStudentInput = {
    where?: AdmitionExameRegistrationWhereInput
    data: XOR<AdmitionExameRegistrationUpdateWithoutStudentInput, AdmitionExameRegistrationUncheckedUpdateWithoutStudentInput>
  }

  export type AdmitionExameRegistrationUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    applicantName?: StringFieldUpdateOperationsInput | string
    paymentRecipt?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    document?: StringFieldUpdateOperationsInput | string
    paymentAmoute?: NullableIntFieldUpdateOperationsInput | number | null
    aprovePayment?: NullableBoolFieldUpdateOperationsInput | boolean | null
    exameResults?: NullableIntFieldUpdateOperationsInput | number | null
    passed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    exameDate?: DateTimeFieldUpdateOperationsInput | Date | string
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fase?: ExameFaseUpdateOneRequiredWithoutRegistrationsNestedInput
    academicFalculty?: AcademicFacultyUpdateOneRequiredWithoutAdmitionExameNestedInput
  }

  export type AdmitionExameRegistrationUncheckedUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    applicantName?: StringFieldUpdateOperationsInput | string
    paymentRecipt?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    document?: StringFieldUpdateOperationsInput | string
    paymentAmoute?: NullableIntFieldUpdateOperationsInput | number | null
    aprovePayment?: NullableBoolFieldUpdateOperationsInput | boolean | null
    exameResults?: NullableIntFieldUpdateOperationsInput | number | null
    passed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    faseId?: StringFieldUpdateOperationsInput | string
    exameDate?: DateTimeFieldUpdateOperationsInput | Date | string
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    academicFalcultyId?: StringFieldUpdateOperationsInput | string
  }

  export type AcademicDepartmentUpsertWithoutStudentsInput = {
    update: XOR<AcademicDepartmentUpdateWithoutStudentsInput, AcademicDepartmentUncheckedUpdateWithoutStudentsInput>
    create: XOR<AcademicDepartmentCreateWithoutStudentsInput, AcademicDepartmentUncheckedCreateWithoutStudentsInput>
    where?: AcademicDepartmentWhereInput
  }

  export type AcademicDepartmentUpdateToOneWithWhereWithoutStudentsInput = {
    where?: AcademicDepartmentWhereInput
    data: XOR<AcademicDepartmentUpdateWithoutStudentsInput, AcademicDepartmentUncheckedUpdateWithoutStudentsInput>
  }

  export type AcademicDepartmentUpdateWithoutStudentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    academicFaculty?: AcademicFacultyUpdateOneRequiredWithoutAcademicDepartmentsNestedInput
    faculties?: FacultyUpdateManyWithoutAcademicDepartmentNestedInput
    courses?: CourseUpdateManyWithoutAcademicDepartmentNestedInput
    departmentHead?: UsersUpdateOneWithoutAcademicDepartmentNestedInput
    staffMembers?: UsersUpdateManyWithoutStaffDepartmentsNestedInput
    offeredCourses?: OfferedCourseUpdateManyWithoutAcademicDepartmentNestedInput
  }

  export type AcademicDepartmentUncheckedUpdateWithoutStudentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    academicFacultyId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    departmentHeadId?: NullableStringFieldUpdateOperationsInput | string | null
    faculties?: FacultyUncheckedUpdateManyWithoutAcademicDepartmentNestedInput
    courses?: CourseUncheckedUpdateManyWithoutAcademicDepartmentNestedInput
    staffMembers?: UsersUncheckedUpdateManyWithoutStaffDepartmentsNestedInput
    offeredCourses?: OfferedCourseUncheckedUpdateManyWithoutAcademicDepartmentNestedInput
  }

  export type AcademicSemesterUpsertWithoutStudentsInput = {
    update: XOR<AcademicSemesterUpdateWithoutStudentsInput, AcademicSemesterUncheckedUpdateWithoutStudentsInput>
    create: XOR<AcademicSemesterCreateWithoutStudentsInput, AcademicSemesterUncheckedCreateWithoutStudentsInput>
    where?: AcademicSemesterWhereInput
  }

  export type AcademicSemesterUpdateToOneWithWhereWithoutStudentsInput = {
    where?: AcademicSemesterWhereInput
    data: XOR<AcademicSemesterUpdateWithoutStudentsInput, AcademicSemesterUncheckedUpdateWithoutStudentsInput>
  }

  export type AcademicSemesterUpdateWithoutStudentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    year?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    startMonth?: StringFieldUpdateOperationsInput | string
    endMonth?: StringFieldUpdateOperationsInput | string
    isCurrent?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    courseDisciplines?: CourseDisciplineUpdateManyWithoutSemesterNestedInput
    semesterRegistrations?: SemesterRegistrationUpdateManyWithoutAcademicSemesterNestedInput
    studentEnrolledCourses?: StudentEnrolledCourseUpdateManyWithoutAcademicSemesterNestedInput
    studentEnrolledCourseMarks?: StudentEnrolledCourseMarkUpdateManyWithoutAcademicSemesterNestedInput
    studentSemesterPayments?: StudentSemesterPaymentUpdateManyWithoutAcademicSemesterNestedInput
    StudentCarriedCourse?: StudentCarriedCourseUpdateManyWithoutSemesterNestedInput
  }

  export type AcademicSemesterUncheckedUpdateWithoutStudentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    year?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    startMonth?: StringFieldUpdateOperationsInput | string
    endMonth?: StringFieldUpdateOperationsInput | string
    isCurrent?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    courseDisciplines?: CourseDisciplineUncheckedUpdateManyWithoutSemesterNestedInput
    semesterRegistrations?: SemesterRegistrationUncheckedUpdateManyWithoutAcademicSemesterNestedInput
    studentEnrolledCourses?: StudentEnrolledCourseUncheckedUpdateManyWithoutAcademicSemesterNestedInput
    studentEnrolledCourseMarks?: StudentEnrolledCourseMarkUncheckedUpdateManyWithoutAcademicSemesterNestedInput
    studentSemesterPayments?: StudentSemesterPaymentUncheckedUpdateManyWithoutAcademicSemesterNestedInput
    StudentCarriedCourse?: StudentCarriedCourseUncheckedUpdateManyWithoutSemesterNestedInput
  }

  export type StudentSemesterRegistrationUpsertWithWhereUniqueWithoutStudentInput = {
    where: StudentSemesterRegistrationWhereUniqueInput
    update: XOR<StudentSemesterRegistrationUpdateWithoutStudentInput, StudentSemesterRegistrationUncheckedUpdateWithoutStudentInput>
    create: XOR<StudentSemesterRegistrationCreateWithoutStudentInput, StudentSemesterRegistrationUncheckedCreateWithoutStudentInput>
  }

  export type StudentSemesterRegistrationUpdateWithWhereUniqueWithoutStudentInput = {
    where: StudentSemesterRegistrationWhereUniqueInput
    data: XOR<StudentSemesterRegistrationUpdateWithoutStudentInput, StudentSemesterRegistrationUncheckedUpdateWithoutStudentInput>
  }

  export type StudentSemesterRegistrationUpdateManyWithWhereWithoutStudentInput = {
    where: StudentSemesterRegistrationScalarWhereInput
    data: XOR<StudentSemesterRegistrationUpdateManyMutationInput, StudentSemesterRegistrationUncheckedUpdateManyWithoutStudentInput>
  }

  export type StudentSemesterRegistrationScalarWhereInput = {
    AND?: StudentSemesterRegistrationScalarWhereInput | StudentSemesterRegistrationScalarWhereInput[]
    OR?: StudentSemesterRegistrationScalarWhereInput[]
    NOT?: StudentSemesterRegistrationScalarWhereInput | StudentSemesterRegistrationScalarWhereInput[]
    id?: StringFilter<"StudentSemesterRegistration"> | string
    isConfirmed?: BoolNullableFilter<"StudentSemesterRegistration"> | boolean | null
    totalCreditsTaken?: IntNullableFilter<"StudentSemesterRegistration"> | number | null
    paymentRecipt?: StringNullableFilter<"StudentSemesterRegistration"> | string | null
    createdAt?: DateTimeFilter<"StudentSemesterRegistration"> | Date | string
    updatedAt?: DateTimeFilter<"StudentSemesterRegistration"> | Date | string
    studentId?: StringFilter<"StudentSemesterRegistration"> | string
    semesterRegistrationId?: StringFilter<"StudentSemesterRegistration"> | string
  }

  export type StudentSemesterRegistrationCourseUpsertWithWhereUniqueWithoutStudentInput = {
    where: StudentSemesterRegistrationCourseWhereUniqueInput
    update: XOR<StudentSemesterRegistrationCourseUpdateWithoutStudentInput, StudentSemesterRegistrationCourseUncheckedUpdateWithoutStudentInput>
    create: XOR<StudentSemesterRegistrationCourseCreateWithoutStudentInput, StudentSemesterRegistrationCourseUncheckedCreateWithoutStudentInput>
  }

  export type StudentSemesterRegistrationCourseUpdateWithWhereUniqueWithoutStudentInput = {
    where: StudentSemesterRegistrationCourseWhereUniqueInput
    data: XOR<StudentSemesterRegistrationCourseUpdateWithoutStudentInput, StudentSemesterRegistrationCourseUncheckedUpdateWithoutStudentInput>
  }

  export type StudentSemesterRegistrationCourseUpdateManyWithWhereWithoutStudentInput = {
    where: StudentSemesterRegistrationCourseScalarWhereInput
    data: XOR<StudentSemesterRegistrationCourseUpdateManyMutationInput, StudentSemesterRegistrationCourseUncheckedUpdateManyWithoutStudentInput>
  }

  export type StudentSemesterRegistrationCourseScalarWhereInput = {
    AND?: StudentSemesterRegistrationCourseScalarWhereInput | StudentSemesterRegistrationCourseScalarWhereInput[]
    OR?: StudentSemesterRegistrationCourseScalarWhereInput[]
    NOT?: StudentSemesterRegistrationCourseScalarWhereInput | StudentSemesterRegistrationCourseScalarWhereInput[]
    semesterRegistrationId?: StringFilter<"StudentSemesterRegistrationCourse"> | string
    studentId?: StringFilter<"StudentSemesterRegistrationCourse"> | string
    offeredCourseId?: StringFilter<"StudentSemesterRegistrationCourse"> | string
    offeredCourseSectionId?: StringFilter<"StudentSemesterRegistrationCourse"> | string
    createdAt?: DateTimeFilter<"StudentSemesterRegistrationCourse"> | Date | string
    updatedAt?: DateTimeFilter<"StudentSemesterRegistrationCourse"> | Date | string
  }

  export type StudentEnrolledCourseUpsertWithWhereUniqueWithoutStudentInput = {
    where: StudentEnrolledCourseWhereUniqueInput
    update: XOR<StudentEnrolledCourseUpdateWithoutStudentInput, StudentEnrolledCourseUncheckedUpdateWithoutStudentInput>
    create: XOR<StudentEnrolledCourseCreateWithoutStudentInput, StudentEnrolledCourseUncheckedCreateWithoutStudentInput>
  }

  export type StudentEnrolledCourseUpdateWithWhereUniqueWithoutStudentInput = {
    where: StudentEnrolledCourseWhereUniqueInput
    data: XOR<StudentEnrolledCourseUpdateWithoutStudentInput, StudentEnrolledCourseUncheckedUpdateWithoutStudentInput>
  }

  export type StudentEnrolledCourseUpdateManyWithWhereWithoutStudentInput = {
    where: StudentEnrolledCourseScalarWhereInput
    data: XOR<StudentEnrolledCourseUpdateManyMutationInput, StudentEnrolledCourseUncheckedUpdateManyWithoutStudentInput>
  }

  export type StudentEnrolledCourseMarkUpsertWithWhereUniqueWithoutStudentInput = {
    where: StudentEnrolledCourseMarkWhereUniqueInput
    update: XOR<StudentEnrolledCourseMarkUpdateWithoutStudentInput, StudentEnrolledCourseMarkUncheckedUpdateWithoutStudentInput>
    create: XOR<StudentEnrolledCourseMarkCreateWithoutStudentInput, StudentEnrolledCourseMarkUncheckedCreateWithoutStudentInput>
  }

  export type StudentEnrolledCourseMarkUpdateWithWhereUniqueWithoutStudentInput = {
    where: StudentEnrolledCourseMarkWhereUniqueInput
    data: XOR<StudentEnrolledCourseMarkUpdateWithoutStudentInput, StudentEnrolledCourseMarkUncheckedUpdateWithoutStudentInput>
  }

  export type StudentEnrolledCourseMarkUpdateManyWithWhereWithoutStudentInput = {
    where: StudentEnrolledCourseMarkScalarWhereInput
    data: XOR<StudentEnrolledCourseMarkUpdateManyMutationInput, StudentEnrolledCourseMarkUncheckedUpdateManyWithoutStudentInput>
  }

  export type StudentSemesterPaymentUpsertWithWhereUniqueWithoutStudentInput = {
    where: StudentSemesterPaymentWhereUniqueInput
    update: XOR<StudentSemesterPaymentUpdateWithoutStudentInput, StudentSemesterPaymentUncheckedUpdateWithoutStudentInput>
    create: XOR<StudentSemesterPaymentCreateWithoutStudentInput, StudentSemesterPaymentUncheckedCreateWithoutStudentInput>
  }

  export type StudentSemesterPaymentUpdateWithWhereUniqueWithoutStudentInput = {
    where: StudentSemesterPaymentWhereUniqueInput
    data: XOR<StudentSemesterPaymentUpdateWithoutStudentInput, StudentSemesterPaymentUncheckedUpdateWithoutStudentInput>
  }

  export type StudentSemesterPaymentUpdateManyWithWhereWithoutStudentInput = {
    where: StudentSemesterPaymentScalarWhereInput
    data: XOR<StudentSemesterPaymentUpdateManyMutationInput, StudentSemesterPaymentUncheckedUpdateManyWithoutStudentInput>
  }

  export type StudentAcademicInfoUpsertWithWhereUniqueWithoutStudentInput = {
    where: StudentAcademicInfoWhereUniqueInput
    update: XOR<StudentAcademicInfoUpdateWithoutStudentInput, StudentAcademicInfoUncheckedUpdateWithoutStudentInput>
    create: XOR<StudentAcademicInfoCreateWithoutStudentInput, StudentAcademicInfoUncheckedCreateWithoutStudentInput>
  }

  export type StudentAcademicInfoUpdateWithWhereUniqueWithoutStudentInput = {
    where: StudentAcademicInfoWhereUniqueInput
    data: XOR<StudentAcademicInfoUpdateWithoutStudentInput, StudentAcademicInfoUncheckedUpdateWithoutStudentInput>
  }

  export type StudentAcademicInfoUpdateManyWithWhereWithoutStudentInput = {
    where: StudentAcademicInfoScalarWhereInput
    data: XOR<StudentAcademicInfoUpdateManyMutationInput, StudentAcademicInfoUncheckedUpdateManyWithoutStudentInput>
  }

  export type StudentAcademicInfoScalarWhereInput = {
    AND?: StudentAcademicInfoScalarWhereInput | StudentAcademicInfoScalarWhereInput[]
    OR?: StudentAcademicInfoScalarWhereInput[]
    NOT?: StudentAcademicInfoScalarWhereInput | StudentAcademicInfoScalarWhereInput[]
    id?: StringFilter<"StudentAcademicInfo"> | string
    createdAt?: DateTimeFilter<"StudentAcademicInfo"> | Date | string
    updatedAt?: DateTimeFilter<"StudentAcademicInfo"> | Date | string
    studentId?: StringFilter<"StudentAcademicInfo"> | string
    totalCompletedCredits?: IntNullableFilter<"StudentAcademicInfo"> | number | null
    cgpa?: FloatNullableFilter<"StudentAcademicInfo"> | number | null
  }

  export type StudentCarriedCourseUpsertWithWhereUniqueWithoutStudentInput = {
    where: StudentCarriedCourseWhereUniqueInput
    update: XOR<StudentCarriedCourseUpdateWithoutStudentInput, StudentCarriedCourseUncheckedUpdateWithoutStudentInput>
    create: XOR<StudentCarriedCourseCreateWithoutStudentInput, StudentCarriedCourseUncheckedCreateWithoutStudentInput>
  }

  export type StudentCarriedCourseUpdateWithWhereUniqueWithoutStudentInput = {
    where: StudentCarriedCourseWhereUniqueInput
    data: XOR<StudentCarriedCourseUpdateWithoutStudentInput, StudentCarriedCourseUncheckedUpdateWithoutStudentInput>
  }

  export type StudentCarriedCourseUpdateManyWithWhereWithoutStudentInput = {
    where: StudentCarriedCourseScalarWhereInput
    data: XOR<StudentCarriedCourseUpdateManyMutationInput, StudentCarriedCourseUncheckedUpdateManyWithoutStudentInput>
  }

  export type CourseFacultyCreateWithoutFacultyInput = {
    course: CourseCreateNestedOneWithoutFacultiesInput
  }

  export type CourseFacultyUncheckedCreateWithoutFacultyInput = {
    courseId: string
  }

  export type CourseFacultyCreateOrConnectWithoutFacultyInput = {
    where: CourseFacultyWhereUniqueInput
    create: XOR<CourseFacultyCreateWithoutFacultyInput, CourseFacultyUncheckedCreateWithoutFacultyInput>
  }

  export type CourseFacultyCreateManyFacultyInputEnvelope = {
    data: CourseFacultyCreateManyFacultyInput | CourseFacultyCreateManyFacultyInput[]
    skipDuplicates?: boolean
  }

  export type AcademicDepartmentCreateWithoutFacultiesInput = {
    id?: string
    title: string
    createdAt?: Date | string
    updatedAt?: Date | string
    academicFaculty: AcademicFacultyCreateNestedOneWithoutAcademicDepartmentsInput
    courses?: CourseCreateNestedManyWithoutAcademicDepartmentInput
    students?: StudentCreateNestedManyWithoutAcademicDepartmentInput
    departmentHead?: UsersCreateNestedOneWithoutAcademicDepartmentInput
    staffMembers?: UsersCreateNestedManyWithoutStaffDepartmentsInput
    offeredCourses?: OfferedCourseCreateNestedManyWithoutAcademicDepartmentInput
  }

  export type AcademicDepartmentUncheckedCreateWithoutFacultiesInput = {
    id?: string
    title: string
    academicFacultyId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    departmentHeadId?: string | null
    courses?: CourseUncheckedCreateNestedManyWithoutAcademicDepartmentInput
    students?: StudentUncheckedCreateNestedManyWithoutAcademicDepartmentInput
    staffMembers?: UsersUncheckedCreateNestedManyWithoutStaffDepartmentsInput
    offeredCourses?: OfferedCourseUncheckedCreateNestedManyWithoutAcademicDepartmentInput
  }

  export type AcademicDepartmentCreateOrConnectWithoutFacultiesInput = {
    where: AcademicDepartmentWhereUniqueInput
    create: XOR<AcademicDepartmentCreateWithoutFacultiesInput, AcademicDepartmentUncheckedCreateWithoutFacultiesInput>
  }

  export type AcademicFacultyCreateWithoutFacultiesInput = {
    id?: string
    title: string
    createdAt?: Date | string
    updatedAt?: Date | string
    academicDepartments?: AcademicDepartmentCreateNestedManyWithoutAcademicFacultyInput
    students?: StudentCreateNestedManyWithoutAcademicFacultyInput
    admitionExame?: AdmitionExameRegistrationCreateNestedManyWithoutAcademicFalcultyInput
    AdmitionExamePrice?: AdmitionExamePriceCreateNestedManyWithoutAcademicFacultyInput
    AdmitionExamePeriod?: AdmitionExamePeriodCreateNestedManyWithoutAcademicFacultyInput
  }

  export type AcademicFacultyUncheckedCreateWithoutFacultiesInput = {
    id?: string
    title: string
    createdAt?: Date | string
    updatedAt?: Date | string
    academicDepartments?: AcademicDepartmentUncheckedCreateNestedManyWithoutAcademicFacultyInput
    students?: StudentUncheckedCreateNestedManyWithoutAcademicFacultyInput
    admitionExame?: AdmitionExameRegistrationUncheckedCreateNestedManyWithoutAcademicFalcultyInput
    AdmitionExamePrice?: AdmitionExamePriceUncheckedCreateNestedManyWithoutAcademicFacultyInput
    AdmitionExamePeriod?: AdmitionExamePeriodUncheckedCreateNestedManyWithoutAcademicFacultyInput
  }

  export type AcademicFacultyCreateOrConnectWithoutFacultiesInput = {
    where: AcademicFacultyWhereUniqueInput
    create: XOR<AcademicFacultyCreateWithoutFacultiesInput, AcademicFacultyUncheckedCreateWithoutFacultiesInput>
  }

  export type OfferedCourseClassScheduleCreateWithoutFacultyInput = {
    id?: string
    startTime: string
    endTime: string
    dayOfWeek?: $Enums.WeekDays
    createdAt?: Date | string
    updatedAt?: Date | string
    offeredCourseSection: OfferedCourseSectionCreateNestedOneWithoutOfferedCourseClassSchedulesInput
    semesterRegistration: SemesterRegistrationCreateNestedOneWithoutOfferedCourseClassSchedulesInput
    room: RoomCreateNestedOneWithoutOfferedCourseClassSchedulesInput
  }

  export type OfferedCourseClassScheduleUncheckedCreateWithoutFacultyInput = {
    id?: string
    startTime: string
    endTime: string
    dayOfWeek?: $Enums.WeekDays
    createdAt?: Date | string
    updatedAt?: Date | string
    offeredCourseSectionId: string
    semesterRegistrationId: string
    roomId: string
  }

  export type OfferedCourseClassScheduleCreateOrConnectWithoutFacultyInput = {
    where: OfferedCourseClassScheduleWhereUniqueInput
    create: XOR<OfferedCourseClassScheduleCreateWithoutFacultyInput, OfferedCourseClassScheduleUncheckedCreateWithoutFacultyInput>
  }

  export type OfferedCourseClassScheduleCreateManyFacultyInputEnvelope = {
    data: OfferedCourseClassScheduleCreateManyFacultyInput | OfferedCourseClassScheduleCreateManyFacultyInput[]
    skipDuplicates?: boolean
  }

  export type CourseFacultyUpsertWithWhereUniqueWithoutFacultyInput = {
    where: CourseFacultyWhereUniqueInput
    update: XOR<CourseFacultyUpdateWithoutFacultyInput, CourseFacultyUncheckedUpdateWithoutFacultyInput>
    create: XOR<CourseFacultyCreateWithoutFacultyInput, CourseFacultyUncheckedCreateWithoutFacultyInput>
  }

  export type CourseFacultyUpdateWithWhereUniqueWithoutFacultyInput = {
    where: CourseFacultyWhereUniqueInput
    data: XOR<CourseFacultyUpdateWithoutFacultyInput, CourseFacultyUncheckedUpdateWithoutFacultyInput>
  }

  export type CourseFacultyUpdateManyWithWhereWithoutFacultyInput = {
    where: CourseFacultyScalarWhereInput
    data: XOR<CourseFacultyUpdateManyMutationInput, CourseFacultyUncheckedUpdateManyWithoutFacultyInput>
  }

  export type CourseFacultyScalarWhereInput = {
    AND?: CourseFacultyScalarWhereInput | CourseFacultyScalarWhereInput[]
    OR?: CourseFacultyScalarWhereInput[]
    NOT?: CourseFacultyScalarWhereInput | CourseFacultyScalarWhereInput[]
    courseId?: StringFilter<"CourseFaculty"> | string
    facultyId?: StringFilter<"CourseFaculty"> | string
  }

  export type AcademicDepartmentUpsertWithoutFacultiesInput = {
    update: XOR<AcademicDepartmentUpdateWithoutFacultiesInput, AcademicDepartmentUncheckedUpdateWithoutFacultiesInput>
    create: XOR<AcademicDepartmentCreateWithoutFacultiesInput, AcademicDepartmentUncheckedCreateWithoutFacultiesInput>
    where?: AcademicDepartmentWhereInput
  }

  export type AcademicDepartmentUpdateToOneWithWhereWithoutFacultiesInput = {
    where?: AcademicDepartmentWhereInput
    data: XOR<AcademicDepartmentUpdateWithoutFacultiesInput, AcademicDepartmentUncheckedUpdateWithoutFacultiesInput>
  }

  export type AcademicDepartmentUpdateWithoutFacultiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    academicFaculty?: AcademicFacultyUpdateOneRequiredWithoutAcademicDepartmentsNestedInput
    courses?: CourseUpdateManyWithoutAcademicDepartmentNestedInput
    students?: StudentUpdateManyWithoutAcademicDepartmentNestedInput
    departmentHead?: UsersUpdateOneWithoutAcademicDepartmentNestedInput
    staffMembers?: UsersUpdateManyWithoutStaffDepartmentsNestedInput
    offeredCourses?: OfferedCourseUpdateManyWithoutAcademicDepartmentNestedInput
  }

  export type AcademicDepartmentUncheckedUpdateWithoutFacultiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    academicFacultyId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    departmentHeadId?: NullableStringFieldUpdateOperationsInput | string | null
    courses?: CourseUncheckedUpdateManyWithoutAcademicDepartmentNestedInput
    students?: StudentUncheckedUpdateManyWithoutAcademicDepartmentNestedInput
    staffMembers?: UsersUncheckedUpdateManyWithoutStaffDepartmentsNestedInput
    offeredCourses?: OfferedCourseUncheckedUpdateManyWithoutAcademicDepartmentNestedInput
  }

  export type AcademicFacultyUpsertWithoutFacultiesInput = {
    update: XOR<AcademicFacultyUpdateWithoutFacultiesInput, AcademicFacultyUncheckedUpdateWithoutFacultiesInput>
    create: XOR<AcademicFacultyCreateWithoutFacultiesInput, AcademicFacultyUncheckedCreateWithoutFacultiesInput>
    where?: AcademicFacultyWhereInput
  }

  export type AcademicFacultyUpdateToOneWithWhereWithoutFacultiesInput = {
    where?: AcademicFacultyWhereInput
    data: XOR<AcademicFacultyUpdateWithoutFacultiesInput, AcademicFacultyUncheckedUpdateWithoutFacultiesInput>
  }

  export type AcademicFacultyUpdateWithoutFacultiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    academicDepartments?: AcademicDepartmentUpdateManyWithoutAcademicFacultyNestedInput
    students?: StudentUpdateManyWithoutAcademicFacultyNestedInput
    admitionExame?: AdmitionExameRegistrationUpdateManyWithoutAcademicFalcultyNestedInput
    AdmitionExamePrice?: AdmitionExamePriceUpdateManyWithoutAcademicFacultyNestedInput
    AdmitionExamePeriod?: AdmitionExamePeriodUpdateManyWithoutAcademicFacultyNestedInput
  }

  export type AcademicFacultyUncheckedUpdateWithoutFacultiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    academicDepartments?: AcademicDepartmentUncheckedUpdateManyWithoutAcademicFacultyNestedInput
    students?: StudentUncheckedUpdateManyWithoutAcademicFacultyNestedInput
    admitionExame?: AdmitionExameRegistrationUncheckedUpdateManyWithoutAcademicFalcultyNestedInput
    AdmitionExamePrice?: AdmitionExamePriceUncheckedUpdateManyWithoutAcademicFacultyNestedInput
    AdmitionExamePeriod?: AdmitionExamePeriodUncheckedUpdateManyWithoutAcademicFacultyNestedInput
  }

  export type OfferedCourseClassScheduleUpsertWithWhereUniqueWithoutFacultyInput = {
    where: OfferedCourseClassScheduleWhereUniqueInput
    update: XOR<OfferedCourseClassScheduleUpdateWithoutFacultyInput, OfferedCourseClassScheduleUncheckedUpdateWithoutFacultyInput>
    create: XOR<OfferedCourseClassScheduleCreateWithoutFacultyInput, OfferedCourseClassScheduleUncheckedCreateWithoutFacultyInput>
  }

  export type OfferedCourseClassScheduleUpdateWithWhereUniqueWithoutFacultyInput = {
    where: OfferedCourseClassScheduleWhereUniqueInput
    data: XOR<OfferedCourseClassScheduleUpdateWithoutFacultyInput, OfferedCourseClassScheduleUncheckedUpdateWithoutFacultyInput>
  }

  export type OfferedCourseClassScheduleUpdateManyWithWhereWithoutFacultyInput = {
    where: OfferedCourseClassScheduleScalarWhereInput
    data: XOR<OfferedCourseClassScheduleUpdateManyMutationInput, OfferedCourseClassScheduleUncheckedUpdateManyWithoutFacultyInput>
  }

  export type OfferedCourseClassScheduleScalarWhereInput = {
    AND?: OfferedCourseClassScheduleScalarWhereInput | OfferedCourseClassScheduleScalarWhereInput[]
    OR?: OfferedCourseClassScheduleScalarWhereInput[]
    NOT?: OfferedCourseClassScheduleScalarWhereInput | OfferedCourseClassScheduleScalarWhereInput[]
    id?: StringFilter<"OfferedCourseClassSchedule"> | string
    startTime?: StringFilter<"OfferedCourseClassSchedule"> | string
    endTime?: StringFilter<"OfferedCourseClassSchedule"> | string
    dayOfWeek?: EnumWeekDaysFilter<"OfferedCourseClassSchedule"> | $Enums.WeekDays
    createdAt?: DateTimeFilter<"OfferedCourseClassSchedule"> | Date | string
    updatedAt?: DateTimeFilter<"OfferedCourseClassSchedule"> | Date | string
    offeredCourseSectionId?: StringFilter<"OfferedCourseClassSchedule"> | string
    semesterRegistrationId?: StringFilter<"OfferedCourseClassSchedule"> | string
    roomId?: StringFilter<"OfferedCourseClassSchedule"> | string
    facultyId?: StringFilter<"OfferedCourseClassSchedule"> | string
  }

  export type RoomCreateWithoutBuildingInput = {
    id?: string
    roomNumber: string
    floor: string
    createdAt?: Date | string
    updatedAt?: Date | string
    offeredCourseClassSchedules?: OfferedCourseClassScheduleCreateNestedManyWithoutRoomInput
  }

  export type RoomUncheckedCreateWithoutBuildingInput = {
    id?: string
    roomNumber: string
    floor: string
    createdAt?: Date | string
    updatedAt?: Date | string
    offeredCourseClassSchedules?: OfferedCourseClassScheduleUncheckedCreateNestedManyWithoutRoomInput
  }

  export type RoomCreateOrConnectWithoutBuildingInput = {
    where: RoomWhereUniqueInput
    create: XOR<RoomCreateWithoutBuildingInput, RoomUncheckedCreateWithoutBuildingInput>
  }

  export type RoomCreateManyBuildingInputEnvelope = {
    data: RoomCreateManyBuildingInput | RoomCreateManyBuildingInput[]
    skipDuplicates?: boolean
  }

  export type RoomUpsertWithWhereUniqueWithoutBuildingInput = {
    where: RoomWhereUniqueInput
    update: XOR<RoomUpdateWithoutBuildingInput, RoomUncheckedUpdateWithoutBuildingInput>
    create: XOR<RoomCreateWithoutBuildingInput, RoomUncheckedCreateWithoutBuildingInput>
  }

  export type RoomUpdateWithWhereUniqueWithoutBuildingInput = {
    where: RoomWhereUniqueInput
    data: XOR<RoomUpdateWithoutBuildingInput, RoomUncheckedUpdateWithoutBuildingInput>
  }

  export type RoomUpdateManyWithWhereWithoutBuildingInput = {
    where: RoomScalarWhereInput
    data: XOR<RoomUpdateManyMutationInput, RoomUncheckedUpdateManyWithoutBuildingInput>
  }

  export type RoomScalarWhereInput = {
    AND?: RoomScalarWhereInput | RoomScalarWhereInput[]
    OR?: RoomScalarWhereInput[]
    NOT?: RoomScalarWhereInput | RoomScalarWhereInput[]
    id?: StringFilter<"Room"> | string
    roomNumber?: StringFilter<"Room"> | string
    floor?: StringFilter<"Room"> | string
    buildingId?: StringFilter<"Room"> | string
    createdAt?: DateTimeFilter<"Room"> | Date | string
    updatedAt?: DateTimeFilter<"Room"> | Date | string
  }

  export type BuildingCreateWithoutRoomsInput = {
    id?: string
    title: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BuildingUncheckedCreateWithoutRoomsInput = {
    id?: string
    title: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BuildingCreateOrConnectWithoutRoomsInput = {
    where: BuildingWhereUniqueInput
    create: XOR<BuildingCreateWithoutRoomsInput, BuildingUncheckedCreateWithoutRoomsInput>
  }

  export type OfferedCourseClassScheduleCreateWithoutRoomInput = {
    id?: string
    startTime: string
    endTime: string
    dayOfWeek?: $Enums.WeekDays
    createdAt?: Date | string
    updatedAt?: Date | string
    offeredCourseSection: OfferedCourseSectionCreateNestedOneWithoutOfferedCourseClassSchedulesInput
    semesterRegistration: SemesterRegistrationCreateNestedOneWithoutOfferedCourseClassSchedulesInput
    faculty: FacultyCreateNestedOneWithoutOfferedCourseClassSchedulesInput
  }

  export type OfferedCourseClassScheduleUncheckedCreateWithoutRoomInput = {
    id?: string
    startTime: string
    endTime: string
    dayOfWeek?: $Enums.WeekDays
    createdAt?: Date | string
    updatedAt?: Date | string
    offeredCourseSectionId: string
    semesterRegistrationId: string
    facultyId: string
  }

  export type OfferedCourseClassScheduleCreateOrConnectWithoutRoomInput = {
    where: OfferedCourseClassScheduleWhereUniqueInput
    create: XOR<OfferedCourseClassScheduleCreateWithoutRoomInput, OfferedCourseClassScheduleUncheckedCreateWithoutRoomInput>
  }

  export type OfferedCourseClassScheduleCreateManyRoomInputEnvelope = {
    data: OfferedCourseClassScheduleCreateManyRoomInput | OfferedCourseClassScheduleCreateManyRoomInput[]
    skipDuplicates?: boolean
  }

  export type BuildingUpsertWithoutRoomsInput = {
    update: XOR<BuildingUpdateWithoutRoomsInput, BuildingUncheckedUpdateWithoutRoomsInput>
    create: XOR<BuildingCreateWithoutRoomsInput, BuildingUncheckedCreateWithoutRoomsInput>
    where?: BuildingWhereInput
  }

  export type BuildingUpdateToOneWithWhereWithoutRoomsInput = {
    where?: BuildingWhereInput
    data: XOR<BuildingUpdateWithoutRoomsInput, BuildingUncheckedUpdateWithoutRoomsInput>
  }

  export type BuildingUpdateWithoutRoomsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BuildingUncheckedUpdateWithoutRoomsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OfferedCourseClassScheduleUpsertWithWhereUniqueWithoutRoomInput = {
    where: OfferedCourseClassScheduleWhereUniqueInput
    update: XOR<OfferedCourseClassScheduleUpdateWithoutRoomInput, OfferedCourseClassScheduleUncheckedUpdateWithoutRoomInput>
    create: XOR<OfferedCourseClassScheduleCreateWithoutRoomInput, OfferedCourseClassScheduleUncheckedCreateWithoutRoomInput>
  }

  export type OfferedCourseClassScheduleUpdateWithWhereUniqueWithoutRoomInput = {
    where: OfferedCourseClassScheduleWhereUniqueInput
    data: XOR<OfferedCourseClassScheduleUpdateWithoutRoomInput, OfferedCourseClassScheduleUncheckedUpdateWithoutRoomInput>
  }

  export type OfferedCourseClassScheduleUpdateManyWithWhereWithoutRoomInput = {
    where: OfferedCourseClassScheduleScalarWhereInput
    data: XOR<OfferedCourseClassScheduleUpdateManyMutationInput, OfferedCourseClassScheduleUncheckedUpdateManyWithoutRoomInput>
  }

  export type CourseDisciplineCreateWithoutCourseInput = {
    id?: string
    credits: number
    discipline: DisciplineCreateNestedOneWithoutCourseDisciplinesInput
    semester: AcademicSemesterCreateNestedOneWithoutCourseDisciplinesInput
  }

  export type CourseDisciplineUncheckedCreateWithoutCourseInput = {
    id?: string
    disciplineId: string
    semesterId: string
    credits: number
  }

  export type CourseDisciplineCreateOrConnectWithoutCourseInput = {
    where: CourseDisciplineWhereUniqueInput
    create: XOR<CourseDisciplineCreateWithoutCourseInput, CourseDisciplineUncheckedCreateWithoutCourseInput>
  }

  export type CourseDisciplineCreateManyCourseInputEnvelope = {
    data: CourseDisciplineCreateManyCourseInput | CourseDisciplineCreateManyCourseInput[]
    skipDuplicates?: boolean
  }

  export type CoursePricingCreateWithoutCourseInput = {
    id?: string
    price: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CoursePricingUncheckedCreateWithoutCourseInput = {
    id?: string
    price: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CoursePricingCreateOrConnectWithoutCourseInput = {
    where: CoursePricingWhereUniqueInput
    create: XOR<CoursePricingCreateWithoutCourseInput, CoursePricingUncheckedCreateWithoutCourseInput>
  }

  export type AcademicDepartmentCreateWithoutCoursesInput = {
    id?: string
    title: string
    createdAt?: Date | string
    updatedAt?: Date | string
    academicFaculty: AcademicFacultyCreateNestedOneWithoutAcademicDepartmentsInput
    faculties?: FacultyCreateNestedManyWithoutAcademicDepartmentInput
    students?: StudentCreateNestedManyWithoutAcademicDepartmentInput
    departmentHead?: UsersCreateNestedOneWithoutAcademicDepartmentInput
    staffMembers?: UsersCreateNestedManyWithoutStaffDepartmentsInput
    offeredCourses?: OfferedCourseCreateNestedManyWithoutAcademicDepartmentInput
  }

  export type AcademicDepartmentUncheckedCreateWithoutCoursesInput = {
    id?: string
    title: string
    academicFacultyId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    departmentHeadId?: string | null
    faculties?: FacultyUncheckedCreateNestedManyWithoutAcademicDepartmentInput
    students?: StudentUncheckedCreateNestedManyWithoutAcademicDepartmentInput
    staffMembers?: UsersUncheckedCreateNestedManyWithoutStaffDepartmentsInput
    offeredCourses?: OfferedCourseUncheckedCreateNestedManyWithoutAcademicDepartmentInput
  }

  export type AcademicDepartmentCreateOrConnectWithoutCoursesInput = {
    where: AcademicDepartmentWhereUniqueInput
    create: XOR<AcademicDepartmentCreateWithoutCoursesInput, AcademicDepartmentUncheckedCreateWithoutCoursesInput>
  }

  export type StudentEnrolledCourseCreateWithoutCourseInput = {
    id?: string
    grade?: string | null
    point?: number | null
    totalMarks?: number | null
    status?: $Enums.StudentEnrolledCourseStatus | null
    createdAt?: Date | string
    updatedAt?: Date | string
    student: StudentCreateNestedOneWithoutStudentEnrolledCoursesInput
    studentEnrolledCourseMarks?: StudentEnrolledCourseMarkCreateNestedManyWithoutStudentEnrolledCourseInput
    academicSemester: AcademicSemesterCreateNestedOneWithoutStudentEnrolledCoursesInput
  }

  export type StudentEnrolledCourseUncheckedCreateWithoutCourseInput = {
    id?: string
    grade?: string | null
    point?: number | null
    totalMarks?: number | null
    status?: $Enums.StudentEnrolledCourseStatus | null
    createdAt?: Date | string
    updatedAt?: Date | string
    studentId: string
    academicSemesterId: string
    studentEnrolledCourseMarks?: StudentEnrolledCourseMarkUncheckedCreateNestedManyWithoutStudentEnrolledCourseInput
  }

  export type StudentEnrolledCourseCreateOrConnectWithoutCourseInput = {
    where: StudentEnrolledCourseWhereUniqueInput
    create: XOR<StudentEnrolledCourseCreateWithoutCourseInput, StudentEnrolledCourseUncheckedCreateWithoutCourseInput>
  }

  export type StudentEnrolledCourseCreateManyCourseInputEnvelope = {
    data: StudentEnrolledCourseCreateManyCourseInput | StudentEnrolledCourseCreateManyCourseInput[]
    skipDuplicates?: boolean
  }

  export type CourseToPreRequisiteCreateWithoutCourseInput = {
    preRequisite: CourseCreateNestedOneWithoutPreRequisiteForInput
  }

  export type CourseToPreRequisiteUncheckedCreateWithoutCourseInput = {
    preRequisiteId: string
  }

  export type CourseToPreRequisiteCreateOrConnectWithoutCourseInput = {
    where: CourseToPreRequisiteWhereUniqueInput
    create: XOR<CourseToPreRequisiteCreateWithoutCourseInput, CourseToPreRequisiteUncheckedCreateWithoutCourseInput>
  }

  export type CourseToPreRequisiteCreateManyCourseInputEnvelope = {
    data: CourseToPreRequisiteCreateManyCourseInput | CourseToPreRequisiteCreateManyCourseInput[]
    skipDuplicates?: boolean
  }

  export type CourseToPreRequisiteCreateWithoutPreRequisiteInput = {
    course: CourseCreateNestedOneWithoutPreRequisiteInput
  }

  export type CourseToPreRequisiteUncheckedCreateWithoutPreRequisiteInput = {
    courseId: string
  }

  export type CourseToPreRequisiteCreateOrConnectWithoutPreRequisiteInput = {
    where: CourseToPreRequisiteWhereUniqueInput
    create: XOR<CourseToPreRequisiteCreateWithoutPreRequisiteInput, CourseToPreRequisiteUncheckedCreateWithoutPreRequisiteInput>
  }

  export type CourseToPreRequisiteCreateManyPreRequisiteInputEnvelope = {
    data: CourseToPreRequisiteCreateManyPreRequisiteInput | CourseToPreRequisiteCreateManyPreRequisiteInput[]
    skipDuplicates?: boolean
  }

  export type CourseFacultyCreateWithoutCourseInput = {
    faculty: FacultyCreateNestedOneWithoutCoursesInput
  }

  export type CourseFacultyUncheckedCreateWithoutCourseInput = {
    facultyId: string
  }

  export type CourseFacultyCreateOrConnectWithoutCourseInput = {
    where: CourseFacultyWhereUniqueInput
    create: XOR<CourseFacultyCreateWithoutCourseInput, CourseFacultyUncheckedCreateWithoutCourseInput>
  }

  export type CourseFacultyCreateManyCourseInputEnvelope = {
    data: CourseFacultyCreateManyCourseInput | CourseFacultyCreateManyCourseInput[]
    skipDuplicates?: boolean
  }

  export type OfferedCourseCreateWithoutCourseInput = {
    id?: string
    suspendGrade?: number
    academicDepartment: AcademicDepartmentCreateNestedOneWithoutOfferedCoursesInput
    semesterRegistration: SemesterRegistrationCreateNestedOneWithoutOfferedCoursesInput
    offeredCourseSections?: OfferedCourseSectionCreateNestedManyWithoutOfferedCourseInput
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseCreateNestedManyWithoutOfferedCourseInput
  }

  export type OfferedCourseUncheckedCreateWithoutCourseInput = {
    id?: string
    academicDepartmentId: string
    semesterRegistrationId: string
    suspendGrade?: number
    offeredCourseSections?: OfferedCourseSectionUncheckedCreateNestedManyWithoutOfferedCourseInput
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseUncheckedCreateNestedManyWithoutOfferedCourseInput
  }

  export type OfferedCourseCreateOrConnectWithoutCourseInput = {
    where: OfferedCourseWhereUniqueInput
    create: XOR<OfferedCourseCreateWithoutCourseInput, OfferedCourseUncheckedCreateWithoutCourseInput>
  }

  export type OfferedCourseCreateManyCourseInputEnvelope = {
    data: OfferedCourseCreateManyCourseInput | OfferedCourseCreateManyCourseInput[]
    skipDuplicates?: boolean
  }

  export type CourseDisciplineUpsertWithWhereUniqueWithoutCourseInput = {
    where: CourseDisciplineWhereUniqueInput
    update: XOR<CourseDisciplineUpdateWithoutCourseInput, CourseDisciplineUncheckedUpdateWithoutCourseInput>
    create: XOR<CourseDisciplineCreateWithoutCourseInput, CourseDisciplineUncheckedCreateWithoutCourseInput>
  }

  export type CourseDisciplineUpdateWithWhereUniqueWithoutCourseInput = {
    where: CourseDisciplineWhereUniqueInput
    data: XOR<CourseDisciplineUpdateWithoutCourseInput, CourseDisciplineUncheckedUpdateWithoutCourseInput>
  }

  export type CourseDisciplineUpdateManyWithWhereWithoutCourseInput = {
    where: CourseDisciplineScalarWhereInput
    data: XOR<CourseDisciplineUpdateManyMutationInput, CourseDisciplineUncheckedUpdateManyWithoutCourseInput>
  }

  export type CoursePricingUpsertWithoutCourseInput = {
    update: XOR<CoursePricingUpdateWithoutCourseInput, CoursePricingUncheckedUpdateWithoutCourseInput>
    create: XOR<CoursePricingCreateWithoutCourseInput, CoursePricingUncheckedCreateWithoutCourseInput>
    where?: CoursePricingWhereInput
  }

  export type CoursePricingUpdateToOneWithWhereWithoutCourseInput = {
    where?: CoursePricingWhereInput
    data: XOR<CoursePricingUpdateWithoutCourseInput, CoursePricingUncheckedUpdateWithoutCourseInput>
  }

  export type CoursePricingUpdateWithoutCourseInput = {
    id?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CoursePricingUncheckedUpdateWithoutCourseInput = {
    id?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AcademicDepartmentUpsertWithoutCoursesInput = {
    update: XOR<AcademicDepartmentUpdateWithoutCoursesInput, AcademicDepartmentUncheckedUpdateWithoutCoursesInput>
    create: XOR<AcademicDepartmentCreateWithoutCoursesInput, AcademicDepartmentUncheckedCreateWithoutCoursesInput>
    where?: AcademicDepartmentWhereInput
  }

  export type AcademicDepartmentUpdateToOneWithWhereWithoutCoursesInput = {
    where?: AcademicDepartmentWhereInput
    data: XOR<AcademicDepartmentUpdateWithoutCoursesInput, AcademicDepartmentUncheckedUpdateWithoutCoursesInput>
  }

  export type AcademicDepartmentUpdateWithoutCoursesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    academicFaculty?: AcademicFacultyUpdateOneRequiredWithoutAcademicDepartmentsNestedInput
    faculties?: FacultyUpdateManyWithoutAcademicDepartmentNestedInput
    students?: StudentUpdateManyWithoutAcademicDepartmentNestedInput
    departmentHead?: UsersUpdateOneWithoutAcademicDepartmentNestedInput
    staffMembers?: UsersUpdateManyWithoutStaffDepartmentsNestedInput
    offeredCourses?: OfferedCourseUpdateManyWithoutAcademicDepartmentNestedInput
  }

  export type AcademicDepartmentUncheckedUpdateWithoutCoursesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    academicFacultyId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    departmentHeadId?: NullableStringFieldUpdateOperationsInput | string | null
    faculties?: FacultyUncheckedUpdateManyWithoutAcademicDepartmentNestedInput
    students?: StudentUncheckedUpdateManyWithoutAcademicDepartmentNestedInput
    staffMembers?: UsersUncheckedUpdateManyWithoutStaffDepartmentsNestedInput
    offeredCourses?: OfferedCourseUncheckedUpdateManyWithoutAcademicDepartmentNestedInput
  }

  export type StudentEnrolledCourseUpsertWithWhereUniqueWithoutCourseInput = {
    where: StudentEnrolledCourseWhereUniqueInput
    update: XOR<StudentEnrolledCourseUpdateWithoutCourseInput, StudentEnrolledCourseUncheckedUpdateWithoutCourseInput>
    create: XOR<StudentEnrolledCourseCreateWithoutCourseInput, StudentEnrolledCourseUncheckedCreateWithoutCourseInput>
  }

  export type StudentEnrolledCourseUpdateWithWhereUniqueWithoutCourseInput = {
    where: StudentEnrolledCourseWhereUniqueInput
    data: XOR<StudentEnrolledCourseUpdateWithoutCourseInput, StudentEnrolledCourseUncheckedUpdateWithoutCourseInput>
  }

  export type StudentEnrolledCourseUpdateManyWithWhereWithoutCourseInput = {
    where: StudentEnrolledCourseScalarWhereInput
    data: XOR<StudentEnrolledCourseUpdateManyMutationInput, StudentEnrolledCourseUncheckedUpdateManyWithoutCourseInput>
  }

  export type CourseToPreRequisiteUpsertWithWhereUniqueWithoutCourseInput = {
    where: CourseToPreRequisiteWhereUniqueInput
    update: XOR<CourseToPreRequisiteUpdateWithoutCourseInput, CourseToPreRequisiteUncheckedUpdateWithoutCourseInput>
    create: XOR<CourseToPreRequisiteCreateWithoutCourseInput, CourseToPreRequisiteUncheckedCreateWithoutCourseInput>
  }

  export type CourseToPreRequisiteUpdateWithWhereUniqueWithoutCourseInput = {
    where: CourseToPreRequisiteWhereUniqueInput
    data: XOR<CourseToPreRequisiteUpdateWithoutCourseInput, CourseToPreRequisiteUncheckedUpdateWithoutCourseInput>
  }

  export type CourseToPreRequisiteUpdateManyWithWhereWithoutCourseInput = {
    where: CourseToPreRequisiteScalarWhereInput
    data: XOR<CourseToPreRequisiteUpdateManyMutationInput, CourseToPreRequisiteUncheckedUpdateManyWithoutCourseInput>
  }

  export type CourseToPreRequisiteScalarWhereInput = {
    AND?: CourseToPreRequisiteScalarWhereInput | CourseToPreRequisiteScalarWhereInput[]
    OR?: CourseToPreRequisiteScalarWhereInput[]
    NOT?: CourseToPreRequisiteScalarWhereInput | CourseToPreRequisiteScalarWhereInput[]
    courseId?: StringFilter<"CourseToPreRequisite"> | string
    preRequisiteId?: StringFilter<"CourseToPreRequisite"> | string
  }

  export type CourseToPreRequisiteUpsertWithWhereUniqueWithoutPreRequisiteInput = {
    where: CourseToPreRequisiteWhereUniqueInput
    update: XOR<CourseToPreRequisiteUpdateWithoutPreRequisiteInput, CourseToPreRequisiteUncheckedUpdateWithoutPreRequisiteInput>
    create: XOR<CourseToPreRequisiteCreateWithoutPreRequisiteInput, CourseToPreRequisiteUncheckedCreateWithoutPreRequisiteInput>
  }

  export type CourseToPreRequisiteUpdateWithWhereUniqueWithoutPreRequisiteInput = {
    where: CourseToPreRequisiteWhereUniqueInput
    data: XOR<CourseToPreRequisiteUpdateWithoutPreRequisiteInput, CourseToPreRequisiteUncheckedUpdateWithoutPreRequisiteInput>
  }

  export type CourseToPreRequisiteUpdateManyWithWhereWithoutPreRequisiteInput = {
    where: CourseToPreRequisiteScalarWhereInput
    data: XOR<CourseToPreRequisiteUpdateManyMutationInput, CourseToPreRequisiteUncheckedUpdateManyWithoutPreRequisiteInput>
  }

  export type CourseFacultyUpsertWithWhereUniqueWithoutCourseInput = {
    where: CourseFacultyWhereUniqueInput
    update: XOR<CourseFacultyUpdateWithoutCourseInput, CourseFacultyUncheckedUpdateWithoutCourseInput>
    create: XOR<CourseFacultyCreateWithoutCourseInput, CourseFacultyUncheckedCreateWithoutCourseInput>
  }

  export type CourseFacultyUpdateWithWhereUniqueWithoutCourseInput = {
    where: CourseFacultyWhereUniqueInput
    data: XOR<CourseFacultyUpdateWithoutCourseInput, CourseFacultyUncheckedUpdateWithoutCourseInput>
  }

  export type CourseFacultyUpdateManyWithWhereWithoutCourseInput = {
    where: CourseFacultyScalarWhereInput
    data: XOR<CourseFacultyUpdateManyMutationInput, CourseFacultyUncheckedUpdateManyWithoutCourseInput>
  }

  export type OfferedCourseUpsertWithWhereUniqueWithoutCourseInput = {
    where: OfferedCourseWhereUniqueInput
    update: XOR<OfferedCourseUpdateWithoutCourseInput, OfferedCourseUncheckedUpdateWithoutCourseInput>
    create: XOR<OfferedCourseCreateWithoutCourseInput, OfferedCourseUncheckedCreateWithoutCourseInput>
  }

  export type OfferedCourseUpdateWithWhereUniqueWithoutCourseInput = {
    where: OfferedCourseWhereUniqueInput
    data: XOR<OfferedCourseUpdateWithoutCourseInput, OfferedCourseUncheckedUpdateWithoutCourseInput>
  }

  export type OfferedCourseUpdateManyWithWhereWithoutCourseInput = {
    where: OfferedCourseScalarWhereInput
    data: XOR<OfferedCourseUpdateManyMutationInput, OfferedCourseUncheckedUpdateManyWithoutCourseInput>
  }

  export type CourseCreateWithoutPreRequisiteInput = {
    id?: string
    title: string
    code: string
    durationInYears: number
    yearLevel?: $Enums.YearLevel
    shift?: $Enums.Shift
    createdAt?: Date | string
    updatedAt?: Date | string
    courseDisciplines?: CourseDisciplineCreateNestedManyWithoutCourseInput
    coursePricing?: CoursePricingCreateNestedOneWithoutCourseInput
    academicDepartment: AcademicDepartmentCreateNestedOneWithoutCoursesInput
    studentCourses?: StudentEnrolledCourseCreateNestedManyWithoutCourseInput
    preRequisiteFor?: CourseToPreRequisiteCreateNestedManyWithoutPreRequisiteInput
    faculties?: CourseFacultyCreateNestedManyWithoutCourseInput
    offeredCourses?: OfferedCourseCreateNestedManyWithoutCourseInput
  }

  export type CourseUncheckedCreateWithoutPreRequisiteInput = {
    id?: string
    title: string
    code: string
    durationInYears: number
    yearLevel?: $Enums.YearLevel
    shift?: $Enums.Shift
    academicDepartmentId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    courseDisciplines?: CourseDisciplineUncheckedCreateNestedManyWithoutCourseInput
    coursePricing?: CoursePricingUncheckedCreateNestedOneWithoutCourseInput
    studentCourses?: StudentEnrolledCourseUncheckedCreateNestedManyWithoutCourseInput
    preRequisiteFor?: CourseToPreRequisiteUncheckedCreateNestedManyWithoutPreRequisiteInput
    faculties?: CourseFacultyUncheckedCreateNestedManyWithoutCourseInput
    offeredCourses?: OfferedCourseUncheckedCreateNestedManyWithoutCourseInput
  }

  export type CourseCreateOrConnectWithoutPreRequisiteInput = {
    where: CourseWhereUniqueInput
    create: XOR<CourseCreateWithoutPreRequisiteInput, CourseUncheckedCreateWithoutPreRequisiteInput>
  }

  export type CourseCreateWithoutPreRequisiteForInput = {
    id?: string
    title: string
    code: string
    durationInYears: number
    yearLevel?: $Enums.YearLevel
    shift?: $Enums.Shift
    createdAt?: Date | string
    updatedAt?: Date | string
    courseDisciplines?: CourseDisciplineCreateNestedManyWithoutCourseInput
    coursePricing?: CoursePricingCreateNestedOneWithoutCourseInput
    academicDepartment: AcademicDepartmentCreateNestedOneWithoutCoursesInput
    studentCourses?: StudentEnrolledCourseCreateNestedManyWithoutCourseInput
    preRequisite?: CourseToPreRequisiteCreateNestedManyWithoutCourseInput
    faculties?: CourseFacultyCreateNestedManyWithoutCourseInput
    offeredCourses?: OfferedCourseCreateNestedManyWithoutCourseInput
  }

  export type CourseUncheckedCreateWithoutPreRequisiteForInput = {
    id?: string
    title: string
    code: string
    durationInYears: number
    yearLevel?: $Enums.YearLevel
    shift?: $Enums.Shift
    academicDepartmentId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    courseDisciplines?: CourseDisciplineUncheckedCreateNestedManyWithoutCourseInput
    coursePricing?: CoursePricingUncheckedCreateNestedOneWithoutCourseInput
    studentCourses?: StudentEnrolledCourseUncheckedCreateNestedManyWithoutCourseInput
    preRequisite?: CourseToPreRequisiteUncheckedCreateNestedManyWithoutCourseInput
    faculties?: CourseFacultyUncheckedCreateNestedManyWithoutCourseInput
    offeredCourses?: OfferedCourseUncheckedCreateNestedManyWithoutCourseInput
  }

  export type CourseCreateOrConnectWithoutPreRequisiteForInput = {
    where: CourseWhereUniqueInput
    create: XOR<CourseCreateWithoutPreRequisiteForInput, CourseUncheckedCreateWithoutPreRequisiteForInput>
  }

  export type CourseUpsertWithoutPreRequisiteInput = {
    update: XOR<CourseUpdateWithoutPreRequisiteInput, CourseUncheckedUpdateWithoutPreRequisiteInput>
    create: XOR<CourseCreateWithoutPreRequisiteInput, CourseUncheckedCreateWithoutPreRequisiteInput>
    where?: CourseWhereInput
  }

  export type CourseUpdateToOneWithWhereWithoutPreRequisiteInput = {
    where?: CourseWhereInput
    data: XOR<CourseUpdateWithoutPreRequisiteInput, CourseUncheckedUpdateWithoutPreRequisiteInput>
  }

  export type CourseUpdateWithoutPreRequisiteInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    durationInYears?: IntFieldUpdateOperationsInput | number
    yearLevel?: EnumYearLevelFieldUpdateOperationsInput | $Enums.YearLevel
    shift?: EnumShiftFieldUpdateOperationsInput | $Enums.Shift
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    courseDisciplines?: CourseDisciplineUpdateManyWithoutCourseNestedInput
    coursePricing?: CoursePricingUpdateOneWithoutCourseNestedInput
    academicDepartment?: AcademicDepartmentUpdateOneRequiredWithoutCoursesNestedInput
    studentCourses?: StudentEnrolledCourseUpdateManyWithoutCourseNestedInput
    preRequisiteFor?: CourseToPreRequisiteUpdateManyWithoutPreRequisiteNestedInput
    faculties?: CourseFacultyUpdateManyWithoutCourseNestedInput
    offeredCourses?: OfferedCourseUpdateManyWithoutCourseNestedInput
  }

  export type CourseUncheckedUpdateWithoutPreRequisiteInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    durationInYears?: IntFieldUpdateOperationsInput | number
    yearLevel?: EnumYearLevelFieldUpdateOperationsInput | $Enums.YearLevel
    shift?: EnumShiftFieldUpdateOperationsInput | $Enums.Shift
    academicDepartmentId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    courseDisciplines?: CourseDisciplineUncheckedUpdateManyWithoutCourseNestedInput
    coursePricing?: CoursePricingUncheckedUpdateOneWithoutCourseNestedInput
    studentCourses?: StudentEnrolledCourseUncheckedUpdateManyWithoutCourseNestedInput
    preRequisiteFor?: CourseToPreRequisiteUncheckedUpdateManyWithoutPreRequisiteNestedInput
    faculties?: CourseFacultyUncheckedUpdateManyWithoutCourseNestedInput
    offeredCourses?: OfferedCourseUncheckedUpdateManyWithoutCourseNestedInput
  }

  export type CourseUpsertWithoutPreRequisiteForInput = {
    update: XOR<CourseUpdateWithoutPreRequisiteForInput, CourseUncheckedUpdateWithoutPreRequisiteForInput>
    create: XOR<CourseCreateWithoutPreRequisiteForInput, CourseUncheckedCreateWithoutPreRequisiteForInput>
    where?: CourseWhereInput
  }

  export type CourseUpdateToOneWithWhereWithoutPreRequisiteForInput = {
    where?: CourseWhereInput
    data: XOR<CourseUpdateWithoutPreRequisiteForInput, CourseUncheckedUpdateWithoutPreRequisiteForInput>
  }

  export type CourseUpdateWithoutPreRequisiteForInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    durationInYears?: IntFieldUpdateOperationsInput | number
    yearLevel?: EnumYearLevelFieldUpdateOperationsInput | $Enums.YearLevel
    shift?: EnumShiftFieldUpdateOperationsInput | $Enums.Shift
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    courseDisciplines?: CourseDisciplineUpdateManyWithoutCourseNestedInput
    coursePricing?: CoursePricingUpdateOneWithoutCourseNestedInput
    academicDepartment?: AcademicDepartmentUpdateOneRequiredWithoutCoursesNestedInput
    studentCourses?: StudentEnrolledCourseUpdateManyWithoutCourseNestedInput
    preRequisite?: CourseToPreRequisiteUpdateManyWithoutCourseNestedInput
    faculties?: CourseFacultyUpdateManyWithoutCourseNestedInput
    offeredCourses?: OfferedCourseUpdateManyWithoutCourseNestedInput
  }

  export type CourseUncheckedUpdateWithoutPreRequisiteForInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    durationInYears?: IntFieldUpdateOperationsInput | number
    yearLevel?: EnumYearLevelFieldUpdateOperationsInput | $Enums.YearLevel
    shift?: EnumShiftFieldUpdateOperationsInput | $Enums.Shift
    academicDepartmentId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    courseDisciplines?: CourseDisciplineUncheckedUpdateManyWithoutCourseNestedInput
    coursePricing?: CoursePricingUncheckedUpdateOneWithoutCourseNestedInput
    studentCourses?: StudentEnrolledCourseUncheckedUpdateManyWithoutCourseNestedInput
    preRequisite?: CourseToPreRequisiteUncheckedUpdateManyWithoutCourseNestedInput
    faculties?: CourseFacultyUncheckedUpdateManyWithoutCourseNestedInput
    offeredCourses?: OfferedCourseUncheckedUpdateManyWithoutCourseNestedInput
  }

  export type CourseCreateWithoutFacultiesInput = {
    id?: string
    title: string
    code: string
    durationInYears: number
    yearLevel?: $Enums.YearLevel
    shift?: $Enums.Shift
    createdAt?: Date | string
    updatedAt?: Date | string
    courseDisciplines?: CourseDisciplineCreateNestedManyWithoutCourseInput
    coursePricing?: CoursePricingCreateNestedOneWithoutCourseInput
    academicDepartment: AcademicDepartmentCreateNestedOneWithoutCoursesInput
    studentCourses?: StudentEnrolledCourseCreateNestedManyWithoutCourseInput
    preRequisite?: CourseToPreRequisiteCreateNestedManyWithoutCourseInput
    preRequisiteFor?: CourseToPreRequisiteCreateNestedManyWithoutPreRequisiteInput
    offeredCourses?: OfferedCourseCreateNestedManyWithoutCourseInput
  }

  export type CourseUncheckedCreateWithoutFacultiesInput = {
    id?: string
    title: string
    code: string
    durationInYears: number
    yearLevel?: $Enums.YearLevel
    shift?: $Enums.Shift
    academicDepartmentId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    courseDisciplines?: CourseDisciplineUncheckedCreateNestedManyWithoutCourseInput
    coursePricing?: CoursePricingUncheckedCreateNestedOneWithoutCourseInput
    studentCourses?: StudentEnrolledCourseUncheckedCreateNestedManyWithoutCourseInput
    preRequisite?: CourseToPreRequisiteUncheckedCreateNestedManyWithoutCourseInput
    preRequisiteFor?: CourseToPreRequisiteUncheckedCreateNestedManyWithoutPreRequisiteInput
    offeredCourses?: OfferedCourseUncheckedCreateNestedManyWithoutCourseInput
  }

  export type CourseCreateOrConnectWithoutFacultiesInput = {
    where: CourseWhereUniqueInput
    create: XOR<CourseCreateWithoutFacultiesInput, CourseUncheckedCreateWithoutFacultiesInput>
  }

  export type FacultyCreateWithoutCoursesInput = {
    id?: string
    facultyId: string
    firstName: string
    middleName?: string | null
    lastName: string
    profileImage?: string | null
    email?: string | null
    contactNo?: string | null
    shift?: $Enums.Shift
    gender: string
    designation: string
    password: string
    createdAt?: Date | string
    updatedAt?: Date | string
    academicDepartment: AcademicDepartmentCreateNestedOneWithoutFacultiesInput
    academicFaculty: AcademicFacultyCreateNestedOneWithoutFacultiesInput
    offeredCourseClassSchedules?: OfferedCourseClassScheduleCreateNestedManyWithoutFacultyInput
  }

  export type FacultyUncheckedCreateWithoutCoursesInput = {
    id?: string
    facultyId: string
    firstName: string
    middleName?: string | null
    lastName: string
    profileImage?: string | null
    email?: string | null
    contactNo?: string | null
    shift?: $Enums.Shift
    gender: string
    designation: string
    password: string
    academicFacultyId: string
    academicDepartmentId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    offeredCourseClassSchedules?: OfferedCourseClassScheduleUncheckedCreateNestedManyWithoutFacultyInput
  }

  export type FacultyCreateOrConnectWithoutCoursesInput = {
    where: FacultyWhereUniqueInput
    create: XOR<FacultyCreateWithoutCoursesInput, FacultyUncheckedCreateWithoutCoursesInput>
  }

  export type CourseUpsertWithoutFacultiesInput = {
    update: XOR<CourseUpdateWithoutFacultiesInput, CourseUncheckedUpdateWithoutFacultiesInput>
    create: XOR<CourseCreateWithoutFacultiesInput, CourseUncheckedCreateWithoutFacultiesInput>
    where?: CourseWhereInput
  }

  export type CourseUpdateToOneWithWhereWithoutFacultiesInput = {
    where?: CourseWhereInput
    data: XOR<CourseUpdateWithoutFacultiesInput, CourseUncheckedUpdateWithoutFacultiesInput>
  }

  export type CourseUpdateWithoutFacultiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    durationInYears?: IntFieldUpdateOperationsInput | number
    yearLevel?: EnumYearLevelFieldUpdateOperationsInput | $Enums.YearLevel
    shift?: EnumShiftFieldUpdateOperationsInput | $Enums.Shift
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    courseDisciplines?: CourseDisciplineUpdateManyWithoutCourseNestedInput
    coursePricing?: CoursePricingUpdateOneWithoutCourseNestedInput
    academicDepartment?: AcademicDepartmentUpdateOneRequiredWithoutCoursesNestedInput
    studentCourses?: StudentEnrolledCourseUpdateManyWithoutCourseNestedInput
    preRequisite?: CourseToPreRequisiteUpdateManyWithoutCourseNestedInput
    preRequisiteFor?: CourseToPreRequisiteUpdateManyWithoutPreRequisiteNestedInput
    offeredCourses?: OfferedCourseUpdateManyWithoutCourseNestedInput
  }

  export type CourseUncheckedUpdateWithoutFacultiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    durationInYears?: IntFieldUpdateOperationsInput | number
    yearLevel?: EnumYearLevelFieldUpdateOperationsInput | $Enums.YearLevel
    shift?: EnumShiftFieldUpdateOperationsInput | $Enums.Shift
    academicDepartmentId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    courseDisciplines?: CourseDisciplineUncheckedUpdateManyWithoutCourseNestedInput
    coursePricing?: CoursePricingUncheckedUpdateOneWithoutCourseNestedInput
    studentCourses?: StudentEnrolledCourseUncheckedUpdateManyWithoutCourseNestedInput
    preRequisite?: CourseToPreRequisiteUncheckedUpdateManyWithoutCourseNestedInput
    preRequisiteFor?: CourseToPreRequisiteUncheckedUpdateManyWithoutPreRequisiteNestedInput
    offeredCourses?: OfferedCourseUncheckedUpdateManyWithoutCourseNestedInput
  }

  export type FacultyUpsertWithoutCoursesInput = {
    update: XOR<FacultyUpdateWithoutCoursesInput, FacultyUncheckedUpdateWithoutCoursesInput>
    create: XOR<FacultyCreateWithoutCoursesInput, FacultyUncheckedCreateWithoutCoursesInput>
    where?: FacultyWhereInput
  }

  export type FacultyUpdateToOneWithWhereWithoutCoursesInput = {
    where?: FacultyWhereInput
    data: XOR<FacultyUpdateWithoutCoursesInput, FacultyUncheckedUpdateWithoutCoursesInput>
  }

  export type FacultyUpdateWithoutCoursesInput = {
    id?: StringFieldUpdateOperationsInput | string
    facultyId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    contactNo?: NullableStringFieldUpdateOperationsInput | string | null
    shift?: EnumShiftFieldUpdateOperationsInput | $Enums.Shift
    gender?: StringFieldUpdateOperationsInput | string
    designation?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    academicDepartment?: AcademicDepartmentUpdateOneRequiredWithoutFacultiesNestedInput
    academicFaculty?: AcademicFacultyUpdateOneRequiredWithoutFacultiesNestedInput
    offeredCourseClassSchedules?: OfferedCourseClassScheduleUpdateManyWithoutFacultyNestedInput
  }

  export type FacultyUncheckedUpdateWithoutCoursesInput = {
    id?: StringFieldUpdateOperationsInput | string
    facultyId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    contactNo?: NullableStringFieldUpdateOperationsInput | string | null
    shift?: EnumShiftFieldUpdateOperationsInput | $Enums.Shift
    gender?: StringFieldUpdateOperationsInput | string
    designation?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    academicFacultyId?: StringFieldUpdateOperationsInput | string
    academicDepartmentId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    offeredCourseClassSchedules?: OfferedCourseClassScheduleUncheckedUpdateManyWithoutFacultyNestedInput
  }

  export type AcademicSemesterCreateWithoutSemesterRegistrationsInput = {
    id?: string
    title: string
    year: string
    code: string
    startMonth: string
    endMonth: string
    isCurrent?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    courseDisciplines?: CourseDisciplineCreateNestedManyWithoutSemesterInput
    students?: StudentCreateNestedManyWithoutAcademicSemesterInput
    studentEnrolledCourses?: StudentEnrolledCourseCreateNestedManyWithoutAcademicSemesterInput
    studentEnrolledCourseMarks?: StudentEnrolledCourseMarkCreateNestedManyWithoutAcademicSemesterInput
    studentSemesterPayments?: StudentSemesterPaymentCreateNestedManyWithoutAcademicSemesterInput
    StudentCarriedCourse?: StudentCarriedCourseCreateNestedManyWithoutSemesterInput
  }

  export type AcademicSemesterUncheckedCreateWithoutSemesterRegistrationsInput = {
    id?: string
    title: string
    year: string
    code: string
    startMonth: string
    endMonth: string
    isCurrent?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    courseDisciplines?: CourseDisciplineUncheckedCreateNestedManyWithoutSemesterInput
    students?: StudentUncheckedCreateNestedManyWithoutAcademicSemesterInput
    studentEnrolledCourses?: StudentEnrolledCourseUncheckedCreateNestedManyWithoutAcademicSemesterInput
    studentEnrolledCourseMarks?: StudentEnrolledCourseMarkUncheckedCreateNestedManyWithoutAcademicSemesterInput
    studentSemesterPayments?: StudentSemesterPaymentUncheckedCreateNestedManyWithoutAcademicSemesterInput
    StudentCarriedCourse?: StudentCarriedCourseUncheckedCreateNestedManyWithoutSemesterInput
  }

  export type AcademicSemesterCreateOrConnectWithoutSemesterRegistrationsInput = {
    where: AcademicSemesterWhereUniqueInput
    create: XOR<AcademicSemesterCreateWithoutSemesterRegistrationsInput, AcademicSemesterUncheckedCreateWithoutSemesterRegistrationsInput>
  }

  export type OfferedCourseCreateWithoutSemesterRegistrationInput = {
    id?: string
    suspendGrade?: number
    academicDepartment: AcademicDepartmentCreateNestedOneWithoutOfferedCoursesInput
    course: CourseCreateNestedOneWithoutOfferedCoursesInput
    offeredCourseSections?: OfferedCourseSectionCreateNestedManyWithoutOfferedCourseInput
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseCreateNestedManyWithoutOfferedCourseInput
  }

  export type OfferedCourseUncheckedCreateWithoutSemesterRegistrationInput = {
    id?: string
    academicDepartmentId: string
    courseId: string
    suspendGrade?: number
    offeredCourseSections?: OfferedCourseSectionUncheckedCreateNestedManyWithoutOfferedCourseInput
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseUncheckedCreateNestedManyWithoutOfferedCourseInput
  }

  export type OfferedCourseCreateOrConnectWithoutSemesterRegistrationInput = {
    where: OfferedCourseWhereUniqueInput
    create: XOR<OfferedCourseCreateWithoutSemesterRegistrationInput, OfferedCourseUncheckedCreateWithoutSemesterRegistrationInput>
  }

  export type OfferedCourseCreateManySemesterRegistrationInputEnvelope = {
    data: OfferedCourseCreateManySemesterRegistrationInput | OfferedCourseCreateManySemesterRegistrationInput[]
    skipDuplicates?: boolean
  }

  export type OfferedCourseSectionCreateWithoutSemesterRegistrationInput = {
    id?: string
    title: string
    maxCapacity?: number
    currentlyEnrolledStudent?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    offeredCourse: OfferedCourseCreateNestedOneWithoutOfferedCourseSectionsInput
    offeredCourseClassSchedules?: OfferedCourseClassScheduleCreateNestedManyWithoutOfferedCourseSectionInput
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseCreateNestedManyWithoutOfferedCourseSectionInput
  }

  export type OfferedCourseSectionUncheckedCreateWithoutSemesterRegistrationInput = {
    id?: string
    title: string
    maxCapacity?: number
    currentlyEnrolledStudent?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    offeredCourseId: string
    offeredCourseClassSchedules?: OfferedCourseClassScheduleUncheckedCreateNestedManyWithoutOfferedCourseSectionInput
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseUncheckedCreateNestedManyWithoutOfferedCourseSectionInput
  }

  export type OfferedCourseSectionCreateOrConnectWithoutSemesterRegistrationInput = {
    where: OfferedCourseSectionWhereUniqueInput
    create: XOR<OfferedCourseSectionCreateWithoutSemesterRegistrationInput, OfferedCourseSectionUncheckedCreateWithoutSemesterRegistrationInput>
  }

  export type OfferedCourseSectionCreateManySemesterRegistrationInputEnvelope = {
    data: OfferedCourseSectionCreateManySemesterRegistrationInput | OfferedCourseSectionCreateManySemesterRegistrationInput[]
    skipDuplicates?: boolean
  }

  export type OfferedCourseClassScheduleCreateWithoutSemesterRegistrationInput = {
    id?: string
    startTime: string
    endTime: string
    dayOfWeek?: $Enums.WeekDays
    createdAt?: Date | string
    updatedAt?: Date | string
    offeredCourseSection: OfferedCourseSectionCreateNestedOneWithoutOfferedCourseClassSchedulesInput
    room: RoomCreateNestedOneWithoutOfferedCourseClassSchedulesInput
    faculty: FacultyCreateNestedOneWithoutOfferedCourseClassSchedulesInput
  }

  export type OfferedCourseClassScheduleUncheckedCreateWithoutSemesterRegistrationInput = {
    id?: string
    startTime: string
    endTime: string
    dayOfWeek?: $Enums.WeekDays
    createdAt?: Date | string
    updatedAt?: Date | string
    offeredCourseSectionId: string
    roomId: string
    facultyId: string
  }

  export type OfferedCourseClassScheduleCreateOrConnectWithoutSemesterRegistrationInput = {
    where: OfferedCourseClassScheduleWhereUniqueInput
    create: XOR<OfferedCourseClassScheduleCreateWithoutSemesterRegistrationInput, OfferedCourseClassScheduleUncheckedCreateWithoutSemesterRegistrationInput>
  }

  export type OfferedCourseClassScheduleCreateManySemesterRegistrationInputEnvelope = {
    data: OfferedCourseClassScheduleCreateManySemesterRegistrationInput | OfferedCourseClassScheduleCreateManySemesterRegistrationInput[]
    skipDuplicates?: boolean
  }

  export type StudentSemesterRegistrationCreateWithoutSemesterRegistrationInput = {
    id?: string
    isConfirmed?: boolean | null
    totalCreditsTaken?: number | null
    paymentRecipt?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    student: StudentCreateNestedOneWithoutStudentSemesterRegistrationsInput
  }

  export type StudentSemesterRegistrationUncheckedCreateWithoutSemesterRegistrationInput = {
    id?: string
    isConfirmed?: boolean | null
    totalCreditsTaken?: number | null
    paymentRecipt?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    studentId: string
  }

  export type StudentSemesterRegistrationCreateOrConnectWithoutSemesterRegistrationInput = {
    where: StudentSemesterRegistrationWhereUniqueInput
    create: XOR<StudentSemesterRegistrationCreateWithoutSemesterRegistrationInput, StudentSemesterRegistrationUncheckedCreateWithoutSemesterRegistrationInput>
  }

  export type StudentSemesterRegistrationCreateManySemesterRegistrationInputEnvelope = {
    data: StudentSemesterRegistrationCreateManySemesterRegistrationInput | StudentSemesterRegistrationCreateManySemesterRegistrationInput[]
    skipDuplicates?: boolean
  }

  export type StudentSemesterRegistrationCourseCreateWithoutSemesterRegistrationInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    student: StudentCreateNestedOneWithoutStudentSemesterRegistrationCoursesInput
    offeredCourse: OfferedCourseCreateNestedOneWithoutStudentSemesterRegistrationCoursesInput
    offeredCourseSection: OfferedCourseSectionCreateNestedOneWithoutStudentSemesterRegistrationCoursesInput
  }

  export type StudentSemesterRegistrationCourseUncheckedCreateWithoutSemesterRegistrationInput = {
    studentId: string
    offeredCourseId: string
    offeredCourseSectionId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StudentSemesterRegistrationCourseCreateOrConnectWithoutSemesterRegistrationInput = {
    where: StudentSemesterRegistrationCourseWhereUniqueInput
    create: XOR<StudentSemesterRegistrationCourseCreateWithoutSemesterRegistrationInput, StudentSemesterRegistrationCourseUncheckedCreateWithoutSemesterRegistrationInput>
  }

  export type StudentSemesterRegistrationCourseCreateManySemesterRegistrationInputEnvelope = {
    data: StudentSemesterRegistrationCourseCreateManySemesterRegistrationInput | StudentSemesterRegistrationCourseCreateManySemesterRegistrationInput[]
    skipDuplicates?: boolean
  }

  export type AcademicSemesterUpsertWithoutSemesterRegistrationsInput = {
    update: XOR<AcademicSemesterUpdateWithoutSemesterRegistrationsInput, AcademicSemesterUncheckedUpdateWithoutSemesterRegistrationsInput>
    create: XOR<AcademicSemesterCreateWithoutSemesterRegistrationsInput, AcademicSemesterUncheckedCreateWithoutSemesterRegistrationsInput>
    where?: AcademicSemesterWhereInput
  }

  export type AcademicSemesterUpdateToOneWithWhereWithoutSemesterRegistrationsInput = {
    where?: AcademicSemesterWhereInput
    data: XOR<AcademicSemesterUpdateWithoutSemesterRegistrationsInput, AcademicSemesterUncheckedUpdateWithoutSemesterRegistrationsInput>
  }

  export type AcademicSemesterUpdateWithoutSemesterRegistrationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    year?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    startMonth?: StringFieldUpdateOperationsInput | string
    endMonth?: StringFieldUpdateOperationsInput | string
    isCurrent?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    courseDisciplines?: CourseDisciplineUpdateManyWithoutSemesterNestedInput
    students?: StudentUpdateManyWithoutAcademicSemesterNestedInput
    studentEnrolledCourses?: StudentEnrolledCourseUpdateManyWithoutAcademicSemesterNestedInput
    studentEnrolledCourseMarks?: StudentEnrolledCourseMarkUpdateManyWithoutAcademicSemesterNestedInput
    studentSemesterPayments?: StudentSemesterPaymentUpdateManyWithoutAcademicSemesterNestedInput
    StudentCarriedCourse?: StudentCarriedCourseUpdateManyWithoutSemesterNestedInput
  }

  export type AcademicSemesterUncheckedUpdateWithoutSemesterRegistrationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    year?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    startMonth?: StringFieldUpdateOperationsInput | string
    endMonth?: StringFieldUpdateOperationsInput | string
    isCurrent?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    courseDisciplines?: CourseDisciplineUncheckedUpdateManyWithoutSemesterNestedInput
    students?: StudentUncheckedUpdateManyWithoutAcademicSemesterNestedInput
    studentEnrolledCourses?: StudentEnrolledCourseUncheckedUpdateManyWithoutAcademicSemesterNestedInput
    studentEnrolledCourseMarks?: StudentEnrolledCourseMarkUncheckedUpdateManyWithoutAcademicSemesterNestedInput
    studentSemesterPayments?: StudentSemesterPaymentUncheckedUpdateManyWithoutAcademicSemesterNestedInput
    StudentCarriedCourse?: StudentCarriedCourseUncheckedUpdateManyWithoutSemesterNestedInput
  }

  export type OfferedCourseUpsertWithWhereUniqueWithoutSemesterRegistrationInput = {
    where: OfferedCourseWhereUniqueInput
    update: XOR<OfferedCourseUpdateWithoutSemesterRegistrationInput, OfferedCourseUncheckedUpdateWithoutSemesterRegistrationInput>
    create: XOR<OfferedCourseCreateWithoutSemesterRegistrationInput, OfferedCourseUncheckedCreateWithoutSemesterRegistrationInput>
  }

  export type OfferedCourseUpdateWithWhereUniqueWithoutSemesterRegistrationInput = {
    where: OfferedCourseWhereUniqueInput
    data: XOR<OfferedCourseUpdateWithoutSemesterRegistrationInput, OfferedCourseUncheckedUpdateWithoutSemesterRegistrationInput>
  }

  export type OfferedCourseUpdateManyWithWhereWithoutSemesterRegistrationInput = {
    where: OfferedCourseScalarWhereInput
    data: XOR<OfferedCourseUpdateManyMutationInput, OfferedCourseUncheckedUpdateManyWithoutSemesterRegistrationInput>
  }

  export type OfferedCourseSectionUpsertWithWhereUniqueWithoutSemesterRegistrationInput = {
    where: OfferedCourseSectionWhereUniqueInput
    update: XOR<OfferedCourseSectionUpdateWithoutSemesterRegistrationInput, OfferedCourseSectionUncheckedUpdateWithoutSemesterRegistrationInput>
    create: XOR<OfferedCourseSectionCreateWithoutSemesterRegistrationInput, OfferedCourseSectionUncheckedCreateWithoutSemesterRegistrationInput>
  }

  export type OfferedCourseSectionUpdateWithWhereUniqueWithoutSemesterRegistrationInput = {
    where: OfferedCourseSectionWhereUniqueInput
    data: XOR<OfferedCourseSectionUpdateWithoutSemesterRegistrationInput, OfferedCourseSectionUncheckedUpdateWithoutSemesterRegistrationInput>
  }

  export type OfferedCourseSectionUpdateManyWithWhereWithoutSemesterRegistrationInput = {
    where: OfferedCourseSectionScalarWhereInput
    data: XOR<OfferedCourseSectionUpdateManyMutationInput, OfferedCourseSectionUncheckedUpdateManyWithoutSemesterRegistrationInput>
  }

  export type OfferedCourseSectionScalarWhereInput = {
    AND?: OfferedCourseSectionScalarWhereInput | OfferedCourseSectionScalarWhereInput[]
    OR?: OfferedCourseSectionScalarWhereInput[]
    NOT?: OfferedCourseSectionScalarWhereInput | OfferedCourseSectionScalarWhereInput[]
    id?: StringFilter<"OfferedCourseSection"> | string
    title?: StringFilter<"OfferedCourseSection"> | string
    maxCapacity?: IntFilter<"OfferedCourseSection"> | number
    currentlyEnrolledStudent?: IntFilter<"OfferedCourseSection"> | number
    createdAt?: DateTimeFilter<"OfferedCourseSection"> | Date | string
    updatedAt?: DateTimeFilter<"OfferedCourseSection"> | Date | string
    semesterRegistrationId?: StringFilter<"OfferedCourseSection"> | string
    offeredCourseId?: StringFilter<"OfferedCourseSection"> | string
  }

  export type OfferedCourseClassScheduleUpsertWithWhereUniqueWithoutSemesterRegistrationInput = {
    where: OfferedCourseClassScheduleWhereUniqueInput
    update: XOR<OfferedCourseClassScheduleUpdateWithoutSemesterRegistrationInput, OfferedCourseClassScheduleUncheckedUpdateWithoutSemesterRegistrationInput>
    create: XOR<OfferedCourseClassScheduleCreateWithoutSemesterRegistrationInput, OfferedCourseClassScheduleUncheckedCreateWithoutSemesterRegistrationInput>
  }

  export type OfferedCourseClassScheduleUpdateWithWhereUniqueWithoutSemesterRegistrationInput = {
    where: OfferedCourseClassScheduleWhereUniqueInput
    data: XOR<OfferedCourseClassScheduleUpdateWithoutSemesterRegistrationInput, OfferedCourseClassScheduleUncheckedUpdateWithoutSemesterRegistrationInput>
  }

  export type OfferedCourseClassScheduleUpdateManyWithWhereWithoutSemesterRegistrationInput = {
    where: OfferedCourseClassScheduleScalarWhereInput
    data: XOR<OfferedCourseClassScheduleUpdateManyMutationInput, OfferedCourseClassScheduleUncheckedUpdateManyWithoutSemesterRegistrationInput>
  }

  export type StudentSemesterRegistrationUpsertWithWhereUniqueWithoutSemesterRegistrationInput = {
    where: StudentSemesterRegistrationWhereUniqueInput
    update: XOR<StudentSemesterRegistrationUpdateWithoutSemesterRegistrationInput, StudentSemesterRegistrationUncheckedUpdateWithoutSemesterRegistrationInput>
    create: XOR<StudentSemesterRegistrationCreateWithoutSemesterRegistrationInput, StudentSemesterRegistrationUncheckedCreateWithoutSemesterRegistrationInput>
  }

  export type StudentSemesterRegistrationUpdateWithWhereUniqueWithoutSemesterRegistrationInput = {
    where: StudentSemesterRegistrationWhereUniqueInput
    data: XOR<StudentSemesterRegistrationUpdateWithoutSemesterRegistrationInput, StudentSemesterRegistrationUncheckedUpdateWithoutSemesterRegistrationInput>
  }

  export type StudentSemesterRegistrationUpdateManyWithWhereWithoutSemesterRegistrationInput = {
    where: StudentSemesterRegistrationScalarWhereInput
    data: XOR<StudentSemesterRegistrationUpdateManyMutationInput, StudentSemesterRegistrationUncheckedUpdateManyWithoutSemesterRegistrationInput>
  }

  export type StudentSemesterRegistrationCourseUpsertWithWhereUniqueWithoutSemesterRegistrationInput = {
    where: StudentSemesterRegistrationCourseWhereUniqueInput
    update: XOR<StudentSemesterRegistrationCourseUpdateWithoutSemesterRegistrationInput, StudentSemesterRegistrationCourseUncheckedUpdateWithoutSemesterRegistrationInput>
    create: XOR<StudentSemesterRegistrationCourseCreateWithoutSemesterRegistrationInput, StudentSemesterRegistrationCourseUncheckedCreateWithoutSemesterRegistrationInput>
  }

  export type StudentSemesterRegistrationCourseUpdateWithWhereUniqueWithoutSemesterRegistrationInput = {
    where: StudentSemesterRegistrationCourseWhereUniqueInput
    data: XOR<StudentSemesterRegistrationCourseUpdateWithoutSemesterRegistrationInput, StudentSemesterRegistrationCourseUncheckedUpdateWithoutSemesterRegistrationInput>
  }

  export type StudentSemesterRegistrationCourseUpdateManyWithWhereWithoutSemesterRegistrationInput = {
    where: StudentSemesterRegistrationCourseScalarWhereInput
    data: XOR<StudentSemesterRegistrationCourseUpdateManyMutationInput, StudentSemesterRegistrationCourseUncheckedUpdateManyWithoutSemesterRegistrationInput>
  }

  export type ExameFaseCreateWithoutRegistrationsInput = {
    id?: string
    name: string
    ordem: number
    startDate: Date | string
    endDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExameFaseUncheckedCreateWithoutRegistrationsInput = {
    id?: string
    name: string
    ordem: number
    startDate: Date | string
    endDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExameFaseCreateOrConnectWithoutRegistrationsInput = {
    where: ExameFaseWhereUniqueInput
    create: XOR<ExameFaseCreateWithoutRegistrationsInput, ExameFaseUncheckedCreateWithoutRegistrationsInput>
  }

  export type AcademicFacultyCreateWithoutAdmitionExameInput = {
    id?: string
    title: string
    createdAt?: Date | string
    updatedAt?: Date | string
    academicDepartments?: AcademicDepartmentCreateNestedManyWithoutAcademicFacultyInput
    faculties?: FacultyCreateNestedManyWithoutAcademicFacultyInput
    students?: StudentCreateNestedManyWithoutAcademicFacultyInput
    AdmitionExamePrice?: AdmitionExamePriceCreateNestedManyWithoutAcademicFacultyInput
    AdmitionExamePeriod?: AdmitionExamePeriodCreateNestedManyWithoutAcademicFacultyInput
  }

  export type AcademicFacultyUncheckedCreateWithoutAdmitionExameInput = {
    id?: string
    title: string
    createdAt?: Date | string
    updatedAt?: Date | string
    academicDepartments?: AcademicDepartmentUncheckedCreateNestedManyWithoutAcademicFacultyInput
    faculties?: FacultyUncheckedCreateNestedManyWithoutAcademicFacultyInput
    students?: StudentUncheckedCreateNestedManyWithoutAcademicFacultyInput
    AdmitionExamePrice?: AdmitionExamePriceUncheckedCreateNestedManyWithoutAcademicFacultyInput
    AdmitionExamePeriod?: AdmitionExamePeriodUncheckedCreateNestedManyWithoutAcademicFacultyInput
  }

  export type AcademicFacultyCreateOrConnectWithoutAdmitionExameInput = {
    where: AcademicFacultyWhereUniqueInput
    create: XOR<AcademicFacultyCreateWithoutAdmitionExameInput, AcademicFacultyUncheckedCreateWithoutAdmitionExameInput>
  }

  export type StudentCreateWithoutAdmissionRegistrationInput = {
    id?: string
    studentId: string
    studentType?: $Enums.StudentType
    firstName: string
    middleName?: string | null
    lastName: string
    profileImage?: string | null
    email?: string | null
    contactNo?: string | null
    gender: string
    isWoker?: boolean
    shift?: $Enums.Shift
    yearLevel?: $Enums.YearLevel
    isActive?: boolean
    password: string
    gradeDeclarationFile: string
    biFile: string
    presentAddress: string
    permanentAddress?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    academicFaculty: AcademicFacultyCreateNestedOneWithoutStudentsInput
    academicDepartment: AcademicDepartmentCreateNestedOneWithoutStudentsInput
    academicSemester: AcademicSemesterCreateNestedOneWithoutStudentsInput
    studentSemesterRegistrations?: StudentSemesterRegistrationCreateNestedManyWithoutStudentInput
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseCreateNestedManyWithoutStudentInput
    studentEnrolledCourses?: StudentEnrolledCourseCreateNestedManyWithoutStudentInput
    studentEnrolledCourseMarks?: StudentEnrolledCourseMarkCreateNestedManyWithoutStudentInput
    studentSemesterPayments?: StudentSemesterPaymentCreateNestedManyWithoutStudentInput
    studentAcademicInfos?: StudentAcademicInfoCreateNestedManyWithoutStudentInput
    StudentCarriedCourse?: StudentCarriedCourseCreateNestedManyWithoutStudentInput
  }

  export type StudentUncheckedCreateWithoutAdmissionRegistrationInput = {
    id?: string
    studentId: string
    studentType?: $Enums.StudentType
    firstName: string
    middleName?: string | null
    lastName: string
    profileImage?: string | null
    email?: string | null
    contactNo?: string | null
    gender: string
    isWoker?: boolean
    shift?: $Enums.Shift
    yearLevel?: $Enums.YearLevel
    isActive?: boolean
    password: string
    gradeDeclarationFile: string
    biFile: string
    presentAddress: string
    permanentAddress?: string | null
    academicSemesterId: string
    academicFacultyId: string
    academicDepartmentId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    studentSemesterRegistrations?: StudentSemesterRegistrationUncheckedCreateNestedManyWithoutStudentInput
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseUncheckedCreateNestedManyWithoutStudentInput
    studentEnrolledCourses?: StudentEnrolledCourseUncheckedCreateNestedManyWithoutStudentInput
    studentEnrolledCourseMarks?: StudentEnrolledCourseMarkUncheckedCreateNestedManyWithoutStudentInput
    studentSemesterPayments?: StudentSemesterPaymentUncheckedCreateNestedManyWithoutStudentInput
    studentAcademicInfos?: StudentAcademicInfoUncheckedCreateNestedManyWithoutStudentInput
    StudentCarriedCourse?: StudentCarriedCourseUncheckedCreateNestedManyWithoutStudentInput
  }

  export type StudentCreateOrConnectWithoutAdmissionRegistrationInput = {
    where: StudentWhereUniqueInput
    create: XOR<StudentCreateWithoutAdmissionRegistrationInput, StudentUncheckedCreateWithoutAdmissionRegistrationInput>
  }

  export type ExameFaseUpsertWithoutRegistrationsInput = {
    update: XOR<ExameFaseUpdateWithoutRegistrationsInput, ExameFaseUncheckedUpdateWithoutRegistrationsInput>
    create: XOR<ExameFaseCreateWithoutRegistrationsInput, ExameFaseUncheckedCreateWithoutRegistrationsInput>
    where?: ExameFaseWhereInput
  }

  export type ExameFaseUpdateToOneWithWhereWithoutRegistrationsInput = {
    where?: ExameFaseWhereInput
    data: XOR<ExameFaseUpdateWithoutRegistrationsInput, ExameFaseUncheckedUpdateWithoutRegistrationsInput>
  }

  export type ExameFaseUpdateWithoutRegistrationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    ordem?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExameFaseUncheckedUpdateWithoutRegistrationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    ordem?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AcademicFacultyUpsertWithoutAdmitionExameInput = {
    update: XOR<AcademicFacultyUpdateWithoutAdmitionExameInput, AcademicFacultyUncheckedUpdateWithoutAdmitionExameInput>
    create: XOR<AcademicFacultyCreateWithoutAdmitionExameInput, AcademicFacultyUncheckedCreateWithoutAdmitionExameInput>
    where?: AcademicFacultyWhereInput
  }

  export type AcademicFacultyUpdateToOneWithWhereWithoutAdmitionExameInput = {
    where?: AcademicFacultyWhereInput
    data: XOR<AcademicFacultyUpdateWithoutAdmitionExameInput, AcademicFacultyUncheckedUpdateWithoutAdmitionExameInput>
  }

  export type AcademicFacultyUpdateWithoutAdmitionExameInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    academicDepartments?: AcademicDepartmentUpdateManyWithoutAcademicFacultyNestedInput
    faculties?: FacultyUpdateManyWithoutAcademicFacultyNestedInput
    students?: StudentUpdateManyWithoutAcademicFacultyNestedInput
    AdmitionExamePrice?: AdmitionExamePriceUpdateManyWithoutAcademicFacultyNestedInput
    AdmitionExamePeriod?: AdmitionExamePeriodUpdateManyWithoutAcademicFacultyNestedInput
  }

  export type AcademicFacultyUncheckedUpdateWithoutAdmitionExameInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    academicDepartments?: AcademicDepartmentUncheckedUpdateManyWithoutAcademicFacultyNestedInput
    faculties?: FacultyUncheckedUpdateManyWithoutAcademicFacultyNestedInput
    students?: StudentUncheckedUpdateManyWithoutAcademicFacultyNestedInput
    AdmitionExamePrice?: AdmitionExamePriceUncheckedUpdateManyWithoutAcademicFacultyNestedInput
    AdmitionExamePeriod?: AdmitionExamePeriodUncheckedUpdateManyWithoutAcademicFacultyNestedInput
  }

  export type StudentUpsertWithoutAdmissionRegistrationInput = {
    update: XOR<StudentUpdateWithoutAdmissionRegistrationInput, StudentUncheckedUpdateWithoutAdmissionRegistrationInput>
    create: XOR<StudentCreateWithoutAdmissionRegistrationInput, StudentUncheckedCreateWithoutAdmissionRegistrationInput>
    where?: StudentWhereInput
  }

  export type StudentUpdateToOneWithWhereWithoutAdmissionRegistrationInput = {
    where?: StudentWhereInput
    data: XOR<StudentUpdateWithoutAdmissionRegistrationInput, StudentUncheckedUpdateWithoutAdmissionRegistrationInput>
  }

  export type StudentUpdateWithoutAdmissionRegistrationInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    studentType?: EnumStudentTypeFieldUpdateOperationsInput | $Enums.StudentType
    firstName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    contactNo?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: StringFieldUpdateOperationsInput | string
    isWoker?: BoolFieldUpdateOperationsInput | boolean
    shift?: EnumShiftFieldUpdateOperationsInput | $Enums.Shift
    yearLevel?: EnumYearLevelFieldUpdateOperationsInput | $Enums.YearLevel
    isActive?: BoolFieldUpdateOperationsInput | boolean
    password?: StringFieldUpdateOperationsInput | string
    gradeDeclarationFile?: StringFieldUpdateOperationsInput | string
    biFile?: StringFieldUpdateOperationsInput | string
    presentAddress?: StringFieldUpdateOperationsInput | string
    permanentAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    academicFaculty?: AcademicFacultyUpdateOneRequiredWithoutStudentsNestedInput
    academicDepartment?: AcademicDepartmentUpdateOneRequiredWithoutStudentsNestedInput
    academicSemester?: AcademicSemesterUpdateOneRequiredWithoutStudentsNestedInput
    studentSemesterRegistrations?: StudentSemesterRegistrationUpdateManyWithoutStudentNestedInput
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseUpdateManyWithoutStudentNestedInput
    studentEnrolledCourses?: StudentEnrolledCourseUpdateManyWithoutStudentNestedInput
    studentEnrolledCourseMarks?: StudentEnrolledCourseMarkUpdateManyWithoutStudentNestedInput
    studentSemesterPayments?: StudentSemesterPaymentUpdateManyWithoutStudentNestedInput
    studentAcademicInfos?: StudentAcademicInfoUpdateManyWithoutStudentNestedInput
    StudentCarriedCourse?: StudentCarriedCourseUpdateManyWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateWithoutAdmissionRegistrationInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    studentType?: EnumStudentTypeFieldUpdateOperationsInput | $Enums.StudentType
    firstName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    contactNo?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: StringFieldUpdateOperationsInput | string
    isWoker?: BoolFieldUpdateOperationsInput | boolean
    shift?: EnumShiftFieldUpdateOperationsInput | $Enums.Shift
    yearLevel?: EnumYearLevelFieldUpdateOperationsInput | $Enums.YearLevel
    isActive?: BoolFieldUpdateOperationsInput | boolean
    password?: StringFieldUpdateOperationsInput | string
    gradeDeclarationFile?: StringFieldUpdateOperationsInput | string
    biFile?: StringFieldUpdateOperationsInput | string
    presentAddress?: StringFieldUpdateOperationsInput | string
    permanentAddress?: NullableStringFieldUpdateOperationsInput | string | null
    academicSemesterId?: StringFieldUpdateOperationsInput | string
    academicFacultyId?: StringFieldUpdateOperationsInput | string
    academicDepartmentId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    studentSemesterRegistrations?: StudentSemesterRegistrationUncheckedUpdateManyWithoutStudentNestedInput
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseUncheckedUpdateManyWithoutStudentNestedInput
    studentEnrolledCourses?: StudentEnrolledCourseUncheckedUpdateManyWithoutStudentNestedInput
    studentEnrolledCourseMarks?: StudentEnrolledCourseMarkUncheckedUpdateManyWithoutStudentNestedInput
    studentSemesterPayments?: StudentSemesterPaymentUncheckedUpdateManyWithoutStudentNestedInput
    studentAcademicInfos?: StudentAcademicInfoUncheckedUpdateManyWithoutStudentNestedInput
    StudentCarriedCourse?: StudentCarriedCourseUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type AcademicFacultyCreateWithoutAdmitionExamePriceInput = {
    id?: string
    title: string
    createdAt?: Date | string
    updatedAt?: Date | string
    academicDepartments?: AcademicDepartmentCreateNestedManyWithoutAcademicFacultyInput
    faculties?: FacultyCreateNestedManyWithoutAcademicFacultyInput
    students?: StudentCreateNestedManyWithoutAcademicFacultyInput
    admitionExame?: AdmitionExameRegistrationCreateNestedManyWithoutAcademicFalcultyInput
    AdmitionExamePeriod?: AdmitionExamePeriodCreateNestedManyWithoutAcademicFacultyInput
  }

  export type AcademicFacultyUncheckedCreateWithoutAdmitionExamePriceInput = {
    id?: string
    title: string
    createdAt?: Date | string
    updatedAt?: Date | string
    academicDepartments?: AcademicDepartmentUncheckedCreateNestedManyWithoutAcademicFacultyInput
    faculties?: FacultyUncheckedCreateNestedManyWithoutAcademicFacultyInput
    students?: StudentUncheckedCreateNestedManyWithoutAcademicFacultyInput
    admitionExame?: AdmitionExameRegistrationUncheckedCreateNestedManyWithoutAcademicFalcultyInput
    AdmitionExamePeriod?: AdmitionExamePeriodUncheckedCreateNestedManyWithoutAcademicFacultyInput
  }

  export type AcademicFacultyCreateOrConnectWithoutAdmitionExamePriceInput = {
    where: AcademicFacultyWhereUniqueInput
    create: XOR<AcademicFacultyCreateWithoutAdmitionExamePriceInput, AcademicFacultyUncheckedCreateWithoutAdmitionExamePriceInput>
  }

  export type AcademicFacultyUpsertWithoutAdmitionExamePriceInput = {
    update: XOR<AcademicFacultyUpdateWithoutAdmitionExamePriceInput, AcademicFacultyUncheckedUpdateWithoutAdmitionExamePriceInput>
    create: XOR<AcademicFacultyCreateWithoutAdmitionExamePriceInput, AcademicFacultyUncheckedCreateWithoutAdmitionExamePriceInput>
    where?: AcademicFacultyWhereInput
  }

  export type AcademicFacultyUpdateToOneWithWhereWithoutAdmitionExamePriceInput = {
    where?: AcademicFacultyWhereInput
    data: XOR<AcademicFacultyUpdateWithoutAdmitionExamePriceInput, AcademicFacultyUncheckedUpdateWithoutAdmitionExamePriceInput>
  }

  export type AcademicFacultyUpdateWithoutAdmitionExamePriceInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    academicDepartments?: AcademicDepartmentUpdateManyWithoutAcademicFacultyNestedInput
    faculties?: FacultyUpdateManyWithoutAcademicFacultyNestedInput
    students?: StudentUpdateManyWithoutAcademicFacultyNestedInput
    admitionExame?: AdmitionExameRegistrationUpdateManyWithoutAcademicFalcultyNestedInput
    AdmitionExamePeriod?: AdmitionExamePeriodUpdateManyWithoutAcademicFacultyNestedInput
  }

  export type AcademicFacultyUncheckedUpdateWithoutAdmitionExamePriceInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    academicDepartments?: AcademicDepartmentUncheckedUpdateManyWithoutAcademicFacultyNestedInput
    faculties?: FacultyUncheckedUpdateManyWithoutAcademicFacultyNestedInput
    students?: StudentUncheckedUpdateManyWithoutAcademicFacultyNestedInput
    admitionExame?: AdmitionExameRegistrationUncheckedUpdateManyWithoutAcademicFalcultyNestedInput
    AdmitionExamePeriod?: AdmitionExamePeriodUncheckedUpdateManyWithoutAcademicFacultyNestedInput
  }

  export type AcademicFacultyCreateWithoutAdmitionExamePeriodInput = {
    id?: string
    title: string
    createdAt?: Date | string
    updatedAt?: Date | string
    academicDepartments?: AcademicDepartmentCreateNestedManyWithoutAcademicFacultyInput
    faculties?: FacultyCreateNestedManyWithoutAcademicFacultyInput
    students?: StudentCreateNestedManyWithoutAcademicFacultyInput
    admitionExame?: AdmitionExameRegistrationCreateNestedManyWithoutAcademicFalcultyInput
    AdmitionExamePrice?: AdmitionExamePriceCreateNestedManyWithoutAcademicFacultyInput
  }

  export type AcademicFacultyUncheckedCreateWithoutAdmitionExamePeriodInput = {
    id?: string
    title: string
    createdAt?: Date | string
    updatedAt?: Date | string
    academicDepartments?: AcademicDepartmentUncheckedCreateNestedManyWithoutAcademicFacultyInput
    faculties?: FacultyUncheckedCreateNestedManyWithoutAcademicFacultyInput
    students?: StudentUncheckedCreateNestedManyWithoutAcademicFacultyInput
    admitionExame?: AdmitionExameRegistrationUncheckedCreateNestedManyWithoutAcademicFalcultyInput
    AdmitionExamePrice?: AdmitionExamePriceUncheckedCreateNestedManyWithoutAcademicFacultyInput
  }

  export type AcademicFacultyCreateOrConnectWithoutAdmitionExamePeriodInput = {
    where: AcademicFacultyWhereUniqueInput
    create: XOR<AcademicFacultyCreateWithoutAdmitionExamePeriodInput, AcademicFacultyUncheckedCreateWithoutAdmitionExamePeriodInput>
  }

  export type AcademicFacultyUpsertWithoutAdmitionExamePeriodInput = {
    update: XOR<AcademicFacultyUpdateWithoutAdmitionExamePeriodInput, AcademicFacultyUncheckedUpdateWithoutAdmitionExamePeriodInput>
    create: XOR<AcademicFacultyCreateWithoutAdmitionExamePeriodInput, AcademicFacultyUncheckedCreateWithoutAdmitionExamePeriodInput>
    where?: AcademicFacultyWhereInput
  }

  export type AcademicFacultyUpdateToOneWithWhereWithoutAdmitionExamePeriodInput = {
    where?: AcademicFacultyWhereInput
    data: XOR<AcademicFacultyUpdateWithoutAdmitionExamePeriodInput, AcademicFacultyUncheckedUpdateWithoutAdmitionExamePeriodInput>
  }

  export type AcademicFacultyUpdateWithoutAdmitionExamePeriodInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    academicDepartments?: AcademicDepartmentUpdateManyWithoutAcademicFacultyNestedInput
    faculties?: FacultyUpdateManyWithoutAcademicFacultyNestedInput
    students?: StudentUpdateManyWithoutAcademicFacultyNestedInput
    admitionExame?: AdmitionExameRegistrationUpdateManyWithoutAcademicFalcultyNestedInput
    AdmitionExamePrice?: AdmitionExamePriceUpdateManyWithoutAcademicFacultyNestedInput
  }

  export type AcademicFacultyUncheckedUpdateWithoutAdmitionExamePeriodInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    academicDepartments?: AcademicDepartmentUncheckedUpdateManyWithoutAcademicFacultyNestedInput
    faculties?: FacultyUncheckedUpdateManyWithoutAcademicFacultyNestedInput
    students?: StudentUncheckedUpdateManyWithoutAcademicFacultyNestedInput
    admitionExame?: AdmitionExameRegistrationUncheckedUpdateManyWithoutAcademicFalcultyNestedInput
    AdmitionExamePrice?: AdmitionExamePriceUncheckedUpdateManyWithoutAcademicFacultyNestedInput
  }

  export type AdmitionExameRegistrationCreateWithoutFaseInput = {
    id?: string
    applicantName: string
    paymentRecipt: string
    status?: $Enums.Status
    document: string
    paymentAmoute?: number | null
    aprovePayment?: boolean | null
    exameResults?: number | null
    passed?: boolean | null
    exameDate: Date | string
    rejectionReason?: string | null
    phoneNumber: string
    email: string
    createdAt?: Date | string
    updateAt?: Date | string
    academicFalculty: AcademicFacultyCreateNestedOneWithoutAdmitionExameInput
    Student?: StudentCreateNestedOneWithoutAdmissionRegistrationInput
  }

  export type AdmitionExameRegistrationUncheckedCreateWithoutFaseInput = {
    id?: string
    applicantName: string
    paymentRecipt: string
    status?: $Enums.Status
    document: string
    paymentAmoute?: number | null
    aprovePayment?: boolean | null
    exameResults?: number | null
    passed?: boolean | null
    exameDate: Date | string
    rejectionReason?: string | null
    phoneNumber: string
    email: string
    createdAt?: Date | string
    updateAt?: Date | string
    academicFalcultyId: string
    Student?: StudentUncheckedCreateNestedOneWithoutAdmissionRegistrationInput
  }

  export type AdmitionExameRegistrationCreateOrConnectWithoutFaseInput = {
    where: AdmitionExameRegistrationWhereUniqueInput
    create: XOR<AdmitionExameRegistrationCreateWithoutFaseInput, AdmitionExameRegistrationUncheckedCreateWithoutFaseInput>
  }

  export type AdmitionExameRegistrationCreateManyFaseInputEnvelope = {
    data: AdmitionExameRegistrationCreateManyFaseInput | AdmitionExameRegistrationCreateManyFaseInput[]
    skipDuplicates?: boolean
  }

  export type AdmitionExameRegistrationUpsertWithWhereUniqueWithoutFaseInput = {
    where: AdmitionExameRegistrationWhereUniqueInput
    update: XOR<AdmitionExameRegistrationUpdateWithoutFaseInput, AdmitionExameRegistrationUncheckedUpdateWithoutFaseInput>
    create: XOR<AdmitionExameRegistrationCreateWithoutFaseInput, AdmitionExameRegistrationUncheckedCreateWithoutFaseInput>
  }

  export type AdmitionExameRegistrationUpdateWithWhereUniqueWithoutFaseInput = {
    where: AdmitionExameRegistrationWhereUniqueInput
    data: XOR<AdmitionExameRegistrationUpdateWithoutFaseInput, AdmitionExameRegistrationUncheckedUpdateWithoutFaseInput>
  }

  export type AdmitionExameRegistrationUpdateManyWithWhereWithoutFaseInput = {
    where: AdmitionExameRegistrationScalarWhereInput
    data: XOR<AdmitionExameRegistrationUpdateManyMutationInput, AdmitionExameRegistrationUncheckedUpdateManyWithoutFaseInput>
  }

  export type AcademicDepartmentCreateWithoutOfferedCoursesInput = {
    id?: string
    title: string
    createdAt?: Date | string
    updatedAt?: Date | string
    academicFaculty: AcademicFacultyCreateNestedOneWithoutAcademicDepartmentsInput
    faculties?: FacultyCreateNestedManyWithoutAcademicDepartmentInput
    courses?: CourseCreateNestedManyWithoutAcademicDepartmentInput
    students?: StudentCreateNestedManyWithoutAcademicDepartmentInput
    departmentHead?: UsersCreateNestedOneWithoutAcademicDepartmentInput
    staffMembers?: UsersCreateNestedManyWithoutStaffDepartmentsInput
  }

  export type AcademicDepartmentUncheckedCreateWithoutOfferedCoursesInput = {
    id?: string
    title: string
    academicFacultyId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    departmentHeadId?: string | null
    faculties?: FacultyUncheckedCreateNestedManyWithoutAcademicDepartmentInput
    courses?: CourseUncheckedCreateNestedManyWithoutAcademicDepartmentInput
    students?: StudentUncheckedCreateNestedManyWithoutAcademicDepartmentInput
    staffMembers?: UsersUncheckedCreateNestedManyWithoutStaffDepartmentsInput
  }

  export type AcademicDepartmentCreateOrConnectWithoutOfferedCoursesInput = {
    where: AcademicDepartmentWhereUniqueInput
    create: XOR<AcademicDepartmentCreateWithoutOfferedCoursesInput, AcademicDepartmentUncheckedCreateWithoutOfferedCoursesInput>
  }

  export type SemesterRegistrationCreateWithoutOfferedCoursesInput = {
    id?: string
    startDate: Date | string
    endDate: Date | string
    status?: $Enums.SemesterRegistrationStatus | null
    createdAt?: Date | string
    updateAt?: Date | string
    academicSemester: AcademicSemesterCreateNestedOneWithoutSemesterRegistrationsInput
    offeredCourseSections?: OfferedCourseSectionCreateNestedManyWithoutSemesterRegistrationInput
    offeredCourseClassSchedules?: OfferedCourseClassScheduleCreateNestedManyWithoutSemesterRegistrationInput
    studentSemesterRegistrations?: StudentSemesterRegistrationCreateNestedManyWithoutSemesterRegistrationInput
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseCreateNestedManyWithoutSemesterRegistrationInput
  }

  export type SemesterRegistrationUncheckedCreateWithoutOfferedCoursesInput = {
    id?: string
    startDate: Date | string
    endDate: Date | string
    status?: $Enums.SemesterRegistrationStatus | null
    createdAt?: Date | string
    updateAt?: Date | string
    academicSemesterId: string
    offeredCourseSections?: OfferedCourseSectionUncheckedCreateNestedManyWithoutSemesterRegistrationInput
    offeredCourseClassSchedules?: OfferedCourseClassScheduleUncheckedCreateNestedManyWithoutSemesterRegistrationInput
    studentSemesterRegistrations?: StudentSemesterRegistrationUncheckedCreateNestedManyWithoutSemesterRegistrationInput
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseUncheckedCreateNestedManyWithoutSemesterRegistrationInput
  }

  export type SemesterRegistrationCreateOrConnectWithoutOfferedCoursesInput = {
    where: SemesterRegistrationWhereUniqueInput
    create: XOR<SemesterRegistrationCreateWithoutOfferedCoursesInput, SemesterRegistrationUncheckedCreateWithoutOfferedCoursesInput>
  }

  export type CourseCreateWithoutOfferedCoursesInput = {
    id?: string
    title: string
    code: string
    durationInYears: number
    yearLevel?: $Enums.YearLevel
    shift?: $Enums.Shift
    createdAt?: Date | string
    updatedAt?: Date | string
    courseDisciplines?: CourseDisciplineCreateNestedManyWithoutCourseInput
    coursePricing?: CoursePricingCreateNestedOneWithoutCourseInput
    academicDepartment: AcademicDepartmentCreateNestedOneWithoutCoursesInput
    studentCourses?: StudentEnrolledCourseCreateNestedManyWithoutCourseInput
    preRequisite?: CourseToPreRequisiteCreateNestedManyWithoutCourseInput
    preRequisiteFor?: CourseToPreRequisiteCreateNestedManyWithoutPreRequisiteInput
    faculties?: CourseFacultyCreateNestedManyWithoutCourseInput
  }

  export type CourseUncheckedCreateWithoutOfferedCoursesInput = {
    id?: string
    title: string
    code: string
    durationInYears: number
    yearLevel?: $Enums.YearLevel
    shift?: $Enums.Shift
    academicDepartmentId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    courseDisciplines?: CourseDisciplineUncheckedCreateNestedManyWithoutCourseInput
    coursePricing?: CoursePricingUncheckedCreateNestedOneWithoutCourseInput
    studentCourses?: StudentEnrolledCourseUncheckedCreateNestedManyWithoutCourseInput
    preRequisite?: CourseToPreRequisiteUncheckedCreateNestedManyWithoutCourseInput
    preRequisiteFor?: CourseToPreRequisiteUncheckedCreateNestedManyWithoutPreRequisiteInput
    faculties?: CourseFacultyUncheckedCreateNestedManyWithoutCourseInput
  }

  export type CourseCreateOrConnectWithoutOfferedCoursesInput = {
    where: CourseWhereUniqueInput
    create: XOR<CourseCreateWithoutOfferedCoursesInput, CourseUncheckedCreateWithoutOfferedCoursesInput>
  }

  export type OfferedCourseSectionCreateWithoutOfferedCourseInput = {
    id?: string
    title: string
    maxCapacity?: number
    currentlyEnrolledStudent?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    semesterRegistration: SemesterRegistrationCreateNestedOneWithoutOfferedCourseSectionsInput
    offeredCourseClassSchedules?: OfferedCourseClassScheduleCreateNestedManyWithoutOfferedCourseSectionInput
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseCreateNestedManyWithoutOfferedCourseSectionInput
  }

  export type OfferedCourseSectionUncheckedCreateWithoutOfferedCourseInput = {
    id?: string
    title: string
    maxCapacity?: number
    currentlyEnrolledStudent?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    semesterRegistrationId: string
    offeredCourseClassSchedules?: OfferedCourseClassScheduleUncheckedCreateNestedManyWithoutOfferedCourseSectionInput
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseUncheckedCreateNestedManyWithoutOfferedCourseSectionInput
  }

  export type OfferedCourseSectionCreateOrConnectWithoutOfferedCourseInput = {
    where: OfferedCourseSectionWhereUniqueInput
    create: XOR<OfferedCourseSectionCreateWithoutOfferedCourseInput, OfferedCourseSectionUncheckedCreateWithoutOfferedCourseInput>
  }

  export type OfferedCourseSectionCreateManyOfferedCourseInputEnvelope = {
    data: OfferedCourseSectionCreateManyOfferedCourseInput | OfferedCourseSectionCreateManyOfferedCourseInput[]
    skipDuplicates?: boolean
  }

  export type StudentSemesterRegistrationCourseCreateWithoutOfferedCourseInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    semesterRegistration: SemesterRegistrationCreateNestedOneWithoutStudentSemesterRegistrationCoursesInput
    student: StudentCreateNestedOneWithoutStudentSemesterRegistrationCoursesInput
    offeredCourseSection: OfferedCourseSectionCreateNestedOneWithoutStudentSemesterRegistrationCoursesInput
  }

  export type StudentSemesterRegistrationCourseUncheckedCreateWithoutOfferedCourseInput = {
    semesterRegistrationId: string
    studentId: string
    offeredCourseSectionId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StudentSemesterRegistrationCourseCreateOrConnectWithoutOfferedCourseInput = {
    where: StudentSemesterRegistrationCourseWhereUniqueInput
    create: XOR<StudentSemesterRegistrationCourseCreateWithoutOfferedCourseInput, StudentSemesterRegistrationCourseUncheckedCreateWithoutOfferedCourseInput>
  }

  export type StudentSemesterRegistrationCourseCreateManyOfferedCourseInputEnvelope = {
    data: StudentSemesterRegistrationCourseCreateManyOfferedCourseInput | StudentSemesterRegistrationCourseCreateManyOfferedCourseInput[]
    skipDuplicates?: boolean
  }

  export type AcademicDepartmentUpsertWithoutOfferedCoursesInput = {
    update: XOR<AcademicDepartmentUpdateWithoutOfferedCoursesInput, AcademicDepartmentUncheckedUpdateWithoutOfferedCoursesInput>
    create: XOR<AcademicDepartmentCreateWithoutOfferedCoursesInput, AcademicDepartmentUncheckedCreateWithoutOfferedCoursesInput>
    where?: AcademicDepartmentWhereInput
  }

  export type AcademicDepartmentUpdateToOneWithWhereWithoutOfferedCoursesInput = {
    where?: AcademicDepartmentWhereInput
    data: XOR<AcademicDepartmentUpdateWithoutOfferedCoursesInput, AcademicDepartmentUncheckedUpdateWithoutOfferedCoursesInput>
  }

  export type AcademicDepartmentUpdateWithoutOfferedCoursesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    academicFaculty?: AcademicFacultyUpdateOneRequiredWithoutAcademicDepartmentsNestedInput
    faculties?: FacultyUpdateManyWithoutAcademicDepartmentNestedInput
    courses?: CourseUpdateManyWithoutAcademicDepartmentNestedInput
    students?: StudentUpdateManyWithoutAcademicDepartmentNestedInput
    departmentHead?: UsersUpdateOneWithoutAcademicDepartmentNestedInput
    staffMembers?: UsersUpdateManyWithoutStaffDepartmentsNestedInput
  }

  export type AcademicDepartmentUncheckedUpdateWithoutOfferedCoursesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    academicFacultyId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    departmentHeadId?: NullableStringFieldUpdateOperationsInput | string | null
    faculties?: FacultyUncheckedUpdateManyWithoutAcademicDepartmentNestedInput
    courses?: CourseUncheckedUpdateManyWithoutAcademicDepartmentNestedInput
    students?: StudentUncheckedUpdateManyWithoutAcademicDepartmentNestedInput
    staffMembers?: UsersUncheckedUpdateManyWithoutStaffDepartmentsNestedInput
  }

  export type SemesterRegistrationUpsertWithoutOfferedCoursesInput = {
    update: XOR<SemesterRegistrationUpdateWithoutOfferedCoursesInput, SemesterRegistrationUncheckedUpdateWithoutOfferedCoursesInput>
    create: XOR<SemesterRegistrationCreateWithoutOfferedCoursesInput, SemesterRegistrationUncheckedCreateWithoutOfferedCoursesInput>
    where?: SemesterRegistrationWhereInput
  }

  export type SemesterRegistrationUpdateToOneWithWhereWithoutOfferedCoursesInput = {
    where?: SemesterRegistrationWhereInput
    data: XOR<SemesterRegistrationUpdateWithoutOfferedCoursesInput, SemesterRegistrationUncheckedUpdateWithoutOfferedCoursesInput>
  }

  export type SemesterRegistrationUpdateWithoutOfferedCoursesInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: NullableEnumSemesterRegistrationStatusFieldUpdateOperationsInput | $Enums.SemesterRegistrationStatus | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    academicSemester?: AcademicSemesterUpdateOneRequiredWithoutSemesterRegistrationsNestedInput
    offeredCourseSections?: OfferedCourseSectionUpdateManyWithoutSemesterRegistrationNestedInput
    offeredCourseClassSchedules?: OfferedCourseClassScheduleUpdateManyWithoutSemesterRegistrationNestedInput
    studentSemesterRegistrations?: StudentSemesterRegistrationUpdateManyWithoutSemesterRegistrationNestedInput
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseUpdateManyWithoutSemesterRegistrationNestedInput
  }

  export type SemesterRegistrationUncheckedUpdateWithoutOfferedCoursesInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: NullableEnumSemesterRegistrationStatusFieldUpdateOperationsInput | $Enums.SemesterRegistrationStatus | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    academicSemesterId?: StringFieldUpdateOperationsInput | string
    offeredCourseSections?: OfferedCourseSectionUncheckedUpdateManyWithoutSemesterRegistrationNestedInput
    offeredCourseClassSchedules?: OfferedCourseClassScheduleUncheckedUpdateManyWithoutSemesterRegistrationNestedInput
    studentSemesterRegistrations?: StudentSemesterRegistrationUncheckedUpdateManyWithoutSemesterRegistrationNestedInput
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseUncheckedUpdateManyWithoutSemesterRegistrationNestedInput
  }

  export type CourseUpsertWithoutOfferedCoursesInput = {
    update: XOR<CourseUpdateWithoutOfferedCoursesInput, CourseUncheckedUpdateWithoutOfferedCoursesInput>
    create: XOR<CourseCreateWithoutOfferedCoursesInput, CourseUncheckedCreateWithoutOfferedCoursesInput>
    where?: CourseWhereInput
  }

  export type CourseUpdateToOneWithWhereWithoutOfferedCoursesInput = {
    where?: CourseWhereInput
    data: XOR<CourseUpdateWithoutOfferedCoursesInput, CourseUncheckedUpdateWithoutOfferedCoursesInput>
  }

  export type CourseUpdateWithoutOfferedCoursesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    durationInYears?: IntFieldUpdateOperationsInput | number
    yearLevel?: EnumYearLevelFieldUpdateOperationsInput | $Enums.YearLevel
    shift?: EnumShiftFieldUpdateOperationsInput | $Enums.Shift
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    courseDisciplines?: CourseDisciplineUpdateManyWithoutCourseNestedInput
    coursePricing?: CoursePricingUpdateOneWithoutCourseNestedInput
    academicDepartment?: AcademicDepartmentUpdateOneRequiredWithoutCoursesNestedInput
    studentCourses?: StudentEnrolledCourseUpdateManyWithoutCourseNestedInput
    preRequisite?: CourseToPreRequisiteUpdateManyWithoutCourseNestedInput
    preRequisiteFor?: CourseToPreRequisiteUpdateManyWithoutPreRequisiteNestedInput
    faculties?: CourseFacultyUpdateManyWithoutCourseNestedInput
  }

  export type CourseUncheckedUpdateWithoutOfferedCoursesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    durationInYears?: IntFieldUpdateOperationsInput | number
    yearLevel?: EnumYearLevelFieldUpdateOperationsInput | $Enums.YearLevel
    shift?: EnumShiftFieldUpdateOperationsInput | $Enums.Shift
    academicDepartmentId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    courseDisciplines?: CourseDisciplineUncheckedUpdateManyWithoutCourseNestedInput
    coursePricing?: CoursePricingUncheckedUpdateOneWithoutCourseNestedInput
    studentCourses?: StudentEnrolledCourseUncheckedUpdateManyWithoutCourseNestedInput
    preRequisite?: CourseToPreRequisiteUncheckedUpdateManyWithoutCourseNestedInput
    preRequisiteFor?: CourseToPreRequisiteUncheckedUpdateManyWithoutPreRequisiteNestedInput
    faculties?: CourseFacultyUncheckedUpdateManyWithoutCourseNestedInput
  }

  export type OfferedCourseSectionUpsertWithWhereUniqueWithoutOfferedCourseInput = {
    where: OfferedCourseSectionWhereUniqueInput
    update: XOR<OfferedCourseSectionUpdateWithoutOfferedCourseInput, OfferedCourseSectionUncheckedUpdateWithoutOfferedCourseInput>
    create: XOR<OfferedCourseSectionCreateWithoutOfferedCourseInput, OfferedCourseSectionUncheckedCreateWithoutOfferedCourseInput>
  }

  export type OfferedCourseSectionUpdateWithWhereUniqueWithoutOfferedCourseInput = {
    where: OfferedCourseSectionWhereUniqueInput
    data: XOR<OfferedCourseSectionUpdateWithoutOfferedCourseInput, OfferedCourseSectionUncheckedUpdateWithoutOfferedCourseInput>
  }

  export type OfferedCourseSectionUpdateManyWithWhereWithoutOfferedCourseInput = {
    where: OfferedCourseSectionScalarWhereInput
    data: XOR<OfferedCourseSectionUpdateManyMutationInput, OfferedCourseSectionUncheckedUpdateManyWithoutOfferedCourseInput>
  }

  export type StudentSemesterRegistrationCourseUpsertWithWhereUniqueWithoutOfferedCourseInput = {
    where: StudentSemesterRegistrationCourseWhereUniqueInput
    update: XOR<StudentSemesterRegistrationCourseUpdateWithoutOfferedCourseInput, StudentSemesterRegistrationCourseUncheckedUpdateWithoutOfferedCourseInput>
    create: XOR<StudentSemesterRegistrationCourseCreateWithoutOfferedCourseInput, StudentSemesterRegistrationCourseUncheckedCreateWithoutOfferedCourseInput>
  }

  export type StudentSemesterRegistrationCourseUpdateWithWhereUniqueWithoutOfferedCourseInput = {
    where: StudentSemesterRegistrationCourseWhereUniqueInput
    data: XOR<StudentSemesterRegistrationCourseUpdateWithoutOfferedCourseInput, StudentSemesterRegistrationCourseUncheckedUpdateWithoutOfferedCourseInput>
  }

  export type StudentSemesterRegistrationCourseUpdateManyWithWhereWithoutOfferedCourseInput = {
    where: StudentSemesterRegistrationCourseScalarWhereInput
    data: XOR<StudentSemesterRegistrationCourseUpdateManyMutationInput, StudentSemesterRegistrationCourseUncheckedUpdateManyWithoutOfferedCourseInput>
  }

  export type SemesterRegistrationCreateWithoutOfferedCourseSectionsInput = {
    id?: string
    startDate: Date | string
    endDate: Date | string
    status?: $Enums.SemesterRegistrationStatus | null
    createdAt?: Date | string
    updateAt?: Date | string
    academicSemester: AcademicSemesterCreateNestedOneWithoutSemesterRegistrationsInput
    offeredCourses?: OfferedCourseCreateNestedManyWithoutSemesterRegistrationInput
    offeredCourseClassSchedules?: OfferedCourseClassScheduleCreateNestedManyWithoutSemesterRegistrationInput
    studentSemesterRegistrations?: StudentSemesterRegistrationCreateNestedManyWithoutSemesterRegistrationInput
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseCreateNestedManyWithoutSemesterRegistrationInput
  }

  export type SemesterRegistrationUncheckedCreateWithoutOfferedCourseSectionsInput = {
    id?: string
    startDate: Date | string
    endDate: Date | string
    status?: $Enums.SemesterRegistrationStatus | null
    createdAt?: Date | string
    updateAt?: Date | string
    academicSemesterId: string
    offeredCourses?: OfferedCourseUncheckedCreateNestedManyWithoutSemesterRegistrationInput
    offeredCourseClassSchedules?: OfferedCourseClassScheduleUncheckedCreateNestedManyWithoutSemesterRegistrationInput
    studentSemesterRegistrations?: StudentSemesterRegistrationUncheckedCreateNestedManyWithoutSemesterRegistrationInput
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseUncheckedCreateNestedManyWithoutSemesterRegistrationInput
  }

  export type SemesterRegistrationCreateOrConnectWithoutOfferedCourseSectionsInput = {
    where: SemesterRegistrationWhereUniqueInput
    create: XOR<SemesterRegistrationCreateWithoutOfferedCourseSectionsInput, SemesterRegistrationUncheckedCreateWithoutOfferedCourseSectionsInput>
  }

  export type OfferedCourseCreateWithoutOfferedCourseSectionsInput = {
    id?: string
    suspendGrade?: number
    academicDepartment: AcademicDepartmentCreateNestedOneWithoutOfferedCoursesInput
    semesterRegistration: SemesterRegistrationCreateNestedOneWithoutOfferedCoursesInput
    course: CourseCreateNestedOneWithoutOfferedCoursesInput
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseCreateNestedManyWithoutOfferedCourseInput
  }

  export type OfferedCourseUncheckedCreateWithoutOfferedCourseSectionsInput = {
    id?: string
    academicDepartmentId: string
    courseId: string
    semesterRegistrationId: string
    suspendGrade?: number
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseUncheckedCreateNestedManyWithoutOfferedCourseInput
  }

  export type OfferedCourseCreateOrConnectWithoutOfferedCourseSectionsInput = {
    where: OfferedCourseWhereUniqueInput
    create: XOR<OfferedCourseCreateWithoutOfferedCourseSectionsInput, OfferedCourseUncheckedCreateWithoutOfferedCourseSectionsInput>
  }

  export type OfferedCourseClassScheduleCreateWithoutOfferedCourseSectionInput = {
    id?: string
    startTime: string
    endTime: string
    dayOfWeek?: $Enums.WeekDays
    createdAt?: Date | string
    updatedAt?: Date | string
    semesterRegistration: SemesterRegistrationCreateNestedOneWithoutOfferedCourseClassSchedulesInput
    room: RoomCreateNestedOneWithoutOfferedCourseClassSchedulesInput
    faculty: FacultyCreateNestedOneWithoutOfferedCourseClassSchedulesInput
  }

  export type OfferedCourseClassScheduleUncheckedCreateWithoutOfferedCourseSectionInput = {
    id?: string
    startTime: string
    endTime: string
    dayOfWeek?: $Enums.WeekDays
    createdAt?: Date | string
    updatedAt?: Date | string
    semesterRegistrationId: string
    roomId: string
    facultyId: string
  }

  export type OfferedCourseClassScheduleCreateOrConnectWithoutOfferedCourseSectionInput = {
    where: OfferedCourseClassScheduleWhereUniqueInput
    create: XOR<OfferedCourseClassScheduleCreateWithoutOfferedCourseSectionInput, OfferedCourseClassScheduleUncheckedCreateWithoutOfferedCourseSectionInput>
  }

  export type OfferedCourseClassScheduleCreateManyOfferedCourseSectionInputEnvelope = {
    data: OfferedCourseClassScheduleCreateManyOfferedCourseSectionInput | OfferedCourseClassScheduleCreateManyOfferedCourseSectionInput[]
    skipDuplicates?: boolean
  }

  export type StudentSemesterRegistrationCourseCreateWithoutOfferedCourseSectionInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    semesterRegistration: SemesterRegistrationCreateNestedOneWithoutStudentSemesterRegistrationCoursesInput
    student: StudentCreateNestedOneWithoutStudentSemesterRegistrationCoursesInput
    offeredCourse: OfferedCourseCreateNestedOneWithoutStudentSemesterRegistrationCoursesInput
  }

  export type StudentSemesterRegistrationCourseUncheckedCreateWithoutOfferedCourseSectionInput = {
    semesterRegistrationId: string
    studentId: string
    offeredCourseId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StudentSemesterRegistrationCourseCreateOrConnectWithoutOfferedCourseSectionInput = {
    where: StudentSemesterRegistrationCourseWhereUniqueInput
    create: XOR<StudentSemesterRegistrationCourseCreateWithoutOfferedCourseSectionInput, StudentSemesterRegistrationCourseUncheckedCreateWithoutOfferedCourseSectionInput>
  }

  export type StudentSemesterRegistrationCourseCreateManyOfferedCourseSectionInputEnvelope = {
    data: StudentSemesterRegistrationCourseCreateManyOfferedCourseSectionInput | StudentSemesterRegistrationCourseCreateManyOfferedCourseSectionInput[]
    skipDuplicates?: boolean
  }

  export type SemesterRegistrationUpsertWithoutOfferedCourseSectionsInput = {
    update: XOR<SemesterRegistrationUpdateWithoutOfferedCourseSectionsInput, SemesterRegistrationUncheckedUpdateWithoutOfferedCourseSectionsInput>
    create: XOR<SemesterRegistrationCreateWithoutOfferedCourseSectionsInput, SemesterRegistrationUncheckedCreateWithoutOfferedCourseSectionsInput>
    where?: SemesterRegistrationWhereInput
  }

  export type SemesterRegistrationUpdateToOneWithWhereWithoutOfferedCourseSectionsInput = {
    where?: SemesterRegistrationWhereInput
    data: XOR<SemesterRegistrationUpdateWithoutOfferedCourseSectionsInput, SemesterRegistrationUncheckedUpdateWithoutOfferedCourseSectionsInput>
  }

  export type SemesterRegistrationUpdateWithoutOfferedCourseSectionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: NullableEnumSemesterRegistrationStatusFieldUpdateOperationsInput | $Enums.SemesterRegistrationStatus | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    academicSemester?: AcademicSemesterUpdateOneRequiredWithoutSemesterRegistrationsNestedInput
    offeredCourses?: OfferedCourseUpdateManyWithoutSemesterRegistrationNestedInput
    offeredCourseClassSchedules?: OfferedCourseClassScheduleUpdateManyWithoutSemesterRegistrationNestedInput
    studentSemesterRegistrations?: StudentSemesterRegistrationUpdateManyWithoutSemesterRegistrationNestedInput
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseUpdateManyWithoutSemesterRegistrationNestedInput
  }

  export type SemesterRegistrationUncheckedUpdateWithoutOfferedCourseSectionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: NullableEnumSemesterRegistrationStatusFieldUpdateOperationsInput | $Enums.SemesterRegistrationStatus | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    academicSemesterId?: StringFieldUpdateOperationsInput | string
    offeredCourses?: OfferedCourseUncheckedUpdateManyWithoutSemesterRegistrationNestedInput
    offeredCourseClassSchedules?: OfferedCourseClassScheduleUncheckedUpdateManyWithoutSemesterRegistrationNestedInput
    studentSemesterRegistrations?: StudentSemesterRegistrationUncheckedUpdateManyWithoutSemesterRegistrationNestedInput
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseUncheckedUpdateManyWithoutSemesterRegistrationNestedInput
  }

  export type OfferedCourseUpsertWithoutOfferedCourseSectionsInput = {
    update: XOR<OfferedCourseUpdateWithoutOfferedCourseSectionsInput, OfferedCourseUncheckedUpdateWithoutOfferedCourseSectionsInput>
    create: XOR<OfferedCourseCreateWithoutOfferedCourseSectionsInput, OfferedCourseUncheckedCreateWithoutOfferedCourseSectionsInput>
    where?: OfferedCourseWhereInput
  }

  export type OfferedCourseUpdateToOneWithWhereWithoutOfferedCourseSectionsInput = {
    where?: OfferedCourseWhereInput
    data: XOR<OfferedCourseUpdateWithoutOfferedCourseSectionsInput, OfferedCourseUncheckedUpdateWithoutOfferedCourseSectionsInput>
  }

  export type OfferedCourseUpdateWithoutOfferedCourseSectionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    suspendGrade?: IntFieldUpdateOperationsInput | number
    academicDepartment?: AcademicDepartmentUpdateOneRequiredWithoutOfferedCoursesNestedInput
    semesterRegistration?: SemesterRegistrationUpdateOneRequiredWithoutOfferedCoursesNestedInput
    course?: CourseUpdateOneRequiredWithoutOfferedCoursesNestedInput
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseUpdateManyWithoutOfferedCourseNestedInput
  }

  export type OfferedCourseUncheckedUpdateWithoutOfferedCourseSectionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    academicDepartmentId?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    semesterRegistrationId?: StringFieldUpdateOperationsInput | string
    suspendGrade?: IntFieldUpdateOperationsInput | number
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseUncheckedUpdateManyWithoutOfferedCourseNestedInput
  }

  export type OfferedCourseClassScheduleUpsertWithWhereUniqueWithoutOfferedCourseSectionInput = {
    where: OfferedCourseClassScheduleWhereUniqueInput
    update: XOR<OfferedCourseClassScheduleUpdateWithoutOfferedCourseSectionInput, OfferedCourseClassScheduleUncheckedUpdateWithoutOfferedCourseSectionInput>
    create: XOR<OfferedCourseClassScheduleCreateWithoutOfferedCourseSectionInput, OfferedCourseClassScheduleUncheckedCreateWithoutOfferedCourseSectionInput>
  }

  export type OfferedCourseClassScheduleUpdateWithWhereUniqueWithoutOfferedCourseSectionInput = {
    where: OfferedCourseClassScheduleWhereUniqueInput
    data: XOR<OfferedCourseClassScheduleUpdateWithoutOfferedCourseSectionInput, OfferedCourseClassScheduleUncheckedUpdateWithoutOfferedCourseSectionInput>
  }

  export type OfferedCourseClassScheduleUpdateManyWithWhereWithoutOfferedCourseSectionInput = {
    where: OfferedCourseClassScheduleScalarWhereInput
    data: XOR<OfferedCourseClassScheduleUpdateManyMutationInput, OfferedCourseClassScheduleUncheckedUpdateManyWithoutOfferedCourseSectionInput>
  }

  export type StudentSemesterRegistrationCourseUpsertWithWhereUniqueWithoutOfferedCourseSectionInput = {
    where: StudentSemesterRegistrationCourseWhereUniqueInput
    update: XOR<StudentSemesterRegistrationCourseUpdateWithoutOfferedCourseSectionInput, StudentSemesterRegistrationCourseUncheckedUpdateWithoutOfferedCourseSectionInput>
    create: XOR<StudentSemesterRegistrationCourseCreateWithoutOfferedCourseSectionInput, StudentSemesterRegistrationCourseUncheckedCreateWithoutOfferedCourseSectionInput>
  }

  export type StudentSemesterRegistrationCourseUpdateWithWhereUniqueWithoutOfferedCourseSectionInput = {
    where: StudentSemesterRegistrationCourseWhereUniqueInput
    data: XOR<StudentSemesterRegistrationCourseUpdateWithoutOfferedCourseSectionInput, StudentSemesterRegistrationCourseUncheckedUpdateWithoutOfferedCourseSectionInput>
  }

  export type StudentSemesterRegistrationCourseUpdateManyWithWhereWithoutOfferedCourseSectionInput = {
    where: StudentSemesterRegistrationCourseScalarWhereInput
    data: XOR<StudentSemesterRegistrationCourseUpdateManyMutationInput, StudentSemesterRegistrationCourseUncheckedUpdateManyWithoutOfferedCourseSectionInput>
  }

  export type OfferedCourseSectionCreateWithoutOfferedCourseClassSchedulesInput = {
    id?: string
    title: string
    maxCapacity?: number
    currentlyEnrolledStudent?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    semesterRegistration: SemesterRegistrationCreateNestedOneWithoutOfferedCourseSectionsInput
    offeredCourse: OfferedCourseCreateNestedOneWithoutOfferedCourseSectionsInput
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseCreateNestedManyWithoutOfferedCourseSectionInput
  }

  export type OfferedCourseSectionUncheckedCreateWithoutOfferedCourseClassSchedulesInput = {
    id?: string
    title: string
    maxCapacity?: number
    currentlyEnrolledStudent?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    semesterRegistrationId: string
    offeredCourseId: string
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseUncheckedCreateNestedManyWithoutOfferedCourseSectionInput
  }

  export type OfferedCourseSectionCreateOrConnectWithoutOfferedCourseClassSchedulesInput = {
    where: OfferedCourseSectionWhereUniqueInput
    create: XOR<OfferedCourseSectionCreateWithoutOfferedCourseClassSchedulesInput, OfferedCourseSectionUncheckedCreateWithoutOfferedCourseClassSchedulesInput>
  }

  export type SemesterRegistrationCreateWithoutOfferedCourseClassSchedulesInput = {
    id?: string
    startDate: Date | string
    endDate: Date | string
    status?: $Enums.SemesterRegistrationStatus | null
    createdAt?: Date | string
    updateAt?: Date | string
    academicSemester: AcademicSemesterCreateNestedOneWithoutSemesterRegistrationsInput
    offeredCourses?: OfferedCourseCreateNestedManyWithoutSemesterRegistrationInput
    offeredCourseSections?: OfferedCourseSectionCreateNestedManyWithoutSemesterRegistrationInput
    studentSemesterRegistrations?: StudentSemesterRegistrationCreateNestedManyWithoutSemesterRegistrationInput
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseCreateNestedManyWithoutSemesterRegistrationInput
  }

  export type SemesterRegistrationUncheckedCreateWithoutOfferedCourseClassSchedulesInput = {
    id?: string
    startDate: Date | string
    endDate: Date | string
    status?: $Enums.SemesterRegistrationStatus | null
    createdAt?: Date | string
    updateAt?: Date | string
    academicSemesterId: string
    offeredCourses?: OfferedCourseUncheckedCreateNestedManyWithoutSemesterRegistrationInput
    offeredCourseSections?: OfferedCourseSectionUncheckedCreateNestedManyWithoutSemesterRegistrationInput
    studentSemesterRegistrations?: StudentSemesterRegistrationUncheckedCreateNestedManyWithoutSemesterRegistrationInput
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseUncheckedCreateNestedManyWithoutSemesterRegistrationInput
  }

  export type SemesterRegistrationCreateOrConnectWithoutOfferedCourseClassSchedulesInput = {
    where: SemesterRegistrationWhereUniqueInput
    create: XOR<SemesterRegistrationCreateWithoutOfferedCourseClassSchedulesInput, SemesterRegistrationUncheckedCreateWithoutOfferedCourseClassSchedulesInput>
  }

  export type RoomCreateWithoutOfferedCourseClassSchedulesInput = {
    id?: string
    roomNumber: string
    floor: string
    createdAt?: Date | string
    updatedAt?: Date | string
    building: BuildingCreateNestedOneWithoutRoomsInput
  }

  export type RoomUncheckedCreateWithoutOfferedCourseClassSchedulesInput = {
    id?: string
    roomNumber: string
    floor: string
    buildingId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RoomCreateOrConnectWithoutOfferedCourseClassSchedulesInput = {
    where: RoomWhereUniqueInput
    create: XOR<RoomCreateWithoutOfferedCourseClassSchedulesInput, RoomUncheckedCreateWithoutOfferedCourseClassSchedulesInput>
  }

  export type FacultyCreateWithoutOfferedCourseClassSchedulesInput = {
    id?: string
    facultyId: string
    firstName: string
    middleName?: string | null
    lastName: string
    profileImage?: string | null
    email?: string | null
    contactNo?: string | null
    shift?: $Enums.Shift
    gender: string
    designation: string
    password: string
    createdAt?: Date | string
    updatedAt?: Date | string
    courses?: CourseFacultyCreateNestedManyWithoutFacultyInput
    academicDepartment: AcademicDepartmentCreateNestedOneWithoutFacultiesInput
    academicFaculty: AcademicFacultyCreateNestedOneWithoutFacultiesInput
  }

  export type FacultyUncheckedCreateWithoutOfferedCourseClassSchedulesInput = {
    id?: string
    facultyId: string
    firstName: string
    middleName?: string | null
    lastName: string
    profileImage?: string | null
    email?: string | null
    contactNo?: string | null
    shift?: $Enums.Shift
    gender: string
    designation: string
    password: string
    academicFacultyId: string
    academicDepartmentId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    courses?: CourseFacultyUncheckedCreateNestedManyWithoutFacultyInput
  }

  export type FacultyCreateOrConnectWithoutOfferedCourseClassSchedulesInput = {
    where: FacultyWhereUniqueInput
    create: XOR<FacultyCreateWithoutOfferedCourseClassSchedulesInput, FacultyUncheckedCreateWithoutOfferedCourseClassSchedulesInput>
  }

  export type OfferedCourseSectionUpsertWithoutOfferedCourseClassSchedulesInput = {
    update: XOR<OfferedCourseSectionUpdateWithoutOfferedCourseClassSchedulesInput, OfferedCourseSectionUncheckedUpdateWithoutOfferedCourseClassSchedulesInput>
    create: XOR<OfferedCourseSectionCreateWithoutOfferedCourseClassSchedulesInput, OfferedCourseSectionUncheckedCreateWithoutOfferedCourseClassSchedulesInput>
    where?: OfferedCourseSectionWhereInput
  }

  export type OfferedCourseSectionUpdateToOneWithWhereWithoutOfferedCourseClassSchedulesInput = {
    where?: OfferedCourseSectionWhereInput
    data: XOR<OfferedCourseSectionUpdateWithoutOfferedCourseClassSchedulesInput, OfferedCourseSectionUncheckedUpdateWithoutOfferedCourseClassSchedulesInput>
  }

  export type OfferedCourseSectionUpdateWithoutOfferedCourseClassSchedulesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    maxCapacity?: IntFieldUpdateOperationsInput | number
    currentlyEnrolledStudent?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    semesterRegistration?: SemesterRegistrationUpdateOneRequiredWithoutOfferedCourseSectionsNestedInput
    offeredCourse?: OfferedCourseUpdateOneRequiredWithoutOfferedCourseSectionsNestedInput
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseUpdateManyWithoutOfferedCourseSectionNestedInput
  }

  export type OfferedCourseSectionUncheckedUpdateWithoutOfferedCourseClassSchedulesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    maxCapacity?: IntFieldUpdateOperationsInput | number
    currentlyEnrolledStudent?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    semesterRegistrationId?: StringFieldUpdateOperationsInput | string
    offeredCourseId?: StringFieldUpdateOperationsInput | string
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseUncheckedUpdateManyWithoutOfferedCourseSectionNestedInput
  }

  export type SemesterRegistrationUpsertWithoutOfferedCourseClassSchedulesInput = {
    update: XOR<SemesterRegistrationUpdateWithoutOfferedCourseClassSchedulesInput, SemesterRegistrationUncheckedUpdateWithoutOfferedCourseClassSchedulesInput>
    create: XOR<SemesterRegistrationCreateWithoutOfferedCourseClassSchedulesInput, SemesterRegistrationUncheckedCreateWithoutOfferedCourseClassSchedulesInput>
    where?: SemesterRegistrationWhereInput
  }

  export type SemesterRegistrationUpdateToOneWithWhereWithoutOfferedCourseClassSchedulesInput = {
    where?: SemesterRegistrationWhereInput
    data: XOR<SemesterRegistrationUpdateWithoutOfferedCourseClassSchedulesInput, SemesterRegistrationUncheckedUpdateWithoutOfferedCourseClassSchedulesInput>
  }

  export type SemesterRegistrationUpdateWithoutOfferedCourseClassSchedulesInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: NullableEnumSemesterRegistrationStatusFieldUpdateOperationsInput | $Enums.SemesterRegistrationStatus | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    academicSemester?: AcademicSemesterUpdateOneRequiredWithoutSemesterRegistrationsNestedInput
    offeredCourses?: OfferedCourseUpdateManyWithoutSemesterRegistrationNestedInput
    offeredCourseSections?: OfferedCourseSectionUpdateManyWithoutSemesterRegistrationNestedInput
    studentSemesterRegistrations?: StudentSemesterRegistrationUpdateManyWithoutSemesterRegistrationNestedInput
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseUpdateManyWithoutSemesterRegistrationNestedInput
  }

  export type SemesterRegistrationUncheckedUpdateWithoutOfferedCourseClassSchedulesInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: NullableEnumSemesterRegistrationStatusFieldUpdateOperationsInput | $Enums.SemesterRegistrationStatus | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    academicSemesterId?: StringFieldUpdateOperationsInput | string
    offeredCourses?: OfferedCourseUncheckedUpdateManyWithoutSemesterRegistrationNestedInput
    offeredCourseSections?: OfferedCourseSectionUncheckedUpdateManyWithoutSemesterRegistrationNestedInput
    studentSemesterRegistrations?: StudentSemesterRegistrationUncheckedUpdateManyWithoutSemesterRegistrationNestedInput
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseUncheckedUpdateManyWithoutSemesterRegistrationNestedInput
  }

  export type RoomUpsertWithoutOfferedCourseClassSchedulesInput = {
    update: XOR<RoomUpdateWithoutOfferedCourseClassSchedulesInput, RoomUncheckedUpdateWithoutOfferedCourseClassSchedulesInput>
    create: XOR<RoomCreateWithoutOfferedCourseClassSchedulesInput, RoomUncheckedCreateWithoutOfferedCourseClassSchedulesInput>
    where?: RoomWhereInput
  }

  export type RoomUpdateToOneWithWhereWithoutOfferedCourseClassSchedulesInput = {
    where?: RoomWhereInput
    data: XOR<RoomUpdateWithoutOfferedCourseClassSchedulesInput, RoomUncheckedUpdateWithoutOfferedCourseClassSchedulesInput>
  }

  export type RoomUpdateWithoutOfferedCourseClassSchedulesInput = {
    id?: StringFieldUpdateOperationsInput | string
    roomNumber?: StringFieldUpdateOperationsInput | string
    floor?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    building?: BuildingUpdateOneRequiredWithoutRoomsNestedInput
  }

  export type RoomUncheckedUpdateWithoutOfferedCourseClassSchedulesInput = {
    id?: StringFieldUpdateOperationsInput | string
    roomNumber?: StringFieldUpdateOperationsInput | string
    floor?: StringFieldUpdateOperationsInput | string
    buildingId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FacultyUpsertWithoutOfferedCourseClassSchedulesInput = {
    update: XOR<FacultyUpdateWithoutOfferedCourseClassSchedulesInput, FacultyUncheckedUpdateWithoutOfferedCourseClassSchedulesInput>
    create: XOR<FacultyCreateWithoutOfferedCourseClassSchedulesInput, FacultyUncheckedCreateWithoutOfferedCourseClassSchedulesInput>
    where?: FacultyWhereInput
  }

  export type FacultyUpdateToOneWithWhereWithoutOfferedCourseClassSchedulesInput = {
    where?: FacultyWhereInput
    data: XOR<FacultyUpdateWithoutOfferedCourseClassSchedulesInput, FacultyUncheckedUpdateWithoutOfferedCourseClassSchedulesInput>
  }

  export type FacultyUpdateWithoutOfferedCourseClassSchedulesInput = {
    id?: StringFieldUpdateOperationsInput | string
    facultyId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    contactNo?: NullableStringFieldUpdateOperationsInput | string | null
    shift?: EnumShiftFieldUpdateOperationsInput | $Enums.Shift
    gender?: StringFieldUpdateOperationsInput | string
    designation?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    courses?: CourseFacultyUpdateManyWithoutFacultyNestedInput
    academicDepartment?: AcademicDepartmentUpdateOneRequiredWithoutFacultiesNestedInput
    academicFaculty?: AcademicFacultyUpdateOneRequiredWithoutFacultiesNestedInput
  }

  export type FacultyUncheckedUpdateWithoutOfferedCourseClassSchedulesInput = {
    id?: StringFieldUpdateOperationsInput | string
    facultyId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    contactNo?: NullableStringFieldUpdateOperationsInput | string | null
    shift?: EnumShiftFieldUpdateOperationsInput | $Enums.Shift
    gender?: StringFieldUpdateOperationsInput | string
    designation?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    academicFacultyId?: StringFieldUpdateOperationsInput | string
    academicDepartmentId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    courses?: CourseFacultyUncheckedUpdateManyWithoutFacultyNestedInput
  }

  export type StudentCreateWithoutStudentSemesterRegistrationsInput = {
    id?: string
    studentId: string
    studentType?: $Enums.StudentType
    firstName: string
    middleName?: string | null
    lastName: string
    profileImage?: string | null
    email?: string | null
    contactNo?: string | null
    gender: string
    isWoker?: boolean
    shift?: $Enums.Shift
    yearLevel?: $Enums.YearLevel
    isActive?: boolean
    password: string
    gradeDeclarationFile: string
    biFile: string
    presentAddress: string
    permanentAddress?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    academicFaculty: AcademicFacultyCreateNestedOneWithoutStudentsInput
    admissionRegistration?: AdmitionExameRegistrationCreateNestedOneWithoutStudentInput
    academicDepartment: AcademicDepartmentCreateNestedOneWithoutStudentsInput
    academicSemester: AcademicSemesterCreateNestedOneWithoutStudentsInput
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseCreateNestedManyWithoutStudentInput
    studentEnrolledCourses?: StudentEnrolledCourseCreateNestedManyWithoutStudentInput
    studentEnrolledCourseMarks?: StudentEnrolledCourseMarkCreateNestedManyWithoutStudentInput
    studentSemesterPayments?: StudentSemesterPaymentCreateNestedManyWithoutStudentInput
    studentAcademicInfos?: StudentAcademicInfoCreateNestedManyWithoutStudentInput
    StudentCarriedCourse?: StudentCarriedCourseCreateNestedManyWithoutStudentInput
  }

  export type StudentUncheckedCreateWithoutStudentSemesterRegistrationsInput = {
    id?: string
    studentId: string
    studentType?: $Enums.StudentType
    firstName: string
    middleName?: string | null
    lastName: string
    profileImage?: string | null
    email?: string | null
    contactNo?: string | null
    gender: string
    isWoker?: boolean
    shift?: $Enums.Shift
    yearLevel?: $Enums.YearLevel
    isActive?: boolean
    password: string
    gradeDeclarationFile: string
    biFile: string
    presentAddress: string
    permanentAddress?: string | null
    academicSemesterId: string
    academicFacultyId: string
    academicDepartmentId: string
    admissionRegistrationId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseUncheckedCreateNestedManyWithoutStudentInput
    studentEnrolledCourses?: StudentEnrolledCourseUncheckedCreateNestedManyWithoutStudentInput
    studentEnrolledCourseMarks?: StudentEnrolledCourseMarkUncheckedCreateNestedManyWithoutStudentInput
    studentSemesterPayments?: StudentSemesterPaymentUncheckedCreateNestedManyWithoutStudentInput
    studentAcademicInfos?: StudentAcademicInfoUncheckedCreateNestedManyWithoutStudentInput
    StudentCarriedCourse?: StudentCarriedCourseUncheckedCreateNestedManyWithoutStudentInput
  }

  export type StudentCreateOrConnectWithoutStudentSemesterRegistrationsInput = {
    where: StudentWhereUniqueInput
    create: XOR<StudentCreateWithoutStudentSemesterRegistrationsInput, StudentUncheckedCreateWithoutStudentSemesterRegistrationsInput>
  }

  export type SemesterRegistrationCreateWithoutStudentSemesterRegistrationsInput = {
    id?: string
    startDate: Date | string
    endDate: Date | string
    status?: $Enums.SemesterRegistrationStatus | null
    createdAt?: Date | string
    updateAt?: Date | string
    academicSemester: AcademicSemesterCreateNestedOneWithoutSemesterRegistrationsInput
    offeredCourses?: OfferedCourseCreateNestedManyWithoutSemesterRegistrationInput
    offeredCourseSections?: OfferedCourseSectionCreateNestedManyWithoutSemesterRegistrationInput
    offeredCourseClassSchedules?: OfferedCourseClassScheduleCreateNestedManyWithoutSemesterRegistrationInput
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseCreateNestedManyWithoutSemesterRegistrationInput
  }

  export type SemesterRegistrationUncheckedCreateWithoutStudentSemesterRegistrationsInput = {
    id?: string
    startDate: Date | string
    endDate: Date | string
    status?: $Enums.SemesterRegistrationStatus | null
    createdAt?: Date | string
    updateAt?: Date | string
    academicSemesterId: string
    offeredCourses?: OfferedCourseUncheckedCreateNestedManyWithoutSemesterRegistrationInput
    offeredCourseSections?: OfferedCourseSectionUncheckedCreateNestedManyWithoutSemesterRegistrationInput
    offeredCourseClassSchedules?: OfferedCourseClassScheduleUncheckedCreateNestedManyWithoutSemesterRegistrationInput
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseUncheckedCreateNestedManyWithoutSemesterRegistrationInput
  }

  export type SemesterRegistrationCreateOrConnectWithoutStudentSemesterRegistrationsInput = {
    where: SemesterRegistrationWhereUniqueInput
    create: XOR<SemesterRegistrationCreateWithoutStudentSemesterRegistrationsInput, SemesterRegistrationUncheckedCreateWithoutStudentSemesterRegistrationsInput>
  }

  export type StudentUpsertWithoutStudentSemesterRegistrationsInput = {
    update: XOR<StudentUpdateWithoutStudentSemesterRegistrationsInput, StudentUncheckedUpdateWithoutStudentSemesterRegistrationsInput>
    create: XOR<StudentCreateWithoutStudentSemesterRegistrationsInput, StudentUncheckedCreateWithoutStudentSemesterRegistrationsInput>
    where?: StudentWhereInput
  }

  export type StudentUpdateToOneWithWhereWithoutStudentSemesterRegistrationsInput = {
    where?: StudentWhereInput
    data: XOR<StudentUpdateWithoutStudentSemesterRegistrationsInput, StudentUncheckedUpdateWithoutStudentSemesterRegistrationsInput>
  }

  export type StudentUpdateWithoutStudentSemesterRegistrationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    studentType?: EnumStudentTypeFieldUpdateOperationsInput | $Enums.StudentType
    firstName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    contactNo?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: StringFieldUpdateOperationsInput | string
    isWoker?: BoolFieldUpdateOperationsInput | boolean
    shift?: EnumShiftFieldUpdateOperationsInput | $Enums.Shift
    yearLevel?: EnumYearLevelFieldUpdateOperationsInput | $Enums.YearLevel
    isActive?: BoolFieldUpdateOperationsInput | boolean
    password?: StringFieldUpdateOperationsInput | string
    gradeDeclarationFile?: StringFieldUpdateOperationsInput | string
    biFile?: StringFieldUpdateOperationsInput | string
    presentAddress?: StringFieldUpdateOperationsInput | string
    permanentAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    academicFaculty?: AcademicFacultyUpdateOneRequiredWithoutStudentsNestedInput
    admissionRegistration?: AdmitionExameRegistrationUpdateOneWithoutStudentNestedInput
    academicDepartment?: AcademicDepartmentUpdateOneRequiredWithoutStudentsNestedInput
    academicSemester?: AcademicSemesterUpdateOneRequiredWithoutStudentsNestedInput
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseUpdateManyWithoutStudentNestedInput
    studentEnrolledCourses?: StudentEnrolledCourseUpdateManyWithoutStudentNestedInput
    studentEnrolledCourseMarks?: StudentEnrolledCourseMarkUpdateManyWithoutStudentNestedInput
    studentSemesterPayments?: StudentSemesterPaymentUpdateManyWithoutStudentNestedInput
    studentAcademicInfos?: StudentAcademicInfoUpdateManyWithoutStudentNestedInput
    StudentCarriedCourse?: StudentCarriedCourseUpdateManyWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateWithoutStudentSemesterRegistrationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    studentType?: EnumStudentTypeFieldUpdateOperationsInput | $Enums.StudentType
    firstName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    contactNo?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: StringFieldUpdateOperationsInput | string
    isWoker?: BoolFieldUpdateOperationsInput | boolean
    shift?: EnumShiftFieldUpdateOperationsInput | $Enums.Shift
    yearLevel?: EnumYearLevelFieldUpdateOperationsInput | $Enums.YearLevel
    isActive?: BoolFieldUpdateOperationsInput | boolean
    password?: StringFieldUpdateOperationsInput | string
    gradeDeclarationFile?: StringFieldUpdateOperationsInput | string
    biFile?: StringFieldUpdateOperationsInput | string
    presentAddress?: StringFieldUpdateOperationsInput | string
    permanentAddress?: NullableStringFieldUpdateOperationsInput | string | null
    academicSemesterId?: StringFieldUpdateOperationsInput | string
    academicFacultyId?: StringFieldUpdateOperationsInput | string
    academicDepartmentId?: StringFieldUpdateOperationsInput | string
    admissionRegistrationId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseUncheckedUpdateManyWithoutStudentNestedInput
    studentEnrolledCourses?: StudentEnrolledCourseUncheckedUpdateManyWithoutStudentNestedInput
    studentEnrolledCourseMarks?: StudentEnrolledCourseMarkUncheckedUpdateManyWithoutStudentNestedInput
    studentSemesterPayments?: StudentSemesterPaymentUncheckedUpdateManyWithoutStudentNestedInput
    studentAcademicInfos?: StudentAcademicInfoUncheckedUpdateManyWithoutStudentNestedInput
    StudentCarriedCourse?: StudentCarriedCourseUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type SemesterRegistrationUpsertWithoutStudentSemesterRegistrationsInput = {
    update: XOR<SemesterRegistrationUpdateWithoutStudentSemesterRegistrationsInput, SemesterRegistrationUncheckedUpdateWithoutStudentSemesterRegistrationsInput>
    create: XOR<SemesterRegistrationCreateWithoutStudentSemesterRegistrationsInput, SemesterRegistrationUncheckedCreateWithoutStudentSemesterRegistrationsInput>
    where?: SemesterRegistrationWhereInput
  }

  export type SemesterRegistrationUpdateToOneWithWhereWithoutStudentSemesterRegistrationsInput = {
    where?: SemesterRegistrationWhereInput
    data: XOR<SemesterRegistrationUpdateWithoutStudentSemesterRegistrationsInput, SemesterRegistrationUncheckedUpdateWithoutStudentSemesterRegistrationsInput>
  }

  export type SemesterRegistrationUpdateWithoutStudentSemesterRegistrationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: NullableEnumSemesterRegistrationStatusFieldUpdateOperationsInput | $Enums.SemesterRegistrationStatus | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    academicSemester?: AcademicSemesterUpdateOneRequiredWithoutSemesterRegistrationsNestedInput
    offeredCourses?: OfferedCourseUpdateManyWithoutSemesterRegistrationNestedInput
    offeredCourseSections?: OfferedCourseSectionUpdateManyWithoutSemesterRegistrationNestedInput
    offeredCourseClassSchedules?: OfferedCourseClassScheduleUpdateManyWithoutSemesterRegistrationNestedInput
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseUpdateManyWithoutSemesterRegistrationNestedInput
  }

  export type SemesterRegistrationUncheckedUpdateWithoutStudentSemesterRegistrationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: NullableEnumSemesterRegistrationStatusFieldUpdateOperationsInput | $Enums.SemesterRegistrationStatus | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    academicSemesterId?: StringFieldUpdateOperationsInput | string
    offeredCourses?: OfferedCourseUncheckedUpdateManyWithoutSemesterRegistrationNestedInput
    offeredCourseSections?: OfferedCourseSectionUncheckedUpdateManyWithoutSemesterRegistrationNestedInput
    offeredCourseClassSchedules?: OfferedCourseClassScheduleUncheckedUpdateManyWithoutSemesterRegistrationNestedInput
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseUncheckedUpdateManyWithoutSemesterRegistrationNestedInput
  }

  export type SemesterRegistrationCreateWithoutStudentSemesterRegistrationCoursesInput = {
    id?: string
    startDate: Date | string
    endDate: Date | string
    status?: $Enums.SemesterRegistrationStatus | null
    createdAt?: Date | string
    updateAt?: Date | string
    academicSemester: AcademicSemesterCreateNestedOneWithoutSemesterRegistrationsInput
    offeredCourses?: OfferedCourseCreateNestedManyWithoutSemesterRegistrationInput
    offeredCourseSections?: OfferedCourseSectionCreateNestedManyWithoutSemesterRegistrationInput
    offeredCourseClassSchedules?: OfferedCourseClassScheduleCreateNestedManyWithoutSemesterRegistrationInput
    studentSemesterRegistrations?: StudentSemesterRegistrationCreateNestedManyWithoutSemesterRegistrationInput
  }

  export type SemesterRegistrationUncheckedCreateWithoutStudentSemesterRegistrationCoursesInput = {
    id?: string
    startDate: Date | string
    endDate: Date | string
    status?: $Enums.SemesterRegistrationStatus | null
    createdAt?: Date | string
    updateAt?: Date | string
    academicSemesterId: string
    offeredCourses?: OfferedCourseUncheckedCreateNestedManyWithoutSemesterRegistrationInput
    offeredCourseSections?: OfferedCourseSectionUncheckedCreateNestedManyWithoutSemesterRegistrationInput
    offeredCourseClassSchedules?: OfferedCourseClassScheduleUncheckedCreateNestedManyWithoutSemesterRegistrationInput
    studentSemesterRegistrations?: StudentSemesterRegistrationUncheckedCreateNestedManyWithoutSemesterRegistrationInput
  }

  export type SemesterRegistrationCreateOrConnectWithoutStudentSemesterRegistrationCoursesInput = {
    where: SemesterRegistrationWhereUniqueInput
    create: XOR<SemesterRegistrationCreateWithoutStudentSemesterRegistrationCoursesInput, SemesterRegistrationUncheckedCreateWithoutStudentSemesterRegistrationCoursesInput>
  }

  export type StudentCreateWithoutStudentSemesterRegistrationCoursesInput = {
    id?: string
    studentId: string
    studentType?: $Enums.StudentType
    firstName: string
    middleName?: string | null
    lastName: string
    profileImage?: string | null
    email?: string | null
    contactNo?: string | null
    gender: string
    isWoker?: boolean
    shift?: $Enums.Shift
    yearLevel?: $Enums.YearLevel
    isActive?: boolean
    password: string
    gradeDeclarationFile: string
    biFile: string
    presentAddress: string
    permanentAddress?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    academicFaculty: AcademicFacultyCreateNestedOneWithoutStudentsInput
    admissionRegistration?: AdmitionExameRegistrationCreateNestedOneWithoutStudentInput
    academicDepartment: AcademicDepartmentCreateNestedOneWithoutStudentsInput
    academicSemester: AcademicSemesterCreateNestedOneWithoutStudentsInput
    studentSemesterRegistrations?: StudentSemesterRegistrationCreateNestedManyWithoutStudentInput
    studentEnrolledCourses?: StudentEnrolledCourseCreateNestedManyWithoutStudentInput
    studentEnrolledCourseMarks?: StudentEnrolledCourseMarkCreateNestedManyWithoutStudentInput
    studentSemesterPayments?: StudentSemesterPaymentCreateNestedManyWithoutStudentInput
    studentAcademicInfos?: StudentAcademicInfoCreateNestedManyWithoutStudentInput
    StudentCarriedCourse?: StudentCarriedCourseCreateNestedManyWithoutStudentInput
  }

  export type StudentUncheckedCreateWithoutStudentSemesterRegistrationCoursesInput = {
    id?: string
    studentId: string
    studentType?: $Enums.StudentType
    firstName: string
    middleName?: string | null
    lastName: string
    profileImage?: string | null
    email?: string | null
    contactNo?: string | null
    gender: string
    isWoker?: boolean
    shift?: $Enums.Shift
    yearLevel?: $Enums.YearLevel
    isActive?: boolean
    password: string
    gradeDeclarationFile: string
    biFile: string
    presentAddress: string
    permanentAddress?: string | null
    academicSemesterId: string
    academicFacultyId: string
    academicDepartmentId: string
    admissionRegistrationId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    studentSemesterRegistrations?: StudentSemesterRegistrationUncheckedCreateNestedManyWithoutStudentInput
    studentEnrolledCourses?: StudentEnrolledCourseUncheckedCreateNestedManyWithoutStudentInput
    studentEnrolledCourseMarks?: StudentEnrolledCourseMarkUncheckedCreateNestedManyWithoutStudentInput
    studentSemesterPayments?: StudentSemesterPaymentUncheckedCreateNestedManyWithoutStudentInput
    studentAcademicInfos?: StudentAcademicInfoUncheckedCreateNestedManyWithoutStudentInput
    StudentCarriedCourse?: StudentCarriedCourseUncheckedCreateNestedManyWithoutStudentInput
  }

  export type StudentCreateOrConnectWithoutStudentSemesterRegistrationCoursesInput = {
    where: StudentWhereUniqueInput
    create: XOR<StudentCreateWithoutStudentSemesterRegistrationCoursesInput, StudentUncheckedCreateWithoutStudentSemesterRegistrationCoursesInput>
  }

  export type OfferedCourseCreateWithoutStudentSemesterRegistrationCoursesInput = {
    id?: string
    suspendGrade?: number
    academicDepartment: AcademicDepartmentCreateNestedOneWithoutOfferedCoursesInput
    semesterRegistration: SemesterRegistrationCreateNestedOneWithoutOfferedCoursesInput
    course: CourseCreateNestedOneWithoutOfferedCoursesInput
    offeredCourseSections?: OfferedCourseSectionCreateNestedManyWithoutOfferedCourseInput
  }

  export type OfferedCourseUncheckedCreateWithoutStudentSemesterRegistrationCoursesInput = {
    id?: string
    academicDepartmentId: string
    courseId: string
    semesterRegistrationId: string
    suspendGrade?: number
    offeredCourseSections?: OfferedCourseSectionUncheckedCreateNestedManyWithoutOfferedCourseInput
  }

  export type OfferedCourseCreateOrConnectWithoutStudentSemesterRegistrationCoursesInput = {
    where: OfferedCourseWhereUniqueInput
    create: XOR<OfferedCourseCreateWithoutStudentSemesterRegistrationCoursesInput, OfferedCourseUncheckedCreateWithoutStudentSemesterRegistrationCoursesInput>
  }

  export type OfferedCourseSectionCreateWithoutStudentSemesterRegistrationCoursesInput = {
    id?: string
    title: string
    maxCapacity?: number
    currentlyEnrolledStudent?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    semesterRegistration: SemesterRegistrationCreateNestedOneWithoutOfferedCourseSectionsInput
    offeredCourse: OfferedCourseCreateNestedOneWithoutOfferedCourseSectionsInput
    offeredCourseClassSchedules?: OfferedCourseClassScheduleCreateNestedManyWithoutOfferedCourseSectionInput
  }

  export type OfferedCourseSectionUncheckedCreateWithoutStudentSemesterRegistrationCoursesInput = {
    id?: string
    title: string
    maxCapacity?: number
    currentlyEnrolledStudent?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    semesterRegistrationId: string
    offeredCourseId: string
    offeredCourseClassSchedules?: OfferedCourseClassScheduleUncheckedCreateNestedManyWithoutOfferedCourseSectionInput
  }

  export type OfferedCourseSectionCreateOrConnectWithoutStudentSemesterRegistrationCoursesInput = {
    where: OfferedCourseSectionWhereUniqueInput
    create: XOR<OfferedCourseSectionCreateWithoutStudentSemesterRegistrationCoursesInput, OfferedCourseSectionUncheckedCreateWithoutStudentSemesterRegistrationCoursesInput>
  }

  export type SemesterRegistrationUpsertWithoutStudentSemesterRegistrationCoursesInput = {
    update: XOR<SemesterRegistrationUpdateWithoutStudentSemesterRegistrationCoursesInput, SemesterRegistrationUncheckedUpdateWithoutStudentSemesterRegistrationCoursesInput>
    create: XOR<SemesterRegistrationCreateWithoutStudentSemesterRegistrationCoursesInput, SemesterRegistrationUncheckedCreateWithoutStudentSemesterRegistrationCoursesInput>
    where?: SemesterRegistrationWhereInput
  }

  export type SemesterRegistrationUpdateToOneWithWhereWithoutStudentSemesterRegistrationCoursesInput = {
    where?: SemesterRegistrationWhereInput
    data: XOR<SemesterRegistrationUpdateWithoutStudentSemesterRegistrationCoursesInput, SemesterRegistrationUncheckedUpdateWithoutStudentSemesterRegistrationCoursesInput>
  }

  export type SemesterRegistrationUpdateWithoutStudentSemesterRegistrationCoursesInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: NullableEnumSemesterRegistrationStatusFieldUpdateOperationsInput | $Enums.SemesterRegistrationStatus | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    academicSemester?: AcademicSemesterUpdateOneRequiredWithoutSemesterRegistrationsNestedInput
    offeredCourses?: OfferedCourseUpdateManyWithoutSemesterRegistrationNestedInput
    offeredCourseSections?: OfferedCourseSectionUpdateManyWithoutSemesterRegistrationNestedInput
    offeredCourseClassSchedules?: OfferedCourseClassScheduleUpdateManyWithoutSemesterRegistrationNestedInput
    studentSemesterRegistrations?: StudentSemesterRegistrationUpdateManyWithoutSemesterRegistrationNestedInput
  }

  export type SemesterRegistrationUncheckedUpdateWithoutStudentSemesterRegistrationCoursesInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: NullableEnumSemesterRegistrationStatusFieldUpdateOperationsInput | $Enums.SemesterRegistrationStatus | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    academicSemesterId?: StringFieldUpdateOperationsInput | string
    offeredCourses?: OfferedCourseUncheckedUpdateManyWithoutSemesterRegistrationNestedInput
    offeredCourseSections?: OfferedCourseSectionUncheckedUpdateManyWithoutSemesterRegistrationNestedInput
    offeredCourseClassSchedules?: OfferedCourseClassScheduleUncheckedUpdateManyWithoutSemesterRegistrationNestedInput
    studentSemesterRegistrations?: StudentSemesterRegistrationUncheckedUpdateManyWithoutSemesterRegistrationNestedInput
  }

  export type StudentUpsertWithoutStudentSemesterRegistrationCoursesInput = {
    update: XOR<StudentUpdateWithoutStudentSemesterRegistrationCoursesInput, StudentUncheckedUpdateWithoutStudentSemesterRegistrationCoursesInput>
    create: XOR<StudentCreateWithoutStudentSemesterRegistrationCoursesInput, StudentUncheckedCreateWithoutStudentSemesterRegistrationCoursesInput>
    where?: StudentWhereInput
  }

  export type StudentUpdateToOneWithWhereWithoutStudentSemesterRegistrationCoursesInput = {
    where?: StudentWhereInput
    data: XOR<StudentUpdateWithoutStudentSemesterRegistrationCoursesInput, StudentUncheckedUpdateWithoutStudentSemesterRegistrationCoursesInput>
  }

  export type StudentUpdateWithoutStudentSemesterRegistrationCoursesInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    studentType?: EnumStudentTypeFieldUpdateOperationsInput | $Enums.StudentType
    firstName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    contactNo?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: StringFieldUpdateOperationsInput | string
    isWoker?: BoolFieldUpdateOperationsInput | boolean
    shift?: EnumShiftFieldUpdateOperationsInput | $Enums.Shift
    yearLevel?: EnumYearLevelFieldUpdateOperationsInput | $Enums.YearLevel
    isActive?: BoolFieldUpdateOperationsInput | boolean
    password?: StringFieldUpdateOperationsInput | string
    gradeDeclarationFile?: StringFieldUpdateOperationsInput | string
    biFile?: StringFieldUpdateOperationsInput | string
    presentAddress?: StringFieldUpdateOperationsInput | string
    permanentAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    academicFaculty?: AcademicFacultyUpdateOneRequiredWithoutStudentsNestedInput
    admissionRegistration?: AdmitionExameRegistrationUpdateOneWithoutStudentNestedInput
    academicDepartment?: AcademicDepartmentUpdateOneRequiredWithoutStudentsNestedInput
    academicSemester?: AcademicSemesterUpdateOneRequiredWithoutStudentsNestedInput
    studentSemesterRegistrations?: StudentSemesterRegistrationUpdateManyWithoutStudentNestedInput
    studentEnrolledCourses?: StudentEnrolledCourseUpdateManyWithoutStudentNestedInput
    studentEnrolledCourseMarks?: StudentEnrolledCourseMarkUpdateManyWithoutStudentNestedInput
    studentSemesterPayments?: StudentSemesterPaymentUpdateManyWithoutStudentNestedInput
    studentAcademicInfos?: StudentAcademicInfoUpdateManyWithoutStudentNestedInput
    StudentCarriedCourse?: StudentCarriedCourseUpdateManyWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateWithoutStudentSemesterRegistrationCoursesInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    studentType?: EnumStudentTypeFieldUpdateOperationsInput | $Enums.StudentType
    firstName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    contactNo?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: StringFieldUpdateOperationsInput | string
    isWoker?: BoolFieldUpdateOperationsInput | boolean
    shift?: EnumShiftFieldUpdateOperationsInput | $Enums.Shift
    yearLevel?: EnumYearLevelFieldUpdateOperationsInput | $Enums.YearLevel
    isActive?: BoolFieldUpdateOperationsInput | boolean
    password?: StringFieldUpdateOperationsInput | string
    gradeDeclarationFile?: StringFieldUpdateOperationsInput | string
    biFile?: StringFieldUpdateOperationsInput | string
    presentAddress?: StringFieldUpdateOperationsInput | string
    permanentAddress?: NullableStringFieldUpdateOperationsInput | string | null
    academicSemesterId?: StringFieldUpdateOperationsInput | string
    academicFacultyId?: StringFieldUpdateOperationsInput | string
    academicDepartmentId?: StringFieldUpdateOperationsInput | string
    admissionRegistrationId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    studentSemesterRegistrations?: StudentSemesterRegistrationUncheckedUpdateManyWithoutStudentNestedInput
    studentEnrolledCourses?: StudentEnrolledCourseUncheckedUpdateManyWithoutStudentNestedInput
    studentEnrolledCourseMarks?: StudentEnrolledCourseMarkUncheckedUpdateManyWithoutStudentNestedInput
    studentSemesterPayments?: StudentSemesterPaymentUncheckedUpdateManyWithoutStudentNestedInput
    studentAcademicInfos?: StudentAcademicInfoUncheckedUpdateManyWithoutStudentNestedInput
    StudentCarriedCourse?: StudentCarriedCourseUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type OfferedCourseUpsertWithoutStudentSemesterRegistrationCoursesInput = {
    update: XOR<OfferedCourseUpdateWithoutStudentSemesterRegistrationCoursesInput, OfferedCourseUncheckedUpdateWithoutStudentSemesterRegistrationCoursesInput>
    create: XOR<OfferedCourseCreateWithoutStudentSemesterRegistrationCoursesInput, OfferedCourseUncheckedCreateWithoutStudentSemesterRegistrationCoursesInput>
    where?: OfferedCourseWhereInput
  }

  export type OfferedCourseUpdateToOneWithWhereWithoutStudentSemesterRegistrationCoursesInput = {
    where?: OfferedCourseWhereInput
    data: XOR<OfferedCourseUpdateWithoutStudentSemesterRegistrationCoursesInput, OfferedCourseUncheckedUpdateWithoutStudentSemesterRegistrationCoursesInput>
  }

  export type OfferedCourseUpdateWithoutStudentSemesterRegistrationCoursesInput = {
    id?: StringFieldUpdateOperationsInput | string
    suspendGrade?: IntFieldUpdateOperationsInput | number
    academicDepartment?: AcademicDepartmentUpdateOneRequiredWithoutOfferedCoursesNestedInput
    semesterRegistration?: SemesterRegistrationUpdateOneRequiredWithoutOfferedCoursesNestedInput
    course?: CourseUpdateOneRequiredWithoutOfferedCoursesNestedInput
    offeredCourseSections?: OfferedCourseSectionUpdateManyWithoutOfferedCourseNestedInput
  }

  export type OfferedCourseUncheckedUpdateWithoutStudentSemesterRegistrationCoursesInput = {
    id?: StringFieldUpdateOperationsInput | string
    academicDepartmentId?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    semesterRegistrationId?: StringFieldUpdateOperationsInput | string
    suspendGrade?: IntFieldUpdateOperationsInput | number
    offeredCourseSections?: OfferedCourseSectionUncheckedUpdateManyWithoutOfferedCourseNestedInput
  }

  export type OfferedCourseSectionUpsertWithoutStudentSemesterRegistrationCoursesInput = {
    update: XOR<OfferedCourseSectionUpdateWithoutStudentSemesterRegistrationCoursesInput, OfferedCourseSectionUncheckedUpdateWithoutStudentSemesterRegistrationCoursesInput>
    create: XOR<OfferedCourseSectionCreateWithoutStudentSemesterRegistrationCoursesInput, OfferedCourseSectionUncheckedCreateWithoutStudentSemesterRegistrationCoursesInput>
    where?: OfferedCourseSectionWhereInput
  }

  export type OfferedCourseSectionUpdateToOneWithWhereWithoutStudentSemesterRegistrationCoursesInput = {
    where?: OfferedCourseSectionWhereInput
    data: XOR<OfferedCourseSectionUpdateWithoutStudentSemesterRegistrationCoursesInput, OfferedCourseSectionUncheckedUpdateWithoutStudentSemesterRegistrationCoursesInput>
  }

  export type OfferedCourseSectionUpdateWithoutStudentSemesterRegistrationCoursesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    maxCapacity?: IntFieldUpdateOperationsInput | number
    currentlyEnrolledStudent?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    semesterRegistration?: SemesterRegistrationUpdateOneRequiredWithoutOfferedCourseSectionsNestedInput
    offeredCourse?: OfferedCourseUpdateOneRequiredWithoutOfferedCourseSectionsNestedInput
    offeredCourseClassSchedules?: OfferedCourseClassScheduleUpdateManyWithoutOfferedCourseSectionNestedInput
  }

  export type OfferedCourseSectionUncheckedUpdateWithoutStudentSemesterRegistrationCoursesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    maxCapacity?: IntFieldUpdateOperationsInput | number
    currentlyEnrolledStudent?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    semesterRegistrationId?: StringFieldUpdateOperationsInput | string
    offeredCourseId?: StringFieldUpdateOperationsInput | string
    offeredCourseClassSchedules?: OfferedCourseClassScheduleUncheckedUpdateManyWithoutOfferedCourseSectionNestedInput
  }

  export type StudentCreateWithoutStudentEnrolledCoursesInput = {
    id?: string
    studentId: string
    studentType?: $Enums.StudentType
    firstName: string
    middleName?: string | null
    lastName: string
    profileImage?: string | null
    email?: string | null
    contactNo?: string | null
    gender: string
    isWoker?: boolean
    shift?: $Enums.Shift
    yearLevel?: $Enums.YearLevel
    isActive?: boolean
    password: string
    gradeDeclarationFile: string
    biFile: string
    presentAddress: string
    permanentAddress?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    academicFaculty: AcademicFacultyCreateNestedOneWithoutStudentsInput
    admissionRegistration?: AdmitionExameRegistrationCreateNestedOneWithoutStudentInput
    academicDepartment: AcademicDepartmentCreateNestedOneWithoutStudentsInput
    academicSemester: AcademicSemesterCreateNestedOneWithoutStudentsInput
    studentSemesterRegistrations?: StudentSemesterRegistrationCreateNestedManyWithoutStudentInput
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseCreateNestedManyWithoutStudentInput
    studentEnrolledCourseMarks?: StudentEnrolledCourseMarkCreateNestedManyWithoutStudentInput
    studentSemesterPayments?: StudentSemesterPaymentCreateNestedManyWithoutStudentInput
    studentAcademicInfos?: StudentAcademicInfoCreateNestedManyWithoutStudentInput
    StudentCarriedCourse?: StudentCarriedCourseCreateNestedManyWithoutStudentInput
  }

  export type StudentUncheckedCreateWithoutStudentEnrolledCoursesInput = {
    id?: string
    studentId: string
    studentType?: $Enums.StudentType
    firstName: string
    middleName?: string | null
    lastName: string
    profileImage?: string | null
    email?: string | null
    contactNo?: string | null
    gender: string
    isWoker?: boolean
    shift?: $Enums.Shift
    yearLevel?: $Enums.YearLevel
    isActive?: boolean
    password: string
    gradeDeclarationFile: string
    biFile: string
    presentAddress: string
    permanentAddress?: string | null
    academicSemesterId: string
    academicFacultyId: string
    academicDepartmentId: string
    admissionRegistrationId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    studentSemesterRegistrations?: StudentSemesterRegistrationUncheckedCreateNestedManyWithoutStudentInput
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseUncheckedCreateNestedManyWithoutStudentInput
    studentEnrolledCourseMarks?: StudentEnrolledCourseMarkUncheckedCreateNestedManyWithoutStudentInput
    studentSemesterPayments?: StudentSemesterPaymentUncheckedCreateNestedManyWithoutStudentInput
    studentAcademicInfos?: StudentAcademicInfoUncheckedCreateNestedManyWithoutStudentInput
    StudentCarriedCourse?: StudentCarriedCourseUncheckedCreateNestedManyWithoutStudentInput
  }

  export type StudentCreateOrConnectWithoutStudentEnrolledCoursesInput = {
    where: StudentWhereUniqueInput
    create: XOR<StudentCreateWithoutStudentEnrolledCoursesInput, StudentUncheckedCreateWithoutStudentEnrolledCoursesInput>
  }

  export type CourseCreateWithoutStudentCoursesInput = {
    id?: string
    title: string
    code: string
    durationInYears: number
    yearLevel?: $Enums.YearLevel
    shift?: $Enums.Shift
    createdAt?: Date | string
    updatedAt?: Date | string
    courseDisciplines?: CourseDisciplineCreateNestedManyWithoutCourseInput
    coursePricing?: CoursePricingCreateNestedOneWithoutCourseInput
    academicDepartment: AcademicDepartmentCreateNestedOneWithoutCoursesInput
    preRequisite?: CourseToPreRequisiteCreateNestedManyWithoutCourseInput
    preRequisiteFor?: CourseToPreRequisiteCreateNestedManyWithoutPreRequisiteInput
    faculties?: CourseFacultyCreateNestedManyWithoutCourseInput
    offeredCourses?: OfferedCourseCreateNestedManyWithoutCourseInput
  }

  export type CourseUncheckedCreateWithoutStudentCoursesInput = {
    id?: string
    title: string
    code: string
    durationInYears: number
    yearLevel?: $Enums.YearLevel
    shift?: $Enums.Shift
    academicDepartmentId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    courseDisciplines?: CourseDisciplineUncheckedCreateNestedManyWithoutCourseInput
    coursePricing?: CoursePricingUncheckedCreateNestedOneWithoutCourseInput
    preRequisite?: CourseToPreRequisiteUncheckedCreateNestedManyWithoutCourseInput
    preRequisiteFor?: CourseToPreRequisiteUncheckedCreateNestedManyWithoutPreRequisiteInput
    faculties?: CourseFacultyUncheckedCreateNestedManyWithoutCourseInput
    offeredCourses?: OfferedCourseUncheckedCreateNestedManyWithoutCourseInput
  }

  export type CourseCreateOrConnectWithoutStudentCoursesInput = {
    where: CourseWhereUniqueInput
    create: XOR<CourseCreateWithoutStudentCoursesInput, CourseUncheckedCreateWithoutStudentCoursesInput>
  }

  export type StudentEnrolledCourseMarkCreateWithoutStudentEnrolledCourseInput = {
    id?: string
    examType?: $Enums.ExamType | null
    createdAt?: Date | string
    updatedAt?: Date | string
    continuousAssessments: JsonNullValueInput | InputJsonValue
    frequencyExam?: number | null
    finalExam?: number | null
    resourceExam?: number | null
    specialExam?: number | null
    recoveryExam?: number | null
    totalMarks?: number
    grade?: number
    student: StudentCreateNestedOneWithoutStudentEnrolledCourseMarksInput
    academicSemester: AcademicSemesterCreateNestedOneWithoutStudentEnrolledCourseMarksInput
  }

  export type StudentEnrolledCourseMarkUncheckedCreateWithoutStudentEnrolledCourseInput = {
    id?: string
    examType?: $Enums.ExamType | null
    createdAt?: Date | string
    updatedAt?: Date | string
    studentId: string
    academicSemesterId: string
    continuousAssessments: JsonNullValueInput | InputJsonValue
    frequencyExam?: number | null
    finalExam?: number | null
    resourceExam?: number | null
    specialExam?: number | null
    recoveryExam?: number | null
    totalMarks?: number
    grade?: number
  }

  export type StudentEnrolledCourseMarkCreateOrConnectWithoutStudentEnrolledCourseInput = {
    where: StudentEnrolledCourseMarkWhereUniqueInput
    create: XOR<StudentEnrolledCourseMarkCreateWithoutStudentEnrolledCourseInput, StudentEnrolledCourseMarkUncheckedCreateWithoutStudentEnrolledCourseInput>
  }

  export type StudentEnrolledCourseMarkCreateManyStudentEnrolledCourseInputEnvelope = {
    data: StudentEnrolledCourseMarkCreateManyStudentEnrolledCourseInput | StudentEnrolledCourseMarkCreateManyStudentEnrolledCourseInput[]
    skipDuplicates?: boolean
  }

  export type AcademicSemesterCreateWithoutStudentEnrolledCoursesInput = {
    id?: string
    title: string
    year: string
    code: string
    startMonth: string
    endMonth: string
    isCurrent?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    courseDisciplines?: CourseDisciplineCreateNestedManyWithoutSemesterInput
    semesterRegistrations?: SemesterRegistrationCreateNestedManyWithoutAcademicSemesterInput
    students?: StudentCreateNestedManyWithoutAcademicSemesterInput
    studentEnrolledCourseMarks?: StudentEnrolledCourseMarkCreateNestedManyWithoutAcademicSemesterInput
    studentSemesterPayments?: StudentSemesterPaymentCreateNestedManyWithoutAcademicSemesterInput
    StudentCarriedCourse?: StudentCarriedCourseCreateNestedManyWithoutSemesterInput
  }

  export type AcademicSemesterUncheckedCreateWithoutStudentEnrolledCoursesInput = {
    id?: string
    title: string
    year: string
    code: string
    startMonth: string
    endMonth: string
    isCurrent?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    courseDisciplines?: CourseDisciplineUncheckedCreateNestedManyWithoutSemesterInput
    semesterRegistrations?: SemesterRegistrationUncheckedCreateNestedManyWithoutAcademicSemesterInput
    students?: StudentUncheckedCreateNestedManyWithoutAcademicSemesterInput
    studentEnrolledCourseMarks?: StudentEnrolledCourseMarkUncheckedCreateNestedManyWithoutAcademicSemesterInput
    studentSemesterPayments?: StudentSemesterPaymentUncheckedCreateNestedManyWithoutAcademicSemesterInput
    StudentCarriedCourse?: StudentCarriedCourseUncheckedCreateNestedManyWithoutSemesterInput
  }

  export type AcademicSemesterCreateOrConnectWithoutStudentEnrolledCoursesInput = {
    where: AcademicSemesterWhereUniqueInput
    create: XOR<AcademicSemesterCreateWithoutStudentEnrolledCoursesInput, AcademicSemesterUncheckedCreateWithoutStudentEnrolledCoursesInput>
  }

  export type StudentUpsertWithoutStudentEnrolledCoursesInput = {
    update: XOR<StudentUpdateWithoutStudentEnrolledCoursesInput, StudentUncheckedUpdateWithoutStudentEnrolledCoursesInput>
    create: XOR<StudentCreateWithoutStudentEnrolledCoursesInput, StudentUncheckedCreateWithoutStudentEnrolledCoursesInput>
    where?: StudentWhereInput
  }

  export type StudentUpdateToOneWithWhereWithoutStudentEnrolledCoursesInput = {
    where?: StudentWhereInput
    data: XOR<StudentUpdateWithoutStudentEnrolledCoursesInput, StudentUncheckedUpdateWithoutStudentEnrolledCoursesInput>
  }

  export type StudentUpdateWithoutStudentEnrolledCoursesInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    studentType?: EnumStudentTypeFieldUpdateOperationsInput | $Enums.StudentType
    firstName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    contactNo?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: StringFieldUpdateOperationsInput | string
    isWoker?: BoolFieldUpdateOperationsInput | boolean
    shift?: EnumShiftFieldUpdateOperationsInput | $Enums.Shift
    yearLevel?: EnumYearLevelFieldUpdateOperationsInput | $Enums.YearLevel
    isActive?: BoolFieldUpdateOperationsInput | boolean
    password?: StringFieldUpdateOperationsInput | string
    gradeDeclarationFile?: StringFieldUpdateOperationsInput | string
    biFile?: StringFieldUpdateOperationsInput | string
    presentAddress?: StringFieldUpdateOperationsInput | string
    permanentAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    academicFaculty?: AcademicFacultyUpdateOneRequiredWithoutStudentsNestedInput
    admissionRegistration?: AdmitionExameRegistrationUpdateOneWithoutStudentNestedInput
    academicDepartment?: AcademicDepartmentUpdateOneRequiredWithoutStudentsNestedInput
    academicSemester?: AcademicSemesterUpdateOneRequiredWithoutStudentsNestedInput
    studentSemesterRegistrations?: StudentSemesterRegistrationUpdateManyWithoutStudentNestedInput
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseUpdateManyWithoutStudentNestedInput
    studentEnrolledCourseMarks?: StudentEnrolledCourseMarkUpdateManyWithoutStudentNestedInput
    studentSemesterPayments?: StudentSemesterPaymentUpdateManyWithoutStudentNestedInput
    studentAcademicInfos?: StudentAcademicInfoUpdateManyWithoutStudentNestedInput
    StudentCarriedCourse?: StudentCarriedCourseUpdateManyWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateWithoutStudentEnrolledCoursesInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    studentType?: EnumStudentTypeFieldUpdateOperationsInput | $Enums.StudentType
    firstName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    contactNo?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: StringFieldUpdateOperationsInput | string
    isWoker?: BoolFieldUpdateOperationsInput | boolean
    shift?: EnumShiftFieldUpdateOperationsInput | $Enums.Shift
    yearLevel?: EnumYearLevelFieldUpdateOperationsInput | $Enums.YearLevel
    isActive?: BoolFieldUpdateOperationsInput | boolean
    password?: StringFieldUpdateOperationsInput | string
    gradeDeclarationFile?: StringFieldUpdateOperationsInput | string
    biFile?: StringFieldUpdateOperationsInput | string
    presentAddress?: StringFieldUpdateOperationsInput | string
    permanentAddress?: NullableStringFieldUpdateOperationsInput | string | null
    academicSemesterId?: StringFieldUpdateOperationsInput | string
    academicFacultyId?: StringFieldUpdateOperationsInput | string
    academicDepartmentId?: StringFieldUpdateOperationsInput | string
    admissionRegistrationId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    studentSemesterRegistrations?: StudentSemesterRegistrationUncheckedUpdateManyWithoutStudentNestedInput
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseUncheckedUpdateManyWithoutStudentNestedInput
    studentEnrolledCourseMarks?: StudentEnrolledCourseMarkUncheckedUpdateManyWithoutStudentNestedInput
    studentSemesterPayments?: StudentSemesterPaymentUncheckedUpdateManyWithoutStudentNestedInput
    studentAcademicInfos?: StudentAcademicInfoUncheckedUpdateManyWithoutStudentNestedInput
    StudentCarriedCourse?: StudentCarriedCourseUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type CourseUpsertWithoutStudentCoursesInput = {
    update: XOR<CourseUpdateWithoutStudentCoursesInput, CourseUncheckedUpdateWithoutStudentCoursesInput>
    create: XOR<CourseCreateWithoutStudentCoursesInput, CourseUncheckedCreateWithoutStudentCoursesInput>
    where?: CourseWhereInput
  }

  export type CourseUpdateToOneWithWhereWithoutStudentCoursesInput = {
    where?: CourseWhereInput
    data: XOR<CourseUpdateWithoutStudentCoursesInput, CourseUncheckedUpdateWithoutStudentCoursesInput>
  }

  export type CourseUpdateWithoutStudentCoursesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    durationInYears?: IntFieldUpdateOperationsInput | number
    yearLevel?: EnumYearLevelFieldUpdateOperationsInput | $Enums.YearLevel
    shift?: EnumShiftFieldUpdateOperationsInput | $Enums.Shift
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    courseDisciplines?: CourseDisciplineUpdateManyWithoutCourseNestedInput
    coursePricing?: CoursePricingUpdateOneWithoutCourseNestedInput
    academicDepartment?: AcademicDepartmentUpdateOneRequiredWithoutCoursesNestedInput
    preRequisite?: CourseToPreRequisiteUpdateManyWithoutCourseNestedInput
    preRequisiteFor?: CourseToPreRequisiteUpdateManyWithoutPreRequisiteNestedInput
    faculties?: CourseFacultyUpdateManyWithoutCourseNestedInput
    offeredCourses?: OfferedCourseUpdateManyWithoutCourseNestedInput
  }

  export type CourseUncheckedUpdateWithoutStudentCoursesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    durationInYears?: IntFieldUpdateOperationsInput | number
    yearLevel?: EnumYearLevelFieldUpdateOperationsInput | $Enums.YearLevel
    shift?: EnumShiftFieldUpdateOperationsInput | $Enums.Shift
    academicDepartmentId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    courseDisciplines?: CourseDisciplineUncheckedUpdateManyWithoutCourseNestedInput
    coursePricing?: CoursePricingUncheckedUpdateOneWithoutCourseNestedInput
    preRequisite?: CourseToPreRequisiteUncheckedUpdateManyWithoutCourseNestedInput
    preRequisiteFor?: CourseToPreRequisiteUncheckedUpdateManyWithoutPreRequisiteNestedInput
    faculties?: CourseFacultyUncheckedUpdateManyWithoutCourseNestedInput
    offeredCourses?: OfferedCourseUncheckedUpdateManyWithoutCourseNestedInput
  }

  export type StudentEnrolledCourseMarkUpsertWithWhereUniqueWithoutStudentEnrolledCourseInput = {
    where: StudentEnrolledCourseMarkWhereUniqueInput
    update: XOR<StudentEnrolledCourseMarkUpdateWithoutStudentEnrolledCourseInput, StudentEnrolledCourseMarkUncheckedUpdateWithoutStudentEnrolledCourseInput>
    create: XOR<StudentEnrolledCourseMarkCreateWithoutStudentEnrolledCourseInput, StudentEnrolledCourseMarkUncheckedCreateWithoutStudentEnrolledCourseInput>
  }

  export type StudentEnrolledCourseMarkUpdateWithWhereUniqueWithoutStudentEnrolledCourseInput = {
    where: StudentEnrolledCourseMarkWhereUniqueInput
    data: XOR<StudentEnrolledCourseMarkUpdateWithoutStudentEnrolledCourseInput, StudentEnrolledCourseMarkUncheckedUpdateWithoutStudentEnrolledCourseInput>
  }

  export type StudentEnrolledCourseMarkUpdateManyWithWhereWithoutStudentEnrolledCourseInput = {
    where: StudentEnrolledCourseMarkScalarWhereInput
    data: XOR<StudentEnrolledCourseMarkUpdateManyMutationInput, StudentEnrolledCourseMarkUncheckedUpdateManyWithoutStudentEnrolledCourseInput>
  }

  export type AcademicSemesterUpsertWithoutStudentEnrolledCoursesInput = {
    update: XOR<AcademicSemesterUpdateWithoutStudentEnrolledCoursesInput, AcademicSemesterUncheckedUpdateWithoutStudentEnrolledCoursesInput>
    create: XOR<AcademicSemesterCreateWithoutStudentEnrolledCoursesInput, AcademicSemesterUncheckedCreateWithoutStudentEnrolledCoursesInput>
    where?: AcademicSemesterWhereInput
  }

  export type AcademicSemesterUpdateToOneWithWhereWithoutStudentEnrolledCoursesInput = {
    where?: AcademicSemesterWhereInput
    data: XOR<AcademicSemesterUpdateWithoutStudentEnrolledCoursesInput, AcademicSemesterUncheckedUpdateWithoutStudentEnrolledCoursesInput>
  }

  export type AcademicSemesterUpdateWithoutStudentEnrolledCoursesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    year?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    startMonth?: StringFieldUpdateOperationsInput | string
    endMonth?: StringFieldUpdateOperationsInput | string
    isCurrent?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    courseDisciplines?: CourseDisciplineUpdateManyWithoutSemesterNestedInput
    semesterRegistrations?: SemesterRegistrationUpdateManyWithoutAcademicSemesterNestedInput
    students?: StudentUpdateManyWithoutAcademicSemesterNestedInput
    studentEnrolledCourseMarks?: StudentEnrolledCourseMarkUpdateManyWithoutAcademicSemesterNestedInput
    studentSemesterPayments?: StudentSemesterPaymentUpdateManyWithoutAcademicSemesterNestedInput
    StudentCarriedCourse?: StudentCarriedCourseUpdateManyWithoutSemesterNestedInput
  }

  export type AcademicSemesterUncheckedUpdateWithoutStudentEnrolledCoursesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    year?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    startMonth?: StringFieldUpdateOperationsInput | string
    endMonth?: StringFieldUpdateOperationsInput | string
    isCurrent?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    courseDisciplines?: CourseDisciplineUncheckedUpdateManyWithoutSemesterNestedInput
    semesterRegistrations?: SemesterRegistrationUncheckedUpdateManyWithoutAcademicSemesterNestedInput
    students?: StudentUncheckedUpdateManyWithoutAcademicSemesterNestedInput
    studentEnrolledCourseMarks?: StudentEnrolledCourseMarkUncheckedUpdateManyWithoutAcademicSemesterNestedInput
    studentSemesterPayments?: StudentSemesterPaymentUncheckedUpdateManyWithoutAcademicSemesterNestedInput
    StudentCarriedCourse?: StudentCarriedCourseUncheckedUpdateManyWithoutSemesterNestedInput
  }

  export type StudentCreateWithoutStudentEnrolledCourseMarksInput = {
    id?: string
    studentId: string
    studentType?: $Enums.StudentType
    firstName: string
    middleName?: string | null
    lastName: string
    profileImage?: string | null
    email?: string | null
    contactNo?: string | null
    gender: string
    isWoker?: boolean
    shift?: $Enums.Shift
    yearLevel?: $Enums.YearLevel
    isActive?: boolean
    password: string
    gradeDeclarationFile: string
    biFile: string
    presentAddress: string
    permanentAddress?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    academicFaculty: AcademicFacultyCreateNestedOneWithoutStudentsInput
    admissionRegistration?: AdmitionExameRegistrationCreateNestedOneWithoutStudentInput
    academicDepartment: AcademicDepartmentCreateNestedOneWithoutStudentsInput
    academicSemester: AcademicSemesterCreateNestedOneWithoutStudentsInput
    studentSemesterRegistrations?: StudentSemesterRegistrationCreateNestedManyWithoutStudentInput
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseCreateNestedManyWithoutStudentInput
    studentEnrolledCourses?: StudentEnrolledCourseCreateNestedManyWithoutStudentInput
    studentSemesterPayments?: StudentSemesterPaymentCreateNestedManyWithoutStudentInput
    studentAcademicInfos?: StudentAcademicInfoCreateNestedManyWithoutStudentInput
    StudentCarriedCourse?: StudentCarriedCourseCreateNestedManyWithoutStudentInput
  }

  export type StudentUncheckedCreateWithoutStudentEnrolledCourseMarksInput = {
    id?: string
    studentId: string
    studentType?: $Enums.StudentType
    firstName: string
    middleName?: string | null
    lastName: string
    profileImage?: string | null
    email?: string | null
    contactNo?: string | null
    gender: string
    isWoker?: boolean
    shift?: $Enums.Shift
    yearLevel?: $Enums.YearLevel
    isActive?: boolean
    password: string
    gradeDeclarationFile: string
    biFile: string
    presentAddress: string
    permanentAddress?: string | null
    academicSemesterId: string
    academicFacultyId: string
    academicDepartmentId: string
    admissionRegistrationId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    studentSemesterRegistrations?: StudentSemesterRegistrationUncheckedCreateNestedManyWithoutStudentInput
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseUncheckedCreateNestedManyWithoutStudentInput
    studentEnrolledCourses?: StudentEnrolledCourseUncheckedCreateNestedManyWithoutStudentInput
    studentSemesterPayments?: StudentSemesterPaymentUncheckedCreateNestedManyWithoutStudentInput
    studentAcademicInfos?: StudentAcademicInfoUncheckedCreateNestedManyWithoutStudentInput
    StudentCarriedCourse?: StudentCarriedCourseUncheckedCreateNestedManyWithoutStudentInput
  }

  export type StudentCreateOrConnectWithoutStudentEnrolledCourseMarksInput = {
    where: StudentWhereUniqueInput
    create: XOR<StudentCreateWithoutStudentEnrolledCourseMarksInput, StudentUncheckedCreateWithoutStudentEnrolledCourseMarksInput>
  }

  export type StudentEnrolledCourseCreateWithoutStudentEnrolledCourseMarksInput = {
    id?: string
    grade?: string | null
    point?: number | null
    totalMarks?: number | null
    status?: $Enums.StudentEnrolledCourseStatus | null
    createdAt?: Date | string
    updatedAt?: Date | string
    student: StudentCreateNestedOneWithoutStudentEnrolledCoursesInput
    course: CourseCreateNestedOneWithoutStudentCoursesInput
    academicSemester: AcademicSemesterCreateNestedOneWithoutStudentEnrolledCoursesInput
  }

  export type StudentEnrolledCourseUncheckedCreateWithoutStudentEnrolledCourseMarksInput = {
    id?: string
    grade?: string | null
    point?: number | null
    totalMarks?: number | null
    status?: $Enums.StudentEnrolledCourseStatus | null
    createdAt?: Date | string
    updatedAt?: Date | string
    studentId: string
    academicSemesterId: string
    courseId: string
  }

  export type StudentEnrolledCourseCreateOrConnectWithoutStudentEnrolledCourseMarksInput = {
    where: StudentEnrolledCourseWhereUniqueInput
    create: XOR<StudentEnrolledCourseCreateWithoutStudentEnrolledCourseMarksInput, StudentEnrolledCourseUncheckedCreateWithoutStudentEnrolledCourseMarksInput>
  }

  export type AcademicSemesterCreateWithoutStudentEnrolledCourseMarksInput = {
    id?: string
    title: string
    year: string
    code: string
    startMonth: string
    endMonth: string
    isCurrent?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    courseDisciplines?: CourseDisciplineCreateNestedManyWithoutSemesterInput
    semesterRegistrations?: SemesterRegistrationCreateNestedManyWithoutAcademicSemesterInput
    students?: StudentCreateNestedManyWithoutAcademicSemesterInput
    studentEnrolledCourses?: StudentEnrolledCourseCreateNestedManyWithoutAcademicSemesterInput
    studentSemesterPayments?: StudentSemesterPaymentCreateNestedManyWithoutAcademicSemesterInput
    StudentCarriedCourse?: StudentCarriedCourseCreateNestedManyWithoutSemesterInput
  }

  export type AcademicSemesterUncheckedCreateWithoutStudentEnrolledCourseMarksInput = {
    id?: string
    title: string
    year: string
    code: string
    startMonth: string
    endMonth: string
    isCurrent?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    courseDisciplines?: CourseDisciplineUncheckedCreateNestedManyWithoutSemesterInput
    semesterRegistrations?: SemesterRegistrationUncheckedCreateNestedManyWithoutAcademicSemesterInput
    students?: StudentUncheckedCreateNestedManyWithoutAcademicSemesterInput
    studentEnrolledCourses?: StudentEnrolledCourseUncheckedCreateNestedManyWithoutAcademicSemesterInput
    studentSemesterPayments?: StudentSemesterPaymentUncheckedCreateNestedManyWithoutAcademicSemesterInput
    StudentCarriedCourse?: StudentCarriedCourseUncheckedCreateNestedManyWithoutSemesterInput
  }

  export type AcademicSemesterCreateOrConnectWithoutStudentEnrolledCourseMarksInput = {
    where: AcademicSemesterWhereUniqueInput
    create: XOR<AcademicSemesterCreateWithoutStudentEnrolledCourseMarksInput, AcademicSemesterUncheckedCreateWithoutStudentEnrolledCourseMarksInput>
  }

  export type StudentUpsertWithoutStudentEnrolledCourseMarksInput = {
    update: XOR<StudentUpdateWithoutStudentEnrolledCourseMarksInput, StudentUncheckedUpdateWithoutStudentEnrolledCourseMarksInput>
    create: XOR<StudentCreateWithoutStudentEnrolledCourseMarksInput, StudentUncheckedCreateWithoutStudentEnrolledCourseMarksInput>
    where?: StudentWhereInput
  }

  export type StudentUpdateToOneWithWhereWithoutStudentEnrolledCourseMarksInput = {
    where?: StudentWhereInput
    data: XOR<StudentUpdateWithoutStudentEnrolledCourseMarksInput, StudentUncheckedUpdateWithoutStudentEnrolledCourseMarksInput>
  }

  export type StudentUpdateWithoutStudentEnrolledCourseMarksInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    studentType?: EnumStudentTypeFieldUpdateOperationsInput | $Enums.StudentType
    firstName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    contactNo?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: StringFieldUpdateOperationsInput | string
    isWoker?: BoolFieldUpdateOperationsInput | boolean
    shift?: EnumShiftFieldUpdateOperationsInput | $Enums.Shift
    yearLevel?: EnumYearLevelFieldUpdateOperationsInput | $Enums.YearLevel
    isActive?: BoolFieldUpdateOperationsInput | boolean
    password?: StringFieldUpdateOperationsInput | string
    gradeDeclarationFile?: StringFieldUpdateOperationsInput | string
    biFile?: StringFieldUpdateOperationsInput | string
    presentAddress?: StringFieldUpdateOperationsInput | string
    permanentAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    academicFaculty?: AcademicFacultyUpdateOneRequiredWithoutStudentsNestedInput
    admissionRegistration?: AdmitionExameRegistrationUpdateOneWithoutStudentNestedInput
    academicDepartment?: AcademicDepartmentUpdateOneRequiredWithoutStudentsNestedInput
    academicSemester?: AcademicSemesterUpdateOneRequiredWithoutStudentsNestedInput
    studentSemesterRegistrations?: StudentSemesterRegistrationUpdateManyWithoutStudentNestedInput
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseUpdateManyWithoutStudentNestedInput
    studentEnrolledCourses?: StudentEnrolledCourseUpdateManyWithoutStudentNestedInput
    studentSemesterPayments?: StudentSemesterPaymentUpdateManyWithoutStudentNestedInput
    studentAcademicInfos?: StudentAcademicInfoUpdateManyWithoutStudentNestedInput
    StudentCarriedCourse?: StudentCarriedCourseUpdateManyWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateWithoutStudentEnrolledCourseMarksInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    studentType?: EnumStudentTypeFieldUpdateOperationsInput | $Enums.StudentType
    firstName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    contactNo?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: StringFieldUpdateOperationsInput | string
    isWoker?: BoolFieldUpdateOperationsInput | boolean
    shift?: EnumShiftFieldUpdateOperationsInput | $Enums.Shift
    yearLevel?: EnumYearLevelFieldUpdateOperationsInput | $Enums.YearLevel
    isActive?: BoolFieldUpdateOperationsInput | boolean
    password?: StringFieldUpdateOperationsInput | string
    gradeDeclarationFile?: StringFieldUpdateOperationsInput | string
    biFile?: StringFieldUpdateOperationsInput | string
    presentAddress?: StringFieldUpdateOperationsInput | string
    permanentAddress?: NullableStringFieldUpdateOperationsInput | string | null
    academicSemesterId?: StringFieldUpdateOperationsInput | string
    academicFacultyId?: StringFieldUpdateOperationsInput | string
    academicDepartmentId?: StringFieldUpdateOperationsInput | string
    admissionRegistrationId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    studentSemesterRegistrations?: StudentSemesterRegistrationUncheckedUpdateManyWithoutStudentNestedInput
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseUncheckedUpdateManyWithoutStudentNestedInput
    studentEnrolledCourses?: StudentEnrolledCourseUncheckedUpdateManyWithoutStudentNestedInput
    studentSemesterPayments?: StudentSemesterPaymentUncheckedUpdateManyWithoutStudentNestedInput
    studentAcademicInfos?: StudentAcademicInfoUncheckedUpdateManyWithoutStudentNestedInput
    StudentCarriedCourse?: StudentCarriedCourseUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type StudentEnrolledCourseUpsertWithoutStudentEnrolledCourseMarksInput = {
    update: XOR<StudentEnrolledCourseUpdateWithoutStudentEnrolledCourseMarksInput, StudentEnrolledCourseUncheckedUpdateWithoutStudentEnrolledCourseMarksInput>
    create: XOR<StudentEnrolledCourseCreateWithoutStudentEnrolledCourseMarksInput, StudentEnrolledCourseUncheckedCreateWithoutStudentEnrolledCourseMarksInput>
    where?: StudentEnrolledCourseWhereInput
  }

  export type StudentEnrolledCourseUpdateToOneWithWhereWithoutStudentEnrolledCourseMarksInput = {
    where?: StudentEnrolledCourseWhereInput
    data: XOR<StudentEnrolledCourseUpdateWithoutStudentEnrolledCourseMarksInput, StudentEnrolledCourseUncheckedUpdateWithoutStudentEnrolledCourseMarksInput>
  }

  export type StudentEnrolledCourseUpdateWithoutStudentEnrolledCourseMarksInput = {
    id?: StringFieldUpdateOperationsInput | string
    grade?: NullableStringFieldUpdateOperationsInput | string | null
    point?: NullableFloatFieldUpdateOperationsInput | number | null
    totalMarks?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableEnumStudentEnrolledCourseStatusFieldUpdateOperationsInput | $Enums.StudentEnrolledCourseStatus | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUpdateOneRequiredWithoutStudentEnrolledCoursesNestedInput
    course?: CourseUpdateOneRequiredWithoutStudentCoursesNestedInput
    academicSemester?: AcademicSemesterUpdateOneRequiredWithoutStudentEnrolledCoursesNestedInput
  }

  export type StudentEnrolledCourseUncheckedUpdateWithoutStudentEnrolledCourseMarksInput = {
    id?: StringFieldUpdateOperationsInput | string
    grade?: NullableStringFieldUpdateOperationsInput | string | null
    point?: NullableFloatFieldUpdateOperationsInput | number | null
    totalMarks?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableEnumStudentEnrolledCourseStatusFieldUpdateOperationsInput | $Enums.StudentEnrolledCourseStatus | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    studentId?: StringFieldUpdateOperationsInput | string
    academicSemesterId?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
  }

  export type AcademicSemesterUpsertWithoutStudentEnrolledCourseMarksInput = {
    update: XOR<AcademicSemesterUpdateWithoutStudentEnrolledCourseMarksInput, AcademicSemesterUncheckedUpdateWithoutStudentEnrolledCourseMarksInput>
    create: XOR<AcademicSemesterCreateWithoutStudentEnrolledCourseMarksInput, AcademicSemesterUncheckedCreateWithoutStudentEnrolledCourseMarksInput>
    where?: AcademicSemesterWhereInput
  }

  export type AcademicSemesterUpdateToOneWithWhereWithoutStudentEnrolledCourseMarksInput = {
    where?: AcademicSemesterWhereInput
    data: XOR<AcademicSemesterUpdateWithoutStudentEnrolledCourseMarksInput, AcademicSemesterUncheckedUpdateWithoutStudentEnrolledCourseMarksInput>
  }

  export type AcademicSemesterUpdateWithoutStudentEnrolledCourseMarksInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    year?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    startMonth?: StringFieldUpdateOperationsInput | string
    endMonth?: StringFieldUpdateOperationsInput | string
    isCurrent?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    courseDisciplines?: CourseDisciplineUpdateManyWithoutSemesterNestedInput
    semesterRegistrations?: SemesterRegistrationUpdateManyWithoutAcademicSemesterNestedInput
    students?: StudentUpdateManyWithoutAcademicSemesterNestedInput
    studentEnrolledCourses?: StudentEnrolledCourseUpdateManyWithoutAcademicSemesterNestedInput
    studentSemesterPayments?: StudentSemesterPaymentUpdateManyWithoutAcademicSemesterNestedInput
    StudentCarriedCourse?: StudentCarriedCourseUpdateManyWithoutSemesterNestedInput
  }

  export type AcademicSemesterUncheckedUpdateWithoutStudentEnrolledCourseMarksInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    year?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    startMonth?: StringFieldUpdateOperationsInput | string
    endMonth?: StringFieldUpdateOperationsInput | string
    isCurrent?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    courseDisciplines?: CourseDisciplineUncheckedUpdateManyWithoutSemesterNestedInput
    semesterRegistrations?: SemesterRegistrationUncheckedUpdateManyWithoutAcademicSemesterNestedInput
    students?: StudentUncheckedUpdateManyWithoutAcademicSemesterNestedInput
    studentEnrolledCourses?: StudentEnrolledCourseUncheckedUpdateManyWithoutAcademicSemesterNestedInput
    studentSemesterPayments?: StudentSemesterPaymentUncheckedUpdateManyWithoutAcademicSemesterNestedInput
    StudentCarriedCourse?: StudentCarriedCourseUncheckedUpdateManyWithoutSemesterNestedInput
  }

  export type CourseCreateWithoutCourseDisciplinesInput = {
    id?: string
    title: string
    code: string
    durationInYears: number
    yearLevel?: $Enums.YearLevel
    shift?: $Enums.Shift
    createdAt?: Date | string
    updatedAt?: Date | string
    coursePricing?: CoursePricingCreateNestedOneWithoutCourseInput
    academicDepartment: AcademicDepartmentCreateNestedOneWithoutCoursesInput
    studentCourses?: StudentEnrolledCourseCreateNestedManyWithoutCourseInput
    preRequisite?: CourseToPreRequisiteCreateNestedManyWithoutCourseInput
    preRequisiteFor?: CourseToPreRequisiteCreateNestedManyWithoutPreRequisiteInput
    faculties?: CourseFacultyCreateNestedManyWithoutCourseInput
    offeredCourses?: OfferedCourseCreateNestedManyWithoutCourseInput
  }

  export type CourseUncheckedCreateWithoutCourseDisciplinesInput = {
    id?: string
    title: string
    code: string
    durationInYears: number
    yearLevel?: $Enums.YearLevel
    shift?: $Enums.Shift
    academicDepartmentId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    coursePricing?: CoursePricingUncheckedCreateNestedOneWithoutCourseInput
    studentCourses?: StudentEnrolledCourseUncheckedCreateNestedManyWithoutCourseInput
    preRequisite?: CourseToPreRequisiteUncheckedCreateNestedManyWithoutCourseInput
    preRequisiteFor?: CourseToPreRequisiteUncheckedCreateNestedManyWithoutPreRequisiteInput
    faculties?: CourseFacultyUncheckedCreateNestedManyWithoutCourseInput
    offeredCourses?: OfferedCourseUncheckedCreateNestedManyWithoutCourseInput
  }

  export type CourseCreateOrConnectWithoutCourseDisciplinesInput = {
    where: CourseWhereUniqueInput
    create: XOR<CourseCreateWithoutCourseDisciplinesInput, CourseUncheckedCreateWithoutCourseDisciplinesInput>
  }

  export type DisciplineCreateWithoutCourseDisciplinesInput = {
    id?: string
    name: string
    code: string
    description?: string | null
    credits: number
    minimumGradeToDismiss?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    StudentCarriedCourse?: StudentCarriedCourseCreateNestedManyWithoutDisciplineInput
  }

  export type DisciplineUncheckedCreateWithoutCourseDisciplinesInput = {
    id?: string
    name: string
    code: string
    description?: string | null
    credits: number
    minimumGradeToDismiss?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    StudentCarriedCourse?: StudentCarriedCourseUncheckedCreateNestedManyWithoutDisciplineInput
  }

  export type DisciplineCreateOrConnectWithoutCourseDisciplinesInput = {
    where: DisciplineWhereUniqueInput
    create: XOR<DisciplineCreateWithoutCourseDisciplinesInput, DisciplineUncheckedCreateWithoutCourseDisciplinesInput>
  }

  export type AcademicSemesterCreateWithoutCourseDisciplinesInput = {
    id?: string
    title: string
    year: string
    code: string
    startMonth: string
    endMonth: string
    isCurrent?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    semesterRegistrations?: SemesterRegistrationCreateNestedManyWithoutAcademicSemesterInput
    students?: StudentCreateNestedManyWithoutAcademicSemesterInput
    studentEnrolledCourses?: StudentEnrolledCourseCreateNestedManyWithoutAcademicSemesterInput
    studentEnrolledCourseMarks?: StudentEnrolledCourseMarkCreateNestedManyWithoutAcademicSemesterInput
    studentSemesterPayments?: StudentSemesterPaymentCreateNestedManyWithoutAcademicSemesterInput
    StudentCarriedCourse?: StudentCarriedCourseCreateNestedManyWithoutSemesterInput
  }

  export type AcademicSemesterUncheckedCreateWithoutCourseDisciplinesInput = {
    id?: string
    title: string
    year: string
    code: string
    startMonth: string
    endMonth: string
    isCurrent?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    semesterRegistrations?: SemesterRegistrationUncheckedCreateNestedManyWithoutAcademicSemesterInput
    students?: StudentUncheckedCreateNestedManyWithoutAcademicSemesterInput
    studentEnrolledCourses?: StudentEnrolledCourseUncheckedCreateNestedManyWithoutAcademicSemesterInput
    studentEnrolledCourseMarks?: StudentEnrolledCourseMarkUncheckedCreateNestedManyWithoutAcademicSemesterInput
    studentSemesterPayments?: StudentSemesterPaymentUncheckedCreateNestedManyWithoutAcademicSemesterInput
    StudentCarriedCourse?: StudentCarriedCourseUncheckedCreateNestedManyWithoutSemesterInput
  }

  export type AcademicSemesterCreateOrConnectWithoutCourseDisciplinesInput = {
    where: AcademicSemesterWhereUniqueInput
    create: XOR<AcademicSemesterCreateWithoutCourseDisciplinesInput, AcademicSemesterUncheckedCreateWithoutCourseDisciplinesInput>
  }

  export type CourseUpsertWithoutCourseDisciplinesInput = {
    update: XOR<CourseUpdateWithoutCourseDisciplinesInput, CourseUncheckedUpdateWithoutCourseDisciplinesInput>
    create: XOR<CourseCreateWithoutCourseDisciplinesInput, CourseUncheckedCreateWithoutCourseDisciplinesInput>
    where?: CourseWhereInput
  }

  export type CourseUpdateToOneWithWhereWithoutCourseDisciplinesInput = {
    where?: CourseWhereInput
    data: XOR<CourseUpdateWithoutCourseDisciplinesInput, CourseUncheckedUpdateWithoutCourseDisciplinesInput>
  }

  export type CourseUpdateWithoutCourseDisciplinesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    durationInYears?: IntFieldUpdateOperationsInput | number
    yearLevel?: EnumYearLevelFieldUpdateOperationsInput | $Enums.YearLevel
    shift?: EnumShiftFieldUpdateOperationsInput | $Enums.Shift
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    coursePricing?: CoursePricingUpdateOneWithoutCourseNestedInput
    academicDepartment?: AcademicDepartmentUpdateOneRequiredWithoutCoursesNestedInput
    studentCourses?: StudentEnrolledCourseUpdateManyWithoutCourseNestedInput
    preRequisite?: CourseToPreRequisiteUpdateManyWithoutCourseNestedInput
    preRequisiteFor?: CourseToPreRequisiteUpdateManyWithoutPreRequisiteNestedInput
    faculties?: CourseFacultyUpdateManyWithoutCourseNestedInput
    offeredCourses?: OfferedCourseUpdateManyWithoutCourseNestedInput
  }

  export type CourseUncheckedUpdateWithoutCourseDisciplinesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    durationInYears?: IntFieldUpdateOperationsInput | number
    yearLevel?: EnumYearLevelFieldUpdateOperationsInput | $Enums.YearLevel
    shift?: EnumShiftFieldUpdateOperationsInput | $Enums.Shift
    academicDepartmentId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    coursePricing?: CoursePricingUncheckedUpdateOneWithoutCourseNestedInput
    studentCourses?: StudentEnrolledCourseUncheckedUpdateManyWithoutCourseNestedInput
    preRequisite?: CourseToPreRequisiteUncheckedUpdateManyWithoutCourseNestedInput
    preRequisiteFor?: CourseToPreRequisiteUncheckedUpdateManyWithoutPreRequisiteNestedInput
    faculties?: CourseFacultyUncheckedUpdateManyWithoutCourseNestedInput
    offeredCourses?: OfferedCourseUncheckedUpdateManyWithoutCourseNestedInput
  }

  export type DisciplineUpsertWithoutCourseDisciplinesInput = {
    update: XOR<DisciplineUpdateWithoutCourseDisciplinesInput, DisciplineUncheckedUpdateWithoutCourseDisciplinesInput>
    create: XOR<DisciplineCreateWithoutCourseDisciplinesInput, DisciplineUncheckedCreateWithoutCourseDisciplinesInput>
    where?: DisciplineWhereInput
  }

  export type DisciplineUpdateToOneWithWhereWithoutCourseDisciplinesInput = {
    where?: DisciplineWhereInput
    data: XOR<DisciplineUpdateWithoutCourseDisciplinesInput, DisciplineUncheckedUpdateWithoutCourseDisciplinesInput>
  }

  export type DisciplineUpdateWithoutCourseDisciplinesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    credits?: IntFieldUpdateOperationsInput | number
    minimumGradeToDismiss?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    StudentCarriedCourse?: StudentCarriedCourseUpdateManyWithoutDisciplineNestedInput
  }

  export type DisciplineUncheckedUpdateWithoutCourseDisciplinesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    credits?: IntFieldUpdateOperationsInput | number
    minimumGradeToDismiss?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    StudentCarriedCourse?: StudentCarriedCourseUncheckedUpdateManyWithoutDisciplineNestedInput
  }

  export type AcademicSemesterUpsertWithoutCourseDisciplinesInput = {
    update: XOR<AcademicSemesterUpdateWithoutCourseDisciplinesInput, AcademicSemesterUncheckedUpdateWithoutCourseDisciplinesInput>
    create: XOR<AcademicSemesterCreateWithoutCourseDisciplinesInput, AcademicSemesterUncheckedCreateWithoutCourseDisciplinesInput>
    where?: AcademicSemesterWhereInput
  }

  export type AcademicSemesterUpdateToOneWithWhereWithoutCourseDisciplinesInput = {
    where?: AcademicSemesterWhereInput
    data: XOR<AcademicSemesterUpdateWithoutCourseDisciplinesInput, AcademicSemesterUncheckedUpdateWithoutCourseDisciplinesInput>
  }

  export type AcademicSemesterUpdateWithoutCourseDisciplinesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    year?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    startMonth?: StringFieldUpdateOperationsInput | string
    endMonth?: StringFieldUpdateOperationsInput | string
    isCurrent?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    semesterRegistrations?: SemesterRegistrationUpdateManyWithoutAcademicSemesterNestedInput
    students?: StudentUpdateManyWithoutAcademicSemesterNestedInput
    studentEnrolledCourses?: StudentEnrolledCourseUpdateManyWithoutAcademicSemesterNestedInput
    studentEnrolledCourseMarks?: StudentEnrolledCourseMarkUpdateManyWithoutAcademicSemesterNestedInput
    studentSemesterPayments?: StudentSemesterPaymentUpdateManyWithoutAcademicSemesterNestedInput
    StudentCarriedCourse?: StudentCarriedCourseUpdateManyWithoutSemesterNestedInput
  }

  export type AcademicSemesterUncheckedUpdateWithoutCourseDisciplinesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    year?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    startMonth?: StringFieldUpdateOperationsInput | string
    endMonth?: StringFieldUpdateOperationsInput | string
    isCurrent?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    semesterRegistrations?: SemesterRegistrationUncheckedUpdateManyWithoutAcademicSemesterNestedInput
    students?: StudentUncheckedUpdateManyWithoutAcademicSemesterNestedInput
    studentEnrolledCourses?: StudentEnrolledCourseUncheckedUpdateManyWithoutAcademicSemesterNestedInput
    studentEnrolledCourseMarks?: StudentEnrolledCourseMarkUncheckedUpdateManyWithoutAcademicSemesterNestedInput
    studentSemesterPayments?: StudentSemesterPaymentUncheckedUpdateManyWithoutAcademicSemesterNestedInput
    StudentCarriedCourse?: StudentCarriedCourseUncheckedUpdateManyWithoutSemesterNestedInput
  }

  export type StudentCreateWithoutStudentCarriedCourseInput = {
    id?: string
    studentId: string
    studentType?: $Enums.StudentType
    firstName: string
    middleName?: string | null
    lastName: string
    profileImage?: string | null
    email?: string | null
    contactNo?: string | null
    gender: string
    isWoker?: boolean
    shift?: $Enums.Shift
    yearLevel?: $Enums.YearLevel
    isActive?: boolean
    password: string
    gradeDeclarationFile: string
    biFile: string
    presentAddress: string
    permanentAddress?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    academicFaculty: AcademicFacultyCreateNestedOneWithoutStudentsInput
    admissionRegistration?: AdmitionExameRegistrationCreateNestedOneWithoutStudentInput
    academicDepartment: AcademicDepartmentCreateNestedOneWithoutStudentsInput
    academicSemester: AcademicSemesterCreateNestedOneWithoutStudentsInput
    studentSemesterRegistrations?: StudentSemesterRegistrationCreateNestedManyWithoutStudentInput
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseCreateNestedManyWithoutStudentInput
    studentEnrolledCourses?: StudentEnrolledCourseCreateNestedManyWithoutStudentInput
    studentEnrolledCourseMarks?: StudentEnrolledCourseMarkCreateNestedManyWithoutStudentInput
    studentSemesterPayments?: StudentSemesterPaymentCreateNestedManyWithoutStudentInput
    studentAcademicInfos?: StudentAcademicInfoCreateNestedManyWithoutStudentInput
  }

  export type StudentUncheckedCreateWithoutStudentCarriedCourseInput = {
    id?: string
    studentId: string
    studentType?: $Enums.StudentType
    firstName: string
    middleName?: string | null
    lastName: string
    profileImage?: string | null
    email?: string | null
    contactNo?: string | null
    gender: string
    isWoker?: boolean
    shift?: $Enums.Shift
    yearLevel?: $Enums.YearLevel
    isActive?: boolean
    password: string
    gradeDeclarationFile: string
    biFile: string
    presentAddress: string
    permanentAddress?: string | null
    academicSemesterId: string
    academicFacultyId: string
    academicDepartmentId: string
    admissionRegistrationId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    studentSemesterRegistrations?: StudentSemesterRegistrationUncheckedCreateNestedManyWithoutStudentInput
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseUncheckedCreateNestedManyWithoutStudentInput
    studentEnrolledCourses?: StudentEnrolledCourseUncheckedCreateNestedManyWithoutStudentInput
    studentEnrolledCourseMarks?: StudentEnrolledCourseMarkUncheckedCreateNestedManyWithoutStudentInput
    studentSemesterPayments?: StudentSemesterPaymentUncheckedCreateNestedManyWithoutStudentInput
    studentAcademicInfos?: StudentAcademicInfoUncheckedCreateNestedManyWithoutStudentInput
  }

  export type StudentCreateOrConnectWithoutStudentCarriedCourseInput = {
    where: StudentWhereUniqueInput
    create: XOR<StudentCreateWithoutStudentCarriedCourseInput, StudentUncheckedCreateWithoutStudentCarriedCourseInput>
  }

  export type DisciplineCreateWithoutStudentCarriedCourseInput = {
    id?: string
    name: string
    code: string
    description?: string | null
    credits: number
    minimumGradeToDismiss?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    courseDisciplines?: CourseDisciplineCreateNestedManyWithoutDisciplineInput
  }

  export type DisciplineUncheckedCreateWithoutStudentCarriedCourseInput = {
    id?: string
    name: string
    code: string
    description?: string | null
    credits: number
    minimumGradeToDismiss?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    courseDisciplines?: CourseDisciplineUncheckedCreateNestedManyWithoutDisciplineInput
  }

  export type DisciplineCreateOrConnectWithoutStudentCarriedCourseInput = {
    where: DisciplineWhereUniqueInput
    create: XOR<DisciplineCreateWithoutStudentCarriedCourseInput, DisciplineUncheckedCreateWithoutStudentCarriedCourseInput>
  }

  export type AcademicSemesterCreateWithoutStudentCarriedCourseInput = {
    id?: string
    title: string
    year: string
    code: string
    startMonth: string
    endMonth: string
    isCurrent?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    courseDisciplines?: CourseDisciplineCreateNestedManyWithoutSemesterInput
    semesterRegistrations?: SemesterRegistrationCreateNestedManyWithoutAcademicSemesterInput
    students?: StudentCreateNestedManyWithoutAcademicSemesterInput
    studentEnrolledCourses?: StudentEnrolledCourseCreateNestedManyWithoutAcademicSemesterInput
    studentEnrolledCourseMarks?: StudentEnrolledCourseMarkCreateNestedManyWithoutAcademicSemesterInput
    studentSemesterPayments?: StudentSemesterPaymentCreateNestedManyWithoutAcademicSemesterInput
  }

  export type AcademicSemesterUncheckedCreateWithoutStudentCarriedCourseInput = {
    id?: string
    title: string
    year: string
    code: string
    startMonth: string
    endMonth: string
    isCurrent?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    courseDisciplines?: CourseDisciplineUncheckedCreateNestedManyWithoutSemesterInput
    semesterRegistrations?: SemesterRegistrationUncheckedCreateNestedManyWithoutAcademicSemesterInput
    students?: StudentUncheckedCreateNestedManyWithoutAcademicSemesterInput
    studentEnrolledCourses?: StudentEnrolledCourseUncheckedCreateNestedManyWithoutAcademicSemesterInput
    studentEnrolledCourseMarks?: StudentEnrolledCourseMarkUncheckedCreateNestedManyWithoutAcademicSemesterInput
    studentSemesterPayments?: StudentSemesterPaymentUncheckedCreateNestedManyWithoutAcademicSemesterInput
  }

  export type AcademicSemesterCreateOrConnectWithoutStudentCarriedCourseInput = {
    where: AcademicSemesterWhereUniqueInput
    create: XOR<AcademicSemesterCreateWithoutStudentCarriedCourseInput, AcademicSemesterUncheckedCreateWithoutStudentCarriedCourseInput>
  }

  export type StudentUpsertWithoutStudentCarriedCourseInput = {
    update: XOR<StudentUpdateWithoutStudentCarriedCourseInput, StudentUncheckedUpdateWithoutStudentCarriedCourseInput>
    create: XOR<StudentCreateWithoutStudentCarriedCourseInput, StudentUncheckedCreateWithoutStudentCarriedCourseInput>
    where?: StudentWhereInput
  }

  export type StudentUpdateToOneWithWhereWithoutStudentCarriedCourseInput = {
    where?: StudentWhereInput
    data: XOR<StudentUpdateWithoutStudentCarriedCourseInput, StudentUncheckedUpdateWithoutStudentCarriedCourseInput>
  }

  export type StudentUpdateWithoutStudentCarriedCourseInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    studentType?: EnumStudentTypeFieldUpdateOperationsInput | $Enums.StudentType
    firstName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    contactNo?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: StringFieldUpdateOperationsInput | string
    isWoker?: BoolFieldUpdateOperationsInput | boolean
    shift?: EnumShiftFieldUpdateOperationsInput | $Enums.Shift
    yearLevel?: EnumYearLevelFieldUpdateOperationsInput | $Enums.YearLevel
    isActive?: BoolFieldUpdateOperationsInput | boolean
    password?: StringFieldUpdateOperationsInput | string
    gradeDeclarationFile?: StringFieldUpdateOperationsInput | string
    biFile?: StringFieldUpdateOperationsInput | string
    presentAddress?: StringFieldUpdateOperationsInput | string
    permanentAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    academicFaculty?: AcademicFacultyUpdateOneRequiredWithoutStudentsNestedInput
    admissionRegistration?: AdmitionExameRegistrationUpdateOneWithoutStudentNestedInput
    academicDepartment?: AcademicDepartmentUpdateOneRequiredWithoutStudentsNestedInput
    academicSemester?: AcademicSemesterUpdateOneRequiredWithoutStudentsNestedInput
    studentSemesterRegistrations?: StudentSemesterRegistrationUpdateManyWithoutStudentNestedInput
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseUpdateManyWithoutStudentNestedInput
    studentEnrolledCourses?: StudentEnrolledCourseUpdateManyWithoutStudentNestedInput
    studentEnrolledCourseMarks?: StudentEnrolledCourseMarkUpdateManyWithoutStudentNestedInput
    studentSemesterPayments?: StudentSemesterPaymentUpdateManyWithoutStudentNestedInput
    studentAcademicInfos?: StudentAcademicInfoUpdateManyWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateWithoutStudentCarriedCourseInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    studentType?: EnumStudentTypeFieldUpdateOperationsInput | $Enums.StudentType
    firstName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    contactNo?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: StringFieldUpdateOperationsInput | string
    isWoker?: BoolFieldUpdateOperationsInput | boolean
    shift?: EnumShiftFieldUpdateOperationsInput | $Enums.Shift
    yearLevel?: EnumYearLevelFieldUpdateOperationsInput | $Enums.YearLevel
    isActive?: BoolFieldUpdateOperationsInput | boolean
    password?: StringFieldUpdateOperationsInput | string
    gradeDeclarationFile?: StringFieldUpdateOperationsInput | string
    biFile?: StringFieldUpdateOperationsInput | string
    presentAddress?: StringFieldUpdateOperationsInput | string
    permanentAddress?: NullableStringFieldUpdateOperationsInput | string | null
    academicSemesterId?: StringFieldUpdateOperationsInput | string
    academicFacultyId?: StringFieldUpdateOperationsInput | string
    academicDepartmentId?: StringFieldUpdateOperationsInput | string
    admissionRegistrationId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    studentSemesterRegistrations?: StudentSemesterRegistrationUncheckedUpdateManyWithoutStudentNestedInput
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseUncheckedUpdateManyWithoutStudentNestedInput
    studentEnrolledCourses?: StudentEnrolledCourseUncheckedUpdateManyWithoutStudentNestedInput
    studentEnrolledCourseMarks?: StudentEnrolledCourseMarkUncheckedUpdateManyWithoutStudentNestedInput
    studentSemesterPayments?: StudentSemesterPaymentUncheckedUpdateManyWithoutStudentNestedInput
    studentAcademicInfos?: StudentAcademicInfoUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type DisciplineUpsertWithoutStudentCarriedCourseInput = {
    update: XOR<DisciplineUpdateWithoutStudentCarriedCourseInput, DisciplineUncheckedUpdateWithoutStudentCarriedCourseInput>
    create: XOR<DisciplineCreateWithoutStudentCarriedCourseInput, DisciplineUncheckedCreateWithoutStudentCarriedCourseInput>
    where?: DisciplineWhereInput
  }

  export type DisciplineUpdateToOneWithWhereWithoutStudentCarriedCourseInput = {
    where?: DisciplineWhereInput
    data: XOR<DisciplineUpdateWithoutStudentCarriedCourseInput, DisciplineUncheckedUpdateWithoutStudentCarriedCourseInput>
  }

  export type DisciplineUpdateWithoutStudentCarriedCourseInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    credits?: IntFieldUpdateOperationsInput | number
    minimumGradeToDismiss?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    courseDisciplines?: CourseDisciplineUpdateManyWithoutDisciplineNestedInput
  }

  export type DisciplineUncheckedUpdateWithoutStudentCarriedCourseInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    credits?: IntFieldUpdateOperationsInput | number
    minimumGradeToDismiss?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    courseDisciplines?: CourseDisciplineUncheckedUpdateManyWithoutDisciplineNestedInput
  }

  export type AcademicSemesterUpsertWithoutStudentCarriedCourseInput = {
    update: XOR<AcademicSemesterUpdateWithoutStudentCarriedCourseInput, AcademicSemesterUncheckedUpdateWithoutStudentCarriedCourseInput>
    create: XOR<AcademicSemesterCreateWithoutStudentCarriedCourseInput, AcademicSemesterUncheckedCreateWithoutStudentCarriedCourseInput>
    where?: AcademicSemesterWhereInput
  }

  export type AcademicSemesterUpdateToOneWithWhereWithoutStudentCarriedCourseInput = {
    where?: AcademicSemesterWhereInput
    data: XOR<AcademicSemesterUpdateWithoutStudentCarriedCourseInput, AcademicSemesterUncheckedUpdateWithoutStudentCarriedCourseInput>
  }

  export type AcademicSemesterUpdateWithoutStudentCarriedCourseInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    year?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    startMonth?: StringFieldUpdateOperationsInput | string
    endMonth?: StringFieldUpdateOperationsInput | string
    isCurrent?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    courseDisciplines?: CourseDisciplineUpdateManyWithoutSemesterNestedInput
    semesterRegistrations?: SemesterRegistrationUpdateManyWithoutAcademicSemesterNestedInput
    students?: StudentUpdateManyWithoutAcademicSemesterNestedInput
    studentEnrolledCourses?: StudentEnrolledCourseUpdateManyWithoutAcademicSemesterNestedInput
    studentEnrolledCourseMarks?: StudentEnrolledCourseMarkUpdateManyWithoutAcademicSemesterNestedInput
    studentSemesterPayments?: StudentSemesterPaymentUpdateManyWithoutAcademicSemesterNestedInput
  }

  export type AcademicSemesterUncheckedUpdateWithoutStudentCarriedCourseInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    year?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    startMonth?: StringFieldUpdateOperationsInput | string
    endMonth?: StringFieldUpdateOperationsInput | string
    isCurrent?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    courseDisciplines?: CourseDisciplineUncheckedUpdateManyWithoutSemesterNestedInput
    semesterRegistrations?: SemesterRegistrationUncheckedUpdateManyWithoutAcademicSemesterNestedInput
    students?: StudentUncheckedUpdateManyWithoutAcademicSemesterNestedInput
    studentEnrolledCourses?: StudentEnrolledCourseUncheckedUpdateManyWithoutAcademicSemesterNestedInput
    studentEnrolledCourseMarks?: StudentEnrolledCourseMarkUncheckedUpdateManyWithoutAcademicSemesterNestedInput
    studentSemesterPayments?: StudentSemesterPaymentUncheckedUpdateManyWithoutAcademicSemesterNestedInput
  }

  export type CourseCreateWithoutCoursePricingInput = {
    id?: string
    title: string
    code: string
    durationInYears: number
    yearLevel?: $Enums.YearLevel
    shift?: $Enums.Shift
    createdAt?: Date | string
    updatedAt?: Date | string
    courseDisciplines?: CourseDisciplineCreateNestedManyWithoutCourseInput
    academicDepartment: AcademicDepartmentCreateNestedOneWithoutCoursesInput
    studentCourses?: StudentEnrolledCourseCreateNestedManyWithoutCourseInput
    preRequisite?: CourseToPreRequisiteCreateNestedManyWithoutCourseInput
    preRequisiteFor?: CourseToPreRequisiteCreateNestedManyWithoutPreRequisiteInput
    faculties?: CourseFacultyCreateNestedManyWithoutCourseInput
    offeredCourses?: OfferedCourseCreateNestedManyWithoutCourseInput
  }

  export type CourseUncheckedCreateWithoutCoursePricingInput = {
    id?: string
    title: string
    code: string
    durationInYears: number
    yearLevel?: $Enums.YearLevel
    shift?: $Enums.Shift
    academicDepartmentId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    courseDisciplines?: CourseDisciplineUncheckedCreateNestedManyWithoutCourseInput
    studentCourses?: StudentEnrolledCourseUncheckedCreateNestedManyWithoutCourseInput
    preRequisite?: CourseToPreRequisiteUncheckedCreateNestedManyWithoutCourseInput
    preRequisiteFor?: CourseToPreRequisiteUncheckedCreateNestedManyWithoutPreRequisiteInput
    faculties?: CourseFacultyUncheckedCreateNestedManyWithoutCourseInput
    offeredCourses?: OfferedCourseUncheckedCreateNestedManyWithoutCourseInput
  }

  export type CourseCreateOrConnectWithoutCoursePricingInput = {
    where: CourseWhereUniqueInput
    create: XOR<CourseCreateWithoutCoursePricingInput, CourseUncheckedCreateWithoutCoursePricingInput>
  }

  export type CourseUpsertWithoutCoursePricingInput = {
    update: XOR<CourseUpdateWithoutCoursePricingInput, CourseUncheckedUpdateWithoutCoursePricingInput>
    create: XOR<CourseCreateWithoutCoursePricingInput, CourseUncheckedCreateWithoutCoursePricingInput>
    where?: CourseWhereInput
  }

  export type CourseUpdateToOneWithWhereWithoutCoursePricingInput = {
    where?: CourseWhereInput
    data: XOR<CourseUpdateWithoutCoursePricingInput, CourseUncheckedUpdateWithoutCoursePricingInput>
  }

  export type CourseUpdateWithoutCoursePricingInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    durationInYears?: IntFieldUpdateOperationsInput | number
    yearLevel?: EnumYearLevelFieldUpdateOperationsInput | $Enums.YearLevel
    shift?: EnumShiftFieldUpdateOperationsInput | $Enums.Shift
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    courseDisciplines?: CourseDisciplineUpdateManyWithoutCourseNestedInput
    academicDepartment?: AcademicDepartmentUpdateOneRequiredWithoutCoursesNestedInput
    studentCourses?: StudentEnrolledCourseUpdateManyWithoutCourseNestedInput
    preRequisite?: CourseToPreRequisiteUpdateManyWithoutCourseNestedInput
    preRequisiteFor?: CourseToPreRequisiteUpdateManyWithoutPreRequisiteNestedInput
    faculties?: CourseFacultyUpdateManyWithoutCourseNestedInput
    offeredCourses?: OfferedCourseUpdateManyWithoutCourseNestedInput
  }

  export type CourseUncheckedUpdateWithoutCoursePricingInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    durationInYears?: IntFieldUpdateOperationsInput | number
    yearLevel?: EnumYearLevelFieldUpdateOperationsInput | $Enums.YearLevel
    shift?: EnumShiftFieldUpdateOperationsInput | $Enums.Shift
    academicDepartmentId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    courseDisciplines?: CourseDisciplineUncheckedUpdateManyWithoutCourseNestedInput
    studentCourses?: StudentEnrolledCourseUncheckedUpdateManyWithoutCourseNestedInput
    preRequisite?: CourseToPreRequisiteUncheckedUpdateManyWithoutCourseNestedInput
    preRequisiteFor?: CourseToPreRequisiteUncheckedUpdateManyWithoutPreRequisiteNestedInput
    faculties?: CourseFacultyUncheckedUpdateManyWithoutCourseNestedInput
    offeredCourses?: OfferedCourseUncheckedUpdateManyWithoutCourseNestedInput
  }

  export type CourseDisciplineCreateWithoutDisciplineInput = {
    id?: string
    credits: number
    course: CourseCreateNestedOneWithoutCourseDisciplinesInput
    semester: AcademicSemesterCreateNestedOneWithoutCourseDisciplinesInput
  }

  export type CourseDisciplineUncheckedCreateWithoutDisciplineInput = {
    id?: string
    courseId: string
    semesterId: string
    credits: number
  }

  export type CourseDisciplineCreateOrConnectWithoutDisciplineInput = {
    where: CourseDisciplineWhereUniqueInput
    create: XOR<CourseDisciplineCreateWithoutDisciplineInput, CourseDisciplineUncheckedCreateWithoutDisciplineInput>
  }

  export type CourseDisciplineCreateManyDisciplineInputEnvelope = {
    data: CourseDisciplineCreateManyDisciplineInput | CourseDisciplineCreateManyDisciplineInput[]
    skipDuplicates?: boolean
  }

  export type StudentCarriedCourseCreateWithoutDisciplineInput = {
    id?: string
    shift: $Enums.Shift
    price: number
    status?: $Enums.CarriedCourseStatus
    createdAt?: Date | string
    student: StudentCreateNestedOneWithoutStudentCarriedCourseInput
    semester: AcademicSemesterCreateNestedOneWithoutStudentCarriedCourseInput
  }

  export type StudentCarriedCourseUncheckedCreateWithoutDisciplineInput = {
    id?: string
    studentId: string
    semesterId: string
    shift: $Enums.Shift
    price: number
    status?: $Enums.CarriedCourseStatus
    createdAt?: Date | string
  }

  export type StudentCarriedCourseCreateOrConnectWithoutDisciplineInput = {
    where: StudentCarriedCourseWhereUniqueInput
    create: XOR<StudentCarriedCourseCreateWithoutDisciplineInput, StudentCarriedCourseUncheckedCreateWithoutDisciplineInput>
  }

  export type StudentCarriedCourseCreateManyDisciplineInputEnvelope = {
    data: StudentCarriedCourseCreateManyDisciplineInput | StudentCarriedCourseCreateManyDisciplineInput[]
    skipDuplicates?: boolean
  }

  export type CourseDisciplineUpsertWithWhereUniqueWithoutDisciplineInput = {
    where: CourseDisciplineWhereUniqueInput
    update: XOR<CourseDisciplineUpdateWithoutDisciplineInput, CourseDisciplineUncheckedUpdateWithoutDisciplineInput>
    create: XOR<CourseDisciplineCreateWithoutDisciplineInput, CourseDisciplineUncheckedCreateWithoutDisciplineInput>
  }

  export type CourseDisciplineUpdateWithWhereUniqueWithoutDisciplineInput = {
    where: CourseDisciplineWhereUniqueInput
    data: XOR<CourseDisciplineUpdateWithoutDisciplineInput, CourseDisciplineUncheckedUpdateWithoutDisciplineInput>
  }

  export type CourseDisciplineUpdateManyWithWhereWithoutDisciplineInput = {
    where: CourseDisciplineScalarWhereInput
    data: XOR<CourseDisciplineUpdateManyMutationInput, CourseDisciplineUncheckedUpdateManyWithoutDisciplineInput>
  }

  export type StudentCarriedCourseUpsertWithWhereUniqueWithoutDisciplineInput = {
    where: StudentCarriedCourseWhereUniqueInput
    update: XOR<StudentCarriedCourseUpdateWithoutDisciplineInput, StudentCarriedCourseUncheckedUpdateWithoutDisciplineInput>
    create: XOR<StudentCarriedCourseCreateWithoutDisciplineInput, StudentCarriedCourseUncheckedCreateWithoutDisciplineInput>
  }

  export type StudentCarriedCourseUpdateWithWhereUniqueWithoutDisciplineInput = {
    where: StudentCarriedCourseWhereUniqueInput
    data: XOR<StudentCarriedCourseUpdateWithoutDisciplineInput, StudentCarriedCourseUncheckedUpdateWithoutDisciplineInput>
  }

  export type StudentCarriedCourseUpdateManyWithWhereWithoutDisciplineInput = {
    where: StudentCarriedCourseScalarWhereInput
    data: XOR<StudentCarriedCourseUpdateManyMutationInput, StudentCarriedCourseUncheckedUpdateManyWithoutDisciplineInput>
  }

  export type PaymentCreateWithoutStudentSemesterPaymentInput = {
    id?: string
    paymentRecipt?: string | null
    totalAmount?: number
    approved?: boolean
    paymentType?: $Enums.PAYMENTTYPE
    status?: $Enums.PAYMENTSTATUS
    method?: $Enums.PAYMENTMETHOD
    createdAt?: Date | string
    updatedAt?: Date | string
    PaymentReference?: PaymentReferenceCreateNestedManyWithoutPaymentInput
  }

  export type PaymentUncheckedCreateWithoutStudentSemesterPaymentInput = {
    id?: string
    paymentRecipt?: string | null
    totalAmount?: number
    approved?: boolean
    paymentType?: $Enums.PAYMENTTYPE
    status?: $Enums.PAYMENTSTATUS
    method?: $Enums.PAYMENTMETHOD
    createdAt?: Date | string
    updatedAt?: Date | string
    PaymentReference?: PaymentReferenceUncheckedCreateNestedManyWithoutPaymentInput
  }

  export type PaymentCreateOrConnectWithoutStudentSemesterPaymentInput = {
    where: PaymentWhereUniqueInput
    create: XOR<PaymentCreateWithoutStudentSemesterPaymentInput, PaymentUncheckedCreateWithoutStudentSemesterPaymentInput>
  }

  export type StudentCreateWithoutStudentSemesterPaymentsInput = {
    id?: string
    studentId: string
    studentType?: $Enums.StudentType
    firstName: string
    middleName?: string | null
    lastName: string
    profileImage?: string | null
    email?: string | null
    contactNo?: string | null
    gender: string
    isWoker?: boolean
    shift?: $Enums.Shift
    yearLevel?: $Enums.YearLevel
    isActive?: boolean
    password: string
    gradeDeclarationFile: string
    biFile: string
    presentAddress: string
    permanentAddress?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    academicFaculty: AcademicFacultyCreateNestedOneWithoutStudentsInput
    admissionRegistration?: AdmitionExameRegistrationCreateNestedOneWithoutStudentInput
    academicDepartment: AcademicDepartmentCreateNestedOneWithoutStudentsInput
    academicSemester: AcademicSemesterCreateNestedOneWithoutStudentsInput
    studentSemesterRegistrations?: StudentSemesterRegistrationCreateNestedManyWithoutStudentInput
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseCreateNestedManyWithoutStudentInput
    studentEnrolledCourses?: StudentEnrolledCourseCreateNestedManyWithoutStudentInput
    studentEnrolledCourseMarks?: StudentEnrolledCourseMarkCreateNestedManyWithoutStudentInput
    studentAcademicInfos?: StudentAcademicInfoCreateNestedManyWithoutStudentInput
    StudentCarriedCourse?: StudentCarriedCourseCreateNestedManyWithoutStudentInput
  }

  export type StudentUncheckedCreateWithoutStudentSemesterPaymentsInput = {
    id?: string
    studentId: string
    studentType?: $Enums.StudentType
    firstName: string
    middleName?: string | null
    lastName: string
    profileImage?: string | null
    email?: string | null
    contactNo?: string | null
    gender: string
    isWoker?: boolean
    shift?: $Enums.Shift
    yearLevel?: $Enums.YearLevel
    isActive?: boolean
    password: string
    gradeDeclarationFile: string
    biFile: string
    presentAddress: string
    permanentAddress?: string | null
    academicSemesterId: string
    academicFacultyId: string
    academicDepartmentId: string
    admissionRegistrationId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    studentSemesterRegistrations?: StudentSemesterRegistrationUncheckedCreateNestedManyWithoutStudentInput
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseUncheckedCreateNestedManyWithoutStudentInput
    studentEnrolledCourses?: StudentEnrolledCourseUncheckedCreateNestedManyWithoutStudentInput
    studentEnrolledCourseMarks?: StudentEnrolledCourseMarkUncheckedCreateNestedManyWithoutStudentInput
    studentAcademicInfos?: StudentAcademicInfoUncheckedCreateNestedManyWithoutStudentInput
    StudentCarriedCourse?: StudentCarriedCourseUncheckedCreateNestedManyWithoutStudentInput
  }

  export type StudentCreateOrConnectWithoutStudentSemesterPaymentsInput = {
    where: StudentWhereUniqueInput
    create: XOR<StudentCreateWithoutStudentSemesterPaymentsInput, StudentUncheckedCreateWithoutStudentSemesterPaymentsInput>
  }

  export type AcademicSemesterCreateWithoutStudentSemesterPaymentsInput = {
    id?: string
    title: string
    year: string
    code: string
    startMonth: string
    endMonth: string
    isCurrent?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    courseDisciplines?: CourseDisciplineCreateNestedManyWithoutSemesterInput
    semesterRegistrations?: SemesterRegistrationCreateNestedManyWithoutAcademicSemesterInput
    students?: StudentCreateNestedManyWithoutAcademicSemesterInput
    studentEnrolledCourses?: StudentEnrolledCourseCreateNestedManyWithoutAcademicSemesterInput
    studentEnrolledCourseMarks?: StudentEnrolledCourseMarkCreateNestedManyWithoutAcademicSemesterInput
    StudentCarriedCourse?: StudentCarriedCourseCreateNestedManyWithoutSemesterInput
  }

  export type AcademicSemesterUncheckedCreateWithoutStudentSemesterPaymentsInput = {
    id?: string
    title: string
    year: string
    code: string
    startMonth: string
    endMonth: string
    isCurrent?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    courseDisciplines?: CourseDisciplineUncheckedCreateNestedManyWithoutSemesterInput
    semesterRegistrations?: SemesterRegistrationUncheckedCreateNestedManyWithoutAcademicSemesterInput
    students?: StudentUncheckedCreateNestedManyWithoutAcademicSemesterInput
    studentEnrolledCourses?: StudentEnrolledCourseUncheckedCreateNestedManyWithoutAcademicSemesterInput
    studentEnrolledCourseMarks?: StudentEnrolledCourseMarkUncheckedCreateNestedManyWithoutAcademicSemesterInput
    StudentCarriedCourse?: StudentCarriedCourseUncheckedCreateNestedManyWithoutSemesterInput
  }

  export type AcademicSemesterCreateOrConnectWithoutStudentSemesterPaymentsInput = {
    where: AcademicSemesterWhereUniqueInput
    create: XOR<AcademicSemesterCreateWithoutStudentSemesterPaymentsInput, AcademicSemesterUncheckedCreateWithoutStudentSemesterPaymentsInput>
  }

  export type PaymentUpsertWithoutStudentSemesterPaymentInput = {
    update: XOR<PaymentUpdateWithoutStudentSemesterPaymentInput, PaymentUncheckedUpdateWithoutStudentSemesterPaymentInput>
    create: XOR<PaymentCreateWithoutStudentSemesterPaymentInput, PaymentUncheckedCreateWithoutStudentSemesterPaymentInput>
    where?: PaymentWhereInput
  }

  export type PaymentUpdateToOneWithWhereWithoutStudentSemesterPaymentInput = {
    where?: PaymentWhereInput
    data: XOR<PaymentUpdateWithoutStudentSemesterPaymentInput, PaymentUncheckedUpdateWithoutStudentSemesterPaymentInput>
  }

  export type PaymentUpdateWithoutStudentSemesterPaymentInput = {
    id?: StringFieldUpdateOperationsInput | string
    paymentRecipt?: NullableStringFieldUpdateOperationsInput | string | null
    totalAmount?: IntFieldUpdateOperationsInput | number
    approved?: BoolFieldUpdateOperationsInput | boolean
    paymentType?: EnumPAYMENTTYPEFieldUpdateOperationsInput | $Enums.PAYMENTTYPE
    status?: EnumPAYMENTSTATUSFieldUpdateOperationsInput | $Enums.PAYMENTSTATUS
    method?: EnumPAYMENTMETHODFieldUpdateOperationsInput | $Enums.PAYMENTMETHOD
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    PaymentReference?: PaymentReferenceUpdateManyWithoutPaymentNestedInput
  }

  export type PaymentUncheckedUpdateWithoutStudentSemesterPaymentInput = {
    id?: StringFieldUpdateOperationsInput | string
    paymentRecipt?: NullableStringFieldUpdateOperationsInput | string | null
    totalAmount?: IntFieldUpdateOperationsInput | number
    approved?: BoolFieldUpdateOperationsInput | boolean
    paymentType?: EnumPAYMENTTYPEFieldUpdateOperationsInput | $Enums.PAYMENTTYPE
    status?: EnumPAYMENTSTATUSFieldUpdateOperationsInput | $Enums.PAYMENTSTATUS
    method?: EnumPAYMENTMETHODFieldUpdateOperationsInput | $Enums.PAYMENTMETHOD
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    PaymentReference?: PaymentReferenceUncheckedUpdateManyWithoutPaymentNestedInput
  }

  export type StudentUpsertWithoutStudentSemesterPaymentsInput = {
    update: XOR<StudentUpdateWithoutStudentSemesterPaymentsInput, StudentUncheckedUpdateWithoutStudentSemesterPaymentsInput>
    create: XOR<StudentCreateWithoutStudentSemesterPaymentsInput, StudentUncheckedCreateWithoutStudentSemesterPaymentsInput>
    where?: StudentWhereInput
  }

  export type StudentUpdateToOneWithWhereWithoutStudentSemesterPaymentsInput = {
    where?: StudentWhereInput
    data: XOR<StudentUpdateWithoutStudentSemesterPaymentsInput, StudentUncheckedUpdateWithoutStudentSemesterPaymentsInput>
  }

  export type StudentUpdateWithoutStudentSemesterPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    studentType?: EnumStudentTypeFieldUpdateOperationsInput | $Enums.StudentType
    firstName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    contactNo?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: StringFieldUpdateOperationsInput | string
    isWoker?: BoolFieldUpdateOperationsInput | boolean
    shift?: EnumShiftFieldUpdateOperationsInput | $Enums.Shift
    yearLevel?: EnumYearLevelFieldUpdateOperationsInput | $Enums.YearLevel
    isActive?: BoolFieldUpdateOperationsInput | boolean
    password?: StringFieldUpdateOperationsInput | string
    gradeDeclarationFile?: StringFieldUpdateOperationsInput | string
    biFile?: StringFieldUpdateOperationsInput | string
    presentAddress?: StringFieldUpdateOperationsInput | string
    permanentAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    academicFaculty?: AcademicFacultyUpdateOneRequiredWithoutStudentsNestedInput
    admissionRegistration?: AdmitionExameRegistrationUpdateOneWithoutStudentNestedInput
    academicDepartment?: AcademicDepartmentUpdateOneRequiredWithoutStudentsNestedInput
    academicSemester?: AcademicSemesterUpdateOneRequiredWithoutStudentsNestedInput
    studentSemesterRegistrations?: StudentSemesterRegistrationUpdateManyWithoutStudentNestedInput
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseUpdateManyWithoutStudentNestedInput
    studentEnrolledCourses?: StudentEnrolledCourseUpdateManyWithoutStudentNestedInput
    studentEnrolledCourseMarks?: StudentEnrolledCourseMarkUpdateManyWithoutStudentNestedInput
    studentAcademicInfos?: StudentAcademicInfoUpdateManyWithoutStudentNestedInput
    StudentCarriedCourse?: StudentCarriedCourseUpdateManyWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateWithoutStudentSemesterPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    studentType?: EnumStudentTypeFieldUpdateOperationsInput | $Enums.StudentType
    firstName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    contactNo?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: StringFieldUpdateOperationsInput | string
    isWoker?: BoolFieldUpdateOperationsInput | boolean
    shift?: EnumShiftFieldUpdateOperationsInput | $Enums.Shift
    yearLevel?: EnumYearLevelFieldUpdateOperationsInput | $Enums.YearLevel
    isActive?: BoolFieldUpdateOperationsInput | boolean
    password?: StringFieldUpdateOperationsInput | string
    gradeDeclarationFile?: StringFieldUpdateOperationsInput | string
    biFile?: StringFieldUpdateOperationsInput | string
    presentAddress?: StringFieldUpdateOperationsInput | string
    permanentAddress?: NullableStringFieldUpdateOperationsInput | string | null
    academicSemesterId?: StringFieldUpdateOperationsInput | string
    academicFacultyId?: StringFieldUpdateOperationsInput | string
    academicDepartmentId?: StringFieldUpdateOperationsInput | string
    admissionRegistrationId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    studentSemesterRegistrations?: StudentSemesterRegistrationUncheckedUpdateManyWithoutStudentNestedInput
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseUncheckedUpdateManyWithoutStudentNestedInput
    studentEnrolledCourses?: StudentEnrolledCourseUncheckedUpdateManyWithoutStudentNestedInput
    studentEnrolledCourseMarks?: StudentEnrolledCourseMarkUncheckedUpdateManyWithoutStudentNestedInput
    studentAcademicInfos?: StudentAcademicInfoUncheckedUpdateManyWithoutStudentNestedInput
    StudentCarriedCourse?: StudentCarriedCourseUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type AcademicSemesterUpsertWithoutStudentSemesterPaymentsInput = {
    update: XOR<AcademicSemesterUpdateWithoutStudentSemesterPaymentsInput, AcademicSemesterUncheckedUpdateWithoutStudentSemesterPaymentsInput>
    create: XOR<AcademicSemesterCreateWithoutStudentSemesterPaymentsInput, AcademicSemesterUncheckedCreateWithoutStudentSemesterPaymentsInput>
    where?: AcademicSemesterWhereInput
  }

  export type AcademicSemesterUpdateToOneWithWhereWithoutStudentSemesterPaymentsInput = {
    where?: AcademicSemesterWhereInput
    data: XOR<AcademicSemesterUpdateWithoutStudentSemesterPaymentsInput, AcademicSemesterUncheckedUpdateWithoutStudentSemesterPaymentsInput>
  }

  export type AcademicSemesterUpdateWithoutStudentSemesterPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    year?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    startMonth?: StringFieldUpdateOperationsInput | string
    endMonth?: StringFieldUpdateOperationsInput | string
    isCurrent?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    courseDisciplines?: CourseDisciplineUpdateManyWithoutSemesterNestedInput
    semesterRegistrations?: SemesterRegistrationUpdateManyWithoutAcademicSemesterNestedInput
    students?: StudentUpdateManyWithoutAcademicSemesterNestedInput
    studentEnrolledCourses?: StudentEnrolledCourseUpdateManyWithoutAcademicSemesterNestedInput
    studentEnrolledCourseMarks?: StudentEnrolledCourseMarkUpdateManyWithoutAcademicSemesterNestedInput
    StudentCarriedCourse?: StudentCarriedCourseUpdateManyWithoutSemesterNestedInput
  }

  export type AcademicSemesterUncheckedUpdateWithoutStudentSemesterPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    year?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    startMonth?: StringFieldUpdateOperationsInput | string
    endMonth?: StringFieldUpdateOperationsInput | string
    isCurrent?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    courseDisciplines?: CourseDisciplineUncheckedUpdateManyWithoutSemesterNestedInput
    semesterRegistrations?: SemesterRegistrationUncheckedUpdateManyWithoutAcademicSemesterNestedInput
    students?: StudentUncheckedUpdateManyWithoutAcademicSemesterNestedInput
    studentEnrolledCourses?: StudentEnrolledCourseUncheckedUpdateManyWithoutAcademicSemesterNestedInput
    studentEnrolledCourseMarks?: StudentEnrolledCourseMarkUncheckedUpdateManyWithoutAcademicSemesterNestedInput
    StudentCarriedCourse?: StudentCarriedCourseUncheckedUpdateManyWithoutSemesterNestedInput
  }

  export type StudentCreateWithoutStudentAcademicInfosInput = {
    id?: string
    studentId: string
    studentType?: $Enums.StudentType
    firstName: string
    middleName?: string | null
    lastName: string
    profileImage?: string | null
    email?: string | null
    contactNo?: string | null
    gender: string
    isWoker?: boolean
    shift?: $Enums.Shift
    yearLevel?: $Enums.YearLevel
    isActive?: boolean
    password: string
    gradeDeclarationFile: string
    biFile: string
    presentAddress: string
    permanentAddress?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    academicFaculty: AcademicFacultyCreateNestedOneWithoutStudentsInput
    admissionRegistration?: AdmitionExameRegistrationCreateNestedOneWithoutStudentInput
    academicDepartment: AcademicDepartmentCreateNestedOneWithoutStudentsInput
    academicSemester: AcademicSemesterCreateNestedOneWithoutStudentsInput
    studentSemesterRegistrations?: StudentSemesterRegistrationCreateNestedManyWithoutStudentInput
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseCreateNestedManyWithoutStudentInput
    studentEnrolledCourses?: StudentEnrolledCourseCreateNestedManyWithoutStudentInput
    studentEnrolledCourseMarks?: StudentEnrolledCourseMarkCreateNestedManyWithoutStudentInput
    studentSemesterPayments?: StudentSemesterPaymentCreateNestedManyWithoutStudentInput
    StudentCarriedCourse?: StudentCarriedCourseCreateNestedManyWithoutStudentInput
  }

  export type StudentUncheckedCreateWithoutStudentAcademicInfosInput = {
    id?: string
    studentId: string
    studentType?: $Enums.StudentType
    firstName: string
    middleName?: string | null
    lastName: string
    profileImage?: string | null
    email?: string | null
    contactNo?: string | null
    gender: string
    isWoker?: boolean
    shift?: $Enums.Shift
    yearLevel?: $Enums.YearLevel
    isActive?: boolean
    password: string
    gradeDeclarationFile: string
    biFile: string
    presentAddress: string
    permanentAddress?: string | null
    academicSemesterId: string
    academicFacultyId: string
    academicDepartmentId: string
    admissionRegistrationId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    studentSemesterRegistrations?: StudentSemesterRegistrationUncheckedCreateNestedManyWithoutStudentInput
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseUncheckedCreateNestedManyWithoutStudentInput
    studentEnrolledCourses?: StudentEnrolledCourseUncheckedCreateNestedManyWithoutStudentInput
    studentEnrolledCourseMarks?: StudentEnrolledCourseMarkUncheckedCreateNestedManyWithoutStudentInput
    studentSemesterPayments?: StudentSemesterPaymentUncheckedCreateNestedManyWithoutStudentInput
    StudentCarriedCourse?: StudentCarriedCourseUncheckedCreateNestedManyWithoutStudentInput
  }

  export type StudentCreateOrConnectWithoutStudentAcademicInfosInput = {
    where: StudentWhereUniqueInput
    create: XOR<StudentCreateWithoutStudentAcademicInfosInput, StudentUncheckedCreateWithoutStudentAcademicInfosInput>
  }

  export type StudentUpsertWithoutStudentAcademicInfosInput = {
    update: XOR<StudentUpdateWithoutStudentAcademicInfosInput, StudentUncheckedUpdateWithoutStudentAcademicInfosInput>
    create: XOR<StudentCreateWithoutStudentAcademicInfosInput, StudentUncheckedCreateWithoutStudentAcademicInfosInput>
    where?: StudentWhereInput
  }

  export type StudentUpdateToOneWithWhereWithoutStudentAcademicInfosInput = {
    where?: StudentWhereInput
    data: XOR<StudentUpdateWithoutStudentAcademicInfosInput, StudentUncheckedUpdateWithoutStudentAcademicInfosInput>
  }

  export type StudentUpdateWithoutStudentAcademicInfosInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    studentType?: EnumStudentTypeFieldUpdateOperationsInput | $Enums.StudentType
    firstName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    contactNo?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: StringFieldUpdateOperationsInput | string
    isWoker?: BoolFieldUpdateOperationsInput | boolean
    shift?: EnumShiftFieldUpdateOperationsInput | $Enums.Shift
    yearLevel?: EnumYearLevelFieldUpdateOperationsInput | $Enums.YearLevel
    isActive?: BoolFieldUpdateOperationsInput | boolean
    password?: StringFieldUpdateOperationsInput | string
    gradeDeclarationFile?: StringFieldUpdateOperationsInput | string
    biFile?: StringFieldUpdateOperationsInput | string
    presentAddress?: StringFieldUpdateOperationsInput | string
    permanentAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    academicFaculty?: AcademicFacultyUpdateOneRequiredWithoutStudentsNestedInput
    admissionRegistration?: AdmitionExameRegistrationUpdateOneWithoutStudentNestedInput
    academicDepartment?: AcademicDepartmentUpdateOneRequiredWithoutStudentsNestedInput
    academicSemester?: AcademicSemesterUpdateOneRequiredWithoutStudentsNestedInput
    studentSemesterRegistrations?: StudentSemesterRegistrationUpdateManyWithoutStudentNestedInput
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseUpdateManyWithoutStudentNestedInput
    studentEnrolledCourses?: StudentEnrolledCourseUpdateManyWithoutStudentNestedInput
    studentEnrolledCourseMarks?: StudentEnrolledCourseMarkUpdateManyWithoutStudentNestedInput
    studentSemesterPayments?: StudentSemesterPaymentUpdateManyWithoutStudentNestedInput
    StudentCarriedCourse?: StudentCarriedCourseUpdateManyWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateWithoutStudentAcademicInfosInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    studentType?: EnumStudentTypeFieldUpdateOperationsInput | $Enums.StudentType
    firstName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    contactNo?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: StringFieldUpdateOperationsInput | string
    isWoker?: BoolFieldUpdateOperationsInput | boolean
    shift?: EnumShiftFieldUpdateOperationsInput | $Enums.Shift
    yearLevel?: EnumYearLevelFieldUpdateOperationsInput | $Enums.YearLevel
    isActive?: BoolFieldUpdateOperationsInput | boolean
    password?: StringFieldUpdateOperationsInput | string
    gradeDeclarationFile?: StringFieldUpdateOperationsInput | string
    biFile?: StringFieldUpdateOperationsInput | string
    presentAddress?: StringFieldUpdateOperationsInput | string
    permanentAddress?: NullableStringFieldUpdateOperationsInput | string | null
    academicSemesterId?: StringFieldUpdateOperationsInput | string
    academicFacultyId?: StringFieldUpdateOperationsInput | string
    academicDepartmentId?: StringFieldUpdateOperationsInput | string
    admissionRegistrationId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    studentSemesterRegistrations?: StudentSemesterRegistrationUncheckedUpdateManyWithoutStudentNestedInput
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseUncheckedUpdateManyWithoutStudentNestedInput
    studentEnrolledCourses?: StudentEnrolledCourseUncheckedUpdateManyWithoutStudentNestedInput
    studentEnrolledCourseMarks?: StudentEnrolledCourseMarkUncheckedUpdateManyWithoutStudentNestedInput
    studentSemesterPayments?: StudentSemesterPaymentUncheckedUpdateManyWithoutStudentNestedInput
    StudentCarriedCourse?: StudentCarriedCourseUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type StudentSemesterPaymentCreateWithoutPaymentInput = {
    id?: string
    totalPayment: number
    baseAmount: number
    lateFee?: number
    paymentMonth: number
    paymentYear: number
    createdAt?: Date | string
    updatedAt?: Date | string
    student: StudentCreateNestedOneWithoutStudentSemesterPaymentsInput
    academicSemester: AcademicSemesterCreateNestedOneWithoutStudentSemesterPaymentsInput
  }

  export type StudentSemesterPaymentUncheckedCreateWithoutPaymentInput = {
    id?: string
    totalPayment: number
    baseAmount: number
    lateFee?: number
    paymentMonth: number
    paymentYear: number
    createdAt?: Date | string
    updatedAt?: Date | string
    studentId: string
    academicSemesterId: string
  }

  export type StudentSemesterPaymentCreateOrConnectWithoutPaymentInput = {
    where: StudentSemesterPaymentWhereUniqueInput
    create: XOR<StudentSemesterPaymentCreateWithoutPaymentInput, StudentSemesterPaymentUncheckedCreateWithoutPaymentInput>
  }

  export type StudentSemesterPaymentCreateManyPaymentInputEnvelope = {
    data: StudentSemesterPaymentCreateManyPaymentInput | StudentSemesterPaymentCreateManyPaymentInput[]
    skipDuplicates?: boolean
  }

  export type PaymentReferenceCreateWithoutPaymentInput = {
    id?: string
    reference: string
    code: number
    message: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentReferenceUncheckedCreateWithoutPaymentInput = {
    id?: string
    reference: string
    code: number
    message: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentReferenceCreateOrConnectWithoutPaymentInput = {
    where: PaymentReferenceWhereUniqueInput
    create: XOR<PaymentReferenceCreateWithoutPaymentInput, PaymentReferenceUncheckedCreateWithoutPaymentInput>
  }

  export type PaymentReferenceCreateManyPaymentInputEnvelope = {
    data: PaymentReferenceCreateManyPaymentInput | PaymentReferenceCreateManyPaymentInput[]
    skipDuplicates?: boolean
  }

  export type StudentSemesterPaymentUpsertWithWhereUniqueWithoutPaymentInput = {
    where: StudentSemesterPaymentWhereUniqueInput
    update: XOR<StudentSemesterPaymentUpdateWithoutPaymentInput, StudentSemesterPaymentUncheckedUpdateWithoutPaymentInput>
    create: XOR<StudentSemesterPaymentCreateWithoutPaymentInput, StudentSemesterPaymentUncheckedCreateWithoutPaymentInput>
  }

  export type StudentSemesterPaymentUpdateWithWhereUniqueWithoutPaymentInput = {
    where: StudentSemesterPaymentWhereUniqueInput
    data: XOR<StudentSemesterPaymentUpdateWithoutPaymentInput, StudentSemesterPaymentUncheckedUpdateWithoutPaymentInput>
  }

  export type StudentSemesterPaymentUpdateManyWithWhereWithoutPaymentInput = {
    where: StudentSemesterPaymentScalarWhereInput
    data: XOR<StudentSemesterPaymentUpdateManyMutationInput, StudentSemesterPaymentUncheckedUpdateManyWithoutPaymentInput>
  }

  export type PaymentReferenceUpsertWithWhereUniqueWithoutPaymentInput = {
    where: PaymentReferenceWhereUniqueInput
    update: XOR<PaymentReferenceUpdateWithoutPaymentInput, PaymentReferenceUncheckedUpdateWithoutPaymentInput>
    create: XOR<PaymentReferenceCreateWithoutPaymentInput, PaymentReferenceUncheckedCreateWithoutPaymentInput>
  }

  export type PaymentReferenceUpdateWithWhereUniqueWithoutPaymentInput = {
    where: PaymentReferenceWhereUniqueInput
    data: XOR<PaymentReferenceUpdateWithoutPaymentInput, PaymentReferenceUncheckedUpdateWithoutPaymentInput>
  }

  export type PaymentReferenceUpdateManyWithWhereWithoutPaymentInput = {
    where: PaymentReferenceScalarWhereInput
    data: XOR<PaymentReferenceUpdateManyMutationInput, PaymentReferenceUncheckedUpdateManyWithoutPaymentInput>
  }

  export type PaymentReferenceScalarWhereInput = {
    AND?: PaymentReferenceScalarWhereInput | PaymentReferenceScalarWhereInput[]
    OR?: PaymentReferenceScalarWhereInput[]
    NOT?: PaymentReferenceScalarWhereInput | PaymentReferenceScalarWhereInput[]
    id?: StringFilter<"PaymentReference"> | string
    reference?: StringFilter<"PaymentReference"> | string
    code?: IntFilter<"PaymentReference"> | number
    message?: StringFilter<"PaymentReference"> | string
    paymentId?: StringFilter<"PaymentReference"> | string
    createdAt?: DateTimeFilter<"PaymentReference"> | Date | string
    updatedAt?: DateTimeFilter<"PaymentReference"> | Date | string
  }

  export type PaymentCreateWithoutPaymentReferenceInput = {
    id?: string
    paymentRecipt?: string | null
    totalAmount?: number
    approved?: boolean
    paymentType?: $Enums.PAYMENTTYPE
    status?: $Enums.PAYMENTSTATUS
    method?: $Enums.PAYMENTMETHOD
    createdAt?: Date | string
    updatedAt?: Date | string
    StudentSemesterPayment?: StudentSemesterPaymentCreateNestedManyWithoutPaymentInput
  }

  export type PaymentUncheckedCreateWithoutPaymentReferenceInput = {
    id?: string
    paymentRecipt?: string | null
    totalAmount?: number
    approved?: boolean
    paymentType?: $Enums.PAYMENTTYPE
    status?: $Enums.PAYMENTSTATUS
    method?: $Enums.PAYMENTMETHOD
    createdAt?: Date | string
    updatedAt?: Date | string
    StudentSemesterPayment?: StudentSemesterPaymentUncheckedCreateNestedManyWithoutPaymentInput
  }

  export type PaymentCreateOrConnectWithoutPaymentReferenceInput = {
    where: PaymentWhereUniqueInput
    create: XOR<PaymentCreateWithoutPaymentReferenceInput, PaymentUncheckedCreateWithoutPaymentReferenceInput>
  }

  export type PaymentUpsertWithoutPaymentReferenceInput = {
    update: XOR<PaymentUpdateWithoutPaymentReferenceInput, PaymentUncheckedUpdateWithoutPaymentReferenceInput>
    create: XOR<PaymentCreateWithoutPaymentReferenceInput, PaymentUncheckedCreateWithoutPaymentReferenceInput>
    where?: PaymentWhereInput
  }

  export type PaymentUpdateToOneWithWhereWithoutPaymentReferenceInput = {
    where?: PaymentWhereInput
    data: XOR<PaymentUpdateWithoutPaymentReferenceInput, PaymentUncheckedUpdateWithoutPaymentReferenceInput>
  }

  export type PaymentUpdateWithoutPaymentReferenceInput = {
    id?: StringFieldUpdateOperationsInput | string
    paymentRecipt?: NullableStringFieldUpdateOperationsInput | string | null
    totalAmount?: IntFieldUpdateOperationsInput | number
    approved?: BoolFieldUpdateOperationsInput | boolean
    paymentType?: EnumPAYMENTTYPEFieldUpdateOperationsInput | $Enums.PAYMENTTYPE
    status?: EnumPAYMENTSTATUSFieldUpdateOperationsInput | $Enums.PAYMENTSTATUS
    method?: EnumPAYMENTMETHODFieldUpdateOperationsInput | $Enums.PAYMENTMETHOD
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    StudentSemesterPayment?: StudentSemesterPaymentUpdateManyWithoutPaymentNestedInput
  }

  export type PaymentUncheckedUpdateWithoutPaymentReferenceInput = {
    id?: StringFieldUpdateOperationsInput | string
    paymentRecipt?: NullableStringFieldUpdateOperationsInput | string | null
    totalAmount?: IntFieldUpdateOperationsInput | number
    approved?: BoolFieldUpdateOperationsInput | boolean
    paymentType?: EnumPAYMENTTYPEFieldUpdateOperationsInput | $Enums.PAYMENTTYPE
    status?: EnumPAYMENTSTATUSFieldUpdateOperationsInput | $Enums.PAYMENTSTATUS
    method?: EnumPAYMENTMETHODFieldUpdateOperationsInput | $Enums.PAYMENTMETHOD
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    StudentSemesterPayment?: StudentSemesterPaymentUncheckedUpdateManyWithoutPaymentNestedInput
  }

  export type AcademicDepartmentUpdateWithoutStaffMembersInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    academicFaculty?: AcademicFacultyUpdateOneRequiredWithoutAcademicDepartmentsNestedInput
    faculties?: FacultyUpdateManyWithoutAcademicDepartmentNestedInput
    courses?: CourseUpdateManyWithoutAcademicDepartmentNestedInput
    students?: StudentUpdateManyWithoutAcademicDepartmentNestedInput
    departmentHead?: UsersUpdateOneWithoutAcademicDepartmentNestedInput
    offeredCourses?: OfferedCourseUpdateManyWithoutAcademicDepartmentNestedInput
  }

  export type AcademicDepartmentUncheckedUpdateWithoutStaffMembersInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    academicFacultyId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    departmentHeadId?: NullableStringFieldUpdateOperationsInput | string | null
    faculties?: FacultyUncheckedUpdateManyWithoutAcademicDepartmentNestedInput
    courses?: CourseUncheckedUpdateManyWithoutAcademicDepartmentNestedInput
    students?: StudentUncheckedUpdateManyWithoutAcademicDepartmentNestedInput
    offeredCourses?: OfferedCourseUncheckedUpdateManyWithoutAcademicDepartmentNestedInput
  }

  export type AcademicDepartmentUncheckedUpdateManyWithoutStaffMembersInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    academicFacultyId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    departmentHeadId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CourseDisciplineCreateManySemesterInput = {
    id?: string
    courseId: string
    disciplineId: string
    credits: number
  }

  export type SemesterRegistrationCreateManyAcademicSemesterInput = {
    id?: string
    startDate: Date | string
    endDate: Date | string
    status?: $Enums.SemesterRegistrationStatus | null
    createdAt?: Date | string
    updateAt?: Date | string
  }

  export type StudentCreateManyAcademicSemesterInput = {
    id?: string
    studentId: string
    studentType?: $Enums.StudentType
    firstName: string
    middleName?: string | null
    lastName: string
    profileImage?: string | null
    email?: string | null
    contactNo?: string | null
    gender: string
    isWoker?: boolean
    shift?: $Enums.Shift
    yearLevel?: $Enums.YearLevel
    isActive?: boolean
    password: string
    gradeDeclarationFile: string
    biFile: string
    presentAddress: string
    permanentAddress?: string | null
    academicFacultyId: string
    academicDepartmentId: string
    admissionRegistrationId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StudentEnrolledCourseCreateManyAcademicSemesterInput = {
    id?: string
    grade?: string | null
    point?: number | null
    totalMarks?: number | null
    status?: $Enums.StudentEnrolledCourseStatus | null
    createdAt?: Date | string
    updatedAt?: Date | string
    studentId: string
    courseId: string
  }

  export type StudentEnrolledCourseMarkCreateManyAcademicSemesterInput = {
    id?: string
    examType?: $Enums.ExamType | null
    createdAt?: Date | string
    updatedAt?: Date | string
    studentId: string
    studentEnrolledCourseId: string
    continuousAssessments: JsonNullValueInput | InputJsonValue
    frequencyExam?: number | null
    finalExam?: number | null
    resourceExam?: number | null
    specialExam?: number | null
    recoveryExam?: number | null
    totalMarks?: number
    grade?: number
  }

  export type StudentSemesterPaymentCreateManyAcademicSemesterInput = {
    id?: string
    paymentId: string
    totalPayment: number
    baseAmount: number
    lateFee?: number
    paymentMonth: number
    paymentYear: number
    createdAt?: Date | string
    updatedAt?: Date | string
    studentId: string
  }

  export type StudentCarriedCourseCreateManySemesterInput = {
    id?: string
    studentId: string
    disciplineId: string
    shift: $Enums.Shift
    price: number
    status?: $Enums.CarriedCourseStatus
    createdAt?: Date | string
  }

  export type CourseDisciplineUpdateWithoutSemesterInput = {
    id?: StringFieldUpdateOperationsInput | string
    credits?: IntFieldUpdateOperationsInput | number
    course?: CourseUpdateOneRequiredWithoutCourseDisciplinesNestedInput
    discipline?: DisciplineUpdateOneRequiredWithoutCourseDisciplinesNestedInput
  }

  export type CourseDisciplineUncheckedUpdateWithoutSemesterInput = {
    id?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    disciplineId?: StringFieldUpdateOperationsInput | string
    credits?: IntFieldUpdateOperationsInput | number
  }

  export type CourseDisciplineUncheckedUpdateManyWithoutSemesterInput = {
    id?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    disciplineId?: StringFieldUpdateOperationsInput | string
    credits?: IntFieldUpdateOperationsInput | number
  }

  export type SemesterRegistrationUpdateWithoutAcademicSemesterInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: NullableEnumSemesterRegistrationStatusFieldUpdateOperationsInput | $Enums.SemesterRegistrationStatus | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    offeredCourses?: OfferedCourseUpdateManyWithoutSemesterRegistrationNestedInput
    offeredCourseSections?: OfferedCourseSectionUpdateManyWithoutSemesterRegistrationNestedInput
    offeredCourseClassSchedules?: OfferedCourseClassScheduleUpdateManyWithoutSemesterRegistrationNestedInput
    studentSemesterRegistrations?: StudentSemesterRegistrationUpdateManyWithoutSemesterRegistrationNestedInput
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseUpdateManyWithoutSemesterRegistrationNestedInput
  }

  export type SemesterRegistrationUncheckedUpdateWithoutAcademicSemesterInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: NullableEnumSemesterRegistrationStatusFieldUpdateOperationsInput | $Enums.SemesterRegistrationStatus | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    offeredCourses?: OfferedCourseUncheckedUpdateManyWithoutSemesterRegistrationNestedInput
    offeredCourseSections?: OfferedCourseSectionUncheckedUpdateManyWithoutSemesterRegistrationNestedInput
    offeredCourseClassSchedules?: OfferedCourseClassScheduleUncheckedUpdateManyWithoutSemesterRegistrationNestedInput
    studentSemesterRegistrations?: StudentSemesterRegistrationUncheckedUpdateManyWithoutSemesterRegistrationNestedInput
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseUncheckedUpdateManyWithoutSemesterRegistrationNestedInput
  }

  export type SemesterRegistrationUncheckedUpdateManyWithoutAcademicSemesterInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: NullableEnumSemesterRegistrationStatusFieldUpdateOperationsInput | $Enums.SemesterRegistrationStatus | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentUpdateWithoutAcademicSemesterInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    studentType?: EnumStudentTypeFieldUpdateOperationsInput | $Enums.StudentType
    firstName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    contactNo?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: StringFieldUpdateOperationsInput | string
    isWoker?: BoolFieldUpdateOperationsInput | boolean
    shift?: EnumShiftFieldUpdateOperationsInput | $Enums.Shift
    yearLevel?: EnumYearLevelFieldUpdateOperationsInput | $Enums.YearLevel
    isActive?: BoolFieldUpdateOperationsInput | boolean
    password?: StringFieldUpdateOperationsInput | string
    gradeDeclarationFile?: StringFieldUpdateOperationsInput | string
    biFile?: StringFieldUpdateOperationsInput | string
    presentAddress?: StringFieldUpdateOperationsInput | string
    permanentAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    academicFaculty?: AcademicFacultyUpdateOneRequiredWithoutStudentsNestedInput
    admissionRegistration?: AdmitionExameRegistrationUpdateOneWithoutStudentNestedInput
    academicDepartment?: AcademicDepartmentUpdateOneRequiredWithoutStudentsNestedInput
    studentSemesterRegistrations?: StudentSemesterRegistrationUpdateManyWithoutStudentNestedInput
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseUpdateManyWithoutStudentNestedInput
    studentEnrolledCourses?: StudentEnrolledCourseUpdateManyWithoutStudentNestedInput
    studentEnrolledCourseMarks?: StudentEnrolledCourseMarkUpdateManyWithoutStudentNestedInput
    studentSemesterPayments?: StudentSemesterPaymentUpdateManyWithoutStudentNestedInput
    studentAcademicInfos?: StudentAcademicInfoUpdateManyWithoutStudentNestedInput
    StudentCarriedCourse?: StudentCarriedCourseUpdateManyWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateWithoutAcademicSemesterInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    studentType?: EnumStudentTypeFieldUpdateOperationsInput | $Enums.StudentType
    firstName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    contactNo?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: StringFieldUpdateOperationsInput | string
    isWoker?: BoolFieldUpdateOperationsInput | boolean
    shift?: EnumShiftFieldUpdateOperationsInput | $Enums.Shift
    yearLevel?: EnumYearLevelFieldUpdateOperationsInput | $Enums.YearLevel
    isActive?: BoolFieldUpdateOperationsInput | boolean
    password?: StringFieldUpdateOperationsInput | string
    gradeDeclarationFile?: StringFieldUpdateOperationsInput | string
    biFile?: StringFieldUpdateOperationsInput | string
    presentAddress?: StringFieldUpdateOperationsInput | string
    permanentAddress?: NullableStringFieldUpdateOperationsInput | string | null
    academicFacultyId?: StringFieldUpdateOperationsInput | string
    academicDepartmentId?: StringFieldUpdateOperationsInput | string
    admissionRegistrationId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    studentSemesterRegistrations?: StudentSemesterRegistrationUncheckedUpdateManyWithoutStudentNestedInput
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseUncheckedUpdateManyWithoutStudentNestedInput
    studentEnrolledCourses?: StudentEnrolledCourseUncheckedUpdateManyWithoutStudentNestedInput
    studentEnrolledCourseMarks?: StudentEnrolledCourseMarkUncheckedUpdateManyWithoutStudentNestedInput
    studentSemesterPayments?: StudentSemesterPaymentUncheckedUpdateManyWithoutStudentNestedInput
    studentAcademicInfos?: StudentAcademicInfoUncheckedUpdateManyWithoutStudentNestedInput
    StudentCarriedCourse?: StudentCarriedCourseUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateManyWithoutAcademicSemesterInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    studentType?: EnumStudentTypeFieldUpdateOperationsInput | $Enums.StudentType
    firstName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    contactNo?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: StringFieldUpdateOperationsInput | string
    isWoker?: BoolFieldUpdateOperationsInput | boolean
    shift?: EnumShiftFieldUpdateOperationsInput | $Enums.Shift
    yearLevel?: EnumYearLevelFieldUpdateOperationsInput | $Enums.YearLevel
    isActive?: BoolFieldUpdateOperationsInput | boolean
    password?: StringFieldUpdateOperationsInput | string
    gradeDeclarationFile?: StringFieldUpdateOperationsInput | string
    biFile?: StringFieldUpdateOperationsInput | string
    presentAddress?: StringFieldUpdateOperationsInput | string
    permanentAddress?: NullableStringFieldUpdateOperationsInput | string | null
    academicFacultyId?: StringFieldUpdateOperationsInput | string
    academicDepartmentId?: StringFieldUpdateOperationsInput | string
    admissionRegistrationId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentEnrolledCourseUpdateWithoutAcademicSemesterInput = {
    id?: StringFieldUpdateOperationsInput | string
    grade?: NullableStringFieldUpdateOperationsInput | string | null
    point?: NullableFloatFieldUpdateOperationsInput | number | null
    totalMarks?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableEnumStudentEnrolledCourseStatusFieldUpdateOperationsInput | $Enums.StudentEnrolledCourseStatus | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUpdateOneRequiredWithoutStudentEnrolledCoursesNestedInput
    course?: CourseUpdateOneRequiredWithoutStudentCoursesNestedInput
    studentEnrolledCourseMarks?: StudentEnrolledCourseMarkUpdateManyWithoutStudentEnrolledCourseNestedInput
  }

  export type StudentEnrolledCourseUncheckedUpdateWithoutAcademicSemesterInput = {
    id?: StringFieldUpdateOperationsInput | string
    grade?: NullableStringFieldUpdateOperationsInput | string | null
    point?: NullableFloatFieldUpdateOperationsInput | number | null
    totalMarks?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableEnumStudentEnrolledCourseStatusFieldUpdateOperationsInput | $Enums.StudentEnrolledCourseStatus | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    studentId?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    studentEnrolledCourseMarks?: StudentEnrolledCourseMarkUncheckedUpdateManyWithoutStudentEnrolledCourseNestedInput
  }

  export type StudentEnrolledCourseUncheckedUpdateManyWithoutAcademicSemesterInput = {
    id?: StringFieldUpdateOperationsInput | string
    grade?: NullableStringFieldUpdateOperationsInput | string | null
    point?: NullableFloatFieldUpdateOperationsInput | number | null
    totalMarks?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableEnumStudentEnrolledCourseStatusFieldUpdateOperationsInput | $Enums.StudentEnrolledCourseStatus | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    studentId?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
  }

  export type StudentEnrolledCourseMarkUpdateWithoutAcademicSemesterInput = {
    id?: StringFieldUpdateOperationsInput | string
    examType?: NullableEnumExamTypeFieldUpdateOperationsInput | $Enums.ExamType | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    continuousAssessments?: JsonNullValueInput | InputJsonValue
    frequencyExam?: NullableFloatFieldUpdateOperationsInput | number | null
    finalExam?: NullableFloatFieldUpdateOperationsInput | number | null
    resourceExam?: NullableFloatFieldUpdateOperationsInput | number | null
    specialExam?: NullableFloatFieldUpdateOperationsInput | number | null
    recoveryExam?: NullableFloatFieldUpdateOperationsInput | number | null
    totalMarks?: FloatFieldUpdateOperationsInput | number
    grade?: FloatFieldUpdateOperationsInput | number
    student?: StudentUpdateOneRequiredWithoutStudentEnrolledCourseMarksNestedInput
    studentEnrolledCourse?: StudentEnrolledCourseUpdateOneRequiredWithoutStudentEnrolledCourseMarksNestedInput
  }

  export type StudentEnrolledCourseMarkUncheckedUpdateWithoutAcademicSemesterInput = {
    id?: StringFieldUpdateOperationsInput | string
    examType?: NullableEnumExamTypeFieldUpdateOperationsInput | $Enums.ExamType | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    studentId?: StringFieldUpdateOperationsInput | string
    studentEnrolledCourseId?: StringFieldUpdateOperationsInput | string
    continuousAssessments?: JsonNullValueInput | InputJsonValue
    frequencyExam?: NullableFloatFieldUpdateOperationsInput | number | null
    finalExam?: NullableFloatFieldUpdateOperationsInput | number | null
    resourceExam?: NullableFloatFieldUpdateOperationsInput | number | null
    specialExam?: NullableFloatFieldUpdateOperationsInput | number | null
    recoveryExam?: NullableFloatFieldUpdateOperationsInput | number | null
    totalMarks?: FloatFieldUpdateOperationsInput | number
    grade?: FloatFieldUpdateOperationsInput | number
  }

  export type StudentEnrolledCourseMarkUncheckedUpdateManyWithoutAcademicSemesterInput = {
    id?: StringFieldUpdateOperationsInput | string
    examType?: NullableEnumExamTypeFieldUpdateOperationsInput | $Enums.ExamType | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    studentId?: StringFieldUpdateOperationsInput | string
    studentEnrolledCourseId?: StringFieldUpdateOperationsInput | string
    continuousAssessments?: JsonNullValueInput | InputJsonValue
    frequencyExam?: NullableFloatFieldUpdateOperationsInput | number | null
    finalExam?: NullableFloatFieldUpdateOperationsInput | number | null
    resourceExam?: NullableFloatFieldUpdateOperationsInput | number | null
    specialExam?: NullableFloatFieldUpdateOperationsInput | number | null
    recoveryExam?: NullableFloatFieldUpdateOperationsInput | number | null
    totalMarks?: FloatFieldUpdateOperationsInput | number
    grade?: FloatFieldUpdateOperationsInput | number
  }

  export type StudentSemesterPaymentUpdateWithoutAcademicSemesterInput = {
    id?: StringFieldUpdateOperationsInput | string
    totalPayment?: IntFieldUpdateOperationsInput | number
    baseAmount?: IntFieldUpdateOperationsInput | number
    lateFee?: IntFieldUpdateOperationsInput | number
    paymentMonth?: IntFieldUpdateOperationsInput | number
    paymentYear?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payment?: PaymentUpdateOneRequiredWithoutStudentSemesterPaymentNestedInput
    student?: StudentUpdateOneRequiredWithoutStudentSemesterPaymentsNestedInput
  }

  export type StudentSemesterPaymentUncheckedUpdateWithoutAcademicSemesterInput = {
    id?: StringFieldUpdateOperationsInput | string
    paymentId?: StringFieldUpdateOperationsInput | string
    totalPayment?: IntFieldUpdateOperationsInput | number
    baseAmount?: IntFieldUpdateOperationsInput | number
    lateFee?: IntFieldUpdateOperationsInput | number
    paymentMonth?: IntFieldUpdateOperationsInput | number
    paymentYear?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    studentId?: StringFieldUpdateOperationsInput | string
  }

  export type StudentSemesterPaymentUncheckedUpdateManyWithoutAcademicSemesterInput = {
    id?: StringFieldUpdateOperationsInput | string
    paymentId?: StringFieldUpdateOperationsInput | string
    totalPayment?: IntFieldUpdateOperationsInput | number
    baseAmount?: IntFieldUpdateOperationsInput | number
    lateFee?: IntFieldUpdateOperationsInput | number
    paymentMonth?: IntFieldUpdateOperationsInput | number
    paymentYear?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    studentId?: StringFieldUpdateOperationsInput | string
  }

  export type StudentCarriedCourseUpdateWithoutSemesterInput = {
    id?: StringFieldUpdateOperationsInput | string
    shift?: EnumShiftFieldUpdateOperationsInput | $Enums.Shift
    price?: IntFieldUpdateOperationsInput | number
    status?: EnumCarriedCourseStatusFieldUpdateOperationsInput | $Enums.CarriedCourseStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUpdateOneRequiredWithoutStudentCarriedCourseNestedInput
    discipline?: DisciplineUpdateOneRequiredWithoutStudentCarriedCourseNestedInput
  }

  export type StudentCarriedCourseUncheckedUpdateWithoutSemesterInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    disciplineId?: StringFieldUpdateOperationsInput | string
    shift?: EnumShiftFieldUpdateOperationsInput | $Enums.Shift
    price?: IntFieldUpdateOperationsInput | number
    status?: EnumCarriedCourseStatusFieldUpdateOperationsInput | $Enums.CarriedCourseStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentCarriedCourseUncheckedUpdateManyWithoutSemesterInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    disciplineId?: StringFieldUpdateOperationsInput | string
    shift?: EnumShiftFieldUpdateOperationsInput | $Enums.Shift
    price?: IntFieldUpdateOperationsInput | number
    status?: EnumCarriedCourseStatusFieldUpdateOperationsInput | $Enums.CarriedCourseStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AcademicDepartmentCreateManyAcademicFacultyInput = {
    id?: string
    title: string
    createdAt?: Date | string
    updatedAt?: Date | string
    departmentHeadId?: string | null
  }

  export type FacultyCreateManyAcademicFacultyInput = {
    id?: string
    facultyId: string
    firstName: string
    middleName?: string | null
    lastName: string
    profileImage?: string | null
    email?: string | null
    contactNo?: string | null
    shift?: $Enums.Shift
    gender: string
    designation: string
    password: string
    academicDepartmentId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StudentCreateManyAcademicFacultyInput = {
    id?: string
    studentId: string
    studentType?: $Enums.StudentType
    firstName: string
    middleName?: string | null
    lastName: string
    profileImage?: string | null
    email?: string | null
    contactNo?: string | null
    gender: string
    isWoker?: boolean
    shift?: $Enums.Shift
    yearLevel?: $Enums.YearLevel
    isActive?: boolean
    password: string
    gradeDeclarationFile: string
    biFile: string
    presentAddress: string
    permanentAddress?: string | null
    academicSemesterId: string
    academicDepartmentId: string
    admissionRegistrationId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AdmitionExameRegistrationCreateManyAcademicFalcultyInput = {
    id?: string
    applicantName: string
    paymentRecipt: string
    status?: $Enums.Status
    document: string
    paymentAmoute?: number | null
    aprovePayment?: boolean | null
    exameResults?: number | null
    passed?: boolean | null
    faseId: string
    exameDate: Date | string
    rejectionReason?: string | null
    phoneNumber: string
    email: string
    createdAt?: Date | string
    updateAt?: Date | string
  }

  export type AdmitionExamePriceCreateManyAcademicFacultyInput = {
    id?: string
    price: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AdmitionExamePeriodCreateManyAcademicFacultyInput = {
    id?: string
    startDate: Date | string
    endDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AcademicDepartmentUpdateWithoutAcademicFacultyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    faculties?: FacultyUpdateManyWithoutAcademicDepartmentNestedInput
    courses?: CourseUpdateManyWithoutAcademicDepartmentNestedInput
    students?: StudentUpdateManyWithoutAcademicDepartmentNestedInput
    departmentHead?: UsersUpdateOneWithoutAcademicDepartmentNestedInput
    staffMembers?: UsersUpdateManyWithoutStaffDepartmentsNestedInput
    offeredCourses?: OfferedCourseUpdateManyWithoutAcademicDepartmentNestedInput
  }

  export type AcademicDepartmentUncheckedUpdateWithoutAcademicFacultyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    departmentHeadId?: NullableStringFieldUpdateOperationsInput | string | null
    faculties?: FacultyUncheckedUpdateManyWithoutAcademicDepartmentNestedInput
    courses?: CourseUncheckedUpdateManyWithoutAcademicDepartmentNestedInput
    students?: StudentUncheckedUpdateManyWithoutAcademicDepartmentNestedInput
    staffMembers?: UsersUncheckedUpdateManyWithoutStaffDepartmentsNestedInput
    offeredCourses?: OfferedCourseUncheckedUpdateManyWithoutAcademicDepartmentNestedInput
  }

  export type AcademicDepartmentUncheckedUpdateManyWithoutAcademicFacultyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    departmentHeadId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type FacultyUpdateWithoutAcademicFacultyInput = {
    id?: StringFieldUpdateOperationsInput | string
    facultyId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    contactNo?: NullableStringFieldUpdateOperationsInput | string | null
    shift?: EnumShiftFieldUpdateOperationsInput | $Enums.Shift
    gender?: StringFieldUpdateOperationsInput | string
    designation?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    courses?: CourseFacultyUpdateManyWithoutFacultyNestedInput
    academicDepartment?: AcademicDepartmentUpdateOneRequiredWithoutFacultiesNestedInput
    offeredCourseClassSchedules?: OfferedCourseClassScheduleUpdateManyWithoutFacultyNestedInput
  }

  export type FacultyUncheckedUpdateWithoutAcademicFacultyInput = {
    id?: StringFieldUpdateOperationsInput | string
    facultyId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    contactNo?: NullableStringFieldUpdateOperationsInput | string | null
    shift?: EnumShiftFieldUpdateOperationsInput | $Enums.Shift
    gender?: StringFieldUpdateOperationsInput | string
    designation?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    academicDepartmentId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    courses?: CourseFacultyUncheckedUpdateManyWithoutFacultyNestedInput
    offeredCourseClassSchedules?: OfferedCourseClassScheduleUncheckedUpdateManyWithoutFacultyNestedInput
  }

  export type FacultyUncheckedUpdateManyWithoutAcademicFacultyInput = {
    id?: StringFieldUpdateOperationsInput | string
    facultyId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    contactNo?: NullableStringFieldUpdateOperationsInput | string | null
    shift?: EnumShiftFieldUpdateOperationsInput | $Enums.Shift
    gender?: StringFieldUpdateOperationsInput | string
    designation?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    academicDepartmentId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentUpdateWithoutAcademicFacultyInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    studentType?: EnumStudentTypeFieldUpdateOperationsInput | $Enums.StudentType
    firstName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    contactNo?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: StringFieldUpdateOperationsInput | string
    isWoker?: BoolFieldUpdateOperationsInput | boolean
    shift?: EnumShiftFieldUpdateOperationsInput | $Enums.Shift
    yearLevel?: EnumYearLevelFieldUpdateOperationsInput | $Enums.YearLevel
    isActive?: BoolFieldUpdateOperationsInput | boolean
    password?: StringFieldUpdateOperationsInput | string
    gradeDeclarationFile?: StringFieldUpdateOperationsInput | string
    biFile?: StringFieldUpdateOperationsInput | string
    presentAddress?: StringFieldUpdateOperationsInput | string
    permanentAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    admissionRegistration?: AdmitionExameRegistrationUpdateOneWithoutStudentNestedInput
    academicDepartment?: AcademicDepartmentUpdateOneRequiredWithoutStudentsNestedInput
    academicSemester?: AcademicSemesterUpdateOneRequiredWithoutStudentsNestedInput
    studentSemesterRegistrations?: StudentSemesterRegistrationUpdateManyWithoutStudentNestedInput
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseUpdateManyWithoutStudentNestedInput
    studentEnrolledCourses?: StudentEnrolledCourseUpdateManyWithoutStudentNestedInput
    studentEnrolledCourseMarks?: StudentEnrolledCourseMarkUpdateManyWithoutStudentNestedInput
    studentSemesterPayments?: StudentSemesterPaymentUpdateManyWithoutStudentNestedInput
    studentAcademicInfos?: StudentAcademicInfoUpdateManyWithoutStudentNestedInput
    StudentCarriedCourse?: StudentCarriedCourseUpdateManyWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateWithoutAcademicFacultyInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    studentType?: EnumStudentTypeFieldUpdateOperationsInput | $Enums.StudentType
    firstName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    contactNo?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: StringFieldUpdateOperationsInput | string
    isWoker?: BoolFieldUpdateOperationsInput | boolean
    shift?: EnumShiftFieldUpdateOperationsInput | $Enums.Shift
    yearLevel?: EnumYearLevelFieldUpdateOperationsInput | $Enums.YearLevel
    isActive?: BoolFieldUpdateOperationsInput | boolean
    password?: StringFieldUpdateOperationsInput | string
    gradeDeclarationFile?: StringFieldUpdateOperationsInput | string
    biFile?: StringFieldUpdateOperationsInput | string
    presentAddress?: StringFieldUpdateOperationsInput | string
    permanentAddress?: NullableStringFieldUpdateOperationsInput | string | null
    academicSemesterId?: StringFieldUpdateOperationsInput | string
    academicDepartmentId?: StringFieldUpdateOperationsInput | string
    admissionRegistrationId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    studentSemesterRegistrations?: StudentSemesterRegistrationUncheckedUpdateManyWithoutStudentNestedInput
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseUncheckedUpdateManyWithoutStudentNestedInput
    studentEnrolledCourses?: StudentEnrolledCourseUncheckedUpdateManyWithoutStudentNestedInput
    studentEnrolledCourseMarks?: StudentEnrolledCourseMarkUncheckedUpdateManyWithoutStudentNestedInput
    studentSemesterPayments?: StudentSemesterPaymentUncheckedUpdateManyWithoutStudentNestedInput
    studentAcademicInfos?: StudentAcademicInfoUncheckedUpdateManyWithoutStudentNestedInput
    StudentCarriedCourse?: StudentCarriedCourseUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateManyWithoutAcademicFacultyInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    studentType?: EnumStudentTypeFieldUpdateOperationsInput | $Enums.StudentType
    firstName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    contactNo?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: StringFieldUpdateOperationsInput | string
    isWoker?: BoolFieldUpdateOperationsInput | boolean
    shift?: EnumShiftFieldUpdateOperationsInput | $Enums.Shift
    yearLevel?: EnumYearLevelFieldUpdateOperationsInput | $Enums.YearLevel
    isActive?: BoolFieldUpdateOperationsInput | boolean
    password?: StringFieldUpdateOperationsInput | string
    gradeDeclarationFile?: StringFieldUpdateOperationsInput | string
    biFile?: StringFieldUpdateOperationsInput | string
    presentAddress?: StringFieldUpdateOperationsInput | string
    permanentAddress?: NullableStringFieldUpdateOperationsInput | string | null
    academicSemesterId?: StringFieldUpdateOperationsInput | string
    academicDepartmentId?: StringFieldUpdateOperationsInput | string
    admissionRegistrationId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdmitionExameRegistrationUpdateWithoutAcademicFalcultyInput = {
    id?: StringFieldUpdateOperationsInput | string
    applicantName?: StringFieldUpdateOperationsInput | string
    paymentRecipt?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    document?: StringFieldUpdateOperationsInput | string
    paymentAmoute?: NullableIntFieldUpdateOperationsInput | number | null
    aprovePayment?: NullableBoolFieldUpdateOperationsInput | boolean | null
    exameResults?: NullableIntFieldUpdateOperationsInput | number | null
    passed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    exameDate?: DateTimeFieldUpdateOperationsInput | Date | string
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fase?: ExameFaseUpdateOneRequiredWithoutRegistrationsNestedInput
    Student?: StudentUpdateOneWithoutAdmissionRegistrationNestedInput
  }

  export type AdmitionExameRegistrationUncheckedUpdateWithoutAcademicFalcultyInput = {
    id?: StringFieldUpdateOperationsInput | string
    applicantName?: StringFieldUpdateOperationsInput | string
    paymentRecipt?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    document?: StringFieldUpdateOperationsInput | string
    paymentAmoute?: NullableIntFieldUpdateOperationsInput | number | null
    aprovePayment?: NullableBoolFieldUpdateOperationsInput | boolean | null
    exameResults?: NullableIntFieldUpdateOperationsInput | number | null
    passed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    faseId?: StringFieldUpdateOperationsInput | string
    exameDate?: DateTimeFieldUpdateOperationsInput | Date | string
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Student?: StudentUncheckedUpdateOneWithoutAdmissionRegistrationNestedInput
  }

  export type AdmitionExameRegistrationUncheckedUpdateManyWithoutAcademicFalcultyInput = {
    id?: StringFieldUpdateOperationsInput | string
    applicantName?: StringFieldUpdateOperationsInput | string
    paymentRecipt?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    document?: StringFieldUpdateOperationsInput | string
    paymentAmoute?: NullableIntFieldUpdateOperationsInput | number | null
    aprovePayment?: NullableBoolFieldUpdateOperationsInput | boolean | null
    exameResults?: NullableIntFieldUpdateOperationsInput | number | null
    passed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    faseId?: StringFieldUpdateOperationsInput | string
    exameDate?: DateTimeFieldUpdateOperationsInput | Date | string
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdmitionExamePriceUpdateWithoutAcademicFacultyInput = {
    id?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdmitionExamePriceUncheckedUpdateWithoutAcademicFacultyInput = {
    id?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdmitionExamePriceUncheckedUpdateManyWithoutAcademicFacultyInput = {
    id?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdmitionExamePeriodUpdateWithoutAcademicFacultyInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdmitionExamePeriodUncheckedUpdateWithoutAcademicFacultyInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdmitionExamePeriodUncheckedUpdateManyWithoutAcademicFacultyInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FacultyCreateManyAcademicDepartmentInput = {
    id?: string
    facultyId: string
    firstName: string
    middleName?: string | null
    lastName: string
    profileImage?: string | null
    email?: string | null
    contactNo?: string | null
    shift?: $Enums.Shift
    gender: string
    designation: string
    password: string
    academicFacultyId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CourseCreateManyAcademicDepartmentInput = {
    id?: string
    title: string
    code: string
    durationInYears: number
    yearLevel?: $Enums.YearLevel
    shift?: $Enums.Shift
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StudentCreateManyAcademicDepartmentInput = {
    id?: string
    studentId: string
    studentType?: $Enums.StudentType
    firstName: string
    middleName?: string | null
    lastName: string
    profileImage?: string | null
    email?: string | null
    contactNo?: string | null
    gender: string
    isWoker?: boolean
    shift?: $Enums.Shift
    yearLevel?: $Enums.YearLevel
    isActive?: boolean
    password: string
    gradeDeclarationFile: string
    biFile: string
    presentAddress: string
    permanentAddress?: string | null
    academicSemesterId: string
    academicFacultyId: string
    admissionRegistrationId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OfferedCourseCreateManyAcademicDepartmentInput = {
    id?: string
    courseId: string
    semesterRegistrationId: string
    suspendGrade?: number
  }

  export type FacultyUpdateWithoutAcademicDepartmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    facultyId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    contactNo?: NullableStringFieldUpdateOperationsInput | string | null
    shift?: EnumShiftFieldUpdateOperationsInput | $Enums.Shift
    gender?: StringFieldUpdateOperationsInput | string
    designation?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    courses?: CourseFacultyUpdateManyWithoutFacultyNestedInput
    academicFaculty?: AcademicFacultyUpdateOneRequiredWithoutFacultiesNestedInput
    offeredCourseClassSchedules?: OfferedCourseClassScheduleUpdateManyWithoutFacultyNestedInput
  }

  export type FacultyUncheckedUpdateWithoutAcademicDepartmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    facultyId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    contactNo?: NullableStringFieldUpdateOperationsInput | string | null
    shift?: EnumShiftFieldUpdateOperationsInput | $Enums.Shift
    gender?: StringFieldUpdateOperationsInput | string
    designation?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    academicFacultyId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    courses?: CourseFacultyUncheckedUpdateManyWithoutFacultyNestedInput
    offeredCourseClassSchedules?: OfferedCourseClassScheduleUncheckedUpdateManyWithoutFacultyNestedInput
  }

  export type FacultyUncheckedUpdateManyWithoutAcademicDepartmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    facultyId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    contactNo?: NullableStringFieldUpdateOperationsInput | string | null
    shift?: EnumShiftFieldUpdateOperationsInput | $Enums.Shift
    gender?: StringFieldUpdateOperationsInput | string
    designation?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    academicFacultyId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CourseUpdateWithoutAcademicDepartmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    durationInYears?: IntFieldUpdateOperationsInput | number
    yearLevel?: EnumYearLevelFieldUpdateOperationsInput | $Enums.YearLevel
    shift?: EnumShiftFieldUpdateOperationsInput | $Enums.Shift
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    courseDisciplines?: CourseDisciplineUpdateManyWithoutCourseNestedInput
    coursePricing?: CoursePricingUpdateOneWithoutCourseNestedInput
    studentCourses?: StudentEnrolledCourseUpdateManyWithoutCourseNestedInput
    preRequisite?: CourseToPreRequisiteUpdateManyWithoutCourseNestedInput
    preRequisiteFor?: CourseToPreRequisiteUpdateManyWithoutPreRequisiteNestedInput
    faculties?: CourseFacultyUpdateManyWithoutCourseNestedInput
    offeredCourses?: OfferedCourseUpdateManyWithoutCourseNestedInput
  }

  export type CourseUncheckedUpdateWithoutAcademicDepartmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    durationInYears?: IntFieldUpdateOperationsInput | number
    yearLevel?: EnumYearLevelFieldUpdateOperationsInput | $Enums.YearLevel
    shift?: EnumShiftFieldUpdateOperationsInput | $Enums.Shift
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    courseDisciplines?: CourseDisciplineUncheckedUpdateManyWithoutCourseNestedInput
    coursePricing?: CoursePricingUncheckedUpdateOneWithoutCourseNestedInput
    studentCourses?: StudentEnrolledCourseUncheckedUpdateManyWithoutCourseNestedInput
    preRequisite?: CourseToPreRequisiteUncheckedUpdateManyWithoutCourseNestedInput
    preRequisiteFor?: CourseToPreRequisiteUncheckedUpdateManyWithoutPreRequisiteNestedInput
    faculties?: CourseFacultyUncheckedUpdateManyWithoutCourseNestedInput
    offeredCourses?: OfferedCourseUncheckedUpdateManyWithoutCourseNestedInput
  }

  export type CourseUncheckedUpdateManyWithoutAcademicDepartmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    durationInYears?: IntFieldUpdateOperationsInput | number
    yearLevel?: EnumYearLevelFieldUpdateOperationsInput | $Enums.YearLevel
    shift?: EnumShiftFieldUpdateOperationsInput | $Enums.Shift
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentUpdateWithoutAcademicDepartmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    studentType?: EnumStudentTypeFieldUpdateOperationsInput | $Enums.StudentType
    firstName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    contactNo?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: StringFieldUpdateOperationsInput | string
    isWoker?: BoolFieldUpdateOperationsInput | boolean
    shift?: EnumShiftFieldUpdateOperationsInput | $Enums.Shift
    yearLevel?: EnumYearLevelFieldUpdateOperationsInput | $Enums.YearLevel
    isActive?: BoolFieldUpdateOperationsInput | boolean
    password?: StringFieldUpdateOperationsInput | string
    gradeDeclarationFile?: StringFieldUpdateOperationsInput | string
    biFile?: StringFieldUpdateOperationsInput | string
    presentAddress?: StringFieldUpdateOperationsInput | string
    permanentAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    academicFaculty?: AcademicFacultyUpdateOneRequiredWithoutStudentsNestedInput
    admissionRegistration?: AdmitionExameRegistrationUpdateOneWithoutStudentNestedInput
    academicSemester?: AcademicSemesterUpdateOneRequiredWithoutStudentsNestedInput
    studentSemesterRegistrations?: StudentSemesterRegistrationUpdateManyWithoutStudentNestedInput
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseUpdateManyWithoutStudentNestedInput
    studentEnrolledCourses?: StudentEnrolledCourseUpdateManyWithoutStudentNestedInput
    studentEnrolledCourseMarks?: StudentEnrolledCourseMarkUpdateManyWithoutStudentNestedInput
    studentSemesterPayments?: StudentSemesterPaymentUpdateManyWithoutStudentNestedInput
    studentAcademicInfos?: StudentAcademicInfoUpdateManyWithoutStudentNestedInput
    StudentCarriedCourse?: StudentCarriedCourseUpdateManyWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateWithoutAcademicDepartmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    studentType?: EnumStudentTypeFieldUpdateOperationsInput | $Enums.StudentType
    firstName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    contactNo?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: StringFieldUpdateOperationsInput | string
    isWoker?: BoolFieldUpdateOperationsInput | boolean
    shift?: EnumShiftFieldUpdateOperationsInput | $Enums.Shift
    yearLevel?: EnumYearLevelFieldUpdateOperationsInput | $Enums.YearLevel
    isActive?: BoolFieldUpdateOperationsInput | boolean
    password?: StringFieldUpdateOperationsInput | string
    gradeDeclarationFile?: StringFieldUpdateOperationsInput | string
    biFile?: StringFieldUpdateOperationsInput | string
    presentAddress?: StringFieldUpdateOperationsInput | string
    permanentAddress?: NullableStringFieldUpdateOperationsInput | string | null
    academicSemesterId?: StringFieldUpdateOperationsInput | string
    academicFacultyId?: StringFieldUpdateOperationsInput | string
    admissionRegistrationId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    studentSemesterRegistrations?: StudentSemesterRegistrationUncheckedUpdateManyWithoutStudentNestedInput
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseUncheckedUpdateManyWithoutStudentNestedInput
    studentEnrolledCourses?: StudentEnrolledCourseUncheckedUpdateManyWithoutStudentNestedInput
    studentEnrolledCourseMarks?: StudentEnrolledCourseMarkUncheckedUpdateManyWithoutStudentNestedInput
    studentSemesterPayments?: StudentSemesterPaymentUncheckedUpdateManyWithoutStudentNestedInput
    studentAcademicInfos?: StudentAcademicInfoUncheckedUpdateManyWithoutStudentNestedInput
    StudentCarriedCourse?: StudentCarriedCourseUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateManyWithoutAcademicDepartmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    studentType?: EnumStudentTypeFieldUpdateOperationsInput | $Enums.StudentType
    firstName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    contactNo?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: StringFieldUpdateOperationsInput | string
    isWoker?: BoolFieldUpdateOperationsInput | boolean
    shift?: EnumShiftFieldUpdateOperationsInput | $Enums.Shift
    yearLevel?: EnumYearLevelFieldUpdateOperationsInput | $Enums.YearLevel
    isActive?: BoolFieldUpdateOperationsInput | boolean
    password?: StringFieldUpdateOperationsInput | string
    gradeDeclarationFile?: StringFieldUpdateOperationsInput | string
    biFile?: StringFieldUpdateOperationsInput | string
    presentAddress?: StringFieldUpdateOperationsInput | string
    permanentAddress?: NullableStringFieldUpdateOperationsInput | string | null
    academicSemesterId?: StringFieldUpdateOperationsInput | string
    academicFacultyId?: StringFieldUpdateOperationsInput | string
    admissionRegistrationId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UsersUpdateWithoutStaffDepartmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    academicDepartment?: AcademicDepartmentUpdateOneWithoutDepartmentHeadNestedInput
  }

  export type UsersUncheckedUpdateWithoutStaffDepartmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    academicDepartment?: AcademicDepartmentUncheckedUpdateOneWithoutDepartmentHeadNestedInput
  }

  export type UsersUncheckedUpdateManyWithoutStaffDepartmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OfferedCourseUpdateWithoutAcademicDepartmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    suspendGrade?: IntFieldUpdateOperationsInput | number
    semesterRegistration?: SemesterRegistrationUpdateOneRequiredWithoutOfferedCoursesNestedInput
    course?: CourseUpdateOneRequiredWithoutOfferedCoursesNestedInput
    offeredCourseSections?: OfferedCourseSectionUpdateManyWithoutOfferedCourseNestedInput
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseUpdateManyWithoutOfferedCourseNestedInput
  }

  export type OfferedCourseUncheckedUpdateWithoutAcademicDepartmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    semesterRegistrationId?: StringFieldUpdateOperationsInput | string
    suspendGrade?: IntFieldUpdateOperationsInput | number
    offeredCourseSections?: OfferedCourseSectionUncheckedUpdateManyWithoutOfferedCourseNestedInput
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseUncheckedUpdateManyWithoutOfferedCourseNestedInput
  }

  export type OfferedCourseUncheckedUpdateManyWithoutAcademicDepartmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    semesterRegistrationId?: StringFieldUpdateOperationsInput | string
    suspendGrade?: IntFieldUpdateOperationsInput | number
  }

  export type StudentSemesterRegistrationCreateManyStudentInput = {
    id?: string
    isConfirmed?: boolean | null
    totalCreditsTaken?: number | null
    paymentRecipt?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    semesterRegistrationId: string
  }

  export type StudentSemesterRegistrationCourseCreateManyStudentInput = {
    semesterRegistrationId: string
    offeredCourseId: string
    offeredCourseSectionId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StudentEnrolledCourseCreateManyStudentInput = {
    id?: string
    grade?: string | null
    point?: number | null
    totalMarks?: number | null
    status?: $Enums.StudentEnrolledCourseStatus | null
    createdAt?: Date | string
    updatedAt?: Date | string
    academicSemesterId: string
    courseId: string
  }

  export type StudentEnrolledCourseMarkCreateManyStudentInput = {
    id?: string
    examType?: $Enums.ExamType | null
    createdAt?: Date | string
    updatedAt?: Date | string
    studentEnrolledCourseId: string
    academicSemesterId: string
    continuousAssessments: JsonNullValueInput | InputJsonValue
    frequencyExam?: number | null
    finalExam?: number | null
    resourceExam?: number | null
    specialExam?: number | null
    recoveryExam?: number | null
    totalMarks?: number
    grade?: number
  }

  export type StudentSemesterPaymentCreateManyStudentInput = {
    id?: string
    paymentId: string
    totalPayment: number
    baseAmount: number
    lateFee?: number
    paymentMonth: number
    paymentYear: number
    createdAt?: Date | string
    updatedAt?: Date | string
    academicSemesterId: string
  }

  export type StudentAcademicInfoCreateManyStudentInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    totalCompletedCredits?: number | null
    cgpa?: number | null
  }

  export type StudentCarriedCourseCreateManyStudentInput = {
    id?: string
    disciplineId: string
    semesterId: string
    shift: $Enums.Shift
    price: number
    status?: $Enums.CarriedCourseStatus
    createdAt?: Date | string
  }

  export type StudentSemesterRegistrationUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    isConfirmed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    totalCreditsTaken?: NullableIntFieldUpdateOperationsInput | number | null
    paymentRecipt?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    semesterRegistration?: SemesterRegistrationUpdateOneRequiredWithoutStudentSemesterRegistrationsNestedInput
  }

  export type StudentSemesterRegistrationUncheckedUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    isConfirmed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    totalCreditsTaken?: NullableIntFieldUpdateOperationsInput | number | null
    paymentRecipt?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    semesterRegistrationId?: StringFieldUpdateOperationsInput | string
  }

  export type StudentSemesterRegistrationUncheckedUpdateManyWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    isConfirmed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    totalCreditsTaken?: NullableIntFieldUpdateOperationsInput | number | null
    paymentRecipt?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    semesterRegistrationId?: StringFieldUpdateOperationsInput | string
  }

  export type StudentSemesterRegistrationCourseUpdateWithoutStudentInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    semesterRegistration?: SemesterRegistrationUpdateOneRequiredWithoutStudentSemesterRegistrationCoursesNestedInput
    offeredCourse?: OfferedCourseUpdateOneRequiredWithoutStudentSemesterRegistrationCoursesNestedInput
    offeredCourseSection?: OfferedCourseSectionUpdateOneRequiredWithoutStudentSemesterRegistrationCoursesNestedInput
  }

  export type StudentSemesterRegistrationCourseUncheckedUpdateWithoutStudentInput = {
    semesterRegistrationId?: StringFieldUpdateOperationsInput | string
    offeredCourseId?: StringFieldUpdateOperationsInput | string
    offeredCourseSectionId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentSemesterRegistrationCourseUncheckedUpdateManyWithoutStudentInput = {
    semesterRegistrationId?: StringFieldUpdateOperationsInput | string
    offeredCourseId?: StringFieldUpdateOperationsInput | string
    offeredCourseSectionId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentEnrolledCourseUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    grade?: NullableStringFieldUpdateOperationsInput | string | null
    point?: NullableFloatFieldUpdateOperationsInput | number | null
    totalMarks?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableEnumStudentEnrolledCourseStatusFieldUpdateOperationsInput | $Enums.StudentEnrolledCourseStatus | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    course?: CourseUpdateOneRequiredWithoutStudentCoursesNestedInput
    studentEnrolledCourseMarks?: StudentEnrolledCourseMarkUpdateManyWithoutStudentEnrolledCourseNestedInput
    academicSemester?: AcademicSemesterUpdateOneRequiredWithoutStudentEnrolledCoursesNestedInput
  }

  export type StudentEnrolledCourseUncheckedUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    grade?: NullableStringFieldUpdateOperationsInput | string | null
    point?: NullableFloatFieldUpdateOperationsInput | number | null
    totalMarks?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableEnumStudentEnrolledCourseStatusFieldUpdateOperationsInput | $Enums.StudentEnrolledCourseStatus | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    academicSemesterId?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    studentEnrolledCourseMarks?: StudentEnrolledCourseMarkUncheckedUpdateManyWithoutStudentEnrolledCourseNestedInput
  }

  export type StudentEnrolledCourseUncheckedUpdateManyWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    grade?: NullableStringFieldUpdateOperationsInput | string | null
    point?: NullableFloatFieldUpdateOperationsInput | number | null
    totalMarks?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableEnumStudentEnrolledCourseStatusFieldUpdateOperationsInput | $Enums.StudentEnrolledCourseStatus | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    academicSemesterId?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
  }

  export type StudentEnrolledCourseMarkUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    examType?: NullableEnumExamTypeFieldUpdateOperationsInput | $Enums.ExamType | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    continuousAssessments?: JsonNullValueInput | InputJsonValue
    frequencyExam?: NullableFloatFieldUpdateOperationsInput | number | null
    finalExam?: NullableFloatFieldUpdateOperationsInput | number | null
    resourceExam?: NullableFloatFieldUpdateOperationsInput | number | null
    specialExam?: NullableFloatFieldUpdateOperationsInput | number | null
    recoveryExam?: NullableFloatFieldUpdateOperationsInput | number | null
    totalMarks?: FloatFieldUpdateOperationsInput | number
    grade?: FloatFieldUpdateOperationsInput | number
    studentEnrolledCourse?: StudentEnrolledCourseUpdateOneRequiredWithoutStudentEnrolledCourseMarksNestedInput
    academicSemester?: AcademicSemesterUpdateOneRequiredWithoutStudentEnrolledCourseMarksNestedInput
  }

  export type StudentEnrolledCourseMarkUncheckedUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    examType?: NullableEnumExamTypeFieldUpdateOperationsInput | $Enums.ExamType | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    studentEnrolledCourseId?: StringFieldUpdateOperationsInput | string
    academicSemesterId?: StringFieldUpdateOperationsInput | string
    continuousAssessments?: JsonNullValueInput | InputJsonValue
    frequencyExam?: NullableFloatFieldUpdateOperationsInput | number | null
    finalExam?: NullableFloatFieldUpdateOperationsInput | number | null
    resourceExam?: NullableFloatFieldUpdateOperationsInput | number | null
    specialExam?: NullableFloatFieldUpdateOperationsInput | number | null
    recoveryExam?: NullableFloatFieldUpdateOperationsInput | number | null
    totalMarks?: FloatFieldUpdateOperationsInput | number
    grade?: FloatFieldUpdateOperationsInput | number
  }

  export type StudentEnrolledCourseMarkUncheckedUpdateManyWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    examType?: NullableEnumExamTypeFieldUpdateOperationsInput | $Enums.ExamType | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    studentEnrolledCourseId?: StringFieldUpdateOperationsInput | string
    academicSemesterId?: StringFieldUpdateOperationsInput | string
    continuousAssessments?: JsonNullValueInput | InputJsonValue
    frequencyExam?: NullableFloatFieldUpdateOperationsInput | number | null
    finalExam?: NullableFloatFieldUpdateOperationsInput | number | null
    resourceExam?: NullableFloatFieldUpdateOperationsInput | number | null
    specialExam?: NullableFloatFieldUpdateOperationsInput | number | null
    recoveryExam?: NullableFloatFieldUpdateOperationsInput | number | null
    totalMarks?: FloatFieldUpdateOperationsInput | number
    grade?: FloatFieldUpdateOperationsInput | number
  }

  export type StudentSemesterPaymentUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    totalPayment?: IntFieldUpdateOperationsInput | number
    baseAmount?: IntFieldUpdateOperationsInput | number
    lateFee?: IntFieldUpdateOperationsInput | number
    paymentMonth?: IntFieldUpdateOperationsInput | number
    paymentYear?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payment?: PaymentUpdateOneRequiredWithoutStudentSemesterPaymentNestedInput
    academicSemester?: AcademicSemesterUpdateOneRequiredWithoutStudentSemesterPaymentsNestedInput
  }

  export type StudentSemesterPaymentUncheckedUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    paymentId?: StringFieldUpdateOperationsInput | string
    totalPayment?: IntFieldUpdateOperationsInput | number
    baseAmount?: IntFieldUpdateOperationsInput | number
    lateFee?: IntFieldUpdateOperationsInput | number
    paymentMonth?: IntFieldUpdateOperationsInput | number
    paymentYear?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    academicSemesterId?: StringFieldUpdateOperationsInput | string
  }

  export type StudentSemesterPaymentUncheckedUpdateManyWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    paymentId?: StringFieldUpdateOperationsInput | string
    totalPayment?: IntFieldUpdateOperationsInput | number
    baseAmount?: IntFieldUpdateOperationsInput | number
    lateFee?: IntFieldUpdateOperationsInput | number
    paymentMonth?: IntFieldUpdateOperationsInput | number
    paymentYear?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    academicSemesterId?: StringFieldUpdateOperationsInput | string
  }

  export type StudentAcademicInfoUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    totalCompletedCredits?: NullableIntFieldUpdateOperationsInput | number | null
    cgpa?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type StudentAcademicInfoUncheckedUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    totalCompletedCredits?: NullableIntFieldUpdateOperationsInput | number | null
    cgpa?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type StudentAcademicInfoUncheckedUpdateManyWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    totalCompletedCredits?: NullableIntFieldUpdateOperationsInput | number | null
    cgpa?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type StudentCarriedCourseUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    shift?: EnumShiftFieldUpdateOperationsInput | $Enums.Shift
    price?: IntFieldUpdateOperationsInput | number
    status?: EnumCarriedCourseStatusFieldUpdateOperationsInput | $Enums.CarriedCourseStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    discipline?: DisciplineUpdateOneRequiredWithoutStudentCarriedCourseNestedInput
    semester?: AcademicSemesterUpdateOneRequiredWithoutStudentCarriedCourseNestedInput
  }

  export type StudentCarriedCourseUncheckedUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    disciplineId?: StringFieldUpdateOperationsInput | string
    semesterId?: StringFieldUpdateOperationsInput | string
    shift?: EnumShiftFieldUpdateOperationsInput | $Enums.Shift
    price?: IntFieldUpdateOperationsInput | number
    status?: EnumCarriedCourseStatusFieldUpdateOperationsInput | $Enums.CarriedCourseStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentCarriedCourseUncheckedUpdateManyWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    disciplineId?: StringFieldUpdateOperationsInput | string
    semesterId?: StringFieldUpdateOperationsInput | string
    shift?: EnumShiftFieldUpdateOperationsInput | $Enums.Shift
    price?: IntFieldUpdateOperationsInput | number
    status?: EnumCarriedCourseStatusFieldUpdateOperationsInput | $Enums.CarriedCourseStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CourseFacultyCreateManyFacultyInput = {
    courseId: string
  }

  export type OfferedCourseClassScheduleCreateManyFacultyInput = {
    id?: string
    startTime: string
    endTime: string
    dayOfWeek?: $Enums.WeekDays
    createdAt?: Date | string
    updatedAt?: Date | string
    offeredCourseSectionId: string
    semesterRegistrationId: string
    roomId: string
  }

  export type CourseFacultyUpdateWithoutFacultyInput = {
    course?: CourseUpdateOneRequiredWithoutFacultiesNestedInput
  }

  export type CourseFacultyUncheckedUpdateWithoutFacultyInput = {
    courseId?: StringFieldUpdateOperationsInput | string
  }

  export type CourseFacultyUncheckedUpdateManyWithoutFacultyInput = {
    courseId?: StringFieldUpdateOperationsInput | string
  }

  export type OfferedCourseClassScheduleUpdateWithoutFacultyInput = {
    id?: StringFieldUpdateOperationsInput | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    dayOfWeek?: EnumWeekDaysFieldUpdateOperationsInput | $Enums.WeekDays
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    offeredCourseSection?: OfferedCourseSectionUpdateOneRequiredWithoutOfferedCourseClassSchedulesNestedInput
    semesterRegistration?: SemesterRegistrationUpdateOneRequiredWithoutOfferedCourseClassSchedulesNestedInput
    room?: RoomUpdateOneRequiredWithoutOfferedCourseClassSchedulesNestedInput
  }

  export type OfferedCourseClassScheduleUncheckedUpdateWithoutFacultyInput = {
    id?: StringFieldUpdateOperationsInput | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    dayOfWeek?: EnumWeekDaysFieldUpdateOperationsInput | $Enums.WeekDays
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    offeredCourseSectionId?: StringFieldUpdateOperationsInput | string
    semesterRegistrationId?: StringFieldUpdateOperationsInput | string
    roomId?: StringFieldUpdateOperationsInput | string
  }

  export type OfferedCourseClassScheduleUncheckedUpdateManyWithoutFacultyInput = {
    id?: StringFieldUpdateOperationsInput | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    dayOfWeek?: EnumWeekDaysFieldUpdateOperationsInput | $Enums.WeekDays
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    offeredCourseSectionId?: StringFieldUpdateOperationsInput | string
    semesterRegistrationId?: StringFieldUpdateOperationsInput | string
    roomId?: StringFieldUpdateOperationsInput | string
  }

  export type RoomCreateManyBuildingInput = {
    id?: string
    roomNumber: string
    floor: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RoomUpdateWithoutBuildingInput = {
    id?: StringFieldUpdateOperationsInput | string
    roomNumber?: StringFieldUpdateOperationsInput | string
    floor?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    offeredCourseClassSchedules?: OfferedCourseClassScheduleUpdateManyWithoutRoomNestedInput
  }

  export type RoomUncheckedUpdateWithoutBuildingInput = {
    id?: StringFieldUpdateOperationsInput | string
    roomNumber?: StringFieldUpdateOperationsInput | string
    floor?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    offeredCourseClassSchedules?: OfferedCourseClassScheduleUncheckedUpdateManyWithoutRoomNestedInput
  }

  export type RoomUncheckedUpdateManyWithoutBuildingInput = {
    id?: StringFieldUpdateOperationsInput | string
    roomNumber?: StringFieldUpdateOperationsInput | string
    floor?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OfferedCourseClassScheduleCreateManyRoomInput = {
    id?: string
    startTime: string
    endTime: string
    dayOfWeek?: $Enums.WeekDays
    createdAt?: Date | string
    updatedAt?: Date | string
    offeredCourseSectionId: string
    semesterRegistrationId: string
    facultyId: string
  }

  export type OfferedCourseClassScheduleUpdateWithoutRoomInput = {
    id?: StringFieldUpdateOperationsInput | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    dayOfWeek?: EnumWeekDaysFieldUpdateOperationsInput | $Enums.WeekDays
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    offeredCourseSection?: OfferedCourseSectionUpdateOneRequiredWithoutOfferedCourseClassSchedulesNestedInput
    semesterRegistration?: SemesterRegistrationUpdateOneRequiredWithoutOfferedCourseClassSchedulesNestedInput
    faculty?: FacultyUpdateOneRequiredWithoutOfferedCourseClassSchedulesNestedInput
  }

  export type OfferedCourseClassScheduleUncheckedUpdateWithoutRoomInput = {
    id?: StringFieldUpdateOperationsInput | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    dayOfWeek?: EnumWeekDaysFieldUpdateOperationsInput | $Enums.WeekDays
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    offeredCourseSectionId?: StringFieldUpdateOperationsInput | string
    semesterRegistrationId?: StringFieldUpdateOperationsInput | string
    facultyId?: StringFieldUpdateOperationsInput | string
  }

  export type OfferedCourseClassScheduleUncheckedUpdateManyWithoutRoomInput = {
    id?: StringFieldUpdateOperationsInput | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    dayOfWeek?: EnumWeekDaysFieldUpdateOperationsInput | $Enums.WeekDays
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    offeredCourseSectionId?: StringFieldUpdateOperationsInput | string
    semesterRegistrationId?: StringFieldUpdateOperationsInput | string
    facultyId?: StringFieldUpdateOperationsInput | string
  }

  export type CourseDisciplineCreateManyCourseInput = {
    id?: string
    disciplineId: string
    semesterId: string
    credits: number
  }

  export type StudentEnrolledCourseCreateManyCourseInput = {
    id?: string
    grade?: string | null
    point?: number | null
    totalMarks?: number | null
    status?: $Enums.StudentEnrolledCourseStatus | null
    createdAt?: Date | string
    updatedAt?: Date | string
    studentId: string
    academicSemesterId: string
  }

  export type CourseToPreRequisiteCreateManyCourseInput = {
    preRequisiteId: string
  }

  export type CourseToPreRequisiteCreateManyPreRequisiteInput = {
    courseId: string
  }

  export type CourseFacultyCreateManyCourseInput = {
    facultyId: string
  }

  export type OfferedCourseCreateManyCourseInput = {
    id?: string
    academicDepartmentId: string
    semesterRegistrationId: string
    suspendGrade?: number
  }

  export type CourseDisciplineUpdateWithoutCourseInput = {
    id?: StringFieldUpdateOperationsInput | string
    credits?: IntFieldUpdateOperationsInput | number
    discipline?: DisciplineUpdateOneRequiredWithoutCourseDisciplinesNestedInput
    semester?: AcademicSemesterUpdateOneRequiredWithoutCourseDisciplinesNestedInput
  }

  export type CourseDisciplineUncheckedUpdateWithoutCourseInput = {
    id?: StringFieldUpdateOperationsInput | string
    disciplineId?: StringFieldUpdateOperationsInput | string
    semesterId?: StringFieldUpdateOperationsInput | string
    credits?: IntFieldUpdateOperationsInput | number
  }

  export type CourseDisciplineUncheckedUpdateManyWithoutCourseInput = {
    id?: StringFieldUpdateOperationsInput | string
    disciplineId?: StringFieldUpdateOperationsInput | string
    semesterId?: StringFieldUpdateOperationsInput | string
    credits?: IntFieldUpdateOperationsInput | number
  }

  export type StudentEnrolledCourseUpdateWithoutCourseInput = {
    id?: StringFieldUpdateOperationsInput | string
    grade?: NullableStringFieldUpdateOperationsInput | string | null
    point?: NullableFloatFieldUpdateOperationsInput | number | null
    totalMarks?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableEnumStudentEnrolledCourseStatusFieldUpdateOperationsInput | $Enums.StudentEnrolledCourseStatus | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUpdateOneRequiredWithoutStudentEnrolledCoursesNestedInput
    studentEnrolledCourseMarks?: StudentEnrolledCourseMarkUpdateManyWithoutStudentEnrolledCourseNestedInput
    academicSemester?: AcademicSemesterUpdateOneRequiredWithoutStudentEnrolledCoursesNestedInput
  }

  export type StudentEnrolledCourseUncheckedUpdateWithoutCourseInput = {
    id?: StringFieldUpdateOperationsInput | string
    grade?: NullableStringFieldUpdateOperationsInput | string | null
    point?: NullableFloatFieldUpdateOperationsInput | number | null
    totalMarks?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableEnumStudentEnrolledCourseStatusFieldUpdateOperationsInput | $Enums.StudentEnrolledCourseStatus | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    studentId?: StringFieldUpdateOperationsInput | string
    academicSemesterId?: StringFieldUpdateOperationsInput | string
    studentEnrolledCourseMarks?: StudentEnrolledCourseMarkUncheckedUpdateManyWithoutStudentEnrolledCourseNestedInput
  }

  export type StudentEnrolledCourseUncheckedUpdateManyWithoutCourseInput = {
    id?: StringFieldUpdateOperationsInput | string
    grade?: NullableStringFieldUpdateOperationsInput | string | null
    point?: NullableFloatFieldUpdateOperationsInput | number | null
    totalMarks?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableEnumStudentEnrolledCourseStatusFieldUpdateOperationsInput | $Enums.StudentEnrolledCourseStatus | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    studentId?: StringFieldUpdateOperationsInput | string
    academicSemesterId?: StringFieldUpdateOperationsInput | string
  }

  export type CourseToPreRequisiteUpdateWithoutCourseInput = {
    preRequisite?: CourseUpdateOneRequiredWithoutPreRequisiteForNestedInput
  }

  export type CourseToPreRequisiteUncheckedUpdateWithoutCourseInput = {
    preRequisiteId?: StringFieldUpdateOperationsInput | string
  }

  export type CourseToPreRequisiteUncheckedUpdateManyWithoutCourseInput = {
    preRequisiteId?: StringFieldUpdateOperationsInput | string
  }

  export type CourseToPreRequisiteUpdateWithoutPreRequisiteInput = {
    course?: CourseUpdateOneRequiredWithoutPreRequisiteNestedInput
  }

  export type CourseToPreRequisiteUncheckedUpdateWithoutPreRequisiteInput = {
    courseId?: StringFieldUpdateOperationsInput | string
  }

  export type CourseToPreRequisiteUncheckedUpdateManyWithoutPreRequisiteInput = {
    courseId?: StringFieldUpdateOperationsInput | string
  }

  export type CourseFacultyUpdateWithoutCourseInput = {
    faculty?: FacultyUpdateOneRequiredWithoutCoursesNestedInput
  }

  export type CourseFacultyUncheckedUpdateWithoutCourseInput = {
    facultyId?: StringFieldUpdateOperationsInput | string
  }

  export type CourseFacultyUncheckedUpdateManyWithoutCourseInput = {
    facultyId?: StringFieldUpdateOperationsInput | string
  }

  export type OfferedCourseUpdateWithoutCourseInput = {
    id?: StringFieldUpdateOperationsInput | string
    suspendGrade?: IntFieldUpdateOperationsInput | number
    academicDepartment?: AcademicDepartmentUpdateOneRequiredWithoutOfferedCoursesNestedInput
    semesterRegistration?: SemesterRegistrationUpdateOneRequiredWithoutOfferedCoursesNestedInput
    offeredCourseSections?: OfferedCourseSectionUpdateManyWithoutOfferedCourseNestedInput
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseUpdateManyWithoutOfferedCourseNestedInput
  }

  export type OfferedCourseUncheckedUpdateWithoutCourseInput = {
    id?: StringFieldUpdateOperationsInput | string
    academicDepartmentId?: StringFieldUpdateOperationsInput | string
    semesterRegistrationId?: StringFieldUpdateOperationsInput | string
    suspendGrade?: IntFieldUpdateOperationsInput | number
    offeredCourseSections?: OfferedCourseSectionUncheckedUpdateManyWithoutOfferedCourseNestedInput
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseUncheckedUpdateManyWithoutOfferedCourseNestedInput
  }

  export type OfferedCourseUncheckedUpdateManyWithoutCourseInput = {
    id?: StringFieldUpdateOperationsInput | string
    academicDepartmentId?: StringFieldUpdateOperationsInput | string
    semesterRegistrationId?: StringFieldUpdateOperationsInput | string
    suspendGrade?: IntFieldUpdateOperationsInput | number
  }

  export type OfferedCourseCreateManySemesterRegistrationInput = {
    id?: string
    academicDepartmentId: string
    courseId: string
    suspendGrade?: number
  }

  export type OfferedCourseSectionCreateManySemesterRegistrationInput = {
    id?: string
    title: string
    maxCapacity?: number
    currentlyEnrolledStudent?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    offeredCourseId: string
  }

  export type OfferedCourseClassScheduleCreateManySemesterRegistrationInput = {
    id?: string
    startTime: string
    endTime: string
    dayOfWeek?: $Enums.WeekDays
    createdAt?: Date | string
    updatedAt?: Date | string
    offeredCourseSectionId: string
    roomId: string
    facultyId: string
  }

  export type StudentSemesterRegistrationCreateManySemesterRegistrationInput = {
    id?: string
    isConfirmed?: boolean | null
    totalCreditsTaken?: number | null
    paymentRecipt?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    studentId: string
  }

  export type StudentSemesterRegistrationCourseCreateManySemesterRegistrationInput = {
    studentId: string
    offeredCourseId: string
    offeredCourseSectionId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OfferedCourseUpdateWithoutSemesterRegistrationInput = {
    id?: StringFieldUpdateOperationsInput | string
    suspendGrade?: IntFieldUpdateOperationsInput | number
    academicDepartment?: AcademicDepartmentUpdateOneRequiredWithoutOfferedCoursesNestedInput
    course?: CourseUpdateOneRequiredWithoutOfferedCoursesNestedInput
    offeredCourseSections?: OfferedCourseSectionUpdateManyWithoutOfferedCourseNestedInput
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseUpdateManyWithoutOfferedCourseNestedInput
  }

  export type OfferedCourseUncheckedUpdateWithoutSemesterRegistrationInput = {
    id?: StringFieldUpdateOperationsInput | string
    academicDepartmentId?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    suspendGrade?: IntFieldUpdateOperationsInput | number
    offeredCourseSections?: OfferedCourseSectionUncheckedUpdateManyWithoutOfferedCourseNestedInput
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseUncheckedUpdateManyWithoutOfferedCourseNestedInput
  }

  export type OfferedCourseUncheckedUpdateManyWithoutSemesterRegistrationInput = {
    id?: StringFieldUpdateOperationsInput | string
    academicDepartmentId?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    suspendGrade?: IntFieldUpdateOperationsInput | number
  }

  export type OfferedCourseSectionUpdateWithoutSemesterRegistrationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    maxCapacity?: IntFieldUpdateOperationsInput | number
    currentlyEnrolledStudent?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    offeredCourse?: OfferedCourseUpdateOneRequiredWithoutOfferedCourseSectionsNestedInput
    offeredCourseClassSchedules?: OfferedCourseClassScheduleUpdateManyWithoutOfferedCourseSectionNestedInput
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseUpdateManyWithoutOfferedCourseSectionNestedInput
  }

  export type OfferedCourseSectionUncheckedUpdateWithoutSemesterRegistrationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    maxCapacity?: IntFieldUpdateOperationsInput | number
    currentlyEnrolledStudent?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    offeredCourseId?: StringFieldUpdateOperationsInput | string
    offeredCourseClassSchedules?: OfferedCourseClassScheduleUncheckedUpdateManyWithoutOfferedCourseSectionNestedInput
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseUncheckedUpdateManyWithoutOfferedCourseSectionNestedInput
  }

  export type OfferedCourseSectionUncheckedUpdateManyWithoutSemesterRegistrationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    maxCapacity?: IntFieldUpdateOperationsInput | number
    currentlyEnrolledStudent?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    offeredCourseId?: StringFieldUpdateOperationsInput | string
  }

  export type OfferedCourseClassScheduleUpdateWithoutSemesterRegistrationInput = {
    id?: StringFieldUpdateOperationsInput | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    dayOfWeek?: EnumWeekDaysFieldUpdateOperationsInput | $Enums.WeekDays
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    offeredCourseSection?: OfferedCourseSectionUpdateOneRequiredWithoutOfferedCourseClassSchedulesNestedInput
    room?: RoomUpdateOneRequiredWithoutOfferedCourseClassSchedulesNestedInput
    faculty?: FacultyUpdateOneRequiredWithoutOfferedCourseClassSchedulesNestedInput
  }

  export type OfferedCourseClassScheduleUncheckedUpdateWithoutSemesterRegistrationInput = {
    id?: StringFieldUpdateOperationsInput | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    dayOfWeek?: EnumWeekDaysFieldUpdateOperationsInput | $Enums.WeekDays
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    offeredCourseSectionId?: StringFieldUpdateOperationsInput | string
    roomId?: StringFieldUpdateOperationsInput | string
    facultyId?: StringFieldUpdateOperationsInput | string
  }

  export type OfferedCourseClassScheduleUncheckedUpdateManyWithoutSemesterRegistrationInput = {
    id?: StringFieldUpdateOperationsInput | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    dayOfWeek?: EnumWeekDaysFieldUpdateOperationsInput | $Enums.WeekDays
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    offeredCourseSectionId?: StringFieldUpdateOperationsInput | string
    roomId?: StringFieldUpdateOperationsInput | string
    facultyId?: StringFieldUpdateOperationsInput | string
  }

  export type StudentSemesterRegistrationUpdateWithoutSemesterRegistrationInput = {
    id?: StringFieldUpdateOperationsInput | string
    isConfirmed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    totalCreditsTaken?: NullableIntFieldUpdateOperationsInput | number | null
    paymentRecipt?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUpdateOneRequiredWithoutStudentSemesterRegistrationsNestedInput
  }

  export type StudentSemesterRegistrationUncheckedUpdateWithoutSemesterRegistrationInput = {
    id?: StringFieldUpdateOperationsInput | string
    isConfirmed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    totalCreditsTaken?: NullableIntFieldUpdateOperationsInput | number | null
    paymentRecipt?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    studentId?: StringFieldUpdateOperationsInput | string
  }

  export type StudentSemesterRegistrationUncheckedUpdateManyWithoutSemesterRegistrationInput = {
    id?: StringFieldUpdateOperationsInput | string
    isConfirmed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    totalCreditsTaken?: NullableIntFieldUpdateOperationsInput | number | null
    paymentRecipt?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    studentId?: StringFieldUpdateOperationsInput | string
  }

  export type StudentSemesterRegistrationCourseUpdateWithoutSemesterRegistrationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUpdateOneRequiredWithoutStudentSemesterRegistrationCoursesNestedInput
    offeredCourse?: OfferedCourseUpdateOneRequiredWithoutStudentSemesterRegistrationCoursesNestedInput
    offeredCourseSection?: OfferedCourseSectionUpdateOneRequiredWithoutStudentSemesterRegistrationCoursesNestedInput
  }

  export type StudentSemesterRegistrationCourseUncheckedUpdateWithoutSemesterRegistrationInput = {
    studentId?: StringFieldUpdateOperationsInput | string
    offeredCourseId?: StringFieldUpdateOperationsInput | string
    offeredCourseSectionId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentSemesterRegistrationCourseUncheckedUpdateManyWithoutSemesterRegistrationInput = {
    studentId?: StringFieldUpdateOperationsInput | string
    offeredCourseId?: StringFieldUpdateOperationsInput | string
    offeredCourseSectionId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdmitionExameRegistrationCreateManyFaseInput = {
    id?: string
    applicantName: string
    paymentRecipt: string
    status?: $Enums.Status
    document: string
    paymentAmoute?: number | null
    aprovePayment?: boolean | null
    exameResults?: number | null
    passed?: boolean | null
    exameDate: Date | string
    rejectionReason?: string | null
    phoneNumber: string
    email: string
    createdAt?: Date | string
    updateAt?: Date | string
    academicFalcultyId: string
  }

  export type AdmitionExameRegistrationUpdateWithoutFaseInput = {
    id?: StringFieldUpdateOperationsInput | string
    applicantName?: StringFieldUpdateOperationsInput | string
    paymentRecipt?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    document?: StringFieldUpdateOperationsInput | string
    paymentAmoute?: NullableIntFieldUpdateOperationsInput | number | null
    aprovePayment?: NullableBoolFieldUpdateOperationsInput | boolean | null
    exameResults?: NullableIntFieldUpdateOperationsInput | number | null
    passed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    exameDate?: DateTimeFieldUpdateOperationsInput | Date | string
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    academicFalculty?: AcademicFacultyUpdateOneRequiredWithoutAdmitionExameNestedInput
    Student?: StudentUpdateOneWithoutAdmissionRegistrationNestedInput
  }

  export type AdmitionExameRegistrationUncheckedUpdateWithoutFaseInput = {
    id?: StringFieldUpdateOperationsInput | string
    applicantName?: StringFieldUpdateOperationsInput | string
    paymentRecipt?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    document?: StringFieldUpdateOperationsInput | string
    paymentAmoute?: NullableIntFieldUpdateOperationsInput | number | null
    aprovePayment?: NullableBoolFieldUpdateOperationsInput | boolean | null
    exameResults?: NullableIntFieldUpdateOperationsInput | number | null
    passed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    exameDate?: DateTimeFieldUpdateOperationsInput | Date | string
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    academicFalcultyId?: StringFieldUpdateOperationsInput | string
    Student?: StudentUncheckedUpdateOneWithoutAdmissionRegistrationNestedInput
  }

  export type AdmitionExameRegistrationUncheckedUpdateManyWithoutFaseInput = {
    id?: StringFieldUpdateOperationsInput | string
    applicantName?: StringFieldUpdateOperationsInput | string
    paymentRecipt?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    document?: StringFieldUpdateOperationsInput | string
    paymentAmoute?: NullableIntFieldUpdateOperationsInput | number | null
    aprovePayment?: NullableBoolFieldUpdateOperationsInput | boolean | null
    exameResults?: NullableIntFieldUpdateOperationsInput | number | null
    passed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    exameDate?: DateTimeFieldUpdateOperationsInput | Date | string
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    academicFalcultyId?: StringFieldUpdateOperationsInput | string
  }

  export type OfferedCourseSectionCreateManyOfferedCourseInput = {
    id?: string
    title: string
    maxCapacity?: number
    currentlyEnrolledStudent?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    semesterRegistrationId: string
  }

  export type StudentSemesterRegistrationCourseCreateManyOfferedCourseInput = {
    semesterRegistrationId: string
    studentId: string
    offeredCourseSectionId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OfferedCourseSectionUpdateWithoutOfferedCourseInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    maxCapacity?: IntFieldUpdateOperationsInput | number
    currentlyEnrolledStudent?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    semesterRegistration?: SemesterRegistrationUpdateOneRequiredWithoutOfferedCourseSectionsNestedInput
    offeredCourseClassSchedules?: OfferedCourseClassScheduleUpdateManyWithoutOfferedCourseSectionNestedInput
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseUpdateManyWithoutOfferedCourseSectionNestedInput
  }

  export type OfferedCourseSectionUncheckedUpdateWithoutOfferedCourseInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    maxCapacity?: IntFieldUpdateOperationsInput | number
    currentlyEnrolledStudent?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    semesterRegistrationId?: StringFieldUpdateOperationsInput | string
    offeredCourseClassSchedules?: OfferedCourseClassScheduleUncheckedUpdateManyWithoutOfferedCourseSectionNestedInput
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseUncheckedUpdateManyWithoutOfferedCourseSectionNestedInput
  }

  export type OfferedCourseSectionUncheckedUpdateManyWithoutOfferedCourseInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    maxCapacity?: IntFieldUpdateOperationsInput | number
    currentlyEnrolledStudent?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    semesterRegistrationId?: StringFieldUpdateOperationsInput | string
  }

  export type StudentSemesterRegistrationCourseUpdateWithoutOfferedCourseInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    semesterRegistration?: SemesterRegistrationUpdateOneRequiredWithoutStudentSemesterRegistrationCoursesNestedInput
    student?: StudentUpdateOneRequiredWithoutStudentSemesterRegistrationCoursesNestedInput
    offeredCourseSection?: OfferedCourseSectionUpdateOneRequiredWithoutStudentSemesterRegistrationCoursesNestedInput
  }

  export type StudentSemesterRegistrationCourseUncheckedUpdateWithoutOfferedCourseInput = {
    semesterRegistrationId?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    offeredCourseSectionId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentSemesterRegistrationCourseUncheckedUpdateManyWithoutOfferedCourseInput = {
    semesterRegistrationId?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    offeredCourseSectionId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OfferedCourseClassScheduleCreateManyOfferedCourseSectionInput = {
    id?: string
    startTime: string
    endTime: string
    dayOfWeek?: $Enums.WeekDays
    createdAt?: Date | string
    updatedAt?: Date | string
    semesterRegistrationId: string
    roomId: string
    facultyId: string
  }

  export type StudentSemesterRegistrationCourseCreateManyOfferedCourseSectionInput = {
    semesterRegistrationId: string
    studentId: string
    offeredCourseId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OfferedCourseClassScheduleUpdateWithoutOfferedCourseSectionInput = {
    id?: StringFieldUpdateOperationsInput | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    dayOfWeek?: EnumWeekDaysFieldUpdateOperationsInput | $Enums.WeekDays
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    semesterRegistration?: SemesterRegistrationUpdateOneRequiredWithoutOfferedCourseClassSchedulesNestedInput
    room?: RoomUpdateOneRequiredWithoutOfferedCourseClassSchedulesNestedInput
    faculty?: FacultyUpdateOneRequiredWithoutOfferedCourseClassSchedulesNestedInput
  }

  export type OfferedCourseClassScheduleUncheckedUpdateWithoutOfferedCourseSectionInput = {
    id?: StringFieldUpdateOperationsInput | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    dayOfWeek?: EnumWeekDaysFieldUpdateOperationsInput | $Enums.WeekDays
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    semesterRegistrationId?: StringFieldUpdateOperationsInput | string
    roomId?: StringFieldUpdateOperationsInput | string
    facultyId?: StringFieldUpdateOperationsInput | string
  }

  export type OfferedCourseClassScheduleUncheckedUpdateManyWithoutOfferedCourseSectionInput = {
    id?: StringFieldUpdateOperationsInput | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    dayOfWeek?: EnumWeekDaysFieldUpdateOperationsInput | $Enums.WeekDays
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    semesterRegistrationId?: StringFieldUpdateOperationsInput | string
    roomId?: StringFieldUpdateOperationsInput | string
    facultyId?: StringFieldUpdateOperationsInput | string
  }

  export type StudentSemesterRegistrationCourseUpdateWithoutOfferedCourseSectionInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    semesterRegistration?: SemesterRegistrationUpdateOneRequiredWithoutStudentSemesterRegistrationCoursesNestedInput
    student?: StudentUpdateOneRequiredWithoutStudentSemesterRegistrationCoursesNestedInput
    offeredCourse?: OfferedCourseUpdateOneRequiredWithoutStudentSemesterRegistrationCoursesNestedInput
  }

  export type StudentSemesterRegistrationCourseUncheckedUpdateWithoutOfferedCourseSectionInput = {
    semesterRegistrationId?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    offeredCourseId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentSemesterRegistrationCourseUncheckedUpdateManyWithoutOfferedCourseSectionInput = {
    semesterRegistrationId?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    offeredCourseId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentEnrolledCourseMarkCreateManyStudentEnrolledCourseInput = {
    id?: string
    examType?: $Enums.ExamType | null
    createdAt?: Date | string
    updatedAt?: Date | string
    studentId: string
    academicSemesterId: string
    continuousAssessments: JsonNullValueInput | InputJsonValue
    frequencyExam?: number | null
    finalExam?: number | null
    resourceExam?: number | null
    specialExam?: number | null
    recoveryExam?: number | null
    totalMarks?: number
    grade?: number
  }

  export type StudentEnrolledCourseMarkUpdateWithoutStudentEnrolledCourseInput = {
    id?: StringFieldUpdateOperationsInput | string
    examType?: NullableEnumExamTypeFieldUpdateOperationsInput | $Enums.ExamType | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    continuousAssessments?: JsonNullValueInput | InputJsonValue
    frequencyExam?: NullableFloatFieldUpdateOperationsInput | number | null
    finalExam?: NullableFloatFieldUpdateOperationsInput | number | null
    resourceExam?: NullableFloatFieldUpdateOperationsInput | number | null
    specialExam?: NullableFloatFieldUpdateOperationsInput | number | null
    recoveryExam?: NullableFloatFieldUpdateOperationsInput | number | null
    totalMarks?: FloatFieldUpdateOperationsInput | number
    grade?: FloatFieldUpdateOperationsInput | number
    student?: StudentUpdateOneRequiredWithoutStudentEnrolledCourseMarksNestedInput
    academicSemester?: AcademicSemesterUpdateOneRequiredWithoutStudentEnrolledCourseMarksNestedInput
  }

  export type StudentEnrolledCourseMarkUncheckedUpdateWithoutStudentEnrolledCourseInput = {
    id?: StringFieldUpdateOperationsInput | string
    examType?: NullableEnumExamTypeFieldUpdateOperationsInput | $Enums.ExamType | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    studentId?: StringFieldUpdateOperationsInput | string
    academicSemesterId?: StringFieldUpdateOperationsInput | string
    continuousAssessments?: JsonNullValueInput | InputJsonValue
    frequencyExam?: NullableFloatFieldUpdateOperationsInput | number | null
    finalExam?: NullableFloatFieldUpdateOperationsInput | number | null
    resourceExam?: NullableFloatFieldUpdateOperationsInput | number | null
    specialExam?: NullableFloatFieldUpdateOperationsInput | number | null
    recoveryExam?: NullableFloatFieldUpdateOperationsInput | number | null
    totalMarks?: FloatFieldUpdateOperationsInput | number
    grade?: FloatFieldUpdateOperationsInput | number
  }

  export type StudentEnrolledCourseMarkUncheckedUpdateManyWithoutStudentEnrolledCourseInput = {
    id?: StringFieldUpdateOperationsInput | string
    examType?: NullableEnumExamTypeFieldUpdateOperationsInput | $Enums.ExamType | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    studentId?: StringFieldUpdateOperationsInput | string
    academicSemesterId?: StringFieldUpdateOperationsInput | string
    continuousAssessments?: JsonNullValueInput | InputJsonValue
    frequencyExam?: NullableFloatFieldUpdateOperationsInput | number | null
    finalExam?: NullableFloatFieldUpdateOperationsInput | number | null
    resourceExam?: NullableFloatFieldUpdateOperationsInput | number | null
    specialExam?: NullableFloatFieldUpdateOperationsInput | number | null
    recoveryExam?: NullableFloatFieldUpdateOperationsInput | number | null
    totalMarks?: FloatFieldUpdateOperationsInput | number
    grade?: FloatFieldUpdateOperationsInput | number
  }

  export type CourseDisciplineCreateManyDisciplineInput = {
    id?: string
    courseId: string
    semesterId: string
    credits: number
  }

  export type StudentCarriedCourseCreateManyDisciplineInput = {
    id?: string
    studentId: string
    semesterId: string
    shift: $Enums.Shift
    price: number
    status?: $Enums.CarriedCourseStatus
    createdAt?: Date | string
  }

  export type CourseDisciplineUpdateWithoutDisciplineInput = {
    id?: StringFieldUpdateOperationsInput | string
    credits?: IntFieldUpdateOperationsInput | number
    course?: CourseUpdateOneRequiredWithoutCourseDisciplinesNestedInput
    semester?: AcademicSemesterUpdateOneRequiredWithoutCourseDisciplinesNestedInput
  }

  export type CourseDisciplineUncheckedUpdateWithoutDisciplineInput = {
    id?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    semesterId?: StringFieldUpdateOperationsInput | string
    credits?: IntFieldUpdateOperationsInput | number
  }

  export type CourseDisciplineUncheckedUpdateManyWithoutDisciplineInput = {
    id?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    semesterId?: StringFieldUpdateOperationsInput | string
    credits?: IntFieldUpdateOperationsInput | number
  }

  export type StudentCarriedCourseUpdateWithoutDisciplineInput = {
    id?: StringFieldUpdateOperationsInput | string
    shift?: EnumShiftFieldUpdateOperationsInput | $Enums.Shift
    price?: IntFieldUpdateOperationsInput | number
    status?: EnumCarriedCourseStatusFieldUpdateOperationsInput | $Enums.CarriedCourseStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUpdateOneRequiredWithoutStudentCarriedCourseNestedInput
    semester?: AcademicSemesterUpdateOneRequiredWithoutStudentCarriedCourseNestedInput
  }

  export type StudentCarriedCourseUncheckedUpdateWithoutDisciplineInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    semesterId?: StringFieldUpdateOperationsInput | string
    shift?: EnumShiftFieldUpdateOperationsInput | $Enums.Shift
    price?: IntFieldUpdateOperationsInput | number
    status?: EnumCarriedCourseStatusFieldUpdateOperationsInput | $Enums.CarriedCourseStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentCarriedCourseUncheckedUpdateManyWithoutDisciplineInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    semesterId?: StringFieldUpdateOperationsInput | string
    shift?: EnumShiftFieldUpdateOperationsInput | $Enums.Shift
    price?: IntFieldUpdateOperationsInput | number
    status?: EnumCarriedCourseStatusFieldUpdateOperationsInput | $Enums.CarriedCourseStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentSemesterPaymentCreateManyPaymentInput = {
    id?: string
    totalPayment: number
    baseAmount: number
    lateFee?: number
    paymentMonth: number
    paymentYear: number
    createdAt?: Date | string
    updatedAt?: Date | string
    studentId: string
    academicSemesterId: string
  }

  export type PaymentReferenceCreateManyPaymentInput = {
    id?: string
    reference: string
    code: number
    message: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StudentSemesterPaymentUpdateWithoutPaymentInput = {
    id?: StringFieldUpdateOperationsInput | string
    totalPayment?: IntFieldUpdateOperationsInput | number
    baseAmount?: IntFieldUpdateOperationsInput | number
    lateFee?: IntFieldUpdateOperationsInput | number
    paymentMonth?: IntFieldUpdateOperationsInput | number
    paymentYear?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUpdateOneRequiredWithoutStudentSemesterPaymentsNestedInput
    academicSemester?: AcademicSemesterUpdateOneRequiredWithoutStudentSemesterPaymentsNestedInput
  }

  export type StudentSemesterPaymentUncheckedUpdateWithoutPaymentInput = {
    id?: StringFieldUpdateOperationsInput | string
    totalPayment?: IntFieldUpdateOperationsInput | number
    baseAmount?: IntFieldUpdateOperationsInput | number
    lateFee?: IntFieldUpdateOperationsInput | number
    paymentMonth?: IntFieldUpdateOperationsInput | number
    paymentYear?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    studentId?: StringFieldUpdateOperationsInput | string
    academicSemesterId?: StringFieldUpdateOperationsInput | string
  }

  export type StudentSemesterPaymentUncheckedUpdateManyWithoutPaymentInput = {
    id?: StringFieldUpdateOperationsInput | string
    totalPayment?: IntFieldUpdateOperationsInput | number
    baseAmount?: IntFieldUpdateOperationsInput | number
    lateFee?: IntFieldUpdateOperationsInput | number
    paymentMonth?: IntFieldUpdateOperationsInput | number
    paymentYear?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    studentId?: StringFieldUpdateOperationsInput | string
    academicSemesterId?: StringFieldUpdateOperationsInput | string
  }

  export type PaymentReferenceUpdateWithoutPaymentInput = {
    id?: StringFieldUpdateOperationsInput | string
    reference?: StringFieldUpdateOperationsInput | string
    code?: IntFieldUpdateOperationsInput | number
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentReferenceUncheckedUpdateWithoutPaymentInput = {
    id?: StringFieldUpdateOperationsInput | string
    reference?: StringFieldUpdateOperationsInput | string
    code?: IntFieldUpdateOperationsInput | number
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentReferenceUncheckedUpdateManyWithoutPaymentInput = {
    id?: StringFieldUpdateOperationsInput | string
    reference?: StringFieldUpdateOperationsInput | string
    code?: IntFieldUpdateOperationsInput | number
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}