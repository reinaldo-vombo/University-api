
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Users
 * 
 */
export type Users = $Result.DefaultSelection<Prisma.$UsersPayload>
/**
 * Model AcademicSemester
 * 
 */
export type AcademicSemester = $Result.DefaultSelection<Prisma.$AcademicSemesterPayload>
/**
 * Model AcademicFaculty
 * 
 */
export type AcademicFaculty = $Result.DefaultSelection<Prisma.$AcademicFacultyPayload>
/**
 * Model AcademicDepartment
 * 
 */
export type AcademicDepartment = $Result.DefaultSelection<Prisma.$AcademicDepartmentPayload>
/**
 * Model Student
 * 
 */
export type Student = $Result.DefaultSelection<Prisma.$StudentPayload>
/**
 * Model Faculty
 * 
 */
export type Faculty = $Result.DefaultSelection<Prisma.$FacultyPayload>
/**
 * Model Building
 * 
 */
export type Building = $Result.DefaultSelection<Prisma.$BuildingPayload>
/**
 * Model Room
 * 
 */
export type Room = $Result.DefaultSelection<Prisma.$RoomPayload>
/**
 * Model Course
 * 
 */
export type Course = $Result.DefaultSelection<Prisma.$CoursePayload>
/**
 * Model CourseToPreRequisite
 * 
 */
export type CourseToPreRequisite = $Result.DefaultSelection<Prisma.$CourseToPreRequisitePayload>
/**
 * Model CourseFaculty
 * 
 */
export type CourseFaculty = $Result.DefaultSelection<Prisma.$CourseFacultyPayload>
/**
 * Model SemesterRegistration
 * 
 */
export type SemesterRegistration = $Result.DefaultSelection<Prisma.$SemesterRegistrationPayload>
/**
 * Model AdmitionExameRegistration
 * 
 */
export type AdmitionExameRegistration = $Result.DefaultSelection<Prisma.$AdmitionExameRegistrationPayload>
/**
 * Model OfferedCourse
 * 
 */
export type OfferedCourse = $Result.DefaultSelection<Prisma.$OfferedCoursePayload>
/**
 * Model OfferedCourseSection
 * 
 */
export type OfferedCourseSection = $Result.DefaultSelection<Prisma.$OfferedCourseSectionPayload>
/**
 * Model OfferedCourseClassSchedule
 * 
 */
export type OfferedCourseClassSchedule = $Result.DefaultSelection<Prisma.$OfferedCourseClassSchedulePayload>
/**
 * Model StudentSemesterRegistration
 * 
 */
export type StudentSemesterRegistration = $Result.DefaultSelection<Prisma.$StudentSemesterRegistrationPayload>
/**
 * Model StudentSemesterRegistrationCourse
 * 
 */
export type StudentSemesterRegistrationCourse = $Result.DefaultSelection<Prisma.$StudentSemesterRegistrationCoursePayload>
/**
 * Model StudentEnrolledCourse
 * 
 */
export type StudentEnrolledCourse = $Result.DefaultSelection<Prisma.$StudentEnrolledCoursePayload>
/**
 * Model StudentEnrolledCourseMark
 * 
 */
export type StudentEnrolledCourseMark = $Result.DefaultSelection<Prisma.$StudentEnrolledCourseMarkPayload>
/**
 * Model StudentSemesterPayment
 * 
 */
export type StudentSemesterPayment = $Result.DefaultSelection<Prisma.$StudentSemesterPaymentPayload>
/**
 * Model StudentAcademicInfo
 * 
 */
export type StudentAcademicInfo = $Result.DefaultSelection<Prisma.$StudentAcademicInfoPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const SemesterRegistrationStatus: {
  UPCOMING: 'UPCOMING',
  ONGOING: 'ONGOING',
  ENDED: 'ENDED'
};

export type SemesterRegistrationStatus = (typeof SemesterRegistrationStatus)[keyof typeof SemesterRegistrationStatus]


export const Shift: {
  MANHA: 'MANHA',
  TARDE: 'TARDE',
  NOITE: 'NOITE'
};

export type Shift = (typeof Shift)[keyof typeof Shift]


export const Status: {
  APROVE: 'APROVE',
  PENDING: 'PENDING',
  DENIDE: 'DENIDE'
};

export type Status = (typeof Status)[keyof typeof Status]


export const WeekDays: {
  SATURDAY: 'SATURDAY',
  SUNDAY: 'SUNDAY',
  MONDAY: 'MONDAY',
  TUESDAY: 'TUESDAY',
  WEDNESDAY: 'WEDNESDAY',
  THURSDAY: 'THURSDAY',
  FRIDAY: 'FRIDAY'
};

export type WeekDays = (typeof WeekDays)[keyof typeof WeekDays]


export const StudentEnrolledCourseStatus: {
  ONGOING: 'ONGOING',
  COMPLETED: 'COMPLETED',
  WITHDRAWN: 'WITHDRAWN'
};

export type StudentEnrolledCourseStatus = (typeof StudentEnrolledCourseStatus)[keyof typeof StudentEnrolledCourseStatus]


export const ExamType: {
  MIDTERM: 'MIDTERM',
  FINAL: 'FINAL'
};

export type ExamType = (typeof ExamType)[keyof typeof ExamType]


export const PaymentStatus: {
  PENDING: 'PENDING',
  NOT_PAID: 'NOT_PAID',
  FULL_PAID: 'FULL_PAID'
};

export type PaymentStatus = (typeof PaymentStatus)[keyof typeof PaymentStatus]


export const UserRole: {
  super_admin: 'super_admin',
  admin: 'admin',
  student: 'student',
  faculty: 'faculty',
  accountant: 'accountant',
  department_head: 'department_head',
  staff: 'staff'
};

export type UserRole = (typeof UserRole)[keyof typeof UserRole]


export const PAYMENTTYPE: {
  RECIPT: 'RECIPT',
  EXPRESS: 'EXPRESS'
};

export type PAYMENTTYPE = (typeof PAYMENTTYPE)[keyof typeof PAYMENTTYPE]

}

export type SemesterRegistrationStatus = $Enums.SemesterRegistrationStatus

export const SemesterRegistrationStatus: typeof $Enums.SemesterRegistrationStatus

export type Shift = $Enums.Shift

export const Shift: typeof $Enums.Shift

export type Status = $Enums.Status

export const Status: typeof $Enums.Status

export type WeekDays = $Enums.WeekDays

export const WeekDays: typeof $Enums.WeekDays

export type StudentEnrolledCourseStatus = $Enums.StudentEnrolledCourseStatus

export const StudentEnrolledCourseStatus: typeof $Enums.StudentEnrolledCourseStatus

export type ExamType = $Enums.ExamType

export const ExamType: typeof $Enums.ExamType

export type PaymentStatus = $Enums.PaymentStatus

export const PaymentStatus: typeof $Enums.PaymentStatus

export type UserRole = $Enums.UserRole

export const UserRole: typeof $Enums.UserRole

export type PAYMENTTYPE = $Enums.PAYMENTTYPE

export const PAYMENTTYPE: typeof $Enums.PAYMENTTYPE

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.users.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.users.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.users`: Exposes CRUD operations for the **Users** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.users.findMany()
    * ```
    */
  get users(): Prisma.UsersDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.academicSemester`: Exposes CRUD operations for the **AcademicSemester** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AcademicSemesters
    * const academicSemesters = await prisma.academicSemester.findMany()
    * ```
    */
  get academicSemester(): Prisma.AcademicSemesterDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.academicFaculty`: Exposes CRUD operations for the **AcademicFaculty** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AcademicFaculties
    * const academicFaculties = await prisma.academicFaculty.findMany()
    * ```
    */
  get academicFaculty(): Prisma.AcademicFacultyDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.academicDepartment`: Exposes CRUD operations for the **AcademicDepartment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AcademicDepartments
    * const academicDepartments = await prisma.academicDepartment.findMany()
    * ```
    */
  get academicDepartment(): Prisma.AcademicDepartmentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.student`: Exposes CRUD operations for the **Student** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Students
    * const students = await prisma.student.findMany()
    * ```
    */
  get student(): Prisma.StudentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.faculty`: Exposes CRUD operations for the **Faculty** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Faculties
    * const faculties = await prisma.faculty.findMany()
    * ```
    */
  get faculty(): Prisma.FacultyDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.building`: Exposes CRUD operations for the **Building** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Buildings
    * const buildings = await prisma.building.findMany()
    * ```
    */
  get building(): Prisma.BuildingDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.room`: Exposes CRUD operations for the **Room** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Rooms
    * const rooms = await prisma.room.findMany()
    * ```
    */
  get room(): Prisma.RoomDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.course`: Exposes CRUD operations for the **Course** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Courses
    * const courses = await prisma.course.findMany()
    * ```
    */
  get course(): Prisma.CourseDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.courseToPreRequisite`: Exposes CRUD operations for the **CourseToPreRequisite** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CourseToPreRequisites
    * const courseToPreRequisites = await prisma.courseToPreRequisite.findMany()
    * ```
    */
  get courseToPreRequisite(): Prisma.CourseToPreRequisiteDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.courseFaculty`: Exposes CRUD operations for the **CourseFaculty** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CourseFaculties
    * const courseFaculties = await prisma.courseFaculty.findMany()
    * ```
    */
  get courseFaculty(): Prisma.CourseFacultyDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.semesterRegistration`: Exposes CRUD operations for the **SemesterRegistration** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SemesterRegistrations
    * const semesterRegistrations = await prisma.semesterRegistration.findMany()
    * ```
    */
  get semesterRegistration(): Prisma.SemesterRegistrationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.admitionExameRegistration`: Exposes CRUD operations for the **AdmitionExameRegistration** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AdmitionExameRegistrations
    * const admitionExameRegistrations = await prisma.admitionExameRegistration.findMany()
    * ```
    */
  get admitionExameRegistration(): Prisma.AdmitionExameRegistrationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.offeredCourse`: Exposes CRUD operations for the **OfferedCourse** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OfferedCourses
    * const offeredCourses = await prisma.offeredCourse.findMany()
    * ```
    */
  get offeredCourse(): Prisma.OfferedCourseDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.offeredCourseSection`: Exposes CRUD operations for the **OfferedCourseSection** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OfferedCourseSections
    * const offeredCourseSections = await prisma.offeredCourseSection.findMany()
    * ```
    */
  get offeredCourseSection(): Prisma.OfferedCourseSectionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.offeredCourseClassSchedule`: Exposes CRUD operations for the **OfferedCourseClassSchedule** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OfferedCourseClassSchedules
    * const offeredCourseClassSchedules = await prisma.offeredCourseClassSchedule.findMany()
    * ```
    */
  get offeredCourseClassSchedule(): Prisma.OfferedCourseClassScheduleDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.studentSemesterRegistration`: Exposes CRUD operations for the **StudentSemesterRegistration** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StudentSemesterRegistrations
    * const studentSemesterRegistrations = await prisma.studentSemesterRegistration.findMany()
    * ```
    */
  get studentSemesterRegistration(): Prisma.StudentSemesterRegistrationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.studentSemesterRegistrationCourse`: Exposes CRUD operations for the **StudentSemesterRegistrationCourse** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StudentSemesterRegistrationCourses
    * const studentSemesterRegistrationCourses = await prisma.studentSemesterRegistrationCourse.findMany()
    * ```
    */
  get studentSemesterRegistrationCourse(): Prisma.StudentSemesterRegistrationCourseDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.studentEnrolledCourse`: Exposes CRUD operations for the **StudentEnrolledCourse** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StudentEnrolledCourses
    * const studentEnrolledCourses = await prisma.studentEnrolledCourse.findMany()
    * ```
    */
  get studentEnrolledCourse(): Prisma.StudentEnrolledCourseDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.studentEnrolledCourseMark`: Exposes CRUD operations for the **StudentEnrolledCourseMark** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StudentEnrolledCourseMarks
    * const studentEnrolledCourseMarks = await prisma.studentEnrolledCourseMark.findMany()
    * ```
    */
  get studentEnrolledCourseMark(): Prisma.StudentEnrolledCourseMarkDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.studentSemesterPayment`: Exposes CRUD operations for the **StudentSemesterPayment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StudentSemesterPayments
    * const studentSemesterPayments = await prisma.studentSemesterPayment.findMany()
    * ```
    */
  get studentSemesterPayment(): Prisma.StudentSemesterPaymentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.studentAcademicInfo`: Exposes CRUD operations for the **StudentAcademicInfo** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StudentAcademicInfos
    * const studentAcademicInfos = await prisma.studentAcademicInfo.findMany()
    * ```
    */
  get studentAcademicInfo(): Prisma.StudentAcademicInfoDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.6.0
   * Query Engine version: f676762280b54cd07c770017ed3711ddde35f37a
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Users: 'Users',
    AcademicSemester: 'AcademicSemester',
    AcademicFaculty: 'AcademicFaculty',
    AcademicDepartment: 'AcademicDepartment',
    Student: 'Student',
    Faculty: 'Faculty',
    Building: 'Building',
    Room: 'Room',
    Course: 'Course',
    CourseToPreRequisite: 'CourseToPreRequisite',
    CourseFaculty: 'CourseFaculty',
    SemesterRegistration: 'SemesterRegistration',
    AdmitionExameRegistration: 'AdmitionExameRegistration',
    OfferedCourse: 'OfferedCourse',
    OfferedCourseSection: 'OfferedCourseSection',
    OfferedCourseClassSchedule: 'OfferedCourseClassSchedule',
    StudentSemesterRegistration: 'StudentSemesterRegistration',
    StudentSemesterRegistrationCourse: 'StudentSemesterRegistrationCourse',
    StudentEnrolledCourse: 'StudentEnrolledCourse',
    StudentEnrolledCourseMark: 'StudentEnrolledCourseMark',
    StudentSemesterPayment: 'StudentSemesterPayment',
    StudentAcademicInfo: 'StudentAcademicInfo'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "users" | "academicSemester" | "academicFaculty" | "academicDepartment" | "student" | "faculty" | "building" | "room" | "course" | "courseToPreRequisite" | "courseFaculty" | "semesterRegistration" | "admitionExameRegistration" | "offeredCourse" | "offeredCourseSection" | "offeredCourseClassSchedule" | "studentSemesterRegistration" | "studentSemesterRegistrationCourse" | "studentEnrolledCourse" | "studentEnrolledCourseMark" | "studentSemesterPayment" | "studentAcademicInfo"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Users: {
        payload: Prisma.$UsersPayload<ExtArgs>
        fields: Prisma.UsersFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UsersFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsersPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UsersFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsersPayload>
          }
          findFirst: {
            args: Prisma.UsersFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsersPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UsersFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsersPayload>
          }
          findMany: {
            args: Prisma.UsersFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsersPayload>[]
          }
          create: {
            args: Prisma.UsersCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsersPayload>
          }
          createMany: {
            args: Prisma.UsersCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.UsersDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsersPayload>
          }
          update: {
            args: Prisma.UsersUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsersPayload>
          }
          deleteMany: {
            args: Prisma.UsersDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UsersUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UsersUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsersPayload>
          }
          aggregate: {
            args: Prisma.UsersAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUsers>
          }
          groupBy: {
            args: Prisma.UsersGroupByArgs<ExtArgs>
            result: $Utils.Optional<UsersGroupByOutputType>[]
          }
          count: {
            args: Prisma.UsersCountArgs<ExtArgs>
            result: $Utils.Optional<UsersCountAggregateOutputType> | number
          }
        }
      }
      AcademicSemester: {
        payload: Prisma.$AcademicSemesterPayload<ExtArgs>
        fields: Prisma.AcademicSemesterFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AcademicSemesterFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AcademicSemesterPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AcademicSemesterFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AcademicSemesterPayload>
          }
          findFirst: {
            args: Prisma.AcademicSemesterFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AcademicSemesterPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AcademicSemesterFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AcademicSemesterPayload>
          }
          findMany: {
            args: Prisma.AcademicSemesterFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AcademicSemesterPayload>[]
          }
          create: {
            args: Prisma.AcademicSemesterCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AcademicSemesterPayload>
          }
          createMany: {
            args: Prisma.AcademicSemesterCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.AcademicSemesterDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AcademicSemesterPayload>
          }
          update: {
            args: Prisma.AcademicSemesterUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AcademicSemesterPayload>
          }
          deleteMany: {
            args: Prisma.AcademicSemesterDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AcademicSemesterUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AcademicSemesterUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AcademicSemesterPayload>
          }
          aggregate: {
            args: Prisma.AcademicSemesterAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAcademicSemester>
          }
          groupBy: {
            args: Prisma.AcademicSemesterGroupByArgs<ExtArgs>
            result: $Utils.Optional<AcademicSemesterGroupByOutputType>[]
          }
          count: {
            args: Prisma.AcademicSemesterCountArgs<ExtArgs>
            result: $Utils.Optional<AcademicSemesterCountAggregateOutputType> | number
          }
        }
      }
      AcademicFaculty: {
        payload: Prisma.$AcademicFacultyPayload<ExtArgs>
        fields: Prisma.AcademicFacultyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AcademicFacultyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AcademicFacultyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AcademicFacultyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AcademicFacultyPayload>
          }
          findFirst: {
            args: Prisma.AcademicFacultyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AcademicFacultyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AcademicFacultyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AcademicFacultyPayload>
          }
          findMany: {
            args: Prisma.AcademicFacultyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AcademicFacultyPayload>[]
          }
          create: {
            args: Prisma.AcademicFacultyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AcademicFacultyPayload>
          }
          createMany: {
            args: Prisma.AcademicFacultyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.AcademicFacultyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AcademicFacultyPayload>
          }
          update: {
            args: Prisma.AcademicFacultyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AcademicFacultyPayload>
          }
          deleteMany: {
            args: Prisma.AcademicFacultyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AcademicFacultyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AcademicFacultyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AcademicFacultyPayload>
          }
          aggregate: {
            args: Prisma.AcademicFacultyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAcademicFaculty>
          }
          groupBy: {
            args: Prisma.AcademicFacultyGroupByArgs<ExtArgs>
            result: $Utils.Optional<AcademicFacultyGroupByOutputType>[]
          }
          count: {
            args: Prisma.AcademicFacultyCountArgs<ExtArgs>
            result: $Utils.Optional<AcademicFacultyCountAggregateOutputType> | number
          }
        }
      }
      AcademicDepartment: {
        payload: Prisma.$AcademicDepartmentPayload<ExtArgs>
        fields: Prisma.AcademicDepartmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AcademicDepartmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AcademicDepartmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AcademicDepartmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AcademicDepartmentPayload>
          }
          findFirst: {
            args: Prisma.AcademicDepartmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AcademicDepartmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AcademicDepartmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AcademicDepartmentPayload>
          }
          findMany: {
            args: Prisma.AcademicDepartmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AcademicDepartmentPayload>[]
          }
          create: {
            args: Prisma.AcademicDepartmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AcademicDepartmentPayload>
          }
          createMany: {
            args: Prisma.AcademicDepartmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.AcademicDepartmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AcademicDepartmentPayload>
          }
          update: {
            args: Prisma.AcademicDepartmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AcademicDepartmentPayload>
          }
          deleteMany: {
            args: Prisma.AcademicDepartmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AcademicDepartmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AcademicDepartmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AcademicDepartmentPayload>
          }
          aggregate: {
            args: Prisma.AcademicDepartmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAcademicDepartment>
          }
          groupBy: {
            args: Prisma.AcademicDepartmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<AcademicDepartmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.AcademicDepartmentCountArgs<ExtArgs>
            result: $Utils.Optional<AcademicDepartmentCountAggregateOutputType> | number
          }
        }
      }
      Student: {
        payload: Prisma.$StudentPayload<ExtArgs>
        fields: Prisma.StudentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StudentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StudentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPayload>
          }
          findFirst: {
            args: Prisma.StudentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StudentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPayload>
          }
          findMany: {
            args: Prisma.StudentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPayload>[]
          }
          create: {
            args: Prisma.StudentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPayload>
          }
          createMany: {
            args: Prisma.StudentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.StudentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPayload>
          }
          update: {
            args: Prisma.StudentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPayload>
          }
          deleteMany: {
            args: Prisma.StudentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StudentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.StudentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPayload>
          }
          aggregate: {
            args: Prisma.StudentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStudent>
          }
          groupBy: {
            args: Prisma.StudentGroupByArgs<ExtArgs>
            result: $Utils.Optional<StudentGroupByOutputType>[]
          }
          count: {
            args: Prisma.StudentCountArgs<ExtArgs>
            result: $Utils.Optional<StudentCountAggregateOutputType> | number
          }
        }
      }
      Faculty: {
        payload: Prisma.$FacultyPayload<ExtArgs>
        fields: Prisma.FacultyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FacultyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FacultyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FacultyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FacultyPayload>
          }
          findFirst: {
            args: Prisma.FacultyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FacultyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FacultyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FacultyPayload>
          }
          findMany: {
            args: Prisma.FacultyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FacultyPayload>[]
          }
          create: {
            args: Prisma.FacultyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FacultyPayload>
          }
          createMany: {
            args: Prisma.FacultyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.FacultyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FacultyPayload>
          }
          update: {
            args: Prisma.FacultyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FacultyPayload>
          }
          deleteMany: {
            args: Prisma.FacultyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FacultyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.FacultyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FacultyPayload>
          }
          aggregate: {
            args: Prisma.FacultyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFaculty>
          }
          groupBy: {
            args: Prisma.FacultyGroupByArgs<ExtArgs>
            result: $Utils.Optional<FacultyGroupByOutputType>[]
          }
          count: {
            args: Prisma.FacultyCountArgs<ExtArgs>
            result: $Utils.Optional<FacultyCountAggregateOutputType> | number
          }
        }
      }
      Building: {
        payload: Prisma.$BuildingPayload<ExtArgs>
        fields: Prisma.BuildingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BuildingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BuildingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BuildingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BuildingPayload>
          }
          findFirst: {
            args: Prisma.BuildingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BuildingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BuildingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BuildingPayload>
          }
          findMany: {
            args: Prisma.BuildingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BuildingPayload>[]
          }
          create: {
            args: Prisma.BuildingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BuildingPayload>
          }
          createMany: {
            args: Prisma.BuildingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.BuildingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BuildingPayload>
          }
          update: {
            args: Prisma.BuildingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BuildingPayload>
          }
          deleteMany: {
            args: Prisma.BuildingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BuildingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BuildingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BuildingPayload>
          }
          aggregate: {
            args: Prisma.BuildingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBuilding>
          }
          groupBy: {
            args: Prisma.BuildingGroupByArgs<ExtArgs>
            result: $Utils.Optional<BuildingGroupByOutputType>[]
          }
          count: {
            args: Prisma.BuildingCountArgs<ExtArgs>
            result: $Utils.Optional<BuildingCountAggregateOutputType> | number
          }
        }
      }
      Room: {
        payload: Prisma.$RoomPayload<ExtArgs>
        fields: Prisma.RoomFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RoomFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RoomFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomPayload>
          }
          findFirst: {
            args: Prisma.RoomFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RoomFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomPayload>
          }
          findMany: {
            args: Prisma.RoomFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomPayload>[]
          }
          create: {
            args: Prisma.RoomCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomPayload>
          }
          createMany: {
            args: Prisma.RoomCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.RoomDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomPayload>
          }
          update: {
            args: Prisma.RoomUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomPayload>
          }
          deleteMany: {
            args: Prisma.RoomDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RoomUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RoomUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomPayload>
          }
          aggregate: {
            args: Prisma.RoomAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRoom>
          }
          groupBy: {
            args: Prisma.RoomGroupByArgs<ExtArgs>
            result: $Utils.Optional<RoomGroupByOutputType>[]
          }
          count: {
            args: Prisma.RoomCountArgs<ExtArgs>
            result: $Utils.Optional<RoomCountAggregateOutputType> | number
          }
        }
      }
      Course: {
        payload: Prisma.$CoursePayload<ExtArgs>
        fields: Prisma.CourseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CourseFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CourseFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload>
          }
          findFirst: {
            args: Prisma.CourseFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CourseFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload>
          }
          findMany: {
            args: Prisma.CourseFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload>[]
          }
          create: {
            args: Prisma.CourseCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload>
          }
          createMany: {
            args: Prisma.CourseCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.CourseDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload>
          }
          update: {
            args: Prisma.CourseUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload>
          }
          deleteMany: {
            args: Prisma.CourseDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CourseUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CourseUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload>
          }
          aggregate: {
            args: Prisma.CourseAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCourse>
          }
          groupBy: {
            args: Prisma.CourseGroupByArgs<ExtArgs>
            result: $Utils.Optional<CourseGroupByOutputType>[]
          }
          count: {
            args: Prisma.CourseCountArgs<ExtArgs>
            result: $Utils.Optional<CourseCountAggregateOutputType> | number
          }
        }
      }
      CourseToPreRequisite: {
        payload: Prisma.$CourseToPreRequisitePayload<ExtArgs>
        fields: Prisma.CourseToPreRequisiteFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CourseToPreRequisiteFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseToPreRequisitePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CourseToPreRequisiteFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseToPreRequisitePayload>
          }
          findFirst: {
            args: Prisma.CourseToPreRequisiteFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseToPreRequisitePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CourseToPreRequisiteFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseToPreRequisitePayload>
          }
          findMany: {
            args: Prisma.CourseToPreRequisiteFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseToPreRequisitePayload>[]
          }
          create: {
            args: Prisma.CourseToPreRequisiteCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseToPreRequisitePayload>
          }
          createMany: {
            args: Prisma.CourseToPreRequisiteCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.CourseToPreRequisiteDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseToPreRequisitePayload>
          }
          update: {
            args: Prisma.CourseToPreRequisiteUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseToPreRequisitePayload>
          }
          deleteMany: {
            args: Prisma.CourseToPreRequisiteDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CourseToPreRequisiteUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CourseToPreRequisiteUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseToPreRequisitePayload>
          }
          aggregate: {
            args: Prisma.CourseToPreRequisiteAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCourseToPreRequisite>
          }
          groupBy: {
            args: Prisma.CourseToPreRequisiteGroupByArgs<ExtArgs>
            result: $Utils.Optional<CourseToPreRequisiteGroupByOutputType>[]
          }
          count: {
            args: Prisma.CourseToPreRequisiteCountArgs<ExtArgs>
            result: $Utils.Optional<CourseToPreRequisiteCountAggregateOutputType> | number
          }
        }
      }
      CourseFaculty: {
        payload: Prisma.$CourseFacultyPayload<ExtArgs>
        fields: Prisma.CourseFacultyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CourseFacultyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseFacultyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CourseFacultyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseFacultyPayload>
          }
          findFirst: {
            args: Prisma.CourseFacultyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseFacultyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CourseFacultyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseFacultyPayload>
          }
          findMany: {
            args: Prisma.CourseFacultyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseFacultyPayload>[]
          }
          create: {
            args: Prisma.CourseFacultyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseFacultyPayload>
          }
          createMany: {
            args: Prisma.CourseFacultyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.CourseFacultyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseFacultyPayload>
          }
          update: {
            args: Prisma.CourseFacultyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseFacultyPayload>
          }
          deleteMany: {
            args: Prisma.CourseFacultyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CourseFacultyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CourseFacultyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseFacultyPayload>
          }
          aggregate: {
            args: Prisma.CourseFacultyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCourseFaculty>
          }
          groupBy: {
            args: Prisma.CourseFacultyGroupByArgs<ExtArgs>
            result: $Utils.Optional<CourseFacultyGroupByOutputType>[]
          }
          count: {
            args: Prisma.CourseFacultyCountArgs<ExtArgs>
            result: $Utils.Optional<CourseFacultyCountAggregateOutputType> | number
          }
        }
      }
      SemesterRegistration: {
        payload: Prisma.$SemesterRegistrationPayload<ExtArgs>
        fields: Prisma.SemesterRegistrationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SemesterRegistrationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SemesterRegistrationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SemesterRegistrationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SemesterRegistrationPayload>
          }
          findFirst: {
            args: Prisma.SemesterRegistrationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SemesterRegistrationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SemesterRegistrationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SemesterRegistrationPayload>
          }
          findMany: {
            args: Prisma.SemesterRegistrationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SemesterRegistrationPayload>[]
          }
          create: {
            args: Prisma.SemesterRegistrationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SemesterRegistrationPayload>
          }
          createMany: {
            args: Prisma.SemesterRegistrationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.SemesterRegistrationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SemesterRegistrationPayload>
          }
          update: {
            args: Prisma.SemesterRegistrationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SemesterRegistrationPayload>
          }
          deleteMany: {
            args: Prisma.SemesterRegistrationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SemesterRegistrationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SemesterRegistrationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SemesterRegistrationPayload>
          }
          aggregate: {
            args: Prisma.SemesterRegistrationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSemesterRegistration>
          }
          groupBy: {
            args: Prisma.SemesterRegistrationGroupByArgs<ExtArgs>
            result: $Utils.Optional<SemesterRegistrationGroupByOutputType>[]
          }
          count: {
            args: Prisma.SemesterRegistrationCountArgs<ExtArgs>
            result: $Utils.Optional<SemesterRegistrationCountAggregateOutputType> | number
          }
        }
      }
      AdmitionExameRegistration: {
        payload: Prisma.$AdmitionExameRegistrationPayload<ExtArgs>
        fields: Prisma.AdmitionExameRegistrationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AdmitionExameRegistrationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdmitionExameRegistrationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AdmitionExameRegistrationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdmitionExameRegistrationPayload>
          }
          findFirst: {
            args: Prisma.AdmitionExameRegistrationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdmitionExameRegistrationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AdmitionExameRegistrationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdmitionExameRegistrationPayload>
          }
          findMany: {
            args: Prisma.AdmitionExameRegistrationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdmitionExameRegistrationPayload>[]
          }
          create: {
            args: Prisma.AdmitionExameRegistrationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdmitionExameRegistrationPayload>
          }
          createMany: {
            args: Prisma.AdmitionExameRegistrationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.AdmitionExameRegistrationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdmitionExameRegistrationPayload>
          }
          update: {
            args: Prisma.AdmitionExameRegistrationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdmitionExameRegistrationPayload>
          }
          deleteMany: {
            args: Prisma.AdmitionExameRegistrationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AdmitionExameRegistrationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AdmitionExameRegistrationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdmitionExameRegistrationPayload>
          }
          aggregate: {
            args: Prisma.AdmitionExameRegistrationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAdmitionExameRegistration>
          }
          groupBy: {
            args: Prisma.AdmitionExameRegistrationGroupByArgs<ExtArgs>
            result: $Utils.Optional<AdmitionExameRegistrationGroupByOutputType>[]
          }
          count: {
            args: Prisma.AdmitionExameRegistrationCountArgs<ExtArgs>
            result: $Utils.Optional<AdmitionExameRegistrationCountAggregateOutputType> | number
          }
        }
      }
      OfferedCourse: {
        payload: Prisma.$OfferedCoursePayload<ExtArgs>
        fields: Prisma.OfferedCourseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OfferedCourseFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OfferedCoursePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OfferedCourseFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OfferedCoursePayload>
          }
          findFirst: {
            args: Prisma.OfferedCourseFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OfferedCoursePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OfferedCourseFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OfferedCoursePayload>
          }
          findMany: {
            args: Prisma.OfferedCourseFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OfferedCoursePayload>[]
          }
          create: {
            args: Prisma.OfferedCourseCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OfferedCoursePayload>
          }
          createMany: {
            args: Prisma.OfferedCourseCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.OfferedCourseDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OfferedCoursePayload>
          }
          update: {
            args: Prisma.OfferedCourseUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OfferedCoursePayload>
          }
          deleteMany: {
            args: Prisma.OfferedCourseDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OfferedCourseUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.OfferedCourseUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OfferedCoursePayload>
          }
          aggregate: {
            args: Prisma.OfferedCourseAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOfferedCourse>
          }
          groupBy: {
            args: Prisma.OfferedCourseGroupByArgs<ExtArgs>
            result: $Utils.Optional<OfferedCourseGroupByOutputType>[]
          }
          count: {
            args: Prisma.OfferedCourseCountArgs<ExtArgs>
            result: $Utils.Optional<OfferedCourseCountAggregateOutputType> | number
          }
        }
      }
      OfferedCourseSection: {
        payload: Prisma.$OfferedCourseSectionPayload<ExtArgs>
        fields: Prisma.OfferedCourseSectionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OfferedCourseSectionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OfferedCourseSectionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OfferedCourseSectionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OfferedCourseSectionPayload>
          }
          findFirst: {
            args: Prisma.OfferedCourseSectionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OfferedCourseSectionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OfferedCourseSectionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OfferedCourseSectionPayload>
          }
          findMany: {
            args: Prisma.OfferedCourseSectionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OfferedCourseSectionPayload>[]
          }
          create: {
            args: Prisma.OfferedCourseSectionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OfferedCourseSectionPayload>
          }
          createMany: {
            args: Prisma.OfferedCourseSectionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.OfferedCourseSectionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OfferedCourseSectionPayload>
          }
          update: {
            args: Prisma.OfferedCourseSectionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OfferedCourseSectionPayload>
          }
          deleteMany: {
            args: Prisma.OfferedCourseSectionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OfferedCourseSectionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.OfferedCourseSectionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OfferedCourseSectionPayload>
          }
          aggregate: {
            args: Prisma.OfferedCourseSectionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOfferedCourseSection>
          }
          groupBy: {
            args: Prisma.OfferedCourseSectionGroupByArgs<ExtArgs>
            result: $Utils.Optional<OfferedCourseSectionGroupByOutputType>[]
          }
          count: {
            args: Prisma.OfferedCourseSectionCountArgs<ExtArgs>
            result: $Utils.Optional<OfferedCourseSectionCountAggregateOutputType> | number
          }
        }
      }
      OfferedCourseClassSchedule: {
        payload: Prisma.$OfferedCourseClassSchedulePayload<ExtArgs>
        fields: Prisma.OfferedCourseClassScheduleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OfferedCourseClassScheduleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OfferedCourseClassSchedulePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OfferedCourseClassScheduleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OfferedCourseClassSchedulePayload>
          }
          findFirst: {
            args: Prisma.OfferedCourseClassScheduleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OfferedCourseClassSchedulePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OfferedCourseClassScheduleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OfferedCourseClassSchedulePayload>
          }
          findMany: {
            args: Prisma.OfferedCourseClassScheduleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OfferedCourseClassSchedulePayload>[]
          }
          create: {
            args: Prisma.OfferedCourseClassScheduleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OfferedCourseClassSchedulePayload>
          }
          createMany: {
            args: Prisma.OfferedCourseClassScheduleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.OfferedCourseClassScheduleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OfferedCourseClassSchedulePayload>
          }
          update: {
            args: Prisma.OfferedCourseClassScheduleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OfferedCourseClassSchedulePayload>
          }
          deleteMany: {
            args: Prisma.OfferedCourseClassScheduleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OfferedCourseClassScheduleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.OfferedCourseClassScheduleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OfferedCourseClassSchedulePayload>
          }
          aggregate: {
            args: Prisma.OfferedCourseClassScheduleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOfferedCourseClassSchedule>
          }
          groupBy: {
            args: Prisma.OfferedCourseClassScheduleGroupByArgs<ExtArgs>
            result: $Utils.Optional<OfferedCourseClassScheduleGroupByOutputType>[]
          }
          count: {
            args: Prisma.OfferedCourseClassScheduleCountArgs<ExtArgs>
            result: $Utils.Optional<OfferedCourseClassScheduleCountAggregateOutputType> | number
          }
        }
      }
      StudentSemesterRegistration: {
        payload: Prisma.$StudentSemesterRegistrationPayload<ExtArgs>
        fields: Prisma.StudentSemesterRegistrationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StudentSemesterRegistrationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentSemesterRegistrationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StudentSemesterRegistrationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentSemesterRegistrationPayload>
          }
          findFirst: {
            args: Prisma.StudentSemesterRegistrationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentSemesterRegistrationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StudentSemesterRegistrationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentSemesterRegistrationPayload>
          }
          findMany: {
            args: Prisma.StudentSemesterRegistrationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentSemesterRegistrationPayload>[]
          }
          create: {
            args: Prisma.StudentSemesterRegistrationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentSemesterRegistrationPayload>
          }
          createMany: {
            args: Prisma.StudentSemesterRegistrationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.StudentSemesterRegistrationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentSemesterRegistrationPayload>
          }
          update: {
            args: Prisma.StudentSemesterRegistrationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentSemesterRegistrationPayload>
          }
          deleteMany: {
            args: Prisma.StudentSemesterRegistrationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StudentSemesterRegistrationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.StudentSemesterRegistrationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentSemesterRegistrationPayload>
          }
          aggregate: {
            args: Prisma.StudentSemesterRegistrationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStudentSemesterRegistration>
          }
          groupBy: {
            args: Prisma.StudentSemesterRegistrationGroupByArgs<ExtArgs>
            result: $Utils.Optional<StudentSemesterRegistrationGroupByOutputType>[]
          }
          count: {
            args: Prisma.StudentSemesterRegistrationCountArgs<ExtArgs>
            result: $Utils.Optional<StudentSemesterRegistrationCountAggregateOutputType> | number
          }
        }
      }
      StudentSemesterRegistrationCourse: {
        payload: Prisma.$StudentSemesterRegistrationCoursePayload<ExtArgs>
        fields: Prisma.StudentSemesterRegistrationCourseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StudentSemesterRegistrationCourseFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentSemesterRegistrationCoursePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StudentSemesterRegistrationCourseFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentSemesterRegistrationCoursePayload>
          }
          findFirst: {
            args: Prisma.StudentSemesterRegistrationCourseFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentSemesterRegistrationCoursePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StudentSemesterRegistrationCourseFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentSemesterRegistrationCoursePayload>
          }
          findMany: {
            args: Prisma.StudentSemesterRegistrationCourseFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentSemesterRegistrationCoursePayload>[]
          }
          create: {
            args: Prisma.StudentSemesterRegistrationCourseCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentSemesterRegistrationCoursePayload>
          }
          createMany: {
            args: Prisma.StudentSemesterRegistrationCourseCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.StudentSemesterRegistrationCourseDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentSemesterRegistrationCoursePayload>
          }
          update: {
            args: Prisma.StudentSemesterRegistrationCourseUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentSemesterRegistrationCoursePayload>
          }
          deleteMany: {
            args: Prisma.StudentSemesterRegistrationCourseDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StudentSemesterRegistrationCourseUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.StudentSemesterRegistrationCourseUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentSemesterRegistrationCoursePayload>
          }
          aggregate: {
            args: Prisma.StudentSemesterRegistrationCourseAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStudentSemesterRegistrationCourse>
          }
          groupBy: {
            args: Prisma.StudentSemesterRegistrationCourseGroupByArgs<ExtArgs>
            result: $Utils.Optional<StudentSemesterRegistrationCourseGroupByOutputType>[]
          }
          count: {
            args: Prisma.StudentSemesterRegistrationCourseCountArgs<ExtArgs>
            result: $Utils.Optional<StudentSemesterRegistrationCourseCountAggregateOutputType> | number
          }
        }
      }
      StudentEnrolledCourse: {
        payload: Prisma.$StudentEnrolledCoursePayload<ExtArgs>
        fields: Prisma.StudentEnrolledCourseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StudentEnrolledCourseFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentEnrolledCoursePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StudentEnrolledCourseFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentEnrolledCoursePayload>
          }
          findFirst: {
            args: Prisma.StudentEnrolledCourseFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentEnrolledCoursePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StudentEnrolledCourseFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentEnrolledCoursePayload>
          }
          findMany: {
            args: Prisma.StudentEnrolledCourseFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentEnrolledCoursePayload>[]
          }
          create: {
            args: Prisma.StudentEnrolledCourseCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentEnrolledCoursePayload>
          }
          createMany: {
            args: Prisma.StudentEnrolledCourseCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.StudentEnrolledCourseDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentEnrolledCoursePayload>
          }
          update: {
            args: Prisma.StudentEnrolledCourseUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentEnrolledCoursePayload>
          }
          deleteMany: {
            args: Prisma.StudentEnrolledCourseDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StudentEnrolledCourseUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.StudentEnrolledCourseUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentEnrolledCoursePayload>
          }
          aggregate: {
            args: Prisma.StudentEnrolledCourseAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStudentEnrolledCourse>
          }
          groupBy: {
            args: Prisma.StudentEnrolledCourseGroupByArgs<ExtArgs>
            result: $Utils.Optional<StudentEnrolledCourseGroupByOutputType>[]
          }
          count: {
            args: Prisma.StudentEnrolledCourseCountArgs<ExtArgs>
            result: $Utils.Optional<StudentEnrolledCourseCountAggregateOutputType> | number
          }
        }
      }
      StudentEnrolledCourseMark: {
        payload: Prisma.$StudentEnrolledCourseMarkPayload<ExtArgs>
        fields: Prisma.StudentEnrolledCourseMarkFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StudentEnrolledCourseMarkFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentEnrolledCourseMarkPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StudentEnrolledCourseMarkFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentEnrolledCourseMarkPayload>
          }
          findFirst: {
            args: Prisma.StudentEnrolledCourseMarkFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentEnrolledCourseMarkPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StudentEnrolledCourseMarkFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentEnrolledCourseMarkPayload>
          }
          findMany: {
            args: Prisma.StudentEnrolledCourseMarkFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentEnrolledCourseMarkPayload>[]
          }
          create: {
            args: Prisma.StudentEnrolledCourseMarkCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentEnrolledCourseMarkPayload>
          }
          createMany: {
            args: Prisma.StudentEnrolledCourseMarkCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.StudentEnrolledCourseMarkDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentEnrolledCourseMarkPayload>
          }
          update: {
            args: Prisma.StudentEnrolledCourseMarkUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentEnrolledCourseMarkPayload>
          }
          deleteMany: {
            args: Prisma.StudentEnrolledCourseMarkDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StudentEnrolledCourseMarkUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.StudentEnrolledCourseMarkUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentEnrolledCourseMarkPayload>
          }
          aggregate: {
            args: Prisma.StudentEnrolledCourseMarkAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStudentEnrolledCourseMark>
          }
          groupBy: {
            args: Prisma.StudentEnrolledCourseMarkGroupByArgs<ExtArgs>
            result: $Utils.Optional<StudentEnrolledCourseMarkGroupByOutputType>[]
          }
          count: {
            args: Prisma.StudentEnrolledCourseMarkCountArgs<ExtArgs>
            result: $Utils.Optional<StudentEnrolledCourseMarkCountAggregateOutputType> | number
          }
        }
      }
      StudentSemesterPayment: {
        payload: Prisma.$StudentSemesterPaymentPayload<ExtArgs>
        fields: Prisma.StudentSemesterPaymentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StudentSemesterPaymentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentSemesterPaymentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StudentSemesterPaymentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentSemesterPaymentPayload>
          }
          findFirst: {
            args: Prisma.StudentSemesterPaymentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentSemesterPaymentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StudentSemesterPaymentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentSemesterPaymentPayload>
          }
          findMany: {
            args: Prisma.StudentSemesterPaymentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentSemesterPaymentPayload>[]
          }
          create: {
            args: Prisma.StudentSemesterPaymentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentSemesterPaymentPayload>
          }
          createMany: {
            args: Prisma.StudentSemesterPaymentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.StudentSemesterPaymentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentSemesterPaymentPayload>
          }
          update: {
            args: Prisma.StudentSemesterPaymentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentSemesterPaymentPayload>
          }
          deleteMany: {
            args: Prisma.StudentSemesterPaymentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StudentSemesterPaymentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.StudentSemesterPaymentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentSemesterPaymentPayload>
          }
          aggregate: {
            args: Prisma.StudentSemesterPaymentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStudentSemesterPayment>
          }
          groupBy: {
            args: Prisma.StudentSemesterPaymentGroupByArgs<ExtArgs>
            result: $Utils.Optional<StudentSemesterPaymentGroupByOutputType>[]
          }
          count: {
            args: Prisma.StudentSemesterPaymentCountArgs<ExtArgs>
            result: $Utils.Optional<StudentSemesterPaymentCountAggregateOutputType> | number
          }
        }
      }
      StudentAcademicInfo: {
        payload: Prisma.$StudentAcademicInfoPayload<ExtArgs>
        fields: Prisma.StudentAcademicInfoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StudentAcademicInfoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentAcademicInfoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StudentAcademicInfoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentAcademicInfoPayload>
          }
          findFirst: {
            args: Prisma.StudentAcademicInfoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentAcademicInfoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StudentAcademicInfoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentAcademicInfoPayload>
          }
          findMany: {
            args: Prisma.StudentAcademicInfoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentAcademicInfoPayload>[]
          }
          create: {
            args: Prisma.StudentAcademicInfoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentAcademicInfoPayload>
          }
          createMany: {
            args: Prisma.StudentAcademicInfoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.StudentAcademicInfoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentAcademicInfoPayload>
          }
          update: {
            args: Prisma.StudentAcademicInfoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentAcademicInfoPayload>
          }
          deleteMany: {
            args: Prisma.StudentAcademicInfoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StudentAcademicInfoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.StudentAcademicInfoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentAcademicInfoPayload>
          }
          aggregate: {
            args: Prisma.StudentAcademicInfoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStudentAcademicInfo>
          }
          groupBy: {
            args: Prisma.StudentAcademicInfoGroupByArgs<ExtArgs>
            result: $Utils.Optional<StudentAcademicInfoGroupByOutputType>[]
          }
          count: {
            args: Prisma.StudentAcademicInfoCountArgs<ExtArgs>
            result: $Utils.Optional<StudentAcademicInfoCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    users?: UsersOmit
    academicSemester?: AcademicSemesterOmit
    academicFaculty?: AcademicFacultyOmit
    academicDepartment?: AcademicDepartmentOmit
    student?: StudentOmit
    faculty?: FacultyOmit
    building?: BuildingOmit
    room?: RoomOmit
    course?: CourseOmit
    courseToPreRequisite?: CourseToPreRequisiteOmit
    courseFaculty?: CourseFacultyOmit
    semesterRegistration?: SemesterRegistrationOmit
    admitionExameRegistration?: AdmitionExameRegistrationOmit
    offeredCourse?: OfferedCourseOmit
    offeredCourseSection?: OfferedCourseSectionOmit
    offeredCourseClassSchedule?: OfferedCourseClassScheduleOmit
    studentSemesterRegistration?: StudentSemesterRegistrationOmit
    studentSemesterRegistrationCourse?: StudentSemesterRegistrationCourseOmit
    studentEnrolledCourse?: StudentEnrolledCourseOmit
    studentEnrolledCourseMark?: StudentEnrolledCourseMarkOmit
    studentSemesterPayment?: StudentSemesterPaymentOmit
    studentAcademicInfo?: StudentAcademicInfoOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UsersCountOutputType
   */

  export type UsersCountOutputType = {
    staffDepartments: number
  }

  export type UsersCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    staffDepartments?: boolean | UsersCountOutputTypeCountStaffDepartmentsArgs
  }

  // Custom InputTypes
  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsersCountOutputType
     */
    select?: UsersCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountStaffDepartmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AcademicDepartmentWhereInput
  }


  /**
   * Count Type AcademicSemesterCountOutputType
   */

  export type AcademicSemesterCountOutputType = {
    semesterRegistrations: number
    studentEnrolledCourses: number
    studentEnrolledCourseMarks: number
    studentSemesterPayments: number
  }

  export type AcademicSemesterCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    semesterRegistrations?: boolean | AcademicSemesterCountOutputTypeCountSemesterRegistrationsArgs
    studentEnrolledCourses?: boolean | AcademicSemesterCountOutputTypeCountStudentEnrolledCoursesArgs
    studentEnrolledCourseMarks?: boolean | AcademicSemesterCountOutputTypeCountStudentEnrolledCourseMarksArgs
    studentSemesterPayments?: boolean | AcademicSemesterCountOutputTypeCountStudentSemesterPaymentsArgs
  }

  // Custom InputTypes
  /**
   * AcademicSemesterCountOutputType without action
   */
  export type AcademicSemesterCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicSemesterCountOutputType
     */
    select?: AcademicSemesterCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AcademicSemesterCountOutputType without action
   */
  export type AcademicSemesterCountOutputTypeCountSemesterRegistrationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SemesterRegistrationWhereInput
  }

  /**
   * AcademicSemesterCountOutputType without action
   */
  export type AcademicSemesterCountOutputTypeCountStudentEnrolledCoursesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentEnrolledCourseWhereInput
  }

  /**
   * AcademicSemesterCountOutputType without action
   */
  export type AcademicSemesterCountOutputTypeCountStudentEnrolledCourseMarksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentEnrolledCourseMarkWhereInput
  }

  /**
   * AcademicSemesterCountOutputType without action
   */
  export type AcademicSemesterCountOutputTypeCountStudentSemesterPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentSemesterPaymentWhereInput
  }


  /**
   * Count Type AcademicDepartmentCountOutputType
   */

  export type AcademicDepartmentCountOutputType = {
    staffMembers: number
    admitionExame: number
    offeredCourses: number
  }

  export type AcademicDepartmentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    staffMembers?: boolean | AcademicDepartmentCountOutputTypeCountStaffMembersArgs
    admitionExame?: boolean | AcademicDepartmentCountOutputTypeCountAdmitionExameArgs
    offeredCourses?: boolean | AcademicDepartmentCountOutputTypeCountOfferedCoursesArgs
  }

  // Custom InputTypes
  /**
   * AcademicDepartmentCountOutputType without action
   */
  export type AcademicDepartmentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicDepartmentCountOutputType
     */
    select?: AcademicDepartmentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AcademicDepartmentCountOutputType without action
   */
  export type AcademicDepartmentCountOutputTypeCountStaffMembersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UsersWhereInput
  }

  /**
   * AcademicDepartmentCountOutputType without action
   */
  export type AcademicDepartmentCountOutputTypeCountAdmitionExameArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdmitionExameRegistrationWhereInput
  }

  /**
   * AcademicDepartmentCountOutputType without action
   */
  export type AcademicDepartmentCountOutputTypeCountOfferedCoursesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OfferedCourseWhereInput
  }


  /**
   * Count Type StudentCountOutputType
   */

  export type StudentCountOutputType = {
    studentSemesterRegistrations: number
    studentSemesterRegistrationCourses: number
    studentEnrolledCourses: number
    studentEnrolledCourseMarks: number
    studentSemesterPayments: number
    studentAcademicInfos: number
  }

  export type StudentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    studentSemesterRegistrations?: boolean | StudentCountOutputTypeCountStudentSemesterRegistrationsArgs
    studentSemesterRegistrationCourses?: boolean | StudentCountOutputTypeCountStudentSemesterRegistrationCoursesArgs
    studentEnrolledCourses?: boolean | StudentCountOutputTypeCountStudentEnrolledCoursesArgs
    studentEnrolledCourseMarks?: boolean | StudentCountOutputTypeCountStudentEnrolledCourseMarksArgs
    studentSemesterPayments?: boolean | StudentCountOutputTypeCountStudentSemesterPaymentsArgs
    studentAcademicInfos?: boolean | StudentCountOutputTypeCountStudentAcademicInfosArgs
  }

  // Custom InputTypes
  /**
   * StudentCountOutputType without action
   */
  export type StudentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentCountOutputType
     */
    select?: StudentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * StudentCountOutputType without action
   */
  export type StudentCountOutputTypeCountStudentSemesterRegistrationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentSemesterRegistrationWhereInput
  }

  /**
   * StudentCountOutputType without action
   */
  export type StudentCountOutputTypeCountStudentSemesterRegistrationCoursesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentSemesterRegistrationCourseWhereInput
  }

  /**
   * StudentCountOutputType without action
   */
  export type StudentCountOutputTypeCountStudentEnrolledCoursesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentEnrolledCourseWhereInput
  }

  /**
   * StudentCountOutputType without action
   */
  export type StudentCountOutputTypeCountStudentEnrolledCourseMarksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentEnrolledCourseMarkWhereInput
  }

  /**
   * StudentCountOutputType without action
   */
  export type StudentCountOutputTypeCountStudentSemesterPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentSemesterPaymentWhereInput
  }

  /**
   * StudentCountOutputType without action
   */
  export type StudentCountOutputTypeCountStudentAcademicInfosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentAcademicInfoWhereInput
  }


  /**
   * Count Type FacultyCountOutputType
   */

  export type FacultyCountOutputType = {
    courses: number
    offeredCourseClassSchedules: number
  }

  export type FacultyCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    courses?: boolean | FacultyCountOutputTypeCountCoursesArgs
    offeredCourseClassSchedules?: boolean | FacultyCountOutputTypeCountOfferedCourseClassSchedulesArgs
  }

  // Custom InputTypes
  /**
   * FacultyCountOutputType without action
   */
  export type FacultyCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FacultyCountOutputType
     */
    select?: FacultyCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * FacultyCountOutputType without action
   */
  export type FacultyCountOutputTypeCountCoursesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CourseFacultyWhereInput
  }

  /**
   * FacultyCountOutputType without action
   */
  export type FacultyCountOutputTypeCountOfferedCourseClassSchedulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OfferedCourseClassScheduleWhereInput
  }


  /**
   * Count Type BuildingCountOutputType
   */

  export type BuildingCountOutputType = {
    rooms: number
  }

  export type BuildingCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    rooms?: boolean | BuildingCountOutputTypeCountRoomsArgs
  }

  // Custom InputTypes
  /**
   * BuildingCountOutputType without action
   */
  export type BuildingCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuildingCountOutputType
     */
    select?: BuildingCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BuildingCountOutputType without action
   */
  export type BuildingCountOutputTypeCountRoomsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoomWhereInput
  }


  /**
   * Count Type RoomCountOutputType
   */

  export type RoomCountOutputType = {
    offeredCourseClassSchedules: number
  }

  export type RoomCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    offeredCourseClassSchedules?: boolean | RoomCountOutputTypeCountOfferedCourseClassSchedulesArgs
  }

  // Custom InputTypes
  /**
   * RoomCountOutputType without action
   */
  export type RoomCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomCountOutputType
     */
    select?: RoomCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RoomCountOutputType without action
   */
  export type RoomCountOutputTypeCountOfferedCourseClassSchedulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OfferedCourseClassScheduleWhereInput
  }


  /**
   * Count Type CourseCountOutputType
   */

  export type CourseCountOutputType = {
    preRequisite: number
    preRequisiteFor: number
    faculties: number
    offeredCourses: number
    studentEnrolledCourses: number
  }

  export type CourseCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    preRequisite?: boolean | CourseCountOutputTypeCountPreRequisiteArgs
    preRequisiteFor?: boolean | CourseCountOutputTypeCountPreRequisiteForArgs
    faculties?: boolean | CourseCountOutputTypeCountFacultiesArgs
    offeredCourses?: boolean | CourseCountOutputTypeCountOfferedCoursesArgs
    studentEnrolledCourses?: boolean | CourseCountOutputTypeCountStudentEnrolledCoursesArgs
  }

  // Custom InputTypes
  /**
   * CourseCountOutputType without action
   */
  export type CourseCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseCountOutputType
     */
    select?: CourseCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CourseCountOutputType without action
   */
  export type CourseCountOutputTypeCountPreRequisiteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CourseToPreRequisiteWhereInput
  }

  /**
   * CourseCountOutputType without action
   */
  export type CourseCountOutputTypeCountPreRequisiteForArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CourseToPreRequisiteWhereInput
  }

  /**
   * CourseCountOutputType without action
   */
  export type CourseCountOutputTypeCountFacultiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CourseFacultyWhereInput
  }

  /**
   * CourseCountOutputType without action
   */
  export type CourseCountOutputTypeCountOfferedCoursesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OfferedCourseWhereInput
  }

  /**
   * CourseCountOutputType without action
   */
  export type CourseCountOutputTypeCountStudentEnrolledCoursesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentEnrolledCourseWhereInput
  }


  /**
   * Count Type SemesterRegistrationCountOutputType
   */

  export type SemesterRegistrationCountOutputType = {
    offeredCourses: number
    offeredCourseSections: number
    offeredCourseClassSchedules: number
    studentSemesterRegistrations: number
    studentSemesterRegistrationCourses: number
  }

  export type SemesterRegistrationCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    offeredCourses?: boolean | SemesterRegistrationCountOutputTypeCountOfferedCoursesArgs
    offeredCourseSections?: boolean | SemesterRegistrationCountOutputTypeCountOfferedCourseSectionsArgs
    offeredCourseClassSchedules?: boolean | SemesterRegistrationCountOutputTypeCountOfferedCourseClassSchedulesArgs
    studentSemesterRegistrations?: boolean | SemesterRegistrationCountOutputTypeCountStudentSemesterRegistrationsArgs
    studentSemesterRegistrationCourses?: boolean | SemesterRegistrationCountOutputTypeCountStudentSemesterRegistrationCoursesArgs
  }

  // Custom InputTypes
  /**
   * SemesterRegistrationCountOutputType without action
   */
  export type SemesterRegistrationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SemesterRegistrationCountOutputType
     */
    select?: SemesterRegistrationCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SemesterRegistrationCountOutputType without action
   */
  export type SemesterRegistrationCountOutputTypeCountOfferedCoursesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OfferedCourseWhereInput
  }

  /**
   * SemesterRegistrationCountOutputType without action
   */
  export type SemesterRegistrationCountOutputTypeCountOfferedCourseSectionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OfferedCourseSectionWhereInput
  }

  /**
   * SemesterRegistrationCountOutputType without action
   */
  export type SemesterRegistrationCountOutputTypeCountOfferedCourseClassSchedulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OfferedCourseClassScheduleWhereInput
  }

  /**
   * SemesterRegistrationCountOutputType without action
   */
  export type SemesterRegistrationCountOutputTypeCountStudentSemesterRegistrationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentSemesterRegistrationWhereInput
  }

  /**
   * SemesterRegistrationCountOutputType without action
   */
  export type SemesterRegistrationCountOutputTypeCountStudentSemesterRegistrationCoursesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentSemesterRegistrationCourseWhereInput
  }


  /**
   * Count Type OfferedCourseCountOutputType
   */

  export type OfferedCourseCountOutputType = {
    offeredCourseSections: number
    studentSemesterRegistrationCourses: number
  }

  export type OfferedCourseCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    offeredCourseSections?: boolean | OfferedCourseCountOutputTypeCountOfferedCourseSectionsArgs
    studentSemesterRegistrationCourses?: boolean | OfferedCourseCountOutputTypeCountStudentSemesterRegistrationCoursesArgs
  }

  // Custom InputTypes
  /**
   * OfferedCourseCountOutputType without action
   */
  export type OfferedCourseCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OfferedCourseCountOutputType
     */
    select?: OfferedCourseCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * OfferedCourseCountOutputType without action
   */
  export type OfferedCourseCountOutputTypeCountOfferedCourseSectionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OfferedCourseSectionWhereInput
  }

  /**
   * OfferedCourseCountOutputType without action
   */
  export type OfferedCourseCountOutputTypeCountStudentSemesterRegistrationCoursesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentSemesterRegistrationCourseWhereInput
  }


  /**
   * Count Type OfferedCourseSectionCountOutputType
   */

  export type OfferedCourseSectionCountOutputType = {
    offeredCourseClassSchedules: number
    studentSemesterRegistrationCourses: number
  }

  export type OfferedCourseSectionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    offeredCourseClassSchedules?: boolean | OfferedCourseSectionCountOutputTypeCountOfferedCourseClassSchedulesArgs
    studentSemesterRegistrationCourses?: boolean | OfferedCourseSectionCountOutputTypeCountStudentSemesterRegistrationCoursesArgs
  }

  // Custom InputTypes
  /**
   * OfferedCourseSectionCountOutputType without action
   */
  export type OfferedCourseSectionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OfferedCourseSectionCountOutputType
     */
    select?: OfferedCourseSectionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * OfferedCourseSectionCountOutputType without action
   */
  export type OfferedCourseSectionCountOutputTypeCountOfferedCourseClassSchedulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OfferedCourseClassScheduleWhereInput
  }

  /**
   * OfferedCourseSectionCountOutputType without action
   */
  export type OfferedCourseSectionCountOutputTypeCountStudentSemesterRegistrationCoursesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentSemesterRegistrationCourseWhereInput
  }


  /**
   * Count Type StudentEnrolledCourseCountOutputType
   */

  export type StudentEnrolledCourseCountOutputType = {
    studentEnrolledCourseMarks: number
  }

  export type StudentEnrolledCourseCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    studentEnrolledCourseMarks?: boolean | StudentEnrolledCourseCountOutputTypeCountStudentEnrolledCourseMarksArgs
  }

  // Custom InputTypes
  /**
   * StudentEnrolledCourseCountOutputType without action
   */
  export type StudentEnrolledCourseCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentEnrolledCourseCountOutputType
     */
    select?: StudentEnrolledCourseCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * StudentEnrolledCourseCountOutputType without action
   */
  export type StudentEnrolledCourseCountOutputTypeCountStudentEnrolledCourseMarksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentEnrolledCourseMarkWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Users
   */

  export type AggregateUsers = {
    _count: UsersCountAggregateOutputType | null
    _min: UsersMinAggregateOutputType | null
    _max: UsersMaxAggregateOutputType | null
  }

  export type UsersMinAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    password: string | null
    avatar: string | null
    role: $Enums.UserRole | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UsersMaxAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    password: string | null
    avatar: string | null
    role: $Enums.UserRole | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UsersCountAggregateOutputType = {
    id: number
    name: number
    email: number
    password: number
    avatar: number
    role: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UsersMinAggregateInputType = {
    id?: true
    name?: true
    email?: true
    password?: true
    avatar?: true
    role?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UsersMaxAggregateInputType = {
    id?: true
    name?: true
    email?: true
    password?: true
    avatar?: true
    role?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UsersCountAggregateInputType = {
    id?: true
    name?: true
    email?: true
    password?: true
    avatar?: true
    role?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UsersAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to aggregate.
     */
    where?: UsersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UsersOrderByWithRelationInput | UsersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UsersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UsersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UsersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UsersMaxAggregateInputType
  }

  export type GetUsersAggregateType<T extends UsersAggregateArgs> = {
        [P in keyof T & keyof AggregateUsers]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUsers[P]>
      : GetScalarType<T[P], AggregateUsers[P]>
  }




  export type UsersGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UsersWhereInput
    orderBy?: UsersOrderByWithAggregationInput | UsersOrderByWithAggregationInput[]
    by: UsersScalarFieldEnum[] | UsersScalarFieldEnum
    having?: UsersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UsersCountAggregateInputType | true
    _min?: UsersMinAggregateInputType
    _max?: UsersMaxAggregateInputType
  }

  export type UsersGroupByOutputType = {
    id: string
    name: string
    email: string
    password: string
    avatar: string | null
    role: $Enums.UserRole
    createdAt: Date
    updatedAt: Date
    _count: UsersCountAggregateOutputType | null
    _min: UsersMinAggregateOutputType | null
    _max: UsersMaxAggregateOutputType | null
  }

  type GetUsersGroupByPayload<T extends UsersGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UsersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UsersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UsersGroupByOutputType[P]>
            : GetScalarType<T[P], UsersGroupByOutputType[P]>
        }
      >
    >


  export type UsersSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    password?: boolean
    avatar?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    academicDepartment?: boolean | Users$academicDepartmentArgs<ExtArgs>
    staffDepartments?: boolean | Users$staffDepartmentsArgs<ExtArgs>
    _count?: boolean | UsersCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["users"]>



  export type UsersSelectScalar = {
    id?: boolean
    name?: boolean
    email?: boolean
    password?: boolean
    avatar?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UsersOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "email" | "password" | "avatar" | "role" | "createdAt" | "updatedAt", ExtArgs["result"]["users"]>
  export type UsersInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    academicDepartment?: boolean | Users$academicDepartmentArgs<ExtArgs>
    staffDepartments?: boolean | Users$staffDepartmentsArgs<ExtArgs>
    _count?: boolean | UsersCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $UsersPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Users"
    objects: {
      academicDepartment: Prisma.$AcademicDepartmentPayload<ExtArgs> | null
      staffDepartments: Prisma.$AcademicDepartmentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      email: string
      password: string
      avatar: string | null
      role: $Enums.UserRole
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["users"]>
    composites: {}
  }

  type UsersGetPayload<S extends boolean | null | undefined | UsersDefaultArgs> = $Result.GetResult<Prisma.$UsersPayload, S>

  type UsersCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UsersFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UsersCountAggregateInputType | true
    }

  export interface UsersDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Users'], meta: { name: 'Users' } }
    /**
     * Find zero or one Users that matches the filter.
     * @param {UsersFindUniqueArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UsersFindUniqueArgs>(args: SelectSubset<T, UsersFindUniqueArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Users that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UsersFindUniqueOrThrowArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UsersFindUniqueOrThrowArgs>(args: SelectSubset<T, UsersFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersFindFirstArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UsersFindFirstArgs>(args?: SelectSubset<T, UsersFindFirstArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Users that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersFindFirstOrThrowArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UsersFindFirstOrThrowArgs>(args?: SelectSubset<T, UsersFindFirstOrThrowArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.users.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.users.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const usersWithIdOnly = await prisma.users.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UsersFindManyArgs>(args?: SelectSubset<T, UsersFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Users.
     * @param {UsersCreateArgs} args - Arguments to create a Users.
     * @example
     * // Create one Users
     * const Users = await prisma.users.create({
     *   data: {
     *     // ... data to create a Users
     *   }
     * })
     * 
     */
    create<T extends UsersCreateArgs>(args: SelectSubset<T, UsersCreateArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UsersCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const users = await prisma.users.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UsersCreateManyArgs>(args?: SelectSubset<T, UsersCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Users.
     * @param {UsersDeleteArgs} args - Arguments to delete one Users.
     * @example
     * // Delete one Users
     * const Users = await prisma.users.delete({
     *   where: {
     *     // ... filter to delete one Users
     *   }
     * })
     * 
     */
    delete<T extends UsersDeleteArgs>(args: SelectSubset<T, UsersDeleteArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Users.
     * @param {UsersUpdateArgs} args - Arguments to update one Users.
     * @example
     * // Update one Users
     * const users = await prisma.users.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UsersUpdateArgs>(args: SelectSubset<T, UsersUpdateArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UsersDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.users.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UsersDeleteManyArgs>(args?: SelectSubset<T, UsersDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const users = await prisma.users.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UsersUpdateManyArgs>(args: SelectSubset<T, UsersUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Users.
     * @param {UsersUpsertArgs} args - Arguments to update or create a Users.
     * @example
     * // Update or create a Users
     * const users = await prisma.users.upsert({
     *   create: {
     *     // ... data to create a Users
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Users we want to update
     *   }
     * })
     */
    upsert<T extends UsersUpsertArgs>(args: SelectSubset<T, UsersUpsertArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.users.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UsersCountArgs>(
      args?: Subset<T, UsersCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UsersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UsersAggregateArgs>(args: Subset<T, UsersAggregateArgs>): Prisma.PrismaPromise<GetUsersAggregateType<T>>

    /**
     * Group by Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UsersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UsersGroupByArgs['orderBy'] }
        : { orderBy?: UsersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UsersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUsersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Users model
   */
  readonly fields: UsersFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Users.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UsersClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    academicDepartment<T extends Users$academicDepartmentArgs<ExtArgs> = {}>(args?: Subset<T, Users$academicDepartmentArgs<ExtArgs>>): Prisma__AcademicDepartmentClient<$Result.GetResult<Prisma.$AcademicDepartmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    staffDepartments<T extends Users$staffDepartmentsArgs<ExtArgs> = {}>(args?: Subset<T, Users$staffDepartmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AcademicDepartmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Users model
   */
  interface UsersFieldRefs {
    readonly id: FieldRef<"Users", 'String'>
    readonly name: FieldRef<"Users", 'String'>
    readonly email: FieldRef<"Users", 'String'>
    readonly password: FieldRef<"Users", 'String'>
    readonly avatar: FieldRef<"Users", 'String'>
    readonly role: FieldRef<"Users", 'UserRole'>
    readonly createdAt: FieldRef<"Users", 'DateTime'>
    readonly updatedAt: FieldRef<"Users", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Users findUnique
   */
  export type UsersFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Users
     */
    omit?: UsersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where: UsersWhereUniqueInput
  }

  /**
   * Users findUniqueOrThrow
   */
  export type UsersFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Users
     */
    omit?: UsersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where: UsersWhereUniqueInput
  }

  /**
   * Users findFirst
   */
  export type UsersFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Users
     */
    omit?: UsersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UsersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UsersOrderByWithRelationInput | UsersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UsersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * Users findFirstOrThrow
   */
  export type UsersFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Users
     */
    omit?: UsersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UsersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UsersOrderByWithRelationInput | UsersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UsersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * Users findMany
   */
  export type UsersFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Users
     */
    omit?: UsersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UsersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UsersOrderByWithRelationInput | UsersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UsersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * Users create
   */
  export type UsersCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Users
     */
    omit?: UsersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersInclude<ExtArgs> | null
    /**
     * The data needed to create a Users.
     */
    data: XOR<UsersCreateInput, UsersUncheckedCreateInput>
  }

  /**
   * Users createMany
   */
  export type UsersCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UsersCreateManyInput | UsersCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Users update
   */
  export type UsersUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Users
     */
    omit?: UsersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersInclude<ExtArgs> | null
    /**
     * The data needed to update a Users.
     */
    data: XOR<UsersUpdateInput, UsersUncheckedUpdateInput>
    /**
     * Choose, which Users to update.
     */
    where: UsersWhereUniqueInput
  }

  /**
   * Users updateMany
   */
  export type UsersUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UsersUpdateManyMutationInput, UsersUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UsersWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * Users upsert
   */
  export type UsersUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Users
     */
    omit?: UsersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersInclude<ExtArgs> | null
    /**
     * The filter to search for the Users to update in case it exists.
     */
    where: UsersWhereUniqueInput
    /**
     * In case the Users found by the `where` argument doesn't exist, create a new Users with this data.
     */
    create: XOR<UsersCreateInput, UsersUncheckedCreateInput>
    /**
     * In case the Users was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UsersUpdateInput, UsersUncheckedUpdateInput>
  }

  /**
   * Users delete
   */
  export type UsersDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Users
     */
    omit?: UsersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersInclude<ExtArgs> | null
    /**
     * Filter which Users to delete.
     */
    where: UsersWhereUniqueInput
  }

  /**
   * Users deleteMany
   */
  export type UsersDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UsersWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * Users.academicDepartment
   */
  export type Users$academicDepartmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicDepartment
     */
    select?: AcademicDepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AcademicDepartment
     */
    omit?: AcademicDepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicDepartmentInclude<ExtArgs> | null
    where?: AcademicDepartmentWhereInput
  }

  /**
   * Users.staffDepartments
   */
  export type Users$staffDepartmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicDepartment
     */
    select?: AcademicDepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AcademicDepartment
     */
    omit?: AcademicDepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicDepartmentInclude<ExtArgs> | null
    where?: AcademicDepartmentWhereInput
    orderBy?: AcademicDepartmentOrderByWithRelationInput | AcademicDepartmentOrderByWithRelationInput[]
    cursor?: AcademicDepartmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AcademicDepartmentScalarFieldEnum | AcademicDepartmentScalarFieldEnum[]
  }

  /**
   * Users without action
   */
  export type UsersDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Users
     */
    omit?: UsersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersInclude<ExtArgs> | null
  }


  /**
   * Model AcademicSemester
   */

  export type AggregateAcademicSemester = {
    _count: AcademicSemesterCountAggregateOutputType | null
    _min: AcademicSemesterMinAggregateOutputType | null
    _max: AcademicSemesterMaxAggregateOutputType | null
  }

  export type AcademicSemesterMinAggregateOutputType = {
    id: string | null
    title: string | null
    year: string | null
    code: string | null
    startMonth: string | null
    endMonth: string | null
    isCurrent: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AcademicSemesterMaxAggregateOutputType = {
    id: string | null
    title: string | null
    year: string | null
    code: string | null
    startMonth: string | null
    endMonth: string | null
    isCurrent: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AcademicSemesterCountAggregateOutputType = {
    id: number
    title: number
    year: number
    code: number
    startMonth: number
    endMonth: number
    isCurrent: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AcademicSemesterMinAggregateInputType = {
    id?: true
    title?: true
    year?: true
    code?: true
    startMonth?: true
    endMonth?: true
    isCurrent?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AcademicSemesterMaxAggregateInputType = {
    id?: true
    title?: true
    year?: true
    code?: true
    startMonth?: true
    endMonth?: true
    isCurrent?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AcademicSemesterCountAggregateInputType = {
    id?: true
    title?: true
    year?: true
    code?: true
    startMonth?: true
    endMonth?: true
    isCurrent?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AcademicSemesterAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AcademicSemester to aggregate.
     */
    where?: AcademicSemesterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AcademicSemesters to fetch.
     */
    orderBy?: AcademicSemesterOrderByWithRelationInput | AcademicSemesterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AcademicSemesterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AcademicSemesters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AcademicSemesters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AcademicSemesters
    **/
    _count?: true | AcademicSemesterCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AcademicSemesterMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AcademicSemesterMaxAggregateInputType
  }

  export type GetAcademicSemesterAggregateType<T extends AcademicSemesterAggregateArgs> = {
        [P in keyof T & keyof AggregateAcademicSemester]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAcademicSemester[P]>
      : GetScalarType<T[P], AggregateAcademicSemester[P]>
  }




  export type AcademicSemesterGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AcademicSemesterWhereInput
    orderBy?: AcademicSemesterOrderByWithAggregationInput | AcademicSemesterOrderByWithAggregationInput[]
    by: AcademicSemesterScalarFieldEnum[] | AcademicSemesterScalarFieldEnum
    having?: AcademicSemesterScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AcademicSemesterCountAggregateInputType | true
    _min?: AcademicSemesterMinAggregateInputType
    _max?: AcademicSemesterMaxAggregateInputType
  }

  export type AcademicSemesterGroupByOutputType = {
    id: string
    title: string
    year: string
    code: string
    startMonth: string
    endMonth: string
    isCurrent: boolean
    createdAt: Date
    updatedAt: Date
    _count: AcademicSemesterCountAggregateOutputType | null
    _min: AcademicSemesterMinAggregateOutputType | null
    _max: AcademicSemesterMaxAggregateOutputType | null
  }

  type GetAcademicSemesterGroupByPayload<T extends AcademicSemesterGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AcademicSemesterGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AcademicSemesterGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AcademicSemesterGroupByOutputType[P]>
            : GetScalarType<T[P], AcademicSemesterGroupByOutputType[P]>
        }
      >
    >


  export type AcademicSemesterSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    year?: boolean
    code?: boolean
    startMonth?: boolean
    endMonth?: boolean
    isCurrent?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    semesterRegistrations?: boolean | AcademicSemester$semesterRegistrationsArgs<ExtArgs>
    students?: boolean | AcademicSemester$studentsArgs<ExtArgs>
    studentEnrolledCourses?: boolean | AcademicSemester$studentEnrolledCoursesArgs<ExtArgs>
    studentEnrolledCourseMarks?: boolean | AcademicSemester$studentEnrolledCourseMarksArgs<ExtArgs>
    studentSemesterPayments?: boolean | AcademicSemester$studentSemesterPaymentsArgs<ExtArgs>
    _count?: boolean | AcademicSemesterCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["academicSemester"]>



  export type AcademicSemesterSelectScalar = {
    id?: boolean
    title?: boolean
    year?: boolean
    code?: boolean
    startMonth?: boolean
    endMonth?: boolean
    isCurrent?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AcademicSemesterOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "year" | "code" | "startMonth" | "endMonth" | "isCurrent" | "createdAt" | "updatedAt", ExtArgs["result"]["academicSemester"]>
  export type AcademicSemesterInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    semesterRegistrations?: boolean | AcademicSemester$semesterRegistrationsArgs<ExtArgs>
    students?: boolean | AcademicSemester$studentsArgs<ExtArgs>
    studentEnrolledCourses?: boolean | AcademicSemester$studentEnrolledCoursesArgs<ExtArgs>
    studentEnrolledCourseMarks?: boolean | AcademicSemester$studentEnrolledCourseMarksArgs<ExtArgs>
    studentSemesterPayments?: boolean | AcademicSemester$studentSemesterPaymentsArgs<ExtArgs>
    _count?: boolean | AcademicSemesterCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $AcademicSemesterPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AcademicSemester"
    objects: {
      semesterRegistrations: Prisma.$SemesterRegistrationPayload<ExtArgs>[]
      students: Prisma.$StudentPayload<ExtArgs> | null
      studentEnrolledCourses: Prisma.$StudentEnrolledCoursePayload<ExtArgs>[]
      studentEnrolledCourseMarks: Prisma.$StudentEnrolledCourseMarkPayload<ExtArgs>[]
      studentSemesterPayments: Prisma.$StudentSemesterPaymentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      year: string
      code: string
      startMonth: string
      endMonth: string
      isCurrent: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["academicSemester"]>
    composites: {}
  }

  type AcademicSemesterGetPayload<S extends boolean | null | undefined | AcademicSemesterDefaultArgs> = $Result.GetResult<Prisma.$AcademicSemesterPayload, S>

  type AcademicSemesterCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AcademicSemesterFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AcademicSemesterCountAggregateInputType | true
    }

  export interface AcademicSemesterDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AcademicSemester'], meta: { name: 'AcademicSemester' } }
    /**
     * Find zero or one AcademicSemester that matches the filter.
     * @param {AcademicSemesterFindUniqueArgs} args - Arguments to find a AcademicSemester
     * @example
     * // Get one AcademicSemester
     * const academicSemester = await prisma.academicSemester.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AcademicSemesterFindUniqueArgs>(args: SelectSubset<T, AcademicSemesterFindUniqueArgs<ExtArgs>>): Prisma__AcademicSemesterClient<$Result.GetResult<Prisma.$AcademicSemesterPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AcademicSemester that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AcademicSemesterFindUniqueOrThrowArgs} args - Arguments to find a AcademicSemester
     * @example
     * // Get one AcademicSemester
     * const academicSemester = await prisma.academicSemester.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AcademicSemesterFindUniqueOrThrowArgs>(args: SelectSubset<T, AcademicSemesterFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AcademicSemesterClient<$Result.GetResult<Prisma.$AcademicSemesterPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AcademicSemester that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AcademicSemesterFindFirstArgs} args - Arguments to find a AcademicSemester
     * @example
     * // Get one AcademicSemester
     * const academicSemester = await prisma.academicSemester.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AcademicSemesterFindFirstArgs>(args?: SelectSubset<T, AcademicSemesterFindFirstArgs<ExtArgs>>): Prisma__AcademicSemesterClient<$Result.GetResult<Prisma.$AcademicSemesterPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AcademicSemester that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AcademicSemesterFindFirstOrThrowArgs} args - Arguments to find a AcademicSemester
     * @example
     * // Get one AcademicSemester
     * const academicSemester = await prisma.academicSemester.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AcademicSemesterFindFirstOrThrowArgs>(args?: SelectSubset<T, AcademicSemesterFindFirstOrThrowArgs<ExtArgs>>): Prisma__AcademicSemesterClient<$Result.GetResult<Prisma.$AcademicSemesterPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AcademicSemesters that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AcademicSemesterFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AcademicSemesters
     * const academicSemesters = await prisma.academicSemester.findMany()
     * 
     * // Get first 10 AcademicSemesters
     * const academicSemesters = await prisma.academicSemester.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const academicSemesterWithIdOnly = await prisma.academicSemester.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AcademicSemesterFindManyArgs>(args?: SelectSubset<T, AcademicSemesterFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AcademicSemesterPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AcademicSemester.
     * @param {AcademicSemesterCreateArgs} args - Arguments to create a AcademicSemester.
     * @example
     * // Create one AcademicSemester
     * const AcademicSemester = await prisma.academicSemester.create({
     *   data: {
     *     // ... data to create a AcademicSemester
     *   }
     * })
     * 
     */
    create<T extends AcademicSemesterCreateArgs>(args: SelectSubset<T, AcademicSemesterCreateArgs<ExtArgs>>): Prisma__AcademicSemesterClient<$Result.GetResult<Prisma.$AcademicSemesterPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AcademicSemesters.
     * @param {AcademicSemesterCreateManyArgs} args - Arguments to create many AcademicSemesters.
     * @example
     * // Create many AcademicSemesters
     * const academicSemester = await prisma.academicSemester.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AcademicSemesterCreateManyArgs>(args?: SelectSubset<T, AcademicSemesterCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a AcademicSemester.
     * @param {AcademicSemesterDeleteArgs} args - Arguments to delete one AcademicSemester.
     * @example
     * // Delete one AcademicSemester
     * const AcademicSemester = await prisma.academicSemester.delete({
     *   where: {
     *     // ... filter to delete one AcademicSemester
     *   }
     * })
     * 
     */
    delete<T extends AcademicSemesterDeleteArgs>(args: SelectSubset<T, AcademicSemesterDeleteArgs<ExtArgs>>): Prisma__AcademicSemesterClient<$Result.GetResult<Prisma.$AcademicSemesterPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AcademicSemester.
     * @param {AcademicSemesterUpdateArgs} args - Arguments to update one AcademicSemester.
     * @example
     * // Update one AcademicSemester
     * const academicSemester = await prisma.academicSemester.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AcademicSemesterUpdateArgs>(args: SelectSubset<T, AcademicSemesterUpdateArgs<ExtArgs>>): Prisma__AcademicSemesterClient<$Result.GetResult<Prisma.$AcademicSemesterPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AcademicSemesters.
     * @param {AcademicSemesterDeleteManyArgs} args - Arguments to filter AcademicSemesters to delete.
     * @example
     * // Delete a few AcademicSemesters
     * const { count } = await prisma.academicSemester.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AcademicSemesterDeleteManyArgs>(args?: SelectSubset<T, AcademicSemesterDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AcademicSemesters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AcademicSemesterUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AcademicSemesters
     * const academicSemester = await prisma.academicSemester.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AcademicSemesterUpdateManyArgs>(args: SelectSubset<T, AcademicSemesterUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AcademicSemester.
     * @param {AcademicSemesterUpsertArgs} args - Arguments to update or create a AcademicSemester.
     * @example
     * // Update or create a AcademicSemester
     * const academicSemester = await prisma.academicSemester.upsert({
     *   create: {
     *     // ... data to create a AcademicSemester
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AcademicSemester we want to update
     *   }
     * })
     */
    upsert<T extends AcademicSemesterUpsertArgs>(args: SelectSubset<T, AcademicSemesterUpsertArgs<ExtArgs>>): Prisma__AcademicSemesterClient<$Result.GetResult<Prisma.$AcademicSemesterPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AcademicSemesters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AcademicSemesterCountArgs} args - Arguments to filter AcademicSemesters to count.
     * @example
     * // Count the number of AcademicSemesters
     * const count = await prisma.academicSemester.count({
     *   where: {
     *     // ... the filter for the AcademicSemesters we want to count
     *   }
     * })
    **/
    count<T extends AcademicSemesterCountArgs>(
      args?: Subset<T, AcademicSemesterCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AcademicSemesterCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AcademicSemester.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AcademicSemesterAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AcademicSemesterAggregateArgs>(args: Subset<T, AcademicSemesterAggregateArgs>): Prisma.PrismaPromise<GetAcademicSemesterAggregateType<T>>

    /**
     * Group by AcademicSemester.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AcademicSemesterGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AcademicSemesterGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AcademicSemesterGroupByArgs['orderBy'] }
        : { orderBy?: AcademicSemesterGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AcademicSemesterGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAcademicSemesterGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AcademicSemester model
   */
  readonly fields: AcademicSemesterFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AcademicSemester.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AcademicSemesterClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    semesterRegistrations<T extends AcademicSemester$semesterRegistrationsArgs<ExtArgs> = {}>(args?: Subset<T, AcademicSemester$semesterRegistrationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SemesterRegistrationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    students<T extends AcademicSemester$studentsArgs<ExtArgs> = {}>(args?: Subset<T, AcademicSemester$studentsArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    studentEnrolledCourses<T extends AcademicSemester$studentEnrolledCoursesArgs<ExtArgs> = {}>(args?: Subset<T, AcademicSemester$studentEnrolledCoursesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentEnrolledCoursePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    studentEnrolledCourseMarks<T extends AcademicSemester$studentEnrolledCourseMarksArgs<ExtArgs> = {}>(args?: Subset<T, AcademicSemester$studentEnrolledCourseMarksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentEnrolledCourseMarkPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    studentSemesterPayments<T extends AcademicSemester$studentSemesterPaymentsArgs<ExtArgs> = {}>(args?: Subset<T, AcademicSemester$studentSemesterPaymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentSemesterPaymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AcademicSemester model
   */
  interface AcademicSemesterFieldRefs {
    readonly id: FieldRef<"AcademicSemester", 'String'>
    readonly title: FieldRef<"AcademicSemester", 'String'>
    readonly year: FieldRef<"AcademicSemester", 'String'>
    readonly code: FieldRef<"AcademicSemester", 'String'>
    readonly startMonth: FieldRef<"AcademicSemester", 'String'>
    readonly endMonth: FieldRef<"AcademicSemester", 'String'>
    readonly isCurrent: FieldRef<"AcademicSemester", 'Boolean'>
    readonly createdAt: FieldRef<"AcademicSemester", 'DateTime'>
    readonly updatedAt: FieldRef<"AcademicSemester", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AcademicSemester findUnique
   */
  export type AcademicSemesterFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicSemester
     */
    select?: AcademicSemesterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AcademicSemester
     */
    omit?: AcademicSemesterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicSemesterInclude<ExtArgs> | null
    /**
     * Filter, which AcademicSemester to fetch.
     */
    where: AcademicSemesterWhereUniqueInput
  }

  /**
   * AcademicSemester findUniqueOrThrow
   */
  export type AcademicSemesterFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicSemester
     */
    select?: AcademicSemesterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AcademicSemester
     */
    omit?: AcademicSemesterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicSemesterInclude<ExtArgs> | null
    /**
     * Filter, which AcademicSemester to fetch.
     */
    where: AcademicSemesterWhereUniqueInput
  }

  /**
   * AcademicSemester findFirst
   */
  export type AcademicSemesterFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicSemester
     */
    select?: AcademicSemesterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AcademicSemester
     */
    omit?: AcademicSemesterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicSemesterInclude<ExtArgs> | null
    /**
     * Filter, which AcademicSemester to fetch.
     */
    where?: AcademicSemesterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AcademicSemesters to fetch.
     */
    orderBy?: AcademicSemesterOrderByWithRelationInput | AcademicSemesterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AcademicSemesters.
     */
    cursor?: AcademicSemesterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AcademicSemesters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AcademicSemesters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AcademicSemesters.
     */
    distinct?: AcademicSemesterScalarFieldEnum | AcademicSemesterScalarFieldEnum[]
  }

  /**
   * AcademicSemester findFirstOrThrow
   */
  export type AcademicSemesterFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicSemester
     */
    select?: AcademicSemesterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AcademicSemester
     */
    omit?: AcademicSemesterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicSemesterInclude<ExtArgs> | null
    /**
     * Filter, which AcademicSemester to fetch.
     */
    where?: AcademicSemesterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AcademicSemesters to fetch.
     */
    orderBy?: AcademicSemesterOrderByWithRelationInput | AcademicSemesterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AcademicSemesters.
     */
    cursor?: AcademicSemesterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AcademicSemesters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AcademicSemesters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AcademicSemesters.
     */
    distinct?: AcademicSemesterScalarFieldEnum | AcademicSemesterScalarFieldEnum[]
  }

  /**
   * AcademicSemester findMany
   */
  export type AcademicSemesterFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicSemester
     */
    select?: AcademicSemesterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AcademicSemester
     */
    omit?: AcademicSemesterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicSemesterInclude<ExtArgs> | null
    /**
     * Filter, which AcademicSemesters to fetch.
     */
    where?: AcademicSemesterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AcademicSemesters to fetch.
     */
    orderBy?: AcademicSemesterOrderByWithRelationInput | AcademicSemesterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AcademicSemesters.
     */
    cursor?: AcademicSemesterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AcademicSemesters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AcademicSemesters.
     */
    skip?: number
    distinct?: AcademicSemesterScalarFieldEnum | AcademicSemesterScalarFieldEnum[]
  }

  /**
   * AcademicSemester create
   */
  export type AcademicSemesterCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicSemester
     */
    select?: AcademicSemesterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AcademicSemester
     */
    omit?: AcademicSemesterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicSemesterInclude<ExtArgs> | null
    /**
     * The data needed to create a AcademicSemester.
     */
    data: XOR<AcademicSemesterCreateInput, AcademicSemesterUncheckedCreateInput>
  }

  /**
   * AcademicSemester createMany
   */
  export type AcademicSemesterCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AcademicSemesters.
     */
    data: AcademicSemesterCreateManyInput | AcademicSemesterCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AcademicSemester update
   */
  export type AcademicSemesterUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicSemester
     */
    select?: AcademicSemesterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AcademicSemester
     */
    omit?: AcademicSemesterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicSemesterInclude<ExtArgs> | null
    /**
     * The data needed to update a AcademicSemester.
     */
    data: XOR<AcademicSemesterUpdateInput, AcademicSemesterUncheckedUpdateInput>
    /**
     * Choose, which AcademicSemester to update.
     */
    where: AcademicSemesterWhereUniqueInput
  }

  /**
   * AcademicSemester updateMany
   */
  export type AcademicSemesterUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AcademicSemesters.
     */
    data: XOR<AcademicSemesterUpdateManyMutationInput, AcademicSemesterUncheckedUpdateManyInput>
    /**
     * Filter which AcademicSemesters to update
     */
    where?: AcademicSemesterWhereInput
    /**
     * Limit how many AcademicSemesters to update.
     */
    limit?: number
  }

  /**
   * AcademicSemester upsert
   */
  export type AcademicSemesterUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicSemester
     */
    select?: AcademicSemesterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AcademicSemester
     */
    omit?: AcademicSemesterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicSemesterInclude<ExtArgs> | null
    /**
     * The filter to search for the AcademicSemester to update in case it exists.
     */
    where: AcademicSemesterWhereUniqueInput
    /**
     * In case the AcademicSemester found by the `where` argument doesn't exist, create a new AcademicSemester with this data.
     */
    create: XOR<AcademicSemesterCreateInput, AcademicSemesterUncheckedCreateInput>
    /**
     * In case the AcademicSemester was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AcademicSemesterUpdateInput, AcademicSemesterUncheckedUpdateInput>
  }

  /**
   * AcademicSemester delete
   */
  export type AcademicSemesterDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicSemester
     */
    select?: AcademicSemesterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AcademicSemester
     */
    omit?: AcademicSemesterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicSemesterInclude<ExtArgs> | null
    /**
     * Filter which AcademicSemester to delete.
     */
    where: AcademicSemesterWhereUniqueInput
  }

  /**
   * AcademicSemester deleteMany
   */
  export type AcademicSemesterDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AcademicSemesters to delete
     */
    where?: AcademicSemesterWhereInput
    /**
     * Limit how many AcademicSemesters to delete.
     */
    limit?: number
  }

  /**
   * AcademicSemester.semesterRegistrations
   */
  export type AcademicSemester$semesterRegistrationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SemesterRegistration
     */
    select?: SemesterRegistrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SemesterRegistration
     */
    omit?: SemesterRegistrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SemesterRegistrationInclude<ExtArgs> | null
    where?: SemesterRegistrationWhereInput
    orderBy?: SemesterRegistrationOrderByWithRelationInput | SemesterRegistrationOrderByWithRelationInput[]
    cursor?: SemesterRegistrationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SemesterRegistrationScalarFieldEnum | SemesterRegistrationScalarFieldEnum[]
  }

  /**
   * AcademicSemester.students
   */
  export type AcademicSemester$studentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Student
     */
    omit?: StudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    where?: StudentWhereInput
  }

  /**
   * AcademicSemester.studentEnrolledCourses
   */
  export type AcademicSemester$studentEnrolledCoursesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentEnrolledCourse
     */
    select?: StudentEnrolledCourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentEnrolledCourse
     */
    omit?: StudentEnrolledCourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentEnrolledCourseInclude<ExtArgs> | null
    where?: StudentEnrolledCourseWhereInput
    orderBy?: StudentEnrolledCourseOrderByWithRelationInput | StudentEnrolledCourseOrderByWithRelationInput[]
    cursor?: StudentEnrolledCourseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StudentEnrolledCourseScalarFieldEnum | StudentEnrolledCourseScalarFieldEnum[]
  }

  /**
   * AcademicSemester.studentEnrolledCourseMarks
   */
  export type AcademicSemester$studentEnrolledCourseMarksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentEnrolledCourseMark
     */
    select?: StudentEnrolledCourseMarkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentEnrolledCourseMark
     */
    omit?: StudentEnrolledCourseMarkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentEnrolledCourseMarkInclude<ExtArgs> | null
    where?: StudentEnrolledCourseMarkWhereInput
    orderBy?: StudentEnrolledCourseMarkOrderByWithRelationInput | StudentEnrolledCourseMarkOrderByWithRelationInput[]
    cursor?: StudentEnrolledCourseMarkWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StudentEnrolledCourseMarkScalarFieldEnum | StudentEnrolledCourseMarkScalarFieldEnum[]
  }

  /**
   * AcademicSemester.studentSemesterPayments
   */
  export type AcademicSemester$studentSemesterPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentSemesterPayment
     */
    select?: StudentSemesterPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentSemesterPayment
     */
    omit?: StudentSemesterPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentSemesterPaymentInclude<ExtArgs> | null
    where?: StudentSemesterPaymentWhereInput
    orderBy?: StudentSemesterPaymentOrderByWithRelationInput | StudentSemesterPaymentOrderByWithRelationInput[]
    cursor?: StudentSemesterPaymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StudentSemesterPaymentScalarFieldEnum | StudentSemesterPaymentScalarFieldEnum[]
  }

  /**
   * AcademicSemester without action
   */
  export type AcademicSemesterDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicSemester
     */
    select?: AcademicSemesterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AcademicSemester
     */
    omit?: AcademicSemesterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicSemesterInclude<ExtArgs> | null
  }


  /**
   * Model AcademicFaculty
   */

  export type AggregateAcademicFaculty = {
    _count: AcademicFacultyCountAggregateOutputType | null
    _min: AcademicFacultyMinAggregateOutputType | null
    _max: AcademicFacultyMaxAggregateOutputType | null
  }

  export type AcademicFacultyMinAggregateOutputType = {
    id: string | null
    title: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AcademicFacultyMaxAggregateOutputType = {
    id: string | null
    title: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AcademicFacultyCountAggregateOutputType = {
    id: number
    title: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AcademicFacultyMinAggregateInputType = {
    id?: true
    title?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AcademicFacultyMaxAggregateInputType = {
    id?: true
    title?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AcademicFacultyCountAggregateInputType = {
    id?: true
    title?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AcademicFacultyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AcademicFaculty to aggregate.
     */
    where?: AcademicFacultyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AcademicFaculties to fetch.
     */
    orderBy?: AcademicFacultyOrderByWithRelationInput | AcademicFacultyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AcademicFacultyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AcademicFaculties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AcademicFaculties.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AcademicFaculties
    **/
    _count?: true | AcademicFacultyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AcademicFacultyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AcademicFacultyMaxAggregateInputType
  }

  export type GetAcademicFacultyAggregateType<T extends AcademicFacultyAggregateArgs> = {
        [P in keyof T & keyof AggregateAcademicFaculty]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAcademicFaculty[P]>
      : GetScalarType<T[P], AggregateAcademicFaculty[P]>
  }




  export type AcademicFacultyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AcademicFacultyWhereInput
    orderBy?: AcademicFacultyOrderByWithAggregationInput | AcademicFacultyOrderByWithAggregationInput[]
    by: AcademicFacultyScalarFieldEnum[] | AcademicFacultyScalarFieldEnum
    having?: AcademicFacultyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AcademicFacultyCountAggregateInputType | true
    _min?: AcademicFacultyMinAggregateInputType
    _max?: AcademicFacultyMaxAggregateInputType
  }

  export type AcademicFacultyGroupByOutputType = {
    id: string
    title: string
    createdAt: Date
    updatedAt: Date
    _count: AcademicFacultyCountAggregateOutputType | null
    _min: AcademicFacultyMinAggregateOutputType | null
    _max: AcademicFacultyMaxAggregateOutputType | null
  }

  type GetAcademicFacultyGroupByPayload<T extends AcademicFacultyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AcademicFacultyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AcademicFacultyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AcademicFacultyGroupByOutputType[P]>
            : GetScalarType<T[P], AcademicFacultyGroupByOutputType[P]>
        }
      >
    >


  export type AcademicFacultySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    academicDepartments?: boolean | AcademicFaculty$academicDepartmentsArgs<ExtArgs>
    faculties?: boolean | AcademicFaculty$facultiesArgs<ExtArgs>
    students?: boolean | AcademicFaculty$studentsArgs<ExtArgs>
  }, ExtArgs["result"]["academicFaculty"]>



  export type AcademicFacultySelectScalar = {
    id?: boolean
    title?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AcademicFacultyOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "createdAt" | "updatedAt", ExtArgs["result"]["academicFaculty"]>
  export type AcademicFacultyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    academicDepartments?: boolean | AcademicFaculty$academicDepartmentsArgs<ExtArgs>
    faculties?: boolean | AcademicFaculty$facultiesArgs<ExtArgs>
    students?: boolean | AcademicFaculty$studentsArgs<ExtArgs>
  }

  export type $AcademicFacultyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AcademicFaculty"
    objects: {
      academicDepartments: Prisma.$AcademicDepartmentPayload<ExtArgs> | null
      faculties: Prisma.$FacultyPayload<ExtArgs> | null
      students: Prisma.$StudentPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["academicFaculty"]>
    composites: {}
  }

  type AcademicFacultyGetPayload<S extends boolean | null | undefined | AcademicFacultyDefaultArgs> = $Result.GetResult<Prisma.$AcademicFacultyPayload, S>

  type AcademicFacultyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AcademicFacultyFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AcademicFacultyCountAggregateInputType | true
    }

  export interface AcademicFacultyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AcademicFaculty'], meta: { name: 'AcademicFaculty' } }
    /**
     * Find zero or one AcademicFaculty that matches the filter.
     * @param {AcademicFacultyFindUniqueArgs} args - Arguments to find a AcademicFaculty
     * @example
     * // Get one AcademicFaculty
     * const academicFaculty = await prisma.academicFaculty.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AcademicFacultyFindUniqueArgs>(args: SelectSubset<T, AcademicFacultyFindUniqueArgs<ExtArgs>>): Prisma__AcademicFacultyClient<$Result.GetResult<Prisma.$AcademicFacultyPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AcademicFaculty that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AcademicFacultyFindUniqueOrThrowArgs} args - Arguments to find a AcademicFaculty
     * @example
     * // Get one AcademicFaculty
     * const academicFaculty = await prisma.academicFaculty.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AcademicFacultyFindUniqueOrThrowArgs>(args: SelectSubset<T, AcademicFacultyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AcademicFacultyClient<$Result.GetResult<Prisma.$AcademicFacultyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AcademicFaculty that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AcademicFacultyFindFirstArgs} args - Arguments to find a AcademicFaculty
     * @example
     * // Get one AcademicFaculty
     * const academicFaculty = await prisma.academicFaculty.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AcademicFacultyFindFirstArgs>(args?: SelectSubset<T, AcademicFacultyFindFirstArgs<ExtArgs>>): Prisma__AcademicFacultyClient<$Result.GetResult<Prisma.$AcademicFacultyPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AcademicFaculty that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AcademicFacultyFindFirstOrThrowArgs} args - Arguments to find a AcademicFaculty
     * @example
     * // Get one AcademicFaculty
     * const academicFaculty = await prisma.academicFaculty.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AcademicFacultyFindFirstOrThrowArgs>(args?: SelectSubset<T, AcademicFacultyFindFirstOrThrowArgs<ExtArgs>>): Prisma__AcademicFacultyClient<$Result.GetResult<Prisma.$AcademicFacultyPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AcademicFaculties that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AcademicFacultyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AcademicFaculties
     * const academicFaculties = await prisma.academicFaculty.findMany()
     * 
     * // Get first 10 AcademicFaculties
     * const academicFaculties = await prisma.academicFaculty.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const academicFacultyWithIdOnly = await prisma.academicFaculty.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AcademicFacultyFindManyArgs>(args?: SelectSubset<T, AcademicFacultyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AcademicFacultyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AcademicFaculty.
     * @param {AcademicFacultyCreateArgs} args - Arguments to create a AcademicFaculty.
     * @example
     * // Create one AcademicFaculty
     * const AcademicFaculty = await prisma.academicFaculty.create({
     *   data: {
     *     // ... data to create a AcademicFaculty
     *   }
     * })
     * 
     */
    create<T extends AcademicFacultyCreateArgs>(args: SelectSubset<T, AcademicFacultyCreateArgs<ExtArgs>>): Prisma__AcademicFacultyClient<$Result.GetResult<Prisma.$AcademicFacultyPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AcademicFaculties.
     * @param {AcademicFacultyCreateManyArgs} args - Arguments to create many AcademicFaculties.
     * @example
     * // Create many AcademicFaculties
     * const academicFaculty = await prisma.academicFaculty.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AcademicFacultyCreateManyArgs>(args?: SelectSubset<T, AcademicFacultyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a AcademicFaculty.
     * @param {AcademicFacultyDeleteArgs} args - Arguments to delete one AcademicFaculty.
     * @example
     * // Delete one AcademicFaculty
     * const AcademicFaculty = await prisma.academicFaculty.delete({
     *   where: {
     *     // ... filter to delete one AcademicFaculty
     *   }
     * })
     * 
     */
    delete<T extends AcademicFacultyDeleteArgs>(args: SelectSubset<T, AcademicFacultyDeleteArgs<ExtArgs>>): Prisma__AcademicFacultyClient<$Result.GetResult<Prisma.$AcademicFacultyPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AcademicFaculty.
     * @param {AcademicFacultyUpdateArgs} args - Arguments to update one AcademicFaculty.
     * @example
     * // Update one AcademicFaculty
     * const academicFaculty = await prisma.academicFaculty.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AcademicFacultyUpdateArgs>(args: SelectSubset<T, AcademicFacultyUpdateArgs<ExtArgs>>): Prisma__AcademicFacultyClient<$Result.GetResult<Prisma.$AcademicFacultyPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AcademicFaculties.
     * @param {AcademicFacultyDeleteManyArgs} args - Arguments to filter AcademicFaculties to delete.
     * @example
     * // Delete a few AcademicFaculties
     * const { count } = await prisma.academicFaculty.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AcademicFacultyDeleteManyArgs>(args?: SelectSubset<T, AcademicFacultyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AcademicFaculties.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AcademicFacultyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AcademicFaculties
     * const academicFaculty = await prisma.academicFaculty.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AcademicFacultyUpdateManyArgs>(args: SelectSubset<T, AcademicFacultyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AcademicFaculty.
     * @param {AcademicFacultyUpsertArgs} args - Arguments to update or create a AcademicFaculty.
     * @example
     * // Update or create a AcademicFaculty
     * const academicFaculty = await prisma.academicFaculty.upsert({
     *   create: {
     *     // ... data to create a AcademicFaculty
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AcademicFaculty we want to update
     *   }
     * })
     */
    upsert<T extends AcademicFacultyUpsertArgs>(args: SelectSubset<T, AcademicFacultyUpsertArgs<ExtArgs>>): Prisma__AcademicFacultyClient<$Result.GetResult<Prisma.$AcademicFacultyPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AcademicFaculties.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AcademicFacultyCountArgs} args - Arguments to filter AcademicFaculties to count.
     * @example
     * // Count the number of AcademicFaculties
     * const count = await prisma.academicFaculty.count({
     *   where: {
     *     // ... the filter for the AcademicFaculties we want to count
     *   }
     * })
    **/
    count<T extends AcademicFacultyCountArgs>(
      args?: Subset<T, AcademicFacultyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AcademicFacultyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AcademicFaculty.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AcademicFacultyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AcademicFacultyAggregateArgs>(args: Subset<T, AcademicFacultyAggregateArgs>): Prisma.PrismaPromise<GetAcademicFacultyAggregateType<T>>

    /**
     * Group by AcademicFaculty.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AcademicFacultyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AcademicFacultyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AcademicFacultyGroupByArgs['orderBy'] }
        : { orderBy?: AcademicFacultyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AcademicFacultyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAcademicFacultyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AcademicFaculty model
   */
  readonly fields: AcademicFacultyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AcademicFaculty.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AcademicFacultyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    academicDepartments<T extends AcademicFaculty$academicDepartmentsArgs<ExtArgs> = {}>(args?: Subset<T, AcademicFaculty$academicDepartmentsArgs<ExtArgs>>): Prisma__AcademicDepartmentClient<$Result.GetResult<Prisma.$AcademicDepartmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    faculties<T extends AcademicFaculty$facultiesArgs<ExtArgs> = {}>(args?: Subset<T, AcademicFaculty$facultiesArgs<ExtArgs>>): Prisma__FacultyClient<$Result.GetResult<Prisma.$FacultyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    students<T extends AcademicFaculty$studentsArgs<ExtArgs> = {}>(args?: Subset<T, AcademicFaculty$studentsArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AcademicFaculty model
   */
  interface AcademicFacultyFieldRefs {
    readonly id: FieldRef<"AcademicFaculty", 'String'>
    readonly title: FieldRef<"AcademicFaculty", 'String'>
    readonly createdAt: FieldRef<"AcademicFaculty", 'DateTime'>
    readonly updatedAt: FieldRef<"AcademicFaculty", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AcademicFaculty findUnique
   */
  export type AcademicFacultyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicFaculty
     */
    select?: AcademicFacultySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AcademicFaculty
     */
    omit?: AcademicFacultyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicFacultyInclude<ExtArgs> | null
    /**
     * Filter, which AcademicFaculty to fetch.
     */
    where: AcademicFacultyWhereUniqueInput
  }

  /**
   * AcademicFaculty findUniqueOrThrow
   */
  export type AcademicFacultyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicFaculty
     */
    select?: AcademicFacultySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AcademicFaculty
     */
    omit?: AcademicFacultyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicFacultyInclude<ExtArgs> | null
    /**
     * Filter, which AcademicFaculty to fetch.
     */
    where: AcademicFacultyWhereUniqueInput
  }

  /**
   * AcademicFaculty findFirst
   */
  export type AcademicFacultyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicFaculty
     */
    select?: AcademicFacultySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AcademicFaculty
     */
    omit?: AcademicFacultyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicFacultyInclude<ExtArgs> | null
    /**
     * Filter, which AcademicFaculty to fetch.
     */
    where?: AcademicFacultyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AcademicFaculties to fetch.
     */
    orderBy?: AcademicFacultyOrderByWithRelationInput | AcademicFacultyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AcademicFaculties.
     */
    cursor?: AcademicFacultyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AcademicFaculties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AcademicFaculties.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AcademicFaculties.
     */
    distinct?: AcademicFacultyScalarFieldEnum | AcademicFacultyScalarFieldEnum[]
  }

  /**
   * AcademicFaculty findFirstOrThrow
   */
  export type AcademicFacultyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicFaculty
     */
    select?: AcademicFacultySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AcademicFaculty
     */
    omit?: AcademicFacultyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicFacultyInclude<ExtArgs> | null
    /**
     * Filter, which AcademicFaculty to fetch.
     */
    where?: AcademicFacultyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AcademicFaculties to fetch.
     */
    orderBy?: AcademicFacultyOrderByWithRelationInput | AcademicFacultyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AcademicFaculties.
     */
    cursor?: AcademicFacultyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AcademicFaculties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AcademicFaculties.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AcademicFaculties.
     */
    distinct?: AcademicFacultyScalarFieldEnum | AcademicFacultyScalarFieldEnum[]
  }

  /**
   * AcademicFaculty findMany
   */
  export type AcademicFacultyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicFaculty
     */
    select?: AcademicFacultySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AcademicFaculty
     */
    omit?: AcademicFacultyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicFacultyInclude<ExtArgs> | null
    /**
     * Filter, which AcademicFaculties to fetch.
     */
    where?: AcademicFacultyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AcademicFaculties to fetch.
     */
    orderBy?: AcademicFacultyOrderByWithRelationInput | AcademicFacultyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AcademicFaculties.
     */
    cursor?: AcademicFacultyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AcademicFaculties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AcademicFaculties.
     */
    skip?: number
    distinct?: AcademicFacultyScalarFieldEnum | AcademicFacultyScalarFieldEnum[]
  }

  /**
   * AcademicFaculty create
   */
  export type AcademicFacultyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicFaculty
     */
    select?: AcademicFacultySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AcademicFaculty
     */
    omit?: AcademicFacultyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicFacultyInclude<ExtArgs> | null
    /**
     * The data needed to create a AcademicFaculty.
     */
    data: XOR<AcademicFacultyCreateInput, AcademicFacultyUncheckedCreateInput>
  }

  /**
   * AcademicFaculty createMany
   */
  export type AcademicFacultyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AcademicFaculties.
     */
    data: AcademicFacultyCreateManyInput | AcademicFacultyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AcademicFaculty update
   */
  export type AcademicFacultyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicFaculty
     */
    select?: AcademicFacultySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AcademicFaculty
     */
    omit?: AcademicFacultyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicFacultyInclude<ExtArgs> | null
    /**
     * The data needed to update a AcademicFaculty.
     */
    data: XOR<AcademicFacultyUpdateInput, AcademicFacultyUncheckedUpdateInput>
    /**
     * Choose, which AcademicFaculty to update.
     */
    where: AcademicFacultyWhereUniqueInput
  }

  /**
   * AcademicFaculty updateMany
   */
  export type AcademicFacultyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AcademicFaculties.
     */
    data: XOR<AcademicFacultyUpdateManyMutationInput, AcademicFacultyUncheckedUpdateManyInput>
    /**
     * Filter which AcademicFaculties to update
     */
    where?: AcademicFacultyWhereInput
    /**
     * Limit how many AcademicFaculties to update.
     */
    limit?: number
  }

  /**
   * AcademicFaculty upsert
   */
  export type AcademicFacultyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicFaculty
     */
    select?: AcademicFacultySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AcademicFaculty
     */
    omit?: AcademicFacultyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicFacultyInclude<ExtArgs> | null
    /**
     * The filter to search for the AcademicFaculty to update in case it exists.
     */
    where: AcademicFacultyWhereUniqueInput
    /**
     * In case the AcademicFaculty found by the `where` argument doesn't exist, create a new AcademicFaculty with this data.
     */
    create: XOR<AcademicFacultyCreateInput, AcademicFacultyUncheckedCreateInput>
    /**
     * In case the AcademicFaculty was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AcademicFacultyUpdateInput, AcademicFacultyUncheckedUpdateInput>
  }

  /**
   * AcademicFaculty delete
   */
  export type AcademicFacultyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicFaculty
     */
    select?: AcademicFacultySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AcademicFaculty
     */
    omit?: AcademicFacultyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicFacultyInclude<ExtArgs> | null
    /**
     * Filter which AcademicFaculty to delete.
     */
    where: AcademicFacultyWhereUniqueInput
  }

  /**
   * AcademicFaculty deleteMany
   */
  export type AcademicFacultyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AcademicFaculties to delete
     */
    where?: AcademicFacultyWhereInput
    /**
     * Limit how many AcademicFaculties to delete.
     */
    limit?: number
  }

  /**
   * AcademicFaculty.academicDepartments
   */
  export type AcademicFaculty$academicDepartmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicDepartment
     */
    select?: AcademicDepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AcademicDepartment
     */
    omit?: AcademicDepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicDepartmentInclude<ExtArgs> | null
    where?: AcademicDepartmentWhereInput
  }

  /**
   * AcademicFaculty.faculties
   */
  export type AcademicFaculty$facultiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Faculty
     */
    select?: FacultySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Faculty
     */
    omit?: FacultyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacultyInclude<ExtArgs> | null
    where?: FacultyWhereInput
  }

  /**
   * AcademicFaculty.students
   */
  export type AcademicFaculty$studentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Student
     */
    omit?: StudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    where?: StudentWhereInput
  }

  /**
   * AcademicFaculty without action
   */
  export type AcademicFacultyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicFaculty
     */
    select?: AcademicFacultySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AcademicFaculty
     */
    omit?: AcademicFacultyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicFacultyInclude<ExtArgs> | null
  }


  /**
   * Model AcademicDepartment
   */

  export type AggregateAcademicDepartment = {
    _count: AcademicDepartmentCountAggregateOutputType | null
    _min: AcademicDepartmentMinAggregateOutputType | null
    _max: AcademicDepartmentMaxAggregateOutputType | null
  }

  export type AcademicDepartmentMinAggregateOutputType = {
    id: string | null
    title: string | null
    academicFacultyId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    departmentHeadId: string | null
  }

  export type AcademicDepartmentMaxAggregateOutputType = {
    id: string | null
    title: string | null
    academicFacultyId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    departmentHeadId: string | null
  }

  export type AcademicDepartmentCountAggregateOutputType = {
    id: number
    title: number
    academicFacultyId: number
    createdAt: number
    updatedAt: number
    departmentHeadId: number
    _all: number
  }


  export type AcademicDepartmentMinAggregateInputType = {
    id?: true
    title?: true
    academicFacultyId?: true
    createdAt?: true
    updatedAt?: true
    departmentHeadId?: true
  }

  export type AcademicDepartmentMaxAggregateInputType = {
    id?: true
    title?: true
    academicFacultyId?: true
    createdAt?: true
    updatedAt?: true
    departmentHeadId?: true
  }

  export type AcademicDepartmentCountAggregateInputType = {
    id?: true
    title?: true
    academicFacultyId?: true
    createdAt?: true
    updatedAt?: true
    departmentHeadId?: true
    _all?: true
  }

  export type AcademicDepartmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AcademicDepartment to aggregate.
     */
    where?: AcademicDepartmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AcademicDepartments to fetch.
     */
    orderBy?: AcademicDepartmentOrderByWithRelationInput | AcademicDepartmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AcademicDepartmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AcademicDepartments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AcademicDepartments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AcademicDepartments
    **/
    _count?: true | AcademicDepartmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AcademicDepartmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AcademicDepartmentMaxAggregateInputType
  }

  export type GetAcademicDepartmentAggregateType<T extends AcademicDepartmentAggregateArgs> = {
        [P in keyof T & keyof AggregateAcademicDepartment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAcademicDepartment[P]>
      : GetScalarType<T[P], AggregateAcademicDepartment[P]>
  }




  export type AcademicDepartmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AcademicDepartmentWhereInput
    orderBy?: AcademicDepartmentOrderByWithAggregationInput | AcademicDepartmentOrderByWithAggregationInput[]
    by: AcademicDepartmentScalarFieldEnum[] | AcademicDepartmentScalarFieldEnum
    having?: AcademicDepartmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AcademicDepartmentCountAggregateInputType | true
    _min?: AcademicDepartmentMinAggregateInputType
    _max?: AcademicDepartmentMaxAggregateInputType
  }

  export type AcademicDepartmentGroupByOutputType = {
    id: string
    title: string
    academicFacultyId: string
    createdAt: Date
    updatedAt: Date
    departmentHeadId: string | null
    _count: AcademicDepartmentCountAggregateOutputType | null
    _min: AcademicDepartmentMinAggregateOutputType | null
    _max: AcademicDepartmentMaxAggregateOutputType | null
  }

  type GetAcademicDepartmentGroupByPayload<T extends AcademicDepartmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AcademicDepartmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AcademicDepartmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AcademicDepartmentGroupByOutputType[P]>
            : GetScalarType<T[P], AcademicDepartmentGroupByOutputType[P]>
        }
      >
    >


  export type AcademicDepartmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    academicFacultyId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    departmentHeadId?: boolean
    academicFaculty?: boolean | AcademicFacultyDefaultArgs<ExtArgs>
    faculties?: boolean | AcademicDepartment$facultiesArgs<ExtArgs>
    students?: boolean | AcademicDepartment$studentsArgs<ExtArgs>
    departmentHead?: boolean | AcademicDepartment$departmentHeadArgs<ExtArgs>
    staffMembers?: boolean | AcademicDepartment$staffMembersArgs<ExtArgs>
    admitionExame?: boolean | AcademicDepartment$admitionExameArgs<ExtArgs>
    offeredCourses?: boolean | AcademicDepartment$offeredCoursesArgs<ExtArgs>
    _count?: boolean | AcademicDepartmentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["academicDepartment"]>



  export type AcademicDepartmentSelectScalar = {
    id?: boolean
    title?: boolean
    academicFacultyId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    departmentHeadId?: boolean
  }

  export type AcademicDepartmentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "academicFacultyId" | "createdAt" | "updatedAt" | "departmentHeadId", ExtArgs["result"]["academicDepartment"]>
  export type AcademicDepartmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    academicFaculty?: boolean | AcademicFacultyDefaultArgs<ExtArgs>
    faculties?: boolean | AcademicDepartment$facultiesArgs<ExtArgs>
    students?: boolean | AcademicDepartment$studentsArgs<ExtArgs>
    departmentHead?: boolean | AcademicDepartment$departmentHeadArgs<ExtArgs>
    staffMembers?: boolean | AcademicDepartment$staffMembersArgs<ExtArgs>
    admitionExame?: boolean | AcademicDepartment$admitionExameArgs<ExtArgs>
    offeredCourses?: boolean | AcademicDepartment$offeredCoursesArgs<ExtArgs>
    _count?: boolean | AcademicDepartmentCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $AcademicDepartmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AcademicDepartment"
    objects: {
      academicFaculty: Prisma.$AcademicFacultyPayload<ExtArgs>
      faculties: Prisma.$FacultyPayload<ExtArgs> | null
      students: Prisma.$StudentPayload<ExtArgs> | null
      departmentHead: Prisma.$UsersPayload<ExtArgs> | null
      staffMembers: Prisma.$UsersPayload<ExtArgs>[]
      admitionExame: Prisma.$AdmitionExameRegistrationPayload<ExtArgs>[]
      offeredCourses: Prisma.$OfferedCoursePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      academicFacultyId: string
      createdAt: Date
      updatedAt: Date
      departmentHeadId: string | null
    }, ExtArgs["result"]["academicDepartment"]>
    composites: {}
  }

  type AcademicDepartmentGetPayload<S extends boolean | null | undefined | AcademicDepartmentDefaultArgs> = $Result.GetResult<Prisma.$AcademicDepartmentPayload, S>

  type AcademicDepartmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AcademicDepartmentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AcademicDepartmentCountAggregateInputType | true
    }

  export interface AcademicDepartmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AcademicDepartment'], meta: { name: 'AcademicDepartment' } }
    /**
     * Find zero or one AcademicDepartment that matches the filter.
     * @param {AcademicDepartmentFindUniqueArgs} args - Arguments to find a AcademicDepartment
     * @example
     * // Get one AcademicDepartment
     * const academicDepartment = await prisma.academicDepartment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AcademicDepartmentFindUniqueArgs>(args: SelectSubset<T, AcademicDepartmentFindUniqueArgs<ExtArgs>>): Prisma__AcademicDepartmentClient<$Result.GetResult<Prisma.$AcademicDepartmentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AcademicDepartment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AcademicDepartmentFindUniqueOrThrowArgs} args - Arguments to find a AcademicDepartment
     * @example
     * // Get one AcademicDepartment
     * const academicDepartment = await prisma.academicDepartment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AcademicDepartmentFindUniqueOrThrowArgs>(args: SelectSubset<T, AcademicDepartmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AcademicDepartmentClient<$Result.GetResult<Prisma.$AcademicDepartmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AcademicDepartment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AcademicDepartmentFindFirstArgs} args - Arguments to find a AcademicDepartment
     * @example
     * // Get one AcademicDepartment
     * const academicDepartment = await prisma.academicDepartment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AcademicDepartmentFindFirstArgs>(args?: SelectSubset<T, AcademicDepartmentFindFirstArgs<ExtArgs>>): Prisma__AcademicDepartmentClient<$Result.GetResult<Prisma.$AcademicDepartmentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AcademicDepartment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AcademicDepartmentFindFirstOrThrowArgs} args - Arguments to find a AcademicDepartment
     * @example
     * // Get one AcademicDepartment
     * const academicDepartment = await prisma.academicDepartment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AcademicDepartmentFindFirstOrThrowArgs>(args?: SelectSubset<T, AcademicDepartmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__AcademicDepartmentClient<$Result.GetResult<Prisma.$AcademicDepartmentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AcademicDepartments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AcademicDepartmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AcademicDepartments
     * const academicDepartments = await prisma.academicDepartment.findMany()
     * 
     * // Get first 10 AcademicDepartments
     * const academicDepartments = await prisma.academicDepartment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const academicDepartmentWithIdOnly = await prisma.academicDepartment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AcademicDepartmentFindManyArgs>(args?: SelectSubset<T, AcademicDepartmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AcademicDepartmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AcademicDepartment.
     * @param {AcademicDepartmentCreateArgs} args - Arguments to create a AcademicDepartment.
     * @example
     * // Create one AcademicDepartment
     * const AcademicDepartment = await prisma.academicDepartment.create({
     *   data: {
     *     // ... data to create a AcademicDepartment
     *   }
     * })
     * 
     */
    create<T extends AcademicDepartmentCreateArgs>(args: SelectSubset<T, AcademicDepartmentCreateArgs<ExtArgs>>): Prisma__AcademicDepartmentClient<$Result.GetResult<Prisma.$AcademicDepartmentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AcademicDepartments.
     * @param {AcademicDepartmentCreateManyArgs} args - Arguments to create many AcademicDepartments.
     * @example
     * // Create many AcademicDepartments
     * const academicDepartment = await prisma.academicDepartment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AcademicDepartmentCreateManyArgs>(args?: SelectSubset<T, AcademicDepartmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a AcademicDepartment.
     * @param {AcademicDepartmentDeleteArgs} args - Arguments to delete one AcademicDepartment.
     * @example
     * // Delete one AcademicDepartment
     * const AcademicDepartment = await prisma.academicDepartment.delete({
     *   where: {
     *     // ... filter to delete one AcademicDepartment
     *   }
     * })
     * 
     */
    delete<T extends AcademicDepartmentDeleteArgs>(args: SelectSubset<T, AcademicDepartmentDeleteArgs<ExtArgs>>): Prisma__AcademicDepartmentClient<$Result.GetResult<Prisma.$AcademicDepartmentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AcademicDepartment.
     * @param {AcademicDepartmentUpdateArgs} args - Arguments to update one AcademicDepartment.
     * @example
     * // Update one AcademicDepartment
     * const academicDepartment = await prisma.academicDepartment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AcademicDepartmentUpdateArgs>(args: SelectSubset<T, AcademicDepartmentUpdateArgs<ExtArgs>>): Prisma__AcademicDepartmentClient<$Result.GetResult<Prisma.$AcademicDepartmentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AcademicDepartments.
     * @param {AcademicDepartmentDeleteManyArgs} args - Arguments to filter AcademicDepartments to delete.
     * @example
     * // Delete a few AcademicDepartments
     * const { count } = await prisma.academicDepartment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AcademicDepartmentDeleteManyArgs>(args?: SelectSubset<T, AcademicDepartmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AcademicDepartments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AcademicDepartmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AcademicDepartments
     * const academicDepartment = await prisma.academicDepartment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AcademicDepartmentUpdateManyArgs>(args: SelectSubset<T, AcademicDepartmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AcademicDepartment.
     * @param {AcademicDepartmentUpsertArgs} args - Arguments to update or create a AcademicDepartment.
     * @example
     * // Update or create a AcademicDepartment
     * const academicDepartment = await prisma.academicDepartment.upsert({
     *   create: {
     *     // ... data to create a AcademicDepartment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AcademicDepartment we want to update
     *   }
     * })
     */
    upsert<T extends AcademicDepartmentUpsertArgs>(args: SelectSubset<T, AcademicDepartmentUpsertArgs<ExtArgs>>): Prisma__AcademicDepartmentClient<$Result.GetResult<Prisma.$AcademicDepartmentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AcademicDepartments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AcademicDepartmentCountArgs} args - Arguments to filter AcademicDepartments to count.
     * @example
     * // Count the number of AcademicDepartments
     * const count = await prisma.academicDepartment.count({
     *   where: {
     *     // ... the filter for the AcademicDepartments we want to count
     *   }
     * })
    **/
    count<T extends AcademicDepartmentCountArgs>(
      args?: Subset<T, AcademicDepartmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AcademicDepartmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AcademicDepartment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AcademicDepartmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AcademicDepartmentAggregateArgs>(args: Subset<T, AcademicDepartmentAggregateArgs>): Prisma.PrismaPromise<GetAcademicDepartmentAggregateType<T>>

    /**
     * Group by AcademicDepartment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AcademicDepartmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AcademicDepartmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AcademicDepartmentGroupByArgs['orderBy'] }
        : { orderBy?: AcademicDepartmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AcademicDepartmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAcademicDepartmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AcademicDepartment model
   */
  readonly fields: AcademicDepartmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AcademicDepartment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AcademicDepartmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    academicFaculty<T extends AcademicFacultyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AcademicFacultyDefaultArgs<ExtArgs>>): Prisma__AcademicFacultyClient<$Result.GetResult<Prisma.$AcademicFacultyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    faculties<T extends AcademicDepartment$facultiesArgs<ExtArgs> = {}>(args?: Subset<T, AcademicDepartment$facultiesArgs<ExtArgs>>): Prisma__FacultyClient<$Result.GetResult<Prisma.$FacultyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    students<T extends AcademicDepartment$studentsArgs<ExtArgs> = {}>(args?: Subset<T, AcademicDepartment$studentsArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    departmentHead<T extends AcademicDepartment$departmentHeadArgs<ExtArgs> = {}>(args?: Subset<T, AcademicDepartment$departmentHeadArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    staffMembers<T extends AcademicDepartment$staffMembersArgs<ExtArgs> = {}>(args?: Subset<T, AcademicDepartment$staffMembersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    admitionExame<T extends AcademicDepartment$admitionExameArgs<ExtArgs> = {}>(args?: Subset<T, AcademicDepartment$admitionExameArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdmitionExameRegistrationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    offeredCourses<T extends AcademicDepartment$offeredCoursesArgs<ExtArgs> = {}>(args?: Subset<T, AcademicDepartment$offeredCoursesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OfferedCoursePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AcademicDepartment model
   */
  interface AcademicDepartmentFieldRefs {
    readonly id: FieldRef<"AcademicDepartment", 'String'>
    readonly title: FieldRef<"AcademicDepartment", 'String'>
    readonly academicFacultyId: FieldRef<"AcademicDepartment", 'String'>
    readonly createdAt: FieldRef<"AcademicDepartment", 'DateTime'>
    readonly updatedAt: FieldRef<"AcademicDepartment", 'DateTime'>
    readonly departmentHeadId: FieldRef<"AcademicDepartment", 'String'>
  }
    

  // Custom InputTypes
  /**
   * AcademicDepartment findUnique
   */
  export type AcademicDepartmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicDepartment
     */
    select?: AcademicDepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AcademicDepartment
     */
    omit?: AcademicDepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicDepartmentInclude<ExtArgs> | null
    /**
     * Filter, which AcademicDepartment to fetch.
     */
    where: AcademicDepartmentWhereUniqueInput
  }

  /**
   * AcademicDepartment findUniqueOrThrow
   */
  export type AcademicDepartmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicDepartment
     */
    select?: AcademicDepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AcademicDepartment
     */
    omit?: AcademicDepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicDepartmentInclude<ExtArgs> | null
    /**
     * Filter, which AcademicDepartment to fetch.
     */
    where: AcademicDepartmentWhereUniqueInput
  }

  /**
   * AcademicDepartment findFirst
   */
  export type AcademicDepartmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicDepartment
     */
    select?: AcademicDepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AcademicDepartment
     */
    omit?: AcademicDepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicDepartmentInclude<ExtArgs> | null
    /**
     * Filter, which AcademicDepartment to fetch.
     */
    where?: AcademicDepartmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AcademicDepartments to fetch.
     */
    orderBy?: AcademicDepartmentOrderByWithRelationInput | AcademicDepartmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AcademicDepartments.
     */
    cursor?: AcademicDepartmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AcademicDepartments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AcademicDepartments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AcademicDepartments.
     */
    distinct?: AcademicDepartmentScalarFieldEnum | AcademicDepartmentScalarFieldEnum[]
  }

  /**
   * AcademicDepartment findFirstOrThrow
   */
  export type AcademicDepartmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicDepartment
     */
    select?: AcademicDepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AcademicDepartment
     */
    omit?: AcademicDepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicDepartmentInclude<ExtArgs> | null
    /**
     * Filter, which AcademicDepartment to fetch.
     */
    where?: AcademicDepartmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AcademicDepartments to fetch.
     */
    orderBy?: AcademicDepartmentOrderByWithRelationInput | AcademicDepartmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AcademicDepartments.
     */
    cursor?: AcademicDepartmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AcademicDepartments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AcademicDepartments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AcademicDepartments.
     */
    distinct?: AcademicDepartmentScalarFieldEnum | AcademicDepartmentScalarFieldEnum[]
  }

  /**
   * AcademicDepartment findMany
   */
  export type AcademicDepartmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicDepartment
     */
    select?: AcademicDepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AcademicDepartment
     */
    omit?: AcademicDepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicDepartmentInclude<ExtArgs> | null
    /**
     * Filter, which AcademicDepartments to fetch.
     */
    where?: AcademicDepartmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AcademicDepartments to fetch.
     */
    orderBy?: AcademicDepartmentOrderByWithRelationInput | AcademicDepartmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AcademicDepartments.
     */
    cursor?: AcademicDepartmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AcademicDepartments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AcademicDepartments.
     */
    skip?: number
    distinct?: AcademicDepartmentScalarFieldEnum | AcademicDepartmentScalarFieldEnum[]
  }

  /**
   * AcademicDepartment create
   */
  export type AcademicDepartmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicDepartment
     */
    select?: AcademicDepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AcademicDepartment
     */
    omit?: AcademicDepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicDepartmentInclude<ExtArgs> | null
    /**
     * The data needed to create a AcademicDepartment.
     */
    data: XOR<AcademicDepartmentCreateInput, AcademicDepartmentUncheckedCreateInput>
  }

  /**
   * AcademicDepartment createMany
   */
  export type AcademicDepartmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AcademicDepartments.
     */
    data: AcademicDepartmentCreateManyInput | AcademicDepartmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AcademicDepartment update
   */
  export type AcademicDepartmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicDepartment
     */
    select?: AcademicDepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AcademicDepartment
     */
    omit?: AcademicDepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicDepartmentInclude<ExtArgs> | null
    /**
     * The data needed to update a AcademicDepartment.
     */
    data: XOR<AcademicDepartmentUpdateInput, AcademicDepartmentUncheckedUpdateInput>
    /**
     * Choose, which AcademicDepartment to update.
     */
    where: AcademicDepartmentWhereUniqueInput
  }

  /**
   * AcademicDepartment updateMany
   */
  export type AcademicDepartmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AcademicDepartments.
     */
    data: XOR<AcademicDepartmentUpdateManyMutationInput, AcademicDepartmentUncheckedUpdateManyInput>
    /**
     * Filter which AcademicDepartments to update
     */
    where?: AcademicDepartmentWhereInput
    /**
     * Limit how many AcademicDepartments to update.
     */
    limit?: number
  }

  /**
   * AcademicDepartment upsert
   */
  export type AcademicDepartmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicDepartment
     */
    select?: AcademicDepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AcademicDepartment
     */
    omit?: AcademicDepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicDepartmentInclude<ExtArgs> | null
    /**
     * The filter to search for the AcademicDepartment to update in case it exists.
     */
    where: AcademicDepartmentWhereUniqueInput
    /**
     * In case the AcademicDepartment found by the `where` argument doesn't exist, create a new AcademicDepartment with this data.
     */
    create: XOR<AcademicDepartmentCreateInput, AcademicDepartmentUncheckedCreateInput>
    /**
     * In case the AcademicDepartment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AcademicDepartmentUpdateInput, AcademicDepartmentUncheckedUpdateInput>
  }

  /**
   * AcademicDepartment delete
   */
  export type AcademicDepartmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicDepartment
     */
    select?: AcademicDepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AcademicDepartment
     */
    omit?: AcademicDepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicDepartmentInclude<ExtArgs> | null
    /**
     * Filter which AcademicDepartment to delete.
     */
    where: AcademicDepartmentWhereUniqueInput
  }

  /**
   * AcademicDepartment deleteMany
   */
  export type AcademicDepartmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AcademicDepartments to delete
     */
    where?: AcademicDepartmentWhereInput
    /**
     * Limit how many AcademicDepartments to delete.
     */
    limit?: number
  }

  /**
   * AcademicDepartment.faculties
   */
  export type AcademicDepartment$facultiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Faculty
     */
    select?: FacultySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Faculty
     */
    omit?: FacultyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacultyInclude<ExtArgs> | null
    where?: FacultyWhereInput
  }

  /**
   * AcademicDepartment.students
   */
  export type AcademicDepartment$studentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Student
     */
    omit?: StudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    where?: StudentWhereInput
  }

  /**
   * AcademicDepartment.departmentHead
   */
  export type AcademicDepartment$departmentHeadArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Users
     */
    omit?: UsersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersInclude<ExtArgs> | null
    where?: UsersWhereInput
  }

  /**
   * AcademicDepartment.staffMembers
   */
  export type AcademicDepartment$staffMembersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Users
     */
    omit?: UsersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersInclude<ExtArgs> | null
    where?: UsersWhereInput
    orderBy?: UsersOrderByWithRelationInput | UsersOrderByWithRelationInput[]
    cursor?: UsersWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * AcademicDepartment.admitionExame
   */
  export type AcademicDepartment$admitionExameArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdmitionExameRegistration
     */
    select?: AdmitionExameRegistrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdmitionExameRegistration
     */
    omit?: AdmitionExameRegistrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdmitionExameRegistrationInclude<ExtArgs> | null
    where?: AdmitionExameRegistrationWhereInput
    orderBy?: AdmitionExameRegistrationOrderByWithRelationInput | AdmitionExameRegistrationOrderByWithRelationInput[]
    cursor?: AdmitionExameRegistrationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AdmitionExameRegistrationScalarFieldEnum | AdmitionExameRegistrationScalarFieldEnum[]
  }

  /**
   * AcademicDepartment.offeredCourses
   */
  export type AcademicDepartment$offeredCoursesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OfferedCourse
     */
    select?: OfferedCourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OfferedCourse
     */
    omit?: OfferedCourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OfferedCourseInclude<ExtArgs> | null
    where?: OfferedCourseWhereInput
    orderBy?: OfferedCourseOrderByWithRelationInput | OfferedCourseOrderByWithRelationInput[]
    cursor?: OfferedCourseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OfferedCourseScalarFieldEnum | OfferedCourseScalarFieldEnum[]
  }

  /**
   * AcademicDepartment without action
   */
  export type AcademicDepartmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicDepartment
     */
    select?: AcademicDepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AcademicDepartment
     */
    omit?: AcademicDepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicDepartmentInclude<ExtArgs> | null
  }


  /**
   * Model Student
   */

  export type AggregateStudent = {
    _count: StudentCountAggregateOutputType | null
    _min: StudentMinAggregateOutputType | null
    _max: StudentMaxAggregateOutputType | null
  }

  export type StudentMinAggregateOutputType = {
    id: string | null
    studentId: string | null
    firstName: string | null
    middleName: string | null
    lastName: string | null
    profileImage: string | null
    email: string | null
    contactNo: string | null
    gender: string | null
    isWoker: boolean | null
    shift: $Enums.Shift | null
    password: string | null
    gradeDeclarationFile: string | null
    biFile: string | null
    presentAddress: string | null
    permanentAddress: string | null
    academicSemesterId: string | null
    academicFacultyId: string | null
    academicDepartmentId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    admissionRegistrationId: string | null
  }

  export type StudentMaxAggregateOutputType = {
    id: string | null
    studentId: string | null
    firstName: string | null
    middleName: string | null
    lastName: string | null
    profileImage: string | null
    email: string | null
    contactNo: string | null
    gender: string | null
    isWoker: boolean | null
    shift: $Enums.Shift | null
    password: string | null
    gradeDeclarationFile: string | null
    biFile: string | null
    presentAddress: string | null
    permanentAddress: string | null
    academicSemesterId: string | null
    academicFacultyId: string | null
    academicDepartmentId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    admissionRegistrationId: string | null
  }

  export type StudentCountAggregateOutputType = {
    id: number
    studentId: number
    firstName: number
    middleName: number
    lastName: number
    profileImage: number
    email: number
    contactNo: number
    gender: number
    isWoker: number
    shift: number
    password: number
    gradeDeclarationFile: number
    biFile: number
    presentAddress: number
    permanentAddress: number
    academicSemesterId: number
    academicFacultyId: number
    academicDepartmentId: number
    createdAt: number
    updatedAt: number
    admissionRegistrationId: number
    _all: number
  }


  export type StudentMinAggregateInputType = {
    id?: true
    studentId?: true
    firstName?: true
    middleName?: true
    lastName?: true
    profileImage?: true
    email?: true
    contactNo?: true
    gender?: true
    isWoker?: true
    shift?: true
    password?: true
    gradeDeclarationFile?: true
    biFile?: true
    presentAddress?: true
    permanentAddress?: true
    academicSemesterId?: true
    academicFacultyId?: true
    academicDepartmentId?: true
    createdAt?: true
    updatedAt?: true
    admissionRegistrationId?: true
  }

  export type StudentMaxAggregateInputType = {
    id?: true
    studentId?: true
    firstName?: true
    middleName?: true
    lastName?: true
    profileImage?: true
    email?: true
    contactNo?: true
    gender?: true
    isWoker?: true
    shift?: true
    password?: true
    gradeDeclarationFile?: true
    biFile?: true
    presentAddress?: true
    permanentAddress?: true
    academicSemesterId?: true
    academicFacultyId?: true
    academicDepartmentId?: true
    createdAt?: true
    updatedAt?: true
    admissionRegistrationId?: true
  }

  export type StudentCountAggregateInputType = {
    id?: true
    studentId?: true
    firstName?: true
    middleName?: true
    lastName?: true
    profileImage?: true
    email?: true
    contactNo?: true
    gender?: true
    isWoker?: true
    shift?: true
    password?: true
    gradeDeclarationFile?: true
    biFile?: true
    presentAddress?: true
    permanentAddress?: true
    academicSemesterId?: true
    academicFacultyId?: true
    academicDepartmentId?: true
    createdAt?: true
    updatedAt?: true
    admissionRegistrationId?: true
    _all?: true
  }

  export type StudentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Student to aggregate.
     */
    where?: StudentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Students to fetch.
     */
    orderBy?: StudentOrderByWithRelationInput | StudentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StudentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Students from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Students.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Students
    **/
    _count?: true | StudentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StudentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StudentMaxAggregateInputType
  }

  export type GetStudentAggregateType<T extends StudentAggregateArgs> = {
        [P in keyof T & keyof AggregateStudent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStudent[P]>
      : GetScalarType<T[P], AggregateStudent[P]>
  }




  export type StudentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentWhereInput
    orderBy?: StudentOrderByWithAggregationInput | StudentOrderByWithAggregationInput[]
    by: StudentScalarFieldEnum[] | StudentScalarFieldEnum
    having?: StudentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StudentCountAggregateInputType | true
    _min?: StudentMinAggregateInputType
    _max?: StudentMaxAggregateInputType
  }

  export type StudentGroupByOutputType = {
    id: string
    studentId: string
    firstName: string
    middleName: string | null
    lastName: string
    profileImage: string | null
    email: string | null
    contactNo: string | null
    gender: string
    isWoker: boolean
    shift: $Enums.Shift
    password: string
    gradeDeclarationFile: string
    biFile: string
    presentAddress: string
    permanentAddress: string | null
    academicSemesterId: string
    academicFacultyId: string
    academicDepartmentId: string
    createdAt: Date
    updatedAt: Date
    admissionRegistrationId: string | null
    _count: StudentCountAggregateOutputType | null
    _min: StudentMinAggregateOutputType | null
    _max: StudentMaxAggregateOutputType | null
  }

  type GetStudentGroupByPayload<T extends StudentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StudentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StudentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StudentGroupByOutputType[P]>
            : GetScalarType<T[P], StudentGroupByOutputType[P]>
        }
      >
    >


  export type StudentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    firstName?: boolean
    middleName?: boolean
    lastName?: boolean
    profileImage?: boolean
    email?: boolean
    contactNo?: boolean
    gender?: boolean
    isWoker?: boolean
    shift?: boolean
    password?: boolean
    gradeDeclarationFile?: boolean
    biFile?: boolean
    presentAddress?: boolean
    permanentAddress?: boolean
    academicSemesterId?: boolean
    academicFacultyId?: boolean
    academicDepartmentId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    admissionRegistrationId?: boolean
    admissionRegistration?: boolean | Student$admissionRegistrationArgs<ExtArgs>
    academicDepartment?: boolean | AcademicDepartmentDefaultArgs<ExtArgs>
    academicFaculty?: boolean | AcademicFacultyDefaultArgs<ExtArgs>
    academicSemester?: boolean | AcademicSemesterDefaultArgs<ExtArgs>
    studentSemesterRegistrations?: boolean | Student$studentSemesterRegistrationsArgs<ExtArgs>
    studentSemesterRegistrationCourses?: boolean | Student$studentSemesterRegistrationCoursesArgs<ExtArgs>
    studentEnrolledCourses?: boolean | Student$studentEnrolledCoursesArgs<ExtArgs>
    studentEnrolledCourseMarks?: boolean | Student$studentEnrolledCourseMarksArgs<ExtArgs>
    studentSemesterPayments?: boolean | Student$studentSemesterPaymentsArgs<ExtArgs>
    studentAcademicInfos?: boolean | Student$studentAcademicInfosArgs<ExtArgs>
    _count?: boolean | StudentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["student"]>



  export type StudentSelectScalar = {
    id?: boolean
    studentId?: boolean
    firstName?: boolean
    middleName?: boolean
    lastName?: boolean
    profileImage?: boolean
    email?: boolean
    contactNo?: boolean
    gender?: boolean
    isWoker?: boolean
    shift?: boolean
    password?: boolean
    gradeDeclarationFile?: boolean
    biFile?: boolean
    presentAddress?: boolean
    permanentAddress?: boolean
    academicSemesterId?: boolean
    academicFacultyId?: boolean
    academicDepartmentId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    admissionRegistrationId?: boolean
  }

  export type StudentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "studentId" | "firstName" | "middleName" | "lastName" | "profileImage" | "email" | "contactNo" | "gender" | "isWoker" | "shift" | "password" | "gradeDeclarationFile" | "biFile" | "presentAddress" | "permanentAddress" | "academicSemesterId" | "academicFacultyId" | "academicDepartmentId" | "createdAt" | "updatedAt" | "admissionRegistrationId", ExtArgs["result"]["student"]>
  export type StudentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    admissionRegistration?: boolean | Student$admissionRegistrationArgs<ExtArgs>
    academicDepartment?: boolean | AcademicDepartmentDefaultArgs<ExtArgs>
    academicFaculty?: boolean | AcademicFacultyDefaultArgs<ExtArgs>
    academicSemester?: boolean | AcademicSemesterDefaultArgs<ExtArgs>
    studentSemesterRegistrations?: boolean | Student$studentSemesterRegistrationsArgs<ExtArgs>
    studentSemesterRegistrationCourses?: boolean | Student$studentSemesterRegistrationCoursesArgs<ExtArgs>
    studentEnrolledCourses?: boolean | Student$studentEnrolledCoursesArgs<ExtArgs>
    studentEnrolledCourseMarks?: boolean | Student$studentEnrolledCourseMarksArgs<ExtArgs>
    studentSemesterPayments?: boolean | Student$studentSemesterPaymentsArgs<ExtArgs>
    studentAcademicInfos?: boolean | Student$studentAcademicInfosArgs<ExtArgs>
    _count?: boolean | StudentCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $StudentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Student"
    objects: {
      admissionRegistration: Prisma.$AdmitionExameRegistrationPayload<ExtArgs> | null
      academicDepartment: Prisma.$AcademicDepartmentPayload<ExtArgs>
      academicFaculty: Prisma.$AcademicFacultyPayload<ExtArgs>
      academicSemester: Prisma.$AcademicSemesterPayload<ExtArgs>
      studentSemesterRegistrations: Prisma.$StudentSemesterRegistrationPayload<ExtArgs>[]
      studentSemesterRegistrationCourses: Prisma.$StudentSemesterRegistrationCoursePayload<ExtArgs>[]
      studentEnrolledCourses: Prisma.$StudentEnrolledCoursePayload<ExtArgs>[]
      studentEnrolledCourseMarks: Prisma.$StudentEnrolledCourseMarkPayload<ExtArgs>[]
      studentSemesterPayments: Prisma.$StudentSemesterPaymentPayload<ExtArgs>[]
      studentAcademicInfos: Prisma.$StudentAcademicInfoPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      studentId: string
      firstName: string
      middleName: string | null
      lastName: string
      profileImage: string | null
      email: string | null
      contactNo: string | null
      gender: string
      isWoker: boolean
      shift: $Enums.Shift
      password: string
      gradeDeclarationFile: string
      biFile: string
      presentAddress: string
      permanentAddress: string | null
      academicSemesterId: string
      academicFacultyId: string
      academicDepartmentId: string
      createdAt: Date
      updatedAt: Date
      admissionRegistrationId: string | null
    }, ExtArgs["result"]["student"]>
    composites: {}
  }

  type StudentGetPayload<S extends boolean | null | undefined | StudentDefaultArgs> = $Result.GetResult<Prisma.$StudentPayload, S>

  type StudentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<StudentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: StudentCountAggregateInputType | true
    }

  export interface StudentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Student'], meta: { name: 'Student' } }
    /**
     * Find zero or one Student that matches the filter.
     * @param {StudentFindUniqueArgs} args - Arguments to find a Student
     * @example
     * // Get one Student
     * const student = await prisma.student.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StudentFindUniqueArgs>(args: SelectSubset<T, StudentFindUniqueArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Student that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {StudentFindUniqueOrThrowArgs} args - Arguments to find a Student
     * @example
     * // Get one Student
     * const student = await prisma.student.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StudentFindUniqueOrThrowArgs>(args: SelectSubset<T, StudentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Student that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentFindFirstArgs} args - Arguments to find a Student
     * @example
     * // Get one Student
     * const student = await prisma.student.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StudentFindFirstArgs>(args?: SelectSubset<T, StudentFindFirstArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Student that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentFindFirstOrThrowArgs} args - Arguments to find a Student
     * @example
     * // Get one Student
     * const student = await prisma.student.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StudentFindFirstOrThrowArgs>(args?: SelectSubset<T, StudentFindFirstOrThrowArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Students that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Students
     * const students = await prisma.student.findMany()
     * 
     * // Get first 10 Students
     * const students = await prisma.student.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const studentWithIdOnly = await prisma.student.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StudentFindManyArgs>(args?: SelectSubset<T, StudentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Student.
     * @param {StudentCreateArgs} args - Arguments to create a Student.
     * @example
     * // Create one Student
     * const Student = await prisma.student.create({
     *   data: {
     *     // ... data to create a Student
     *   }
     * })
     * 
     */
    create<T extends StudentCreateArgs>(args: SelectSubset<T, StudentCreateArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Students.
     * @param {StudentCreateManyArgs} args - Arguments to create many Students.
     * @example
     * // Create many Students
     * const student = await prisma.student.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StudentCreateManyArgs>(args?: SelectSubset<T, StudentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Student.
     * @param {StudentDeleteArgs} args - Arguments to delete one Student.
     * @example
     * // Delete one Student
     * const Student = await prisma.student.delete({
     *   where: {
     *     // ... filter to delete one Student
     *   }
     * })
     * 
     */
    delete<T extends StudentDeleteArgs>(args: SelectSubset<T, StudentDeleteArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Student.
     * @param {StudentUpdateArgs} args - Arguments to update one Student.
     * @example
     * // Update one Student
     * const student = await prisma.student.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StudentUpdateArgs>(args: SelectSubset<T, StudentUpdateArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Students.
     * @param {StudentDeleteManyArgs} args - Arguments to filter Students to delete.
     * @example
     * // Delete a few Students
     * const { count } = await prisma.student.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StudentDeleteManyArgs>(args?: SelectSubset<T, StudentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Students.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Students
     * const student = await prisma.student.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StudentUpdateManyArgs>(args: SelectSubset<T, StudentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Student.
     * @param {StudentUpsertArgs} args - Arguments to update or create a Student.
     * @example
     * // Update or create a Student
     * const student = await prisma.student.upsert({
     *   create: {
     *     // ... data to create a Student
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Student we want to update
     *   }
     * })
     */
    upsert<T extends StudentUpsertArgs>(args: SelectSubset<T, StudentUpsertArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Students.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentCountArgs} args - Arguments to filter Students to count.
     * @example
     * // Count the number of Students
     * const count = await prisma.student.count({
     *   where: {
     *     // ... the filter for the Students we want to count
     *   }
     * })
    **/
    count<T extends StudentCountArgs>(
      args?: Subset<T, StudentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StudentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Student.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StudentAggregateArgs>(args: Subset<T, StudentAggregateArgs>): Prisma.PrismaPromise<GetStudentAggregateType<T>>

    /**
     * Group by Student.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StudentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StudentGroupByArgs['orderBy'] }
        : { orderBy?: StudentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StudentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStudentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Student model
   */
  readonly fields: StudentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Student.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StudentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    admissionRegistration<T extends Student$admissionRegistrationArgs<ExtArgs> = {}>(args?: Subset<T, Student$admissionRegistrationArgs<ExtArgs>>): Prisma__AdmitionExameRegistrationClient<$Result.GetResult<Prisma.$AdmitionExameRegistrationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    academicDepartment<T extends AcademicDepartmentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AcademicDepartmentDefaultArgs<ExtArgs>>): Prisma__AcademicDepartmentClient<$Result.GetResult<Prisma.$AcademicDepartmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    academicFaculty<T extends AcademicFacultyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AcademicFacultyDefaultArgs<ExtArgs>>): Prisma__AcademicFacultyClient<$Result.GetResult<Prisma.$AcademicFacultyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    academicSemester<T extends AcademicSemesterDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AcademicSemesterDefaultArgs<ExtArgs>>): Prisma__AcademicSemesterClient<$Result.GetResult<Prisma.$AcademicSemesterPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    studentSemesterRegistrations<T extends Student$studentSemesterRegistrationsArgs<ExtArgs> = {}>(args?: Subset<T, Student$studentSemesterRegistrationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentSemesterRegistrationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    studentSemesterRegistrationCourses<T extends Student$studentSemesterRegistrationCoursesArgs<ExtArgs> = {}>(args?: Subset<T, Student$studentSemesterRegistrationCoursesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentSemesterRegistrationCoursePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    studentEnrolledCourses<T extends Student$studentEnrolledCoursesArgs<ExtArgs> = {}>(args?: Subset<T, Student$studentEnrolledCoursesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentEnrolledCoursePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    studentEnrolledCourseMarks<T extends Student$studentEnrolledCourseMarksArgs<ExtArgs> = {}>(args?: Subset<T, Student$studentEnrolledCourseMarksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentEnrolledCourseMarkPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    studentSemesterPayments<T extends Student$studentSemesterPaymentsArgs<ExtArgs> = {}>(args?: Subset<T, Student$studentSemesterPaymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentSemesterPaymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    studentAcademicInfos<T extends Student$studentAcademicInfosArgs<ExtArgs> = {}>(args?: Subset<T, Student$studentAcademicInfosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentAcademicInfoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Student model
   */
  interface StudentFieldRefs {
    readonly id: FieldRef<"Student", 'String'>
    readonly studentId: FieldRef<"Student", 'String'>
    readonly firstName: FieldRef<"Student", 'String'>
    readonly middleName: FieldRef<"Student", 'String'>
    readonly lastName: FieldRef<"Student", 'String'>
    readonly profileImage: FieldRef<"Student", 'String'>
    readonly email: FieldRef<"Student", 'String'>
    readonly contactNo: FieldRef<"Student", 'String'>
    readonly gender: FieldRef<"Student", 'String'>
    readonly isWoker: FieldRef<"Student", 'Boolean'>
    readonly shift: FieldRef<"Student", 'Shift'>
    readonly password: FieldRef<"Student", 'String'>
    readonly gradeDeclarationFile: FieldRef<"Student", 'String'>
    readonly biFile: FieldRef<"Student", 'String'>
    readonly presentAddress: FieldRef<"Student", 'String'>
    readonly permanentAddress: FieldRef<"Student", 'String'>
    readonly academicSemesterId: FieldRef<"Student", 'String'>
    readonly academicFacultyId: FieldRef<"Student", 'String'>
    readonly academicDepartmentId: FieldRef<"Student", 'String'>
    readonly createdAt: FieldRef<"Student", 'DateTime'>
    readonly updatedAt: FieldRef<"Student", 'DateTime'>
    readonly admissionRegistrationId: FieldRef<"Student", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Student findUnique
   */
  export type StudentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Student
     */
    omit?: StudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    /**
     * Filter, which Student to fetch.
     */
    where: StudentWhereUniqueInput
  }

  /**
   * Student findUniqueOrThrow
   */
  export type StudentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Student
     */
    omit?: StudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    /**
     * Filter, which Student to fetch.
     */
    where: StudentWhereUniqueInput
  }

  /**
   * Student findFirst
   */
  export type StudentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Student
     */
    omit?: StudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    /**
     * Filter, which Student to fetch.
     */
    where?: StudentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Students to fetch.
     */
    orderBy?: StudentOrderByWithRelationInput | StudentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Students.
     */
    cursor?: StudentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Students from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Students.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Students.
     */
    distinct?: StudentScalarFieldEnum | StudentScalarFieldEnum[]
  }

  /**
   * Student findFirstOrThrow
   */
  export type StudentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Student
     */
    omit?: StudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    /**
     * Filter, which Student to fetch.
     */
    where?: StudentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Students to fetch.
     */
    orderBy?: StudentOrderByWithRelationInput | StudentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Students.
     */
    cursor?: StudentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Students from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Students.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Students.
     */
    distinct?: StudentScalarFieldEnum | StudentScalarFieldEnum[]
  }

  /**
   * Student findMany
   */
  export type StudentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Student
     */
    omit?: StudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    /**
     * Filter, which Students to fetch.
     */
    where?: StudentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Students to fetch.
     */
    orderBy?: StudentOrderByWithRelationInput | StudentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Students.
     */
    cursor?: StudentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Students from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Students.
     */
    skip?: number
    distinct?: StudentScalarFieldEnum | StudentScalarFieldEnum[]
  }

  /**
   * Student create
   */
  export type StudentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Student
     */
    omit?: StudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    /**
     * The data needed to create a Student.
     */
    data: XOR<StudentCreateInput, StudentUncheckedCreateInput>
  }

  /**
   * Student createMany
   */
  export type StudentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Students.
     */
    data: StudentCreateManyInput | StudentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Student update
   */
  export type StudentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Student
     */
    omit?: StudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    /**
     * The data needed to update a Student.
     */
    data: XOR<StudentUpdateInput, StudentUncheckedUpdateInput>
    /**
     * Choose, which Student to update.
     */
    where: StudentWhereUniqueInput
  }

  /**
   * Student updateMany
   */
  export type StudentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Students.
     */
    data: XOR<StudentUpdateManyMutationInput, StudentUncheckedUpdateManyInput>
    /**
     * Filter which Students to update
     */
    where?: StudentWhereInput
    /**
     * Limit how many Students to update.
     */
    limit?: number
  }

  /**
   * Student upsert
   */
  export type StudentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Student
     */
    omit?: StudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    /**
     * The filter to search for the Student to update in case it exists.
     */
    where: StudentWhereUniqueInput
    /**
     * In case the Student found by the `where` argument doesn't exist, create a new Student with this data.
     */
    create: XOR<StudentCreateInput, StudentUncheckedCreateInput>
    /**
     * In case the Student was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StudentUpdateInput, StudentUncheckedUpdateInput>
  }

  /**
   * Student delete
   */
  export type StudentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Student
     */
    omit?: StudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    /**
     * Filter which Student to delete.
     */
    where: StudentWhereUniqueInput
  }

  /**
   * Student deleteMany
   */
  export type StudentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Students to delete
     */
    where?: StudentWhereInput
    /**
     * Limit how many Students to delete.
     */
    limit?: number
  }

  /**
   * Student.admissionRegistration
   */
  export type Student$admissionRegistrationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdmitionExameRegistration
     */
    select?: AdmitionExameRegistrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdmitionExameRegistration
     */
    omit?: AdmitionExameRegistrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdmitionExameRegistrationInclude<ExtArgs> | null
    where?: AdmitionExameRegistrationWhereInput
  }

  /**
   * Student.studentSemesterRegistrations
   */
  export type Student$studentSemesterRegistrationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentSemesterRegistration
     */
    select?: StudentSemesterRegistrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentSemesterRegistration
     */
    omit?: StudentSemesterRegistrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentSemesterRegistrationInclude<ExtArgs> | null
    where?: StudentSemesterRegistrationWhereInput
    orderBy?: StudentSemesterRegistrationOrderByWithRelationInput | StudentSemesterRegistrationOrderByWithRelationInput[]
    cursor?: StudentSemesterRegistrationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StudentSemesterRegistrationScalarFieldEnum | StudentSemesterRegistrationScalarFieldEnum[]
  }

  /**
   * Student.studentSemesterRegistrationCourses
   */
  export type Student$studentSemesterRegistrationCoursesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentSemesterRegistrationCourse
     */
    select?: StudentSemesterRegistrationCourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentSemesterRegistrationCourse
     */
    omit?: StudentSemesterRegistrationCourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentSemesterRegistrationCourseInclude<ExtArgs> | null
    where?: StudentSemesterRegistrationCourseWhereInput
    orderBy?: StudentSemesterRegistrationCourseOrderByWithRelationInput | StudentSemesterRegistrationCourseOrderByWithRelationInput[]
    cursor?: StudentSemesterRegistrationCourseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StudentSemesterRegistrationCourseScalarFieldEnum | StudentSemesterRegistrationCourseScalarFieldEnum[]
  }

  /**
   * Student.studentEnrolledCourses
   */
  export type Student$studentEnrolledCoursesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentEnrolledCourse
     */
    select?: StudentEnrolledCourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentEnrolledCourse
     */
    omit?: StudentEnrolledCourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentEnrolledCourseInclude<ExtArgs> | null
    where?: StudentEnrolledCourseWhereInput
    orderBy?: StudentEnrolledCourseOrderByWithRelationInput | StudentEnrolledCourseOrderByWithRelationInput[]
    cursor?: StudentEnrolledCourseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StudentEnrolledCourseScalarFieldEnum | StudentEnrolledCourseScalarFieldEnum[]
  }

  /**
   * Student.studentEnrolledCourseMarks
   */
  export type Student$studentEnrolledCourseMarksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentEnrolledCourseMark
     */
    select?: StudentEnrolledCourseMarkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentEnrolledCourseMark
     */
    omit?: StudentEnrolledCourseMarkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentEnrolledCourseMarkInclude<ExtArgs> | null
    where?: StudentEnrolledCourseMarkWhereInput
    orderBy?: StudentEnrolledCourseMarkOrderByWithRelationInput | StudentEnrolledCourseMarkOrderByWithRelationInput[]
    cursor?: StudentEnrolledCourseMarkWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StudentEnrolledCourseMarkScalarFieldEnum | StudentEnrolledCourseMarkScalarFieldEnum[]
  }

  /**
   * Student.studentSemesterPayments
   */
  export type Student$studentSemesterPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentSemesterPayment
     */
    select?: StudentSemesterPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentSemesterPayment
     */
    omit?: StudentSemesterPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentSemesterPaymentInclude<ExtArgs> | null
    where?: StudentSemesterPaymentWhereInput
    orderBy?: StudentSemesterPaymentOrderByWithRelationInput | StudentSemesterPaymentOrderByWithRelationInput[]
    cursor?: StudentSemesterPaymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StudentSemesterPaymentScalarFieldEnum | StudentSemesterPaymentScalarFieldEnum[]
  }

  /**
   * Student.studentAcademicInfos
   */
  export type Student$studentAcademicInfosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentAcademicInfo
     */
    select?: StudentAcademicInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentAcademicInfo
     */
    omit?: StudentAcademicInfoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentAcademicInfoInclude<ExtArgs> | null
    where?: StudentAcademicInfoWhereInput
    orderBy?: StudentAcademicInfoOrderByWithRelationInput | StudentAcademicInfoOrderByWithRelationInput[]
    cursor?: StudentAcademicInfoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StudentAcademicInfoScalarFieldEnum | StudentAcademicInfoScalarFieldEnum[]
  }

  /**
   * Student without action
   */
  export type StudentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Student
     */
    omit?: StudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
  }


  /**
   * Model Faculty
   */

  export type AggregateFaculty = {
    _count: FacultyCountAggregateOutputType | null
    _min: FacultyMinAggregateOutputType | null
    _max: FacultyMaxAggregateOutputType | null
  }

  export type FacultyMinAggregateOutputType = {
    id: string | null
    facultyId: string | null
    firstName: string | null
    middleName: string | null
    lastName: string | null
    profileImage: string | null
    email: string | null
    contactNo: string | null
    gender: string | null
    designation: string | null
    password: string | null
    academicFacultyId: string | null
    academicDepartmentId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FacultyMaxAggregateOutputType = {
    id: string | null
    facultyId: string | null
    firstName: string | null
    middleName: string | null
    lastName: string | null
    profileImage: string | null
    email: string | null
    contactNo: string | null
    gender: string | null
    designation: string | null
    password: string | null
    academicFacultyId: string | null
    academicDepartmentId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FacultyCountAggregateOutputType = {
    id: number
    facultyId: number
    firstName: number
    middleName: number
    lastName: number
    profileImage: number
    email: number
    contactNo: number
    gender: number
    designation: number
    password: number
    academicFacultyId: number
    academicDepartmentId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type FacultyMinAggregateInputType = {
    id?: true
    facultyId?: true
    firstName?: true
    middleName?: true
    lastName?: true
    profileImage?: true
    email?: true
    contactNo?: true
    gender?: true
    designation?: true
    password?: true
    academicFacultyId?: true
    academicDepartmentId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FacultyMaxAggregateInputType = {
    id?: true
    facultyId?: true
    firstName?: true
    middleName?: true
    lastName?: true
    profileImage?: true
    email?: true
    contactNo?: true
    gender?: true
    designation?: true
    password?: true
    academicFacultyId?: true
    academicDepartmentId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FacultyCountAggregateInputType = {
    id?: true
    facultyId?: true
    firstName?: true
    middleName?: true
    lastName?: true
    profileImage?: true
    email?: true
    contactNo?: true
    gender?: true
    designation?: true
    password?: true
    academicFacultyId?: true
    academicDepartmentId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type FacultyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Faculty to aggregate.
     */
    where?: FacultyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Faculties to fetch.
     */
    orderBy?: FacultyOrderByWithRelationInput | FacultyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FacultyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Faculties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Faculties.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Faculties
    **/
    _count?: true | FacultyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FacultyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FacultyMaxAggregateInputType
  }

  export type GetFacultyAggregateType<T extends FacultyAggregateArgs> = {
        [P in keyof T & keyof AggregateFaculty]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFaculty[P]>
      : GetScalarType<T[P], AggregateFaculty[P]>
  }




  export type FacultyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FacultyWhereInput
    orderBy?: FacultyOrderByWithAggregationInput | FacultyOrderByWithAggregationInput[]
    by: FacultyScalarFieldEnum[] | FacultyScalarFieldEnum
    having?: FacultyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FacultyCountAggregateInputType | true
    _min?: FacultyMinAggregateInputType
    _max?: FacultyMaxAggregateInputType
  }

  export type FacultyGroupByOutputType = {
    id: string
    facultyId: string
    firstName: string
    middleName: string | null
    lastName: string
    profileImage: string | null
    email: string | null
    contactNo: string | null
    gender: string
    designation: string
    password: string
    academicFacultyId: string
    academicDepartmentId: string
    createdAt: Date
    updatedAt: Date
    _count: FacultyCountAggregateOutputType | null
    _min: FacultyMinAggregateOutputType | null
    _max: FacultyMaxAggregateOutputType | null
  }

  type GetFacultyGroupByPayload<T extends FacultyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FacultyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FacultyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FacultyGroupByOutputType[P]>
            : GetScalarType<T[P], FacultyGroupByOutputType[P]>
        }
      >
    >


  export type FacultySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    facultyId?: boolean
    firstName?: boolean
    middleName?: boolean
    lastName?: boolean
    profileImage?: boolean
    email?: boolean
    contactNo?: boolean
    gender?: boolean
    designation?: boolean
    password?: boolean
    academicFacultyId?: boolean
    academicDepartmentId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    courses?: boolean | Faculty$coursesArgs<ExtArgs>
    academicDepartment?: boolean | AcademicDepartmentDefaultArgs<ExtArgs>
    academicFaculty?: boolean | AcademicFacultyDefaultArgs<ExtArgs>
    offeredCourseClassSchedules?: boolean | Faculty$offeredCourseClassSchedulesArgs<ExtArgs>
    _count?: boolean | FacultyCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["faculty"]>



  export type FacultySelectScalar = {
    id?: boolean
    facultyId?: boolean
    firstName?: boolean
    middleName?: boolean
    lastName?: boolean
    profileImage?: boolean
    email?: boolean
    contactNo?: boolean
    gender?: boolean
    designation?: boolean
    password?: boolean
    academicFacultyId?: boolean
    academicDepartmentId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type FacultyOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "facultyId" | "firstName" | "middleName" | "lastName" | "profileImage" | "email" | "contactNo" | "gender" | "designation" | "password" | "academicFacultyId" | "academicDepartmentId" | "createdAt" | "updatedAt", ExtArgs["result"]["faculty"]>
  export type FacultyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    courses?: boolean | Faculty$coursesArgs<ExtArgs>
    academicDepartment?: boolean | AcademicDepartmentDefaultArgs<ExtArgs>
    academicFaculty?: boolean | AcademicFacultyDefaultArgs<ExtArgs>
    offeredCourseClassSchedules?: boolean | Faculty$offeredCourseClassSchedulesArgs<ExtArgs>
    _count?: boolean | FacultyCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $FacultyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Faculty"
    objects: {
      courses: Prisma.$CourseFacultyPayload<ExtArgs>[]
      academicDepartment: Prisma.$AcademicDepartmentPayload<ExtArgs>
      academicFaculty: Prisma.$AcademicFacultyPayload<ExtArgs>
      offeredCourseClassSchedules: Prisma.$OfferedCourseClassSchedulePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      facultyId: string
      firstName: string
      middleName: string | null
      lastName: string
      profileImage: string | null
      email: string | null
      contactNo: string | null
      gender: string
      designation: string
      password: string
      academicFacultyId: string
      academicDepartmentId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["faculty"]>
    composites: {}
  }

  type FacultyGetPayload<S extends boolean | null | undefined | FacultyDefaultArgs> = $Result.GetResult<Prisma.$FacultyPayload, S>

  type FacultyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FacultyFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FacultyCountAggregateInputType | true
    }

  export interface FacultyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Faculty'], meta: { name: 'Faculty' } }
    /**
     * Find zero or one Faculty that matches the filter.
     * @param {FacultyFindUniqueArgs} args - Arguments to find a Faculty
     * @example
     * // Get one Faculty
     * const faculty = await prisma.faculty.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FacultyFindUniqueArgs>(args: SelectSubset<T, FacultyFindUniqueArgs<ExtArgs>>): Prisma__FacultyClient<$Result.GetResult<Prisma.$FacultyPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Faculty that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FacultyFindUniqueOrThrowArgs} args - Arguments to find a Faculty
     * @example
     * // Get one Faculty
     * const faculty = await prisma.faculty.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FacultyFindUniqueOrThrowArgs>(args: SelectSubset<T, FacultyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FacultyClient<$Result.GetResult<Prisma.$FacultyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Faculty that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacultyFindFirstArgs} args - Arguments to find a Faculty
     * @example
     * // Get one Faculty
     * const faculty = await prisma.faculty.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FacultyFindFirstArgs>(args?: SelectSubset<T, FacultyFindFirstArgs<ExtArgs>>): Prisma__FacultyClient<$Result.GetResult<Prisma.$FacultyPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Faculty that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacultyFindFirstOrThrowArgs} args - Arguments to find a Faculty
     * @example
     * // Get one Faculty
     * const faculty = await prisma.faculty.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FacultyFindFirstOrThrowArgs>(args?: SelectSubset<T, FacultyFindFirstOrThrowArgs<ExtArgs>>): Prisma__FacultyClient<$Result.GetResult<Prisma.$FacultyPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Faculties that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacultyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Faculties
     * const faculties = await prisma.faculty.findMany()
     * 
     * // Get first 10 Faculties
     * const faculties = await prisma.faculty.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const facultyWithIdOnly = await prisma.faculty.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FacultyFindManyArgs>(args?: SelectSubset<T, FacultyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FacultyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Faculty.
     * @param {FacultyCreateArgs} args - Arguments to create a Faculty.
     * @example
     * // Create one Faculty
     * const Faculty = await prisma.faculty.create({
     *   data: {
     *     // ... data to create a Faculty
     *   }
     * })
     * 
     */
    create<T extends FacultyCreateArgs>(args: SelectSubset<T, FacultyCreateArgs<ExtArgs>>): Prisma__FacultyClient<$Result.GetResult<Prisma.$FacultyPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Faculties.
     * @param {FacultyCreateManyArgs} args - Arguments to create many Faculties.
     * @example
     * // Create many Faculties
     * const faculty = await prisma.faculty.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FacultyCreateManyArgs>(args?: SelectSubset<T, FacultyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Faculty.
     * @param {FacultyDeleteArgs} args - Arguments to delete one Faculty.
     * @example
     * // Delete one Faculty
     * const Faculty = await prisma.faculty.delete({
     *   where: {
     *     // ... filter to delete one Faculty
     *   }
     * })
     * 
     */
    delete<T extends FacultyDeleteArgs>(args: SelectSubset<T, FacultyDeleteArgs<ExtArgs>>): Prisma__FacultyClient<$Result.GetResult<Prisma.$FacultyPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Faculty.
     * @param {FacultyUpdateArgs} args - Arguments to update one Faculty.
     * @example
     * // Update one Faculty
     * const faculty = await prisma.faculty.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FacultyUpdateArgs>(args: SelectSubset<T, FacultyUpdateArgs<ExtArgs>>): Prisma__FacultyClient<$Result.GetResult<Prisma.$FacultyPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Faculties.
     * @param {FacultyDeleteManyArgs} args - Arguments to filter Faculties to delete.
     * @example
     * // Delete a few Faculties
     * const { count } = await prisma.faculty.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FacultyDeleteManyArgs>(args?: SelectSubset<T, FacultyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Faculties.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacultyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Faculties
     * const faculty = await prisma.faculty.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FacultyUpdateManyArgs>(args: SelectSubset<T, FacultyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Faculty.
     * @param {FacultyUpsertArgs} args - Arguments to update or create a Faculty.
     * @example
     * // Update or create a Faculty
     * const faculty = await prisma.faculty.upsert({
     *   create: {
     *     // ... data to create a Faculty
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Faculty we want to update
     *   }
     * })
     */
    upsert<T extends FacultyUpsertArgs>(args: SelectSubset<T, FacultyUpsertArgs<ExtArgs>>): Prisma__FacultyClient<$Result.GetResult<Prisma.$FacultyPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Faculties.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacultyCountArgs} args - Arguments to filter Faculties to count.
     * @example
     * // Count the number of Faculties
     * const count = await prisma.faculty.count({
     *   where: {
     *     // ... the filter for the Faculties we want to count
     *   }
     * })
    **/
    count<T extends FacultyCountArgs>(
      args?: Subset<T, FacultyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FacultyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Faculty.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacultyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FacultyAggregateArgs>(args: Subset<T, FacultyAggregateArgs>): Prisma.PrismaPromise<GetFacultyAggregateType<T>>

    /**
     * Group by Faculty.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacultyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FacultyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FacultyGroupByArgs['orderBy'] }
        : { orderBy?: FacultyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FacultyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFacultyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Faculty model
   */
  readonly fields: FacultyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Faculty.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FacultyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    courses<T extends Faculty$coursesArgs<ExtArgs> = {}>(args?: Subset<T, Faculty$coursesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CourseFacultyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    academicDepartment<T extends AcademicDepartmentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AcademicDepartmentDefaultArgs<ExtArgs>>): Prisma__AcademicDepartmentClient<$Result.GetResult<Prisma.$AcademicDepartmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    academicFaculty<T extends AcademicFacultyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AcademicFacultyDefaultArgs<ExtArgs>>): Prisma__AcademicFacultyClient<$Result.GetResult<Prisma.$AcademicFacultyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    offeredCourseClassSchedules<T extends Faculty$offeredCourseClassSchedulesArgs<ExtArgs> = {}>(args?: Subset<T, Faculty$offeredCourseClassSchedulesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OfferedCourseClassSchedulePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Faculty model
   */
  interface FacultyFieldRefs {
    readonly id: FieldRef<"Faculty", 'String'>
    readonly facultyId: FieldRef<"Faculty", 'String'>
    readonly firstName: FieldRef<"Faculty", 'String'>
    readonly middleName: FieldRef<"Faculty", 'String'>
    readonly lastName: FieldRef<"Faculty", 'String'>
    readonly profileImage: FieldRef<"Faculty", 'String'>
    readonly email: FieldRef<"Faculty", 'String'>
    readonly contactNo: FieldRef<"Faculty", 'String'>
    readonly gender: FieldRef<"Faculty", 'String'>
    readonly designation: FieldRef<"Faculty", 'String'>
    readonly password: FieldRef<"Faculty", 'String'>
    readonly academicFacultyId: FieldRef<"Faculty", 'String'>
    readonly academicDepartmentId: FieldRef<"Faculty", 'String'>
    readonly createdAt: FieldRef<"Faculty", 'DateTime'>
    readonly updatedAt: FieldRef<"Faculty", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Faculty findUnique
   */
  export type FacultyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Faculty
     */
    select?: FacultySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Faculty
     */
    omit?: FacultyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacultyInclude<ExtArgs> | null
    /**
     * Filter, which Faculty to fetch.
     */
    where: FacultyWhereUniqueInput
  }

  /**
   * Faculty findUniqueOrThrow
   */
  export type FacultyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Faculty
     */
    select?: FacultySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Faculty
     */
    omit?: FacultyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacultyInclude<ExtArgs> | null
    /**
     * Filter, which Faculty to fetch.
     */
    where: FacultyWhereUniqueInput
  }

  /**
   * Faculty findFirst
   */
  export type FacultyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Faculty
     */
    select?: FacultySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Faculty
     */
    omit?: FacultyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacultyInclude<ExtArgs> | null
    /**
     * Filter, which Faculty to fetch.
     */
    where?: FacultyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Faculties to fetch.
     */
    orderBy?: FacultyOrderByWithRelationInput | FacultyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Faculties.
     */
    cursor?: FacultyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Faculties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Faculties.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Faculties.
     */
    distinct?: FacultyScalarFieldEnum | FacultyScalarFieldEnum[]
  }

  /**
   * Faculty findFirstOrThrow
   */
  export type FacultyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Faculty
     */
    select?: FacultySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Faculty
     */
    omit?: FacultyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacultyInclude<ExtArgs> | null
    /**
     * Filter, which Faculty to fetch.
     */
    where?: FacultyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Faculties to fetch.
     */
    orderBy?: FacultyOrderByWithRelationInput | FacultyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Faculties.
     */
    cursor?: FacultyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Faculties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Faculties.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Faculties.
     */
    distinct?: FacultyScalarFieldEnum | FacultyScalarFieldEnum[]
  }

  /**
   * Faculty findMany
   */
  export type FacultyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Faculty
     */
    select?: FacultySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Faculty
     */
    omit?: FacultyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacultyInclude<ExtArgs> | null
    /**
     * Filter, which Faculties to fetch.
     */
    where?: FacultyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Faculties to fetch.
     */
    orderBy?: FacultyOrderByWithRelationInput | FacultyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Faculties.
     */
    cursor?: FacultyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Faculties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Faculties.
     */
    skip?: number
    distinct?: FacultyScalarFieldEnum | FacultyScalarFieldEnum[]
  }

  /**
   * Faculty create
   */
  export type FacultyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Faculty
     */
    select?: FacultySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Faculty
     */
    omit?: FacultyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacultyInclude<ExtArgs> | null
    /**
     * The data needed to create a Faculty.
     */
    data: XOR<FacultyCreateInput, FacultyUncheckedCreateInput>
  }

  /**
   * Faculty createMany
   */
  export type FacultyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Faculties.
     */
    data: FacultyCreateManyInput | FacultyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Faculty update
   */
  export type FacultyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Faculty
     */
    select?: FacultySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Faculty
     */
    omit?: FacultyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacultyInclude<ExtArgs> | null
    /**
     * The data needed to update a Faculty.
     */
    data: XOR<FacultyUpdateInput, FacultyUncheckedUpdateInput>
    /**
     * Choose, which Faculty to update.
     */
    where: FacultyWhereUniqueInput
  }

  /**
   * Faculty updateMany
   */
  export type FacultyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Faculties.
     */
    data: XOR<FacultyUpdateManyMutationInput, FacultyUncheckedUpdateManyInput>
    /**
     * Filter which Faculties to update
     */
    where?: FacultyWhereInput
    /**
     * Limit how many Faculties to update.
     */
    limit?: number
  }

  /**
   * Faculty upsert
   */
  export type FacultyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Faculty
     */
    select?: FacultySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Faculty
     */
    omit?: FacultyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacultyInclude<ExtArgs> | null
    /**
     * The filter to search for the Faculty to update in case it exists.
     */
    where: FacultyWhereUniqueInput
    /**
     * In case the Faculty found by the `where` argument doesn't exist, create a new Faculty with this data.
     */
    create: XOR<FacultyCreateInput, FacultyUncheckedCreateInput>
    /**
     * In case the Faculty was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FacultyUpdateInput, FacultyUncheckedUpdateInput>
  }

  /**
   * Faculty delete
   */
  export type FacultyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Faculty
     */
    select?: FacultySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Faculty
     */
    omit?: FacultyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacultyInclude<ExtArgs> | null
    /**
     * Filter which Faculty to delete.
     */
    where: FacultyWhereUniqueInput
  }

  /**
   * Faculty deleteMany
   */
  export type FacultyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Faculties to delete
     */
    where?: FacultyWhereInput
    /**
     * Limit how many Faculties to delete.
     */
    limit?: number
  }

  /**
   * Faculty.courses
   */
  export type Faculty$coursesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseFaculty
     */
    select?: CourseFacultySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseFaculty
     */
    omit?: CourseFacultyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseFacultyInclude<ExtArgs> | null
    where?: CourseFacultyWhereInput
    orderBy?: CourseFacultyOrderByWithRelationInput | CourseFacultyOrderByWithRelationInput[]
    cursor?: CourseFacultyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CourseFacultyScalarFieldEnum | CourseFacultyScalarFieldEnum[]
  }

  /**
   * Faculty.offeredCourseClassSchedules
   */
  export type Faculty$offeredCourseClassSchedulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OfferedCourseClassSchedule
     */
    select?: OfferedCourseClassScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OfferedCourseClassSchedule
     */
    omit?: OfferedCourseClassScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OfferedCourseClassScheduleInclude<ExtArgs> | null
    where?: OfferedCourseClassScheduleWhereInput
    orderBy?: OfferedCourseClassScheduleOrderByWithRelationInput | OfferedCourseClassScheduleOrderByWithRelationInput[]
    cursor?: OfferedCourseClassScheduleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OfferedCourseClassScheduleScalarFieldEnum | OfferedCourseClassScheduleScalarFieldEnum[]
  }

  /**
   * Faculty without action
   */
  export type FacultyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Faculty
     */
    select?: FacultySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Faculty
     */
    omit?: FacultyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacultyInclude<ExtArgs> | null
  }


  /**
   * Model Building
   */

  export type AggregateBuilding = {
    _count: BuildingCountAggregateOutputType | null
    _min: BuildingMinAggregateOutputType | null
    _max: BuildingMaxAggregateOutputType | null
  }

  export type BuildingMinAggregateOutputType = {
    id: string | null
    title: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BuildingMaxAggregateOutputType = {
    id: string | null
    title: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BuildingCountAggregateOutputType = {
    id: number
    title: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BuildingMinAggregateInputType = {
    id?: true
    title?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BuildingMaxAggregateInputType = {
    id?: true
    title?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BuildingCountAggregateInputType = {
    id?: true
    title?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BuildingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Building to aggregate.
     */
    where?: BuildingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Buildings to fetch.
     */
    orderBy?: BuildingOrderByWithRelationInput | BuildingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BuildingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Buildings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Buildings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Buildings
    **/
    _count?: true | BuildingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BuildingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BuildingMaxAggregateInputType
  }

  export type GetBuildingAggregateType<T extends BuildingAggregateArgs> = {
        [P in keyof T & keyof AggregateBuilding]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBuilding[P]>
      : GetScalarType<T[P], AggregateBuilding[P]>
  }




  export type BuildingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BuildingWhereInput
    orderBy?: BuildingOrderByWithAggregationInput | BuildingOrderByWithAggregationInput[]
    by: BuildingScalarFieldEnum[] | BuildingScalarFieldEnum
    having?: BuildingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BuildingCountAggregateInputType | true
    _min?: BuildingMinAggregateInputType
    _max?: BuildingMaxAggregateInputType
  }

  export type BuildingGroupByOutputType = {
    id: string
    title: string
    createdAt: Date
    updatedAt: Date
    _count: BuildingCountAggregateOutputType | null
    _min: BuildingMinAggregateOutputType | null
    _max: BuildingMaxAggregateOutputType | null
  }

  type GetBuildingGroupByPayload<T extends BuildingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BuildingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BuildingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BuildingGroupByOutputType[P]>
            : GetScalarType<T[P], BuildingGroupByOutputType[P]>
        }
      >
    >


  export type BuildingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    rooms?: boolean | Building$roomsArgs<ExtArgs>
    _count?: boolean | BuildingCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["building"]>



  export type BuildingSelectScalar = {
    id?: boolean
    title?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type BuildingOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "createdAt" | "updatedAt", ExtArgs["result"]["building"]>
  export type BuildingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    rooms?: boolean | Building$roomsArgs<ExtArgs>
    _count?: boolean | BuildingCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $BuildingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Building"
    objects: {
      rooms: Prisma.$RoomPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["building"]>
    composites: {}
  }

  type BuildingGetPayload<S extends boolean | null | undefined | BuildingDefaultArgs> = $Result.GetResult<Prisma.$BuildingPayload, S>

  type BuildingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BuildingFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BuildingCountAggregateInputType | true
    }

  export interface BuildingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Building'], meta: { name: 'Building' } }
    /**
     * Find zero or one Building that matches the filter.
     * @param {BuildingFindUniqueArgs} args - Arguments to find a Building
     * @example
     * // Get one Building
     * const building = await prisma.building.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BuildingFindUniqueArgs>(args: SelectSubset<T, BuildingFindUniqueArgs<ExtArgs>>): Prisma__BuildingClient<$Result.GetResult<Prisma.$BuildingPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Building that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BuildingFindUniqueOrThrowArgs} args - Arguments to find a Building
     * @example
     * // Get one Building
     * const building = await prisma.building.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BuildingFindUniqueOrThrowArgs>(args: SelectSubset<T, BuildingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BuildingClient<$Result.GetResult<Prisma.$BuildingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Building that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BuildingFindFirstArgs} args - Arguments to find a Building
     * @example
     * // Get one Building
     * const building = await prisma.building.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BuildingFindFirstArgs>(args?: SelectSubset<T, BuildingFindFirstArgs<ExtArgs>>): Prisma__BuildingClient<$Result.GetResult<Prisma.$BuildingPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Building that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BuildingFindFirstOrThrowArgs} args - Arguments to find a Building
     * @example
     * // Get one Building
     * const building = await prisma.building.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BuildingFindFirstOrThrowArgs>(args?: SelectSubset<T, BuildingFindFirstOrThrowArgs<ExtArgs>>): Prisma__BuildingClient<$Result.GetResult<Prisma.$BuildingPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Buildings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BuildingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Buildings
     * const buildings = await prisma.building.findMany()
     * 
     * // Get first 10 Buildings
     * const buildings = await prisma.building.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const buildingWithIdOnly = await prisma.building.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BuildingFindManyArgs>(args?: SelectSubset<T, BuildingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BuildingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Building.
     * @param {BuildingCreateArgs} args - Arguments to create a Building.
     * @example
     * // Create one Building
     * const Building = await prisma.building.create({
     *   data: {
     *     // ... data to create a Building
     *   }
     * })
     * 
     */
    create<T extends BuildingCreateArgs>(args: SelectSubset<T, BuildingCreateArgs<ExtArgs>>): Prisma__BuildingClient<$Result.GetResult<Prisma.$BuildingPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Buildings.
     * @param {BuildingCreateManyArgs} args - Arguments to create many Buildings.
     * @example
     * // Create many Buildings
     * const building = await prisma.building.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BuildingCreateManyArgs>(args?: SelectSubset<T, BuildingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Building.
     * @param {BuildingDeleteArgs} args - Arguments to delete one Building.
     * @example
     * // Delete one Building
     * const Building = await prisma.building.delete({
     *   where: {
     *     // ... filter to delete one Building
     *   }
     * })
     * 
     */
    delete<T extends BuildingDeleteArgs>(args: SelectSubset<T, BuildingDeleteArgs<ExtArgs>>): Prisma__BuildingClient<$Result.GetResult<Prisma.$BuildingPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Building.
     * @param {BuildingUpdateArgs} args - Arguments to update one Building.
     * @example
     * // Update one Building
     * const building = await prisma.building.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BuildingUpdateArgs>(args: SelectSubset<T, BuildingUpdateArgs<ExtArgs>>): Prisma__BuildingClient<$Result.GetResult<Prisma.$BuildingPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Buildings.
     * @param {BuildingDeleteManyArgs} args - Arguments to filter Buildings to delete.
     * @example
     * // Delete a few Buildings
     * const { count } = await prisma.building.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BuildingDeleteManyArgs>(args?: SelectSubset<T, BuildingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Buildings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BuildingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Buildings
     * const building = await prisma.building.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BuildingUpdateManyArgs>(args: SelectSubset<T, BuildingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Building.
     * @param {BuildingUpsertArgs} args - Arguments to update or create a Building.
     * @example
     * // Update or create a Building
     * const building = await prisma.building.upsert({
     *   create: {
     *     // ... data to create a Building
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Building we want to update
     *   }
     * })
     */
    upsert<T extends BuildingUpsertArgs>(args: SelectSubset<T, BuildingUpsertArgs<ExtArgs>>): Prisma__BuildingClient<$Result.GetResult<Prisma.$BuildingPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Buildings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BuildingCountArgs} args - Arguments to filter Buildings to count.
     * @example
     * // Count the number of Buildings
     * const count = await prisma.building.count({
     *   where: {
     *     // ... the filter for the Buildings we want to count
     *   }
     * })
    **/
    count<T extends BuildingCountArgs>(
      args?: Subset<T, BuildingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BuildingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Building.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BuildingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BuildingAggregateArgs>(args: Subset<T, BuildingAggregateArgs>): Prisma.PrismaPromise<GetBuildingAggregateType<T>>

    /**
     * Group by Building.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BuildingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BuildingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BuildingGroupByArgs['orderBy'] }
        : { orderBy?: BuildingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BuildingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBuildingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Building model
   */
  readonly fields: BuildingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Building.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BuildingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    rooms<T extends Building$roomsArgs<ExtArgs> = {}>(args?: Subset<T, Building$roomsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoomPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Building model
   */
  interface BuildingFieldRefs {
    readonly id: FieldRef<"Building", 'String'>
    readonly title: FieldRef<"Building", 'String'>
    readonly createdAt: FieldRef<"Building", 'DateTime'>
    readonly updatedAt: FieldRef<"Building", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Building findUnique
   */
  export type BuildingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Building
     */
    select?: BuildingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Building
     */
    omit?: BuildingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BuildingInclude<ExtArgs> | null
    /**
     * Filter, which Building to fetch.
     */
    where: BuildingWhereUniqueInput
  }

  /**
   * Building findUniqueOrThrow
   */
  export type BuildingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Building
     */
    select?: BuildingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Building
     */
    omit?: BuildingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BuildingInclude<ExtArgs> | null
    /**
     * Filter, which Building to fetch.
     */
    where: BuildingWhereUniqueInput
  }

  /**
   * Building findFirst
   */
  export type BuildingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Building
     */
    select?: BuildingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Building
     */
    omit?: BuildingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BuildingInclude<ExtArgs> | null
    /**
     * Filter, which Building to fetch.
     */
    where?: BuildingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Buildings to fetch.
     */
    orderBy?: BuildingOrderByWithRelationInput | BuildingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Buildings.
     */
    cursor?: BuildingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Buildings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Buildings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Buildings.
     */
    distinct?: BuildingScalarFieldEnum | BuildingScalarFieldEnum[]
  }

  /**
   * Building findFirstOrThrow
   */
  export type BuildingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Building
     */
    select?: BuildingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Building
     */
    omit?: BuildingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BuildingInclude<ExtArgs> | null
    /**
     * Filter, which Building to fetch.
     */
    where?: BuildingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Buildings to fetch.
     */
    orderBy?: BuildingOrderByWithRelationInput | BuildingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Buildings.
     */
    cursor?: BuildingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Buildings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Buildings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Buildings.
     */
    distinct?: BuildingScalarFieldEnum | BuildingScalarFieldEnum[]
  }

  /**
   * Building findMany
   */
  export type BuildingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Building
     */
    select?: BuildingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Building
     */
    omit?: BuildingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BuildingInclude<ExtArgs> | null
    /**
     * Filter, which Buildings to fetch.
     */
    where?: BuildingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Buildings to fetch.
     */
    orderBy?: BuildingOrderByWithRelationInput | BuildingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Buildings.
     */
    cursor?: BuildingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Buildings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Buildings.
     */
    skip?: number
    distinct?: BuildingScalarFieldEnum | BuildingScalarFieldEnum[]
  }

  /**
   * Building create
   */
  export type BuildingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Building
     */
    select?: BuildingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Building
     */
    omit?: BuildingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BuildingInclude<ExtArgs> | null
    /**
     * The data needed to create a Building.
     */
    data: XOR<BuildingCreateInput, BuildingUncheckedCreateInput>
  }

  /**
   * Building createMany
   */
  export type BuildingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Buildings.
     */
    data: BuildingCreateManyInput | BuildingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Building update
   */
  export type BuildingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Building
     */
    select?: BuildingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Building
     */
    omit?: BuildingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BuildingInclude<ExtArgs> | null
    /**
     * The data needed to update a Building.
     */
    data: XOR<BuildingUpdateInput, BuildingUncheckedUpdateInput>
    /**
     * Choose, which Building to update.
     */
    where: BuildingWhereUniqueInput
  }

  /**
   * Building updateMany
   */
  export type BuildingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Buildings.
     */
    data: XOR<BuildingUpdateManyMutationInput, BuildingUncheckedUpdateManyInput>
    /**
     * Filter which Buildings to update
     */
    where?: BuildingWhereInput
    /**
     * Limit how many Buildings to update.
     */
    limit?: number
  }

  /**
   * Building upsert
   */
  export type BuildingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Building
     */
    select?: BuildingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Building
     */
    omit?: BuildingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BuildingInclude<ExtArgs> | null
    /**
     * The filter to search for the Building to update in case it exists.
     */
    where: BuildingWhereUniqueInput
    /**
     * In case the Building found by the `where` argument doesn't exist, create a new Building with this data.
     */
    create: XOR<BuildingCreateInput, BuildingUncheckedCreateInput>
    /**
     * In case the Building was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BuildingUpdateInput, BuildingUncheckedUpdateInput>
  }

  /**
   * Building delete
   */
  export type BuildingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Building
     */
    select?: BuildingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Building
     */
    omit?: BuildingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BuildingInclude<ExtArgs> | null
    /**
     * Filter which Building to delete.
     */
    where: BuildingWhereUniqueInput
  }

  /**
   * Building deleteMany
   */
  export type BuildingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Buildings to delete
     */
    where?: BuildingWhereInput
    /**
     * Limit how many Buildings to delete.
     */
    limit?: number
  }

  /**
   * Building.rooms
   */
  export type Building$roomsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Room
     */
    select?: RoomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Room
     */
    omit?: RoomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomInclude<ExtArgs> | null
    where?: RoomWhereInput
    orderBy?: RoomOrderByWithRelationInput | RoomOrderByWithRelationInput[]
    cursor?: RoomWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RoomScalarFieldEnum | RoomScalarFieldEnum[]
  }

  /**
   * Building without action
   */
  export type BuildingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Building
     */
    select?: BuildingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Building
     */
    omit?: BuildingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BuildingInclude<ExtArgs> | null
  }


  /**
   * Model Room
   */

  export type AggregateRoom = {
    _count: RoomCountAggregateOutputType | null
    _min: RoomMinAggregateOutputType | null
    _max: RoomMaxAggregateOutputType | null
  }

  export type RoomMinAggregateOutputType = {
    id: string | null
    roomNumber: string | null
    floor: string | null
    buildingId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RoomMaxAggregateOutputType = {
    id: string | null
    roomNumber: string | null
    floor: string | null
    buildingId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RoomCountAggregateOutputType = {
    id: number
    roomNumber: number
    floor: number
    buildingId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type RoomMinAggregateInputType = {
    id?: true
    roomNumber?: true
    floor?: true
    buildingId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RoomMaxAggregateInputType = {
    id?: true
    roomNumber?: true
    floor?: true
    buildingId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RoomCountAggregateInputType = {
    id?: true
    roomNumber?: true
    floor?: true
    buildingId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type RoomAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Room to aggregate.
     */
    where?: RoomWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Rooms to fetch.
     */
    orderBy?: RoomOrderByWithRelationInput | RoomOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RoomWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Rooms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Rooms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Rooms
    **/
    _count?: true | RoomCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RoomMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RoomMaxAggregateInputType
  }

  export type GetRoomAggregateType<T extends RoomAggregateArgs> = {
        [P in keyof T & keyof AggregateRoom]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRoom[P]>
      : GetScalarType<T[P], AggregateRoom[P]>
  }




  export type RoomGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoomWhereInput
    orderBy?: RoomOrderByWithAggregationInput | RoomOrderByWithAggregationInput[]
    by: RoomScalarFieldEnum[] | RoomScalarFieldEnum
    having?: RoomScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RoomCountAggregateInputType | true
    _min?: RoomMinAggregateInputType
    _max?: RoomMaxAggregateInputType
  }

  export type RoomGroupByOutputType = {
    id: string
    roomNumber: string
    floor: string
    buildingId: string
    createdAt: Date
    updatedAt: Date
    _count: RoomCountAggregateOutputType | null
    _min: RoomMinAggregateOutputType | null
    _max: RoomMaxAggregateOutputType | null
  }

  type GetRoomGroupByPayload<T extends RoomGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RoomGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RoomGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RoomGroupByOutputType[P]>
            : GetScalarType<T[P], RoomGroupByOutputType[P]>
        }
      >
    >


  export type RoomSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    roomNumber?: boolean
    floor?: boolean
    buildingId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    building?: boolean | BuildingDefaultArgs<ExtArgs>
    offeredCourseClassSchedules?: boolean | Room$offeredCourseClassSchedulesArgs<ExtArgs>
    _count?: boolean | RoomCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["room"]>



  export type RoomSelectScalar = {
    id?: boolean
    roomNumber?: boolean
    floor?: boolean
    buildingId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type RoomOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "roomNumber" | "floor" | "buildingId" | "createdAt" | "updatedAt", ExtArgs["result"]["room"]>
  export type RoomInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    building?: boolean | BuildingDefaultArgs<ExtArgs>
    offeredCourseClassSchedules?: boolean | Room$offeredCourseClassSchedulesArgs<ExtArgs>
    _count?: boolean | RoomCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $RoomPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Room"
    objects: {
      building: Prisma.$BuildingPayload<ExtArgs>
      offeredCourseClassSchedules: Prisma.$OfferedCourseClassSchedulePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      roomNumber: string
      floor: string
      buildingId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["room"]>
    composites: {}
  }

  type RoomGetPayload<S extends boolean | null | undefined | RoomDefaultArgs> = $Result.GetResult<Prisma.$RoomPayload, S>

  type RoomCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RoomFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RoomCountAggregateInputType | true
    }

  export interface RoomDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Room'], meta: { name: 'Room' } }
    /**
     * Find zero or one Room that matches the filter.
     * @param {RoomFindUniqueArgs} args - Arguments to find a Room
     * @example
     * // Get one Room
     * const room = await prisma.room.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RoomFindUniqueArgs>(args: SelectSubset<T, RoomFindUniqueArgs<ExtArgs>>): Prisma__RoomClient<$Result.GetResult<Prisma.$RoomPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Room that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RoomFindUniqueOrThrowArgs} args - Arguments to find a Room
     * @example
     * // Get one Room
     * const room = await prisma.room.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RoomFindUniqueOrThrowArgs>(args: SelectSubset<T, RoomFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RoomClient<$Result.GetResult<Prisma.$RoomPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Room that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomFindFirstArgs} args - Arguments to find a Room
     * @example
     * // Get one Room
     * const room = await prisma.room.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RoomFindFirstArgs>(args?: SelectSubset<T, RoomFindFirstArgs<ExtArgs>>): Prisma__RoomClient<$Result.GetResult<Prisma.$RoomPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Room that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomFindFirstOrThrowArgs} args - Arguments to find a Room
     * @example
     * // Get one Room
     * const room = await prisma.room.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RoomFindFirstOrThrowArgs>(args?: SelectSubset<T, RoomFindFirstOrThrowArgs<ExtArgs>>): Prisma__RoomClient<$Result.GetResult<Prisma.$RoomPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Rooms that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Rooms
     * const rooms = await prisma.room.findMany()
     * 
     * // Get first 10 Rooms
     * const rooms = await prisma.room.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const roomWithIdOnly = await prisma.room.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RoomFindManyArgs>(args?: SelectSubset<T, RoomFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoomPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Room.
     * @param {RoomCreateArgs} args - Arguments to create a Room.
     * @example
     * // Create one Room
     * const Room = await prisma.room.create({
     *   data: {
     *     // ... data to create a Room
     *   }
     * })
     * 
     */
    create<T extends RoomCreateArgs>(args: SelectSubset<T, RoomCreateArgs<ExtArgs>>): Prisma__RoomClient<$Result.GetResult<Prisma.$RoomPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Rooms.
     * @param {RoomCreateManyArgs} args - Arguments to create many Rooms.
     * @example
     * // Create many Rooms
     * const room = await prisma.room.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RoomCreateManyArgs>(args?: SelectSubset<T, RoomCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Room.
     * @param {RoomDeleteArgs} args - Arguments to delete one Room.
     * @example
     * // Delete one Room
     * const Room = await prisma.room.delete({
     *   where: {
     *     // ... filter to delete one Room
     *   }
     * })
     * 
     */
    delete<T extends RoomDeleteArgs>(args: SelectSubset<T, RoomDeleteArgs<ExtArgs>>): Prisma__RoomClient<$Result.GetResult<Prisma.$RoomPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Room.
     * @param {RoomUpdateArgs} args - Arguments to update one Room.
     * @example
     * // Update one Room
     * const room = await prisma.room.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RoomUpdateArgs>(args: SelectSubset<T, RoomUpdateArgs<ExtArgs>>): Prisma__RoomClient<$Result.GetResult<Prisma.$RoomPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Rooms.
     * @param {RoomDeleteManyArgs} args - Arguments to filter Rooms to delete.
     * @example
     * // Delete a few Rooms
     * const { count } = await prisma.room.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RoomDeleteManyArgs>(args?: SelectSubset<T, RoomDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Rooms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Rooms
     * const room = await prisma.room.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RoomUpdateManyArgs>(args: SelectSubset<T, RoomUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Room.
     * @param {RoomUpsertArgs} args - Arguments to update or create a Room.
     * @example
     * // Update or create a Room
     * const room = await prisma.room.upsert({
     *   create: {
     *     // ... data to create a Room
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Room we want to update
     *   }
     * })
     */
    upsert<T extends RoomUpsertArgs>(args: SelectSubset<T, RoomUpsertArgs<ExtArgs>>): Prisma__RoomClient<$Result.GetResult<Prisma.$RoomPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Rooms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomCountArgs} args - Arguments to filter Rooms to count.
     * @example
     * // Count the number of Rooms
     * const count = await prisma.room.count({
     *   where: {
     *     // ... the filter for the Rooms we want to count
     *   }
     * })
    **/
    count<T extends RoomCountArgs>(
      args?: Subset<T, RoomCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RoomCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Room.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RoomAggregateArgs>(args: Subset<T, RoomAggregateArgs>): Prisma.PrismaPromise<GetRoomAggregateType<T>>

    /**
     * Group by Room.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RoomGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RoomGroupByArgs['orderBy'] }
        : { orderBy?: RoomGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RoomGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRoomGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Room model
   */
  readonly fields: RoomFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Room.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RoomClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    building<T extends BuildingDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BuildingDefaultArgs<ExtArgs>>): Prisma__BuildingClient<$Result.GetResult<Prisma.$BuildingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    offeredCourseClassSchedules<T extends Room$offeredCourseClassSchedulesArgs<ExtArgs> = {}>(args?: Subset<T, Room$offeredCourseClassSchedulesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OfferedCourseClassSchedulePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Room model
   */
  interface RoomFieldRefs {
    readonly id: FieldRef<"Room", 'String'>
    readonly roomNumber: FieldRef<"Room", 'String'>
    readonly floor: FieldRef<"Room", 'String'>
    readonly buildingId: FieldRef<"Room", 'String'>
    readonly createdAt: FieldRef<"Room", 'DateTime'>
    readonly updatedAt: FieldRef<"Room", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Room findUnique
   */
  export type RoomFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Room
     */
    select?: RoomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Room
     */
    omit?: RoomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomInclude<ExtArgs> | null
    /**
     * Filter, which Room to fetch.
     */
    where: RoomWhereUniqueInput
  }

  /**
   * Room findUniqueOrThrow
   */
  export type RoomFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Room
     */
    select?: RoomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Room
     */
    omit?: RoomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomInclude<ExtArgs> | null
    /**
     * Filter, which Room to fetch.
     */
    where: RoomWhereUniqueInput
  }

  /**
   * Room findFirst
   */
  export type RoomFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Room
     */
    select?: RoomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Room
     */
    omit?: RoomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomInclude<ExtArgs> | null
    /**
     * Filter, which Room to fetch.
     */
    where?: RoomWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Rooms to fetch.
     */
    orderBy?: RoomOrderByWithRelationInput | RoomOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Rooms.
     */
    cursor?: RoomWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Rooms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Rooms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Rooms.
     */
    distinct?: RoomScalarFieldEnum | RoomScalarFieldEnum[]
  }

  /**
   * Room findFirstOrThrow
   */
  export type RoomFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Room
     */
    select?: RoomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Room
     */
    omit?: RoomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomInclude<ExtArgs> | null
    /**
     * Filter, which Room to fetch.
     */
    where?: RoomWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Rooms to fetch.
     */
    orderBy?: RoomOrderByWithRelationInput | RoomOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Rooms.
     */
    cursor?: RoomWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Rooms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Rooms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Rooms.
     */
    distinct?: RoomScalarFieldEnum | RoomScalarFieldEnum[]
  }

  /**
   * Room findMany
   */
  export type RoomFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Room
     */
    select?: RoomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Room
     */
    omit?: RoomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomInclude<ExtArgs> | null
    /**
     * Filter, which Rooms to fetch.
     */
    where?: RoomWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Rooms to fetch.
     */
    orderBy?: RoomOrderByWithRelationInput | RoomOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Rooms.
     */
    cursor?: RoomWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Rooms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Rooms.
     */
    skip?: number
    distinct?: RoomScalarFieldEnum | RoomScalarFieldEnum[]
  }

  /**
   * Room create
   */
  export type RoomCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Room
     */
    select?: RoomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Room
     */
    omit?: RoomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomInclude<ExtArgs> | null
    /**
     * The data needed to create a Room.
     */
    data: XOR<RoomCreateInput, RoomUncheckedCreateInput>
  }

  /**
   * Room createMany
   */
  export type RoomCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Rooms.
     */
    data: RoomCreateManyInput | RoomCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Room update
   */
  export type RoomUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Room
     */
    select?: RoomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Room
     */
    omit?: RoomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomInclude<ExtArgs> | null
    /**
     * The data needed to update a Room.
     */
    data: XOR<RoomUpdateInput, RoomUncheckedUpdateInput>
    /**
     * Choose, which Room to update.
     */
    where: RoomWhereUniqueInput
  }

  /**
   * Room updateMany
   */
  export type RoomUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Rooms.
     */
    data: XOR<RoomUpdateManyMutationInput, RoomUncheckedUpdateManyInput>
    /**
     * Filter which Rooms to update
     */
    where?: RoomWhereInput
    /**
     * Limit how many Rooms to update.
     */
    limit?: number
  }

  /**
   * Room upsert
   */
  export type RoomUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Room
     */
    select?: RoomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Room
     */
    omit?: RoomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomInclude<ExtArgs> | null
    /**
     * The filter to search for the Room to update in case it exists.
     */
    where: RoomWhereUniqueInput
    /**
     * In case the Room found by the `where` argument doesn't exist, create a new Room with this data.
     */
    create: XOR<RoomCreateInput, RoomUncheckedCreateInput>
    /**
     * In case the Room was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RoomUpdateInput, RoomUncheckedUpdateInput>
  }

  /**
   * Room delete
   */
  export type RoomDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Room
     */
    select?: RoomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Room
     */
    omit?: RoomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomInclude<ExtArgs> | null
    /**
     * Filter which Room to delete.
     */
    where: RoomWhereUniqueInput
  }

  /**
   * Room deleteMany
   */
  export type RoomDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Rooms to delete
     */
    where?: RoomWhereInput
    /**
     * Limit how many Rooms to delete.
     */
    limit?: number
  }

  /**
   * Room.offeredCourseClassSchedules
   */
  export type Room$offeredCourseClassSchedulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OfferedCourseClassSchedule
     */
    select?: OfferedCourseClassScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OfferedCourseClassSchedule
     */
    omit?: OfferedCourseClassScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OfferedCourseClassScheduleInclude<ExtArgs> | null
    where?: OfferedCourseClassScheduleWhereInput
    orderBy?: OfferedCourseClassScheduleOrderByWithRelationInput | OfferedCourseClassScheduleOrderByWithRelationInput[]
    cursor?: OfferedCourseClassScheduleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OfferedCourseClassScheduleScalarFieldEnum | OfferedCourseClassScheduleScalarFieldEnum[]
  }

  /**
   * Room without action
   */
  export type RoomDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Room
     */
    select?: RoomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Room
     */
    omit?: RoomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomInclude<ExtArgs> | null
  }


  /**
   * Model Course
   */

  export type AggregateCourse = {
    _count: CourseCountAggregateOutputType | null
    _avg: CourseAvgAggregateOutputType | null
    _sum: CourseSumAggregateOutputType | null
    _min: CourseMinAggregateOutputType | null
    _max: CourseMaxAggregateOutputType | null
  }

  export type CourseAvgAggregateOutputType = {
    credits: number | null
  }

  export type CourseSumAggregateOutputType = {
    credits: number | null
  }

  export type CourseMinAggregateOutputType = {
    id: string | null
    title: string | null
    code: string | null
    credits: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CourseMaxAggregateOutputType = {
    id: string | null
    title: string | null
    code: string | null
    credits: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CourseCountAggregateOutputType = {
    id: number
    title: number
    code: number
    credits: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CourseAvgAggregateInputType = {
    credits?: true
  }

  export type CourseSumAggregateInputType = {
    credits?: true
  }

  export type CourseMinAggregateInputType = {
    id?: true
    title?: true
    code?: true
    credits?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CourseMaxAggregateInputType = {
    id?: true
    title?: true
    code?: true
    credits?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CourseCountAggregateInputType = {
    id?: true
    title?: true
    code?: true
    credits?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CourseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Course to aggregate.
     */
    where?: CourseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Courses to fetch.
     */
    orderBy?: CourseOrderByWithRelationInput | CourseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CourseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Courses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Courses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Courses
    **/
    _count?: true | CourseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CourseAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CourseSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CourseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CourseMaxAggregateInputType
  }

  export type GetCourseAggregateType<T extends CourseAggregateArgs> = {
        [P in keyof T & keyof AggregateCourse]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCourse[P]>
      : GetScalarType<T[P], AggregateCourse[P]>
  }




  export type CourseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CourseWhereInput
    orderBy?: CourseOrderByWithAggregationInput | CourseOrderByWithAggregationInput[]
    by: CourseScalarFieldEnum[] | CourseScalarFieldEnum
    having?: CourseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CourseCountAggregateInputType | true
    _avg?: CourseAvgAggregateInputType
    _sum?: CourseSumAggregateInputType
    _min?: CourseMinAggregateInputType
    _max?: CourseMaxAggregateInputType
  }

  export type CourseGroupByOutputType = {
    id: string
    title: string
    code: string
    credits: number
    createdAt: Date
    updatedAt: Date
    _count: CourseCountAggregateOutputType | null
    _avg: CourseAvgAggregateOutputType | null
    _sum: CourseSumAggregateOutputType | null
    _min: CourseMinAggregateOutputType | null
    _max: CourseMaxAggregateOutputType | null
  }

  type GetCourseGroupByPayload<T extends CourseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CourseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CourseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CourseGroupByOutputType[P]>
            : GetScalarType<T[P], CourseGroupByOutputType[P]>
        }
      >
    >


  export type CourseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    code?: boolean
    credits?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    preRequisite?: boolean | Course$preRequisiteArgs<ExtArgs>
    preRequisiteFor?: boolean | Course$preRequisiteForArgs<ExtArgs>
    faculties?: boolean | Course$facultiesArgs<ExtArgs>
    offeredCourses?: boolean | Course$offeredCoursesArgs<ExtArgs>
    studentEnrolledCourses?: boolean | Course$studentEnrolledCoursesArgs<ExtArgs>
    _count?: boolean | CourseCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["course"]>



  export type CourseSelectScalar = {
    id?: boolean
    title?: boolean
    code?: boolean
    credits?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CourseOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "code" | "credits" | "createdAt" | "updatedAt", ExtArgs["result"]["course"]>
  export type CourseInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    preRequisite?: boolean | Course$preRequisiteArgs<ExtArgs>
    preRequisiteFor?: boolean | Course$preRequisiteForArgs<ExtArgs>
    faculties?: boolean | Course$facultiesArgs<ExtArgs>
    offeredCourses?: boolean | Course$offeredCoursesArgs<ExtArgs>
    studentEnrolledCourses?: boolean | Course$studentEnrolledCoursesArgs<ExtArgs>
    _count?: boolean | CourseCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $CoursePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Course"
    objects: {
      preRequisite: Prisma.$CourseToPreRequisitePayload<ExtArgs>[]
      preRequisiteFor: Prisma.$CourseToPreRequisitePayload<ExtArgs>[]
      faculties: Prisma.$CourseFacultyPayload<ExtArgs>[]
      offeredCourses: Prisma.$OfferedCoursePayload<ExtArgs>[]
      studentEnrolledCourses: Prisma.$StudentEnrolledCoursePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      code: string
      credits: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["course"]>
    composites: {}
  }

  type CourseGetPayload<S extends boolean | null | undefined | CourseDefaultArgs> = $Result.GetResult<Prisma.$CoursePayload, S>

  type CourseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CourseFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CourseCountAggregateInputType | true
    }

  export interface CourseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Course'], meta: { name: 'Course' } }
    /**
     * Find zero or one Course that matches the filter.
     * @param {CourseFindUniqueArgs} args - Arguments to find a Course
     * @example
     * // Get one Course
     * const course = await prisma.course.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CourseFindUniqueArgs>(args: SelectSubset<T, CourseFindUniqueArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Course that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CourseFindUniqueOrThrowArgs} args - Arguments to find a Course
     * @example
     * // Get one Course
     * const course = await prisma.course.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CourseFindUniqueOrThrowArgs>(args: SelectSubset<T, CourseFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Course that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseFindFirstArgs} args - Arguments to find a Course
     * @example
     * // Get one Course
     * const course = await prisma.course.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CourseFindFirstArgs>(args?: SelectSubset<T, CourseFindFirstArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Course that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseFindFirstOrThrowArgs} args - Arguments to find a Course
     * @example
     * // Get one Course
     * const course = await prisma.course.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CourseFindFirstOrThrowArgs>(args?: SelectSubset<T, CourseFindFirstOrThrowArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Courses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Courses
     * const courses = await prisma.course.findMany()
     * 
     * // Get first 10 Courses
     * const courses = await prisma.course.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const courseWithIdOnly = await prisma.course.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CourseFindManyArgs>(args?: SelectSubset<T, CourseFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Course.
     * @param {CourseCreateArgs} args - Arguments to create a Course.
     * @example
     * // Create one Course
     * const Course = await prisma.course.create({
     *   data: {
     *     // ... data to create a Course
     *   }
     * })
     * 
     */
    create<T extends CourseCreateArgs>(args: SelectSubset<T, CourseCreateArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Courses.
     * @param {CourseCreateManyArgs} args - Arguments to create many Courses.
     * @example
     * // Create many Courses
     * const course = await prisma.course.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CourseCreateManyArgs>(args?: SelectSubset<T, CourseCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Course.
     * @param {CourseDeleteArgs} args - Arguments to delete one Course.
     * @example
     * // Delete one Course
     * const Course = await prisma.course.delete({
     *   where: {
     *     // ... filter to delete one Course
     *   }
     * })
     * 
     */
    delete<T extends CourseDeleteArgs>(args: SelectSubset<T, CourseDeleteArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Course.
     * @param {CourseUpdateArgs} args - Arguments to update one Course.
     * @example
     * // Update one Course
     * const course = await prisma.course.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CourseUpdateArgs>(args: SelectSubset<T, CourseUpdateArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Courses.
     * @param {CourseDeleteManyArgs} args - Arguments to filter Courses to delete.
     * @example
     * // Delete a few Courses
     * const { count } = await prisma.course.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CourseDeleteManyArgs>(args?: SelectSubset<T, CourseDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Courses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Courses
     * const course = await prisma.course.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CourseUpdateManyArgs>(args: SelectSubset<T, CourseUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Course.
     * @param {CourseUpsertArgs} args - Arguments to update or create a Course.
     * @example
     * // Update or create a Course
     * const course = await prisma.course.upsert({
     *   create: {
     *     // ... data to create a Course
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Course we want to update
     *   }
     * })
     */
    upsert<T extends CourseUpsertArgs>(args: SelectSubset<T, CourseUpsertArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Courses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseCountArgs} args - Arguments to filter Courses to count.
     * @example
     * // Count the number of Courses
     * const count = await prisma.course.count({
     *   where: {
     *     // ... the filter for the Courses we want to count
     *   }
     * })
    **/
    count<T extends CourseCountArgs>(
      args?: Subset<T, CourseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CourseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Course.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CourseAggregateArgs>(args: Subset<T, CourseAggregateArgs>): Prisma.PrismaPromise<GetCourseAggregateType<T>>

    /**
     * Group by Course.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CourseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CourseGroupByArgs['orderBy'] }
        : { orderBy?: CourseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CourseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCourseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Course model
   */
  readonly fields: CourseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Course.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CourseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    preRequisite<T extends Course$preRequisiteArgs<ExtArgs> = {}>(args?: Subset<T, Course$preRequisiteArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CourseToPreRequisitePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    preRequisiteFor<T extends Course$preRequisiteForArgs<ExtArgs> = {}>(args?: Subset<T, Course$preRequisiteForArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CourseToPreRequisitePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    faculties<T extends Course$facultiesArgs<ExtArgs> = {}>(args?: Subset<T, Course$facultiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CourseFacultyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    offeredCourses<T extends Course$offeredCoursesArgs<ExtArgs> = {}>(args?: Subset<T, Course$offeredCoursesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OfferedCoursePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    studentEnrolledCourses<T extends Course$studentEnrolledCoursesArgs<ExtArgs> = {}>(args?: Subset<T, Course$studentEnrolledCoursesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentEnrolledCoursePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Course model
   */
  interface CourseFieldRefs {
    readonly id: FieldRef<"Course", 'String'>
    readonly title: FieldRef<"Course", 'String'>
    readonly code: FieldRef<"Course", 'String'>
    readonly credits: FieldRef<"Course", 'Int'>
    readonly createdAt: FieldRef<"Course", 'DateTime'>
    readonly updatedAt: FieldRef<"Course", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Course findUnique
   */
  export type CourseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Course
     */
    omit?: CourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * Filter, which Course to fetch.
     */
    where: CourseWhereUniqueInput
  }

  /**
   * Course findUniqueOrThrow
   */
  export type CourseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Course
     */
    omit?: CourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * Filter, which Course to fetch.
     */
    where: CourseWhereUniqueInput
  }

  /**
   * Course findFirst
   */
  export type CourseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Course
     */
    omit?: CourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * Filter, which Course to fetch.
     */
    where?: CourseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Courses to fetch.
     */
    orderBy?: CourseOrderByWithRelationInput | CourseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Courses.
     */
    cursor?: CourseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Courses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Courses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Courses.
     */
    distinct?: CourseScalarFieldEnum | CourseScalarFieldEnum[]
  }

  /**
   * Course findFirstOrThrow
   */
  export type CourseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Course
     */
    omit?: CourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * Filter, which Course to fetch.
     */
    where?: CourseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Courses to fetch.
     */
    orderBy?: CourseOrderByWithRelationInput | CourseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Courses.
     */
    cursor?: CourseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Courses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Courses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Courses.
     */
    distinct?: CourseScalarFieldEnum | CourseScalarFieldEnum[]
  }

  /**
   * Course findMany
   */
  export type CourseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Course
     */
    omit?: CourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * Filter, which Courses to fetch.
     */
    where?: CourseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Courses to fetch.
     */
    orderBy?: CourseOrderByWithRelationInput | CourseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Courses.
     */
    cursor?: CourseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Courses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Courses.
     */
    skip?: number
    distinct?: CourseScalarFieldEnum | CourseScalarFieldEnum[]
  }

  /**
   * Course create
   */
  export type CourseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Course
     */
    omit?: CourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * The data needed to create a Course.
     */
    data: XOR<CourseCreateInput, CourseUncheckedCreateInput>
  }

  /**
   * Course createMany
   */
  export type CourseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Courses.
     */
    data: CourseCreateManyInput | CourseCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Course update
   */
  export type CourseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Course
     */
    omit?: CourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * The data needed to update a Course.
     */
    data: XOR<CourseUpdateInput, CourseUncheckedUpdateInput>
    /**
     * Choose, which Course to update.
     */
    where: CourseWhereUniqueInput
  }

  /**
   * Course updateMany
   */
  export type CourseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Courses.
     */
    data: XOR<CourseUpdateManyMutationInput, CourseUncheckedUpdateManyInput>
    /**
     * Filter which Courses to update
     */
    where?: CourseWhereInput
    /**
     * Limit how many Courses to update.
     */
    limit?: number
  }

  /**
   * Course upsert
   */
  export type CourseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Course
     */
    omit?: CourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * The filter to search for the Course to update in case it exists.
     */
    where: CourseWhereUniqueInput
    /**
     * In case the Course found by the `where` argument doesn't exist, create a new Course with this data.
     */
    create: XOR<CourseCreateInput, CourseUncheckedCreateInput>
    /**
     * In case the Course was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CourseUpdateInput, CourseUncheckedUpdateInput>
  }

  /**
   * Course delete
   */
  export type CourseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Course
     */
    omit?: CourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * Filter which Course to delete.
     */
    where: CourseWhereUniqueInput
  }

  /**
   * Course deleteMany
   */
  export type CourseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Courses to delete
     */
    where?: CourseWhereInput
    /**
     * Limit how many Courses to delete.
     */
    limit?: number
  }

  /**
   * Course.preRequisite
   */
  export type Course$preRequisiteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseToPreRequisite
     */
    select?: CourseToPreRequisiteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseToPreRequisite
     */
    omit?: CourseToPreRequisiteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseToPreRequisiteInclude<ExtArgs> | null
    where?: CourseToPreRequisiteWhereInput
    orderBy?: CourseToPreRequisiteOrderByWithRelationInput | CourseToPreRequisiteOrderByWithRelationInput[]
    cursor?: CourseToPreRequisiteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CourseToPreRequisiteScalarFieldEnum | CourseToPreRequisiteScalarFieldEnum[]
  }

  /**
   * Course.preRequisiteFor
   */
  export type Course$preRequisiteForArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseToPreRequisite
     */
    select?: CourseToPreRequisiteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseToPreRequisite
     */
    omit?: CourseToPreRequisiteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseToPreRequisiteInclude<ExtArgs> | null
    where?: CourseToPreRequisiteWhereInput
    orderBy?: CourseToPreRequisiteOrderByWithRelationInput | CourseToPreRequisiteOrderByWithRelationInput[]
    cursor?: CourseToPreRequisiteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CourseToPreRequisiteScalarFieldEnum | CourseToPreRequisiteScalarFieldEnum[]
  }

  /**
   * Course.faculties
   */
  export type Course$facultiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseFaculty
     */
    select?: CourseFacultySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseFaculty
     */
    omit?: CourseFacultyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseFacultyInclude<ExtArgs> | null
    where?: CourseFacultyWhereInput
    orderBy?: CourseFacultyOrderByWithRelationInput | CourseFacultyOrderByWithRelationInput[]
    cursor?: CourseFacultyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CourseFacultyScalarFieldEnum | CourseFacultyScalarFieldEnum[]
  }

  /**
   * Course.offeredCourses
   */
  export type Course$offeredCoursesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OfferedCourse
     */
    select?: OfferedCourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OfferedCourse
     */
    omit?: OfferedCourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OfferedCourseInclude<ExtArgs> | null
    where?: OfferedCourseWhereInput
    orderBy?: OfferedCourseOrderByWithRelationInput | OfferedCourseOrderByWithRelationInput[]
    cursor?: OfferedCourseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OfferedCourseScalarFieldEnum | OfferedCourseScalarFieldEnum[]
  }

  /**
   * Course.studentEnrolledCourses
   */
  export type Course$studentEnrolledCoursesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentEnrolledCourse
     */
    select?: StudentEnrolledCourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentEnrolledCourse
     */
    omit?: StudentEnrolledCourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentEnrolledCourseInclude<ExtArgs> | null
    where?: StudentEnrolledCourseWhereInput
    orderBy?: StudentEnrolledCourseOrderByWithRelationInput | StudentEnrolledCourseOrderByWithRelationInput[]
    cursor?: StudentEnrolledCourseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StudentEnrolledCourseScalarFieldEnum | StudentEnrolledCourseScalarFieldEnum[]
  }

  /**
   * Course without action
   */
  export type CourseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Course
     */
    omit?: CourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
  }


  /**
   * Model CourseToPreRequisite
   */

  export type AggregateCourseToPreRequisite = {
    _count: CourseToPreRequisiteCountAggregateOutputType | null
    _min: CourseToPreRequisiteMinAggregateOutputType | null
    _max: CourseToPreRequisiteMaxAggregateOutputType | null
  }

  export type CourseToPreRequisiteMinAggregateOutputType = {
    courseId: string | null
    preRequisiteId: string | null
  }

  export type CourseToPreRequisiteMaxAggregateOutputType = {
    courseId: string | null
    preRequisiteId: string | null
  }

  export type CourseToPreRequisiteCountAggregateOutputType = {
    courseId: number
    preRequisiteId: number
    _all: number
  }


  export type CourseToPreRequisiteMinAggregateInputType = {
    courseId?: true
    preRequisiteId?: true
  }

  export type CourseToPreRequisiteMaxAggregateInputType = {
    courseId?: true
    preRequisiteId?: true
  }

  export type CourseToPreRequisiteCountAggregateInputType = {
    courseId?: true
    preRequisiteId?: true
    _all?: true
  }

  export type CourseToPreRequisiteAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CourseToPreRequisite to aggregate.
     */
    where?: CourseToPreRequisiteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CourseToPreRequisites to fetch.
     */
    orderBy?: CourseToPreRequisiteOrderByWithRelationInput | CourseToPreRequisiteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CourseToPreRequisiteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CourseToPreRequisites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CourseToPreRequisites.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CourseToPreRequisites
    **/
    _count?: true | CourseToPreRequisiteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CourseToPreRequisiteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CourseToPreRequisiteMaxAggregateInputType
  }

  export type GetCourseToPreRequisiteAggregateType<T extends CourseToPreRequisiteAggregateArgs> = {
        [P in keyof T & keyof AggregateCourseToPreRequisite]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCourseToPreRequisite[P]>
      : GetScalarType<T[P], AggregateCourseToPreRequisite[P]>
  }




  export type CourseToPreRequisiteGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CourseToPreRequisiteWhereInput
    orderBy?: CourseToPreRequisiteOrderByWithAggregationInput | CourseToPreRequisiteOrderByWithAggregationInput[]
    by: CourseToPreRequisiteScalarFieldEnum[] | CourseToPreRequisiteScalarFieldEnum
    having?: CourseToPreRequisiteScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CourseToPreRequisiteCountAggregateInputType | true
    _min?: CourseToPreRequisiteMinAggregateInputType
    _max?: CourseToPreRequisiteMaxAggregateInputType
  }

  export type CourseToPreRequisiteGroupByOutputType = {
    courseId: string
    preRequisiteId: string
    _count: CourseToPreRequisiteCountAggregateOutputType | null
    _min: CourseToPreRequisiteMinAggregateOutputType | null
    _max: CourseToPreRequisiteMaxAggregateOutputType | null
  }

  type GetCourseToPreRequisiteGroupByPayload<T extends CourseToPreRequisiteGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CourseToPreRequisiteGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CourseToPreRequisiteGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CourseToPreRequisiteGroupByOutputType[P]>
            : GetScalarType<T[P], CourseToPreRequisiteGroupByOutputType[P]>
        }
      >
    >


  export type CourseToPreRequisiteSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    courseId?: boolean
    preRequisiteId?: boolean
    course?: boolean | CourseDefaultArgs<ExtArgs>
    preRequisite?: boolean | CourseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["courseToPreRequisite"]>



  export type CourseToPreRequisiteSelectScalar = {
    courseId?: boolean
    preRequisiteId?: boolean
  }

  export type CourseToPreRequisiteOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"courseId" | "preRequisiteId", ExtArgs["result"]["courseToPreRequisite"]>
  export type CourseToPreRequisiteInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    course?: boolean | CourseDefaultArgs<ExtArgs>
    preRequisite?: boolean | CourseDefaultArgs<ExtArgs>
  }

  export type $CourseToPreRequisitePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CourseToPreRequisite"
    objects: {
      course: Prisma.$CoursePayload<ExtArgs>
      preRequisite: Prisma.$CoursePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      courseId: string
      preRequisiteId: string
    }, ExtArgs["result"]["courseToPreRequisite"]>
    composites: {}
  }

  type CourseToPreRequisiteGetPayload<S extends boolean | null | undefined | CourseToPreRequisiteDefaultArgs> = $Result.GetResult<Prisma.$CourseToPreRequisitePayload, S>

  type CourseToPreRequisiteCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CourseToPreRequisiteFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CourseToPreRequisiteCountAggregateInputType | true
    }

  export interface CourseToPreRequisiteDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CourseToPreRequisite'], meta: { name: 'CourseToPreRequisite' } }
    /**
     * Find zero or one CourseToPreRequisite that matches the filter.
     * @param {CourseToPreRequisiteFindUniqueArgs} args - Arguments to find a CourseToPreRequisite
     * @example
     * // Get one CourseToPreRequisite
     * const courseToPreRequisite = await prisma.courseToPreRequisite.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CourseToPreRequisiteFindUniqueArgs>(args: SelectSubset<T, CourseToPreRequisiteFindUniqueArgs<ExtArgs>>): Prisma__CourseToPreRequisiteClient<$Result.GetResult<Prisma.$CourseToPreRequisitePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CourseToPreRequisite that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CourseToPreRequisiteFindUniqueOrThrowArgs} args - Arguments to find a CourseToPreRequisite
     * @example
     * // Get one CourseToPreRequisite
     * const courseToPreRequisite = await prisma.courseToPreRequisite.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CourseToPreRequisiteFindUniqueOrThrowArgs>(args: SelectSubset<T, CourseToPreRequisiteFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CourseToPreRequisiteClient<$Result.GetResult<Prisma.$CourseToPreRequisitePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CourseToPreRequisite that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseToPreRequisiteFindFirstArgs} args - Arguments to find a CourseToPreRequisite
     * @example
     * // Get one CourseToPreRequisite
     * const courseToPreRequisite = await prisma.courseToPreRequisite.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CourseToPreRequisiteFindFirstArgs>(args?: SelectSubset<T, CourseToPreRequisiteFindFirstArgs<ExtArgs>>): Prisma__CourseToPreRequisiteClient<$Result.GetResult<Prisma.$CourseToPreRequisitePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CourseToPreRequisite that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseToPreRequisiteFindFirstOrThrowArgs} args - Arguments to find a CourseToPreRequisite
     * @example
     * // Get one CourseToPreRequisite
     * const courseToPreRequisite = await prisma.courseToPreRequisite.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CourseToPreRequisiteFindFirstOrThrowArgs>(args?: SelectSubset<T, CourseToPreRequisiteFindFirstOrThrowArgs<ExtArgs>>): Prisma__CourseToPreRequisiteClient<$Result.GetResult<Prisma.$CourseToPreRequisitePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CourseToPreRequisites that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseToPreRequisiteFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CourseToPreRequisites
     * const courseToPreRequisites = await prisma.courseToPreRequisite.findMany()
     * 
     * // Get first 10 CourseToPreRequisites
     * const courseToPreRequisites = await prisma.courseToPreRequisite.findMany({ take: 10 })
     * 
     * // Only select the `courseId`
     * const courseToPreRequisiteWithCourseIdOnly = await prisma.courseToPreRequisite.findMany({ select: { courseId: true } })
     * 
     */
    findMany<T extends CourseToPreRequisiteFindManyArgs>(args?: SelectSubset<T, CourseToPreRequisiteFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CourseToPreRequisitePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CourseToPreRequisite.
     * @param {CourseToPreRequisiteCreateArgs} args - Arguments to create a CourseToPreRequisite.
     * @example
     * // Create one CourseToPreRequisite
     * const CourseToPreRequisite = await prisma.courseToPreRequisite.create({
     *   data: {
     *     // ... data to create a CourseToPreRequisite
     *   }
     * })
     * 
     */
    create<T extends CourseToPreRequisiteCreateArgs>(args: SelectSubset<T, CourseToPreRequisiteCreateArgs<ExtArgs>>): Prisma__CourseToPreRequisiteClient<$Result.GetResult<Prisma.$CourseToPreRequisitePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CourseToPreRequisites.
     * @param {CourseToPreRequisiteCreateManyArgs} args - Arguments to create many CourseToPreRequisites.
     * @example
     * // Create many CourseToPreRequisites
     * const courseToPreRequisite = await prisma.courseToPreRequisite.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CourseToPreRequisiteCreateManyArgs>(args?: SelectSubset<T, CourseToPreRequisiteCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a CourseToPreRequisite.
     * @param {CourseToPreRequisiteDeleteArgs} args - Arguments to delete one CourseToPreRequisite.
     * @example
     * // Delete one CourseToPreRequisite
     * const CourseToPreRequisite = await prisma.courseToPreRequisite.delete({
     *   where: {
     *     // ... filter to delete one CourseToPreRequisite
     *   }
     * })
     * 
     */
    delete<T extends CourseToPreRequisiteDeleteArgs>(args: SelectSubset<T, CourseToPreRequisiteDeleteArgs<ExtArgs>>): Prisma__CourseToPreRequisiteClient<$Result.GetResult<Prisma.$CourseToPreRequisitePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CourseToPreRequisite.
     * @param {CourseToPreRequisiteUpdateArgs} args - Arguments to update one CourseToPreRequisite.
     * @example
     * // Update one CourseToPreRequisite
     * const courseToPreRequisite = await prisma.courseToPreRequisite.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CourseToPreRequisiteUpdateArgs>(args: SelectSubset<T, CourseToPreRequisiteUpdateArgs<ExtArgs>>): Prisma__CourseToPreRequisiteClient<$Result.GetResult<Prisma.$CourseToPreRequisitePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CourseToPreRequisites.
     * @param {CourseToPreRequisiteDeleteManyArgs} args - Arguments to filter CourseToPreRequisites to delete.
     * @example
     * // Delete a few CourseToPreRequisites
     * const { count } = await prisma.courseToPreRequisite.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CourseToPreRequisiteDeleteManyArgs>(args?: SelectSubset<T, CourseToPreRequisiteDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CourseToPreRequisites.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseToPreRequisiteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CourseToPreRequisites
     * const courseToPreRequisite = await prisma.courseToPreRequisite.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CourseToPreRequisiteUpdateManyArgs>(args: SelectSubset<T, CourseToPreRequisiteUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CourseToPreRequisite.
     * @param {CourseToPreRequisiteUpsertArgs} args - Arguments to update or create a CourseToPreRequisite.
     * @example
     * // Update or create a CourseToPreRequisite
     * const courseToPreRequisite = await prisma.courseToPreRequisite.upsert({
     *   create: {
     *     // ... data to create a CourseToPreRequisite
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CourseToPreRequisite we want to update
     *   }
     * })
     */
    upsert<T extends CourseToPreRequisiteUpsertArgs>(args: SelectSubset<T, CourseToPreRequisiteUpsertArgs<ExtArgs>>): Prisma__CourseToPreRequisiteClient<$Result.GetResult<Prisma.$CourseToPreRequisitePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CourseToPreRequisites.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseToPreRequisiteCountArgs} args - Arguments to filter CourseToPreRequisites to count.
     * @example
     * // Count the number of CourseToPreRequisites
     * const count = await prisma.courseToPreRequisite.count({
     *   where: {
     *     // ... the filter for the CourseToPreRequisites we want to count
     *   }
     * })
    **/
    count<T extends CourseToPreRequisiteCountArgs>(
      args?: Subset<T, CourseToPreRequisiteCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CourseToPreRequisiteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CourseToPreRequisite.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseToPreRequisiteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CourseToPreRequisiteAggregateArgs>(args: Subset<T, CourseToPreRequisiteAggregateArgs>): Prisma.PrismaPromise<GetCourseToPreRequisiteAggregateType<T>>

    /**
     * Group by CourseToPreRequisite.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseToPreRequisiteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CourseToPreRequisiteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CourseToPreRequisiteGroupByArgs['orderBy'] }
        : { orderBy?: CourseToPreRequisiteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CourseToPreRequisiteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCourseToPreRequisiteGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CourseToPreRequisite model
   */
  readonly fields: CourseToPreRequisiteFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CourseToPreRequisite.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CourseToPreRequisiteClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    course<T extends CourseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CourseDefaultArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    preRequisite<T extends CourseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CourseDefaultArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CourseToPreRequisite model
   */
  interface CourseToPreRequisiteFieldRefs {
    readonly courseId: FieldRef<"CourseToPreRequisite", 'String'>
    readonly preRequisiteId: FieldRef<"CourseToPreRequisite", 'String'>
  }
    

  // Custom InputTypes
  /**
   * CourseToPreRequisite findUnique
   */
  export type CourseToPreRequisiteFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseToPreRequisite
     */
    select?: CourseToPreRequisiteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseToPreRequisite
     */
    omit?: CourseToPreRequisiteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseToPreRequisiteInclude<ExtArgs> | null
    /**
     * Filter, which CourseToPreRequisite to fetch.
     */
    where: CourseToPreRequisiteWhereUniqueInput
  }

  /**
   * CourseToPreRequisite findUniqueOrThrow
   */
  export type CourseToPreRequisiteFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseToPreRequisite
     */
    select?: CourseToPreRequisiteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseToPreRequisite
     */
    omit?: CourseToPreRequisiteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseToPreRequisiteInclude<ExtArgs> | null
    /**
     * Filter, which CourseToPreRequisite to fetch.
     */
    where: CourseToPreRequisiteWhereUniqueInput
  }

  /**
   * CourseToPreRequisite findFirst
   */
  export type CourseToPreRequisiteFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseToPreRequisite
     */
    select?: CourseToPreRequisiteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseToPreRequisite
     */
    omit?: CourseToPreRequisiteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseToPreRequisiteInclude<ExtArgs> | null
    /**
     * Filter, which CourseToPreRequisite to fetch.
     */
    where?: CourseToPreRequisiteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CourseToPreRequisites to fetch.
     */
    orderBy?: CourseToPreRequisiteOrderByWithRelationInput | CourseToPreRequisiteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CourseToPreRequisites.
     */
    cursor?: CourseToPreRequisiteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CourseToPreRequisites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CourseToPreRequisites.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CourseToPreRequisites.
     */
    distinct?: CourseToPreRequisiteScalarFieldEnum | CourseToPreRequisiteScalarFieldEnum[]
  }

  /**
   * CourseToPreRequisite findFirstOrThrow
   */
  export type CourseToPreRequisiteFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseToPreRequisite
     */
    select?: CourseToPreRequisiteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseToPreRequisite
     */
    omit?: CourseToPreRequisiteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseToPreRequisiteInclude<ExtArgs> | null
    /**
     * Filter, which CourseToPreRequisite to fetch.
     */
    where?: CourseToPreRequisiteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CourseToPreRequisites to fetch.
     */
    orderBy?: CourseToPreRequisiteOrderByWithRelationInput | CourseToPreRequisiteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CourseToPreRequisites.
     */
    cursor?: CourseToPreRequisiteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CourseToPreRequisites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CourseToPreRequisites.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CourseToPreRequisites.
     */
    distinct?: CourseToPreRequisiteScalarFieldEnum | CourseToPreRequisiteScalarFieldEnum[]
  }

  /**
   * CourseToPreRequisite findMany
   */
  export type CourseToPreRequisiteFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseToPreRequisite
     */
    select?: CourseToPreRequisiteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseToPreRequisite
     */
    omit?: CourseToPreRequisiteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseToPreRequisiteInclude<ExtArgs> | null
    /**
     * Filter, which CourseToPreRequisites to fetch.
     */
    where?: CourseToPreRequisiteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CourseToPreRequisites to fetch.
     */
    orderBy?: CourseToPreRequisiteOrderByWithRelationInput | CourseToPreRequisiteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CourseToPreRequisites.
     */
    cursor?: CourseToPreRequisiteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CourseToPreRequisites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CourseToPreRequisites.
     */
    skip?: number
    distinct?: CourseToPreRequisiteScalarFieldEnum | CourseToPreRequisiteScalarFieldEnum[]
  }

  /**
   * CourseToPreRequisite create
   */
  export type CourseToPreRequisiteCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseToPreRequisite
     */
    select?: CourseToPreRequisiteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseToPreRequisite
     */
    omit?: CourseToPreRequisiteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseToPreRequisiteInclude<ExtArgs> | null
    /**
     * The data needed to create a CourseToPreRequisite.
     */
    data: XOR<CourseToPreRequisiteCreateInput, CourseToPreRequisiteUncheckedCreateInput>
  }

  /**
   * CourseToPreRequisite createMany
   */
  export type CourseToPreRequisiteCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CourseToPreRequisites.
     */
    data: CourseToPreRequisiteCreateManyInput | CourseToPreRequisiteCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CourseToPreRequisite update
   */
  export type CourseToPreRequisiteUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseToPreRequisite
     */
    select?: CourseToPreRequisiteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseToPreRequisite
     */
    omit?: CourseToPreRequisiteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseToPreRequisiteInclude<ExtArgs> | null
    /**
     * The data needed to update a CourseToPreRequisite.
     */
    data: XOR<CourseToPreRequisiteUpdateInput, CourseToPreRequisiteUncheckedUpdateInput>
    /**
     * Choose, which CourseToPreRequisite to update.
     */
    where: CourseToPreRequisiteWhereUniqueInput
  }

  /**
   * CourseToPreRequisite updateMany
   */
  export type CourseToPreRequisiteUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CourseToPreRequisites.
     */
    data: XOR<CourseToPreRequisiteUpdateManyMutationInput, CourseToPreRequisiteUncheckedUpdateManyInput>
    /**
     * Filter which CourseToPreRequisites to update
     */
    where?: CourseToPreRequisiteWhereInput
    /**
     * Limit how many CourseToPreRequisites to update.
     */
    limit?: number
  }

  /**
   * CourseToPreRequisite upsert
   */
  export type CourseToPreRequisiteUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseToPreRequisite
     */
    select?: CourseToPreRequisiteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseToPreRequisite
     */
    omit?: CourseToPreRequisiteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseToPreRequisiteInclude<ExtArgs> | null
    /**
     * The filter to search for the CourseToPreRequisite to update in case it exists.
     */
    where: CourseToPreRequisiteWhereUniqueInput
    /**
     * In case the CourseToPreRequisite found by the `where` argument doesn't exist, create a new CourseToPreRequisite with this data.
     */
    create: XOR<CourseToPreRequisiteCreateInput, CourseToPreRequisiteUncheckedCreateInput>
    /**
     * In case the CourseToPreRequisite was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CourseToPreRequisiteUpdateInput, CourseToPreRequisiteUncheckedUpdateInput>
  }

  /**
   * CourseToPreRequisite delete
   */
  export type CourseToPreRequisiteDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseToPreRequisite
     */
    select?: CourseToPreRequisiteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseToPreRequisite
     */
    omit?: CourseToPreRequisiteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseToPreRequisiteInclude<ExtArgs> | null
    /**
     * Filter which CourseToPreRequisite to delete.
     */
    where: CourseToPreRequisiteWhereUniqueInput
  }

  /**
   * CourseToPreRequisite deleteMany
   */
  export type CourseToPreRequisiteDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CourseToPreRequisites to delete
     */
    where?: CourseToPreRequisiteWhereInput
    /**
     * Limit how many CourseToPreRequisites to delete.
     */
    limit?: number
  }

  /**
   * CourseToPreRequisite without action
   */
  export type CourseToPreRequisiteDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseToPreRequisite
     */
    select?: CourseToPreRequisiteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseToPreRequisite
     */
    omit?: CourseToPreRequisiteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseToPreRequisiteInclude<ExtArgs> | null
  }


  /**
   * Model CourseFaculty
   */

  export type AggregateCourseFaculty = {
    _count: CourseFacultyCountAggregateOutputType | null
    _min: CourseFacultyMinAggregateOutputType | null
    _max: CourseFacultyMaxAggregateOutputType | null
  }

  export type CourseFacultyMinAggregateOutputType = {
    courseId: string | null
    facultyId: string | null
  }

  export type CourseFacultyMaxAggregateOutputType = {
    courseId: string | null
    facultyId: string | null
  }

  export type CourseFacultyCountAggregateOutputType = {
    courseId: number
    facultyId: number
    _all: number
  }


  export type CourseFacultyMinAggregateInputType = {
    courseId?: true
    facultyId?: true
  }

  export type CourseFacultyMaxAggregateInputType = {
    courseId?: true
    facultyId?: true
  }

  export type CourseFacultyCountAggregateInputType = {
    courseId?: true
    facultyId?: true
    _all?: true
  }

  export type CourseFacultyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CourseFaculty to aggregate.
     */
    where?: CourseFacultyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CourseFaculties to fetch.
     */
    orderBy?: CourseFacultyOrderByWithRelationInput | CourseFacultyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CourseFacultyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CourseFaculties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CourseFaculties.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CourseFaculties
    **/
    _count?: true | CourseFacultyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CourseFacultyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CourseFacultyMaxAggregateInputType
  }

  export type GetCourseFacultyAggregateType<T extends CourseFacultyAggregateArgs> = {
        [P in keyof T & keyof AggregateCourseFaculty]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCourseFaculty[P]>
      : GetScalarType<T[P], AggregateCourseFaculty[P]>
  }




  export type CourseFacultyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CourseFacultyWhereInput
    orderBy?: CourseFacultyOrderByWithAggregationInput | CourseFacultyOrderByWithAggregationInput[]
    by: CourseFacultyScalarFieldEnum[] | CourseFacultyScalarFieldEnum
    having?: CourseFacultyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CourseFacultyCountAggregateInputType | true
    _min?: CourseFacultyMinAggregateInputType
    _max?: CourseFacultyMaxAggregateInputType
  }

  export type CourseFacultyGroupByOutputType = {
    courseId: string
    facultyId: string
    _count: CourseFacultyCountAggregateOutputType | null
    _min: CourseFacultyMinAggregateOutputType | null
    _max: CourseFacultyMaxAggregateOutputType | null
  }

  type GetCourseFacultyGroupByPayload<T extends CourseFacultyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CourseFacultyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CourseFacultyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CourseFacultyGroupByOutputType[P]>
            : GetScalarType<T[P], CourseFacultyGroupByOutputType[P]>
        }
      >
    >


  export type CourseFacultySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    courseId?: boolean
    facultyId?: boolean
    course?: boolean | CourseDefaultArgs<ExtArgs>
    faculty?: boolean | FacultyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["courseFaculty"]>



  export type CourseFacultySelectScalar = {
    courseId?: boolean
    facultyId?: boolean
  }

  export type CourseFacultyOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"courseId" | "facultyId", ExtArgs["result"]["courseFaculty"]>
  export type CourseFacultyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    course?: boolean | CourseDefaultArgs<ExtArgs>
    faculty?: boolean | FacultyDefaultArgs<ExtArgs>
  }

  export type $CourseFacultyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CourseFaculty"
    objects: {
      course: Prisma.$CoursePayload<ExtArgs>
      faculty: Prisma.$FacultyPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      courseId: string
      facultyId: string
    }, ExtArgs["result"]["courseFaculty"]>
    composites: {}
  }

  type CourseFacultyGetPayload<S extends boolean | null | undefined | CourseFacultyDefaultArgs> = $Result.GetResult<Prisma.$CourseFacultyPayload, S>

  type CourseFacultyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CourseFacultyFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CourseFacultyCountAggregateInputType | true
    }

  export interface CourseFacultyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CourseFaculty'], meta: { name: 'CourseFaculty' } }
    /**
     * Find zero or one CourseFaculty that matches the filter.
     * @param {CourseFacultyFindUniqueArgs} args - Arguments to find a CourseFaculty
     * @example
     * // Get one CourseFaculty
     * const courseFaculty = await prisma.courseFaculty.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CourseFacultyFindUniqueArgs>(args: SelectSubset<T, CourseFacultyFindUniqueArgs<ExtArgs>>): Prisma__CourseFacultyClient<$Result.GetResult<Prisma.$CourseFacultyPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CourseFaculty that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CourseFacultyFindUniqueOrThrowArgs} args - Arguments to find a CourseFaculty
     * @example
     * // Get one CourseFaculty
     * const courseFaculty = await prisma.courseFaculty.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CourseFacultyFindUniqueOrThrowArgs>(args: SelectSubset<T, CourseFacultyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CourseFacultyClient<$Result.GetResult<Prisma.$CourseFacultyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CourseFaculty that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseFacultyFindFirstArgs} args - Arguments to find a CourseFaculty
     * @example
     * // Get one CourseFaculty
     * const courseFaculty = await prisma.courseFaculty.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CourseFacultyFindFirstArgs>(args?: SelectSubset<T, CourseFacultyFindFirstArgs<ExtArgs>>): Prisma__CourseFacultyClient<$Result.GetResult<Prisma.$CourseFacultyPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CourseFaculty that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseFacultyFindFirstOrThrowArgs} args - Arguments to find a CourseFaculty
     * @example
     * // Get one CourseFaculty
     * const courseFaculty = await prisma.courseFaculty.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CourseFacultyFindFirstOrThrowArgs>(args?: SelectSubset<T, CourseFacultyFindFirstOrThrowArgs<ExtArgs>>): Prisma__CourseFacultyClient<$Result.GetResult<Prisma.$CourseFacultyPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CourseFaculties that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseFacultyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CourseFaculties
     * const courseFaculties = await prisma.courseFaculty.findMany()
     * 
     * // Get first 10 CourseFaculties
     * const courseFaculties = await prisma.courseFaculty.findMany({ take: 10 })
     * 
     * // Only select the `courseId`
     * const courseFacultyWithCourseIdOnly = await prisma.courseFaculty.findMany({ select: { courseId: true } })
     * 
     */
    findMany<T extends CourseFacultyFindManyArgs>(args?: SelectSubset<T, CourseFacultyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CourseFacultyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CourseFaculty.
     * @param {CourseFacultyCreateArgs} args - Arguments to create a CourseFaculty.
     * @example
     * // Create one CourseFaculty
     * const CourseFaculty = await prisma.courseFaculty.create({
     *   data: {
     *     // ... data to create a CourseFaculty
     *   }
     * })
     * 
     */
    create<T extends CourseFacultyCreateArgs>(args: SelectSubset<T, CourseFacultyCreateArgs<ExtArgs>>): Prisma__CourseFacultyClient<$Result.GetResult<Prisma.$CourseFacultyPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CourseFaculties.
     * @param {CourseFacultyCreateManyArgs} args - Arguments to create many CourseFaculties.
     * @example
     * // Create many CourseFaculties
     * const courseFaculty = await prisma.courseFaculty.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CourseFacultyCreateManyArgs>(args?: SelectSubset<T, CourseFacultyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a CourseFaculty.
     * @param {CourseFacultyDeleteArgs} args - Arguments to delete one CourseFaculty.
     * @example
     * // Delete one CourseFaculty
     * const CourseFaculty = await prisma.courseFaculty.delete({
     *   where: {
     *     // ... filter to delete one CourseFaculty
     *   }
     * })
     * 
     */
    delete<T extends CourseFacultyDeleteArgs>(args: SelectSubset<T, CourseFacultyDeleteArgs<ExtArgs>>): Prisma__CourseFacultyClient<$Result.GetResult<Prisma.$CourseFacultyPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CourseFaculty.
     * @param {CourseFacultyUpdateArgs} args - Arguments to update one CourseFaculty.
     * @example
     * // Update one CourseFaculty
     * const courseFaculty = await prisma.courseFaculty.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CourseFacultyUpdateArgs>(args: SelectSubset<T, CourseFacultyUpdateArgs<ExtArgs>>): Prisma__CourseFacultyClient<$Result.GetResult<Prisma.$CourseFacultyPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CourseFaculties.
     * @param {CourseFacultyDeleteManyArgs} args - Arguments to filter CourseFaculties to delete.
     * @example
     * // Delete a few CourseFaculties
     * const { count } = await prisma.courseFaculty.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CourseFacultyDeleteManyArgs>(args?: SelectSubset<T, CourseFacultyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CourseFaculties.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseFacultyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CourseFaculties
     * const courseFaculty = await prisma.courseFaculty.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CourseFacultyUpdateManyArgs>(args: SelectSubset<T, CourseFacultyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CourseFaculty.
     * @param {CourseFacultyUpsertArgs} args - Arguments to update or create a CourseFaculty.
     * @example
     * // Update or create a CourseFaculty
     * const courseFaculty = await prisma.courseFaculty.upsert({
     *   create: {
     *     // ... data to create a CourseFaculty
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CourseFaculty we want to update
     *   }
     * })
     */
    upsert<T extends CourseFacultyUpsertArgs>(args: SelectSubset<T, CourseFacultyUpsertArgs<ExtArgs>>): Prisma__CourseFacultyClient<$Result.GetResult<Prisma.$CourseFacultyPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CourseFaculties.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseFacultyCountArgs} args - Arguments to filter CourseFaculties to count.
     * @example
     * // Count the number of CourseFaculties
     * const count = await prisma.courseFaculty.count({
     *   where: {
     *     // ... the filter for the CourseFaculties we want to count
     *   }
     * })
    **/
    count<T extends CourseFacultyCountArgs>(
      args?: Subset<T, CourseFacultyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CourseFacultyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CourseFaculty.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseFacultyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CourseFacultyAggregateArgs>(args: Subset<T, CourseFacultyAggregateArgs>): Prisma.PrismaPromise<GetCourseFacultyAggregateType<T>>

    /**
     * Group by CourseFaculty.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseFacultyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CourseFacultyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CourseFacultyGroupByArgs['orderBy'] }
        : { orderBy?: CourseFacultyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CourseFacultyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCourseFacultyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CourseFaculty model
   */
  readonly fields: CourseFacultyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CourseFaculty.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CourseFacultyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    course<T extends CourseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CourseDefaultArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    faculty<T extends FacultyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FacultyDefaultArgs<ExtArgs>>): Prisma__FacultyClient<$Result.GetResult<Prisma.$FacultyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CourseFaculty model
   */
  interface CourseFacultyFieldRefs {
    readonly courseId: FieldRef<"CourseFaculty", 'String'>
    readonly facultyId: FieldRef<"CourseFaculty", 'String'>
  }
    

  // Custom InputTypes
  /**
   * CourseFaculty findUnique
   */
  export type CourseFacultyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseFaculty
     */
    select?: CourseFacultySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseFaculty
     */
    omit?: CourseFacultyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseFacultyInclude<ExtArgs> | null
    /**
     * Filter, which CourseFaculty to fetch.
     */
    where: CourseFacultyWhereUniqueInput
  }

  /**
   * CourseFaculty findUniqueOrThrow
   */
  export type CourseFacultyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseFaculty
     */
    select?: CourseFacultySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseFaculty
     */
    omit?: CourseFacultyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseFacultyInclude<ExtArgs> | null
    /**
     * Filter, which CourseFaculty to fetch.
     */
    where: CourseFacultyWhereUniqueInput
  }

  /**
   * CourseFaculty findFirst
   */
  export type CourseFacultyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseFaculty
     */
    select?: CourseFacultySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseFaculty
     */
    omit?: CourseFacultyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseFacultyInclude<ExtArgs> | null
    /**
     * Filter, which CourseFaculty to fetch.
     */
    where?: CourseFacultyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CourseFaculties to fetch.
     */
    orderBy?: CourseFacultyOrderByWithRelationInput | CourseFacultyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CourseFaculties.
     */
    cursor?: CourseFacultyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CourseFaculties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CourseFaculties.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CourseFaculties.
     */
    distinct?: CourseFacultyScalarFieldEnum | CourseFacultyScalarFieldEnum[]
  }

  /**
   * CourseFaculty findFirstOrThrow
   */
  export type CourseFacultyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseFaculty
     */
    select?: CourseFacultySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseFaculty
     */
    omit?: CourseFacultyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseFacultyInclude<ExtArgs> | null
    /**
     * Filter, which CourseFaculty to fetch.
     */
    where?: CourseFacultyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CourseFaculties to fetch.
     */
    orderBy?: CourseFacultyOrderByWithRelationInput | CourseFacultyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CourseFaculties.
     */
    cursor?: CourseFacultyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CourseFaculties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CourseFaculties.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CourseFaculties.
     */
    distinct?: CourseFacultyScalarFieldEnum | CourseFacultyScalarFieldEnum[]
  }

  /**
   * CourseFaculty findMany
   */
  export type CourseFacultyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseFaculty
     */
    select?: CourseFacultySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseFaculty
     */
    omit?: CourseFacultyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseFacultyInclude<ExtArgs> | null
    /**
     * Filter, which CourseFaculties to fetch.
     */
    where?: CourseFacultyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CourseFaculties to fetch.
     */
    orderBy?: CourseFacultyOrderByWithRelationInput | CourseFacultyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CourseFaculties.
     */
    cursor?: CourseFacultyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CourseFaculties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CourseFaculties.
     */
    skip?: number
    distinct?: CourseFacultyScalarFieldEnum | CourseFacultyScalarFieldEnum[]
  }

  /**
   * CourseFaculty create
   */
  export type CourseFacultyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseFaculty
     */
    select?: CourseFacultySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseFaculty
     */
    omit?: CourseFacultyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseFacultyInclude<ExtArgs> | null
    /**
     * The data needed to create a CourseFaculty.
     */
    data: XOR<CourseFacultyCreateInput, CourseFacultyUncheckedCreateInput>
  }

  /**
   * CourseFaculty createMany
   */
  export type CourseFacultyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CourseFaculties.
     */
    data: CourseFacultyCreateManyInput | CourseFacultyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CourseFaculty update
   */
  export type CourseFacultyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseFaculty
     */
    select?: CourseFacultySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseFaculty
     */
    omit?: CourseFacultyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseFacultyInclude<ExtArgs> | null
    /**
     * The data needed to update a CourseFaculty.
     */
    data: XOR<CourseFacultyUpdateInput, CourseFacultyUncheckedUpdateInput>
    /**
     * Choose, which CourseFaculty to update.
     */
    where: CourseFacultyWhereUniqueInput
  }

  /**
   * CourseFaculty updateMany
   */
  export type CourseFacultyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CourseFaculties.
     */
    data: XOR<CourseFacultyUpdateManyMutationInput, CourseFacultyUncheckedUpdateManyInput>
    /**
     * Filter which CourseFaculties to update
     */
    where?: CourseFacultyWhereInput
    /**
     * Limit how many CourseFaculties to update.
     */
    limit?: number
  }

  /**
   * CourseFaculty upsert
   */
  export type CourseFacultyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseFaculty
     */
    select?: CourseFacultySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseFaculty
     */
    omit?: CourseFacultyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseFacultyInclude<ExtArgs> | null
    /**
     * The filter to search for the CourseFaculty to update in case it exists.
     */
    where: CourseFacultyWhereUniqueInput
    /**
     * In case the CourseFaculty found by the `where` argument doesn't exist, create a new CourseFaculty with this data.
     */
    create: XOR<CourseFacultyCreateInput, CourseFacultyUncheckedCreateInput>
    /**
     * In case the CourseFaculty was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CourseFacultyUpdateInput, CourseFacultyUncheckedUpdateInput>
  }

  /**
   * CourseFaculty delete
   */
  export type CourseFacultyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseFaculty
     */
    select?: CourseFacultySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseFaculty
     */
    omit?: CourseFacultyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseFacultyInclude<ExtArgs> | null
    /**
     * Filter which CourseFaculty to delete.
     */
    where: CourseFacultyWhereUniqueInput
  }

  /**
   * CourseFaculty deleteMany
   */
  export type CourseFacultyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CourseFaculties to delete
     */
    where?: CourseFacultyWhereInput
    /**
     * Limit how many CourseFaculties to delete.
     */
    limit?: number
  }

  /**
   * CourseFaculty without action
   */
  export type CourseFacultyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseFaculty
     */
    select?: CourseFacultySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseFaculty
     */
    omit?: CourseFacultyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseFacultyInclude<ExtArgs> | null
  }


  /**
   * Model SemesterRegistration
   */

  export type AggregateSemesterRegistration = {
    _count: SemesterRegistrationCountAggregateOutputType | null
    _avg: SemesterRegistrationAvgAggregateOutputType | null
    _sum: SemesterRegistrationSumAggregateOutputType | null
    _min: SemesterRegistrationMinAggregateOutputType | null
    _max: SemesterRegistrationMaxAggregateOutputType | null
  }

  export type SemesterRegistrationAvgAggregateOutputType = {
    totalPayment: number | null
  }

  export type SemesterRegistrationSumAggregateOutputType = {
    totalPayment: number | null
  }

  export type SemesterRegistrationMinAggregateOutputType = {
    id: string | null
    startDate: Date | null
    endDate: Date | null
    status: $Enums.SemesterRegistrationStatus | null
    paymentRecipt: string | null
    totalPayment: number | null
    createdAt: Date | null
    updateAt: Date | null
    academicSemesterId: string | null
  }

  export type SemesterRegistrationMaxAggregateOutputType = {
    id: string | null
    startDate: Date | null
    endDate: Date | null
    status: $Enums.SemesterRegistrationStatus | null
    paymentRecipt: string | null
    totalPayment: number | null
    createdAt: Date | null
    updateAt: Date | null
    academicSemesterId: string | null
  }

  export type SemesterRegistrationCountAggregateOutputType = {
    id: number
    startDate: number
    endDate: number
    status: number
    paymentRecipt: number
    totalPayment: number
    createdAt: number
    updateAt: number
    academicSemesterId: number
    _all: number
  }


  export type SemesterRegistrationAvgAggregateInputType = {
    totalPayment?: true
  }

  export type SemesterRegistrationSumAggregateInputType = {
    totalPayment?: true
  }

  export type SemesterRegistrationMinAggregateInputType = {
    id?: true
    startDate?: true
    endDate?: true
    status?: true
    paymentRecipt?: true
    totalPayment?: true
    createdAt?: true
    updateAt?: true
    academicSemesterId?: true
  }

  export type SemesterRegistrationMaxAggregateInputType = {
    id?: true
    startDate?: true
    endDate?: true
    status?: true
    paymentRecipt?: true
    totalPayment?: true
    createdAt?: true
    updateAt?: true
    academicSemesterId?: true
  }

  export type SemesterRegistrationCountAggregateInputType = {
    id?: true
    startDate?: true
    endDate?: true
    status?: true
    paymentRecipt?: true
    totalPayment?: true
    createdAt?: true
    updateAt?: true
    academicSemesterId?: true
    _all?: true
  }

  export type SemesterRegistrationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SemesterRegistration to aggregate.
     */
    where?: SemesterRegistrationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SemesterRegistrations to fetch.
     */
    orderBy?: SemesterRegistrationOrderByWithRelationInput | SemesterRegistrationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SemesterRegistrationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SemesterRegistrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SemesterRegistrations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SemesterRegistrations
    **/
    _count?: true | SemesterRegistrationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SemesterRegistrationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SemesterRegistrationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SemesterRegistrationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SemesterRegistrationMaxAggregateInputType
  }

  export type GetSemesterRegistrationAggregateType<T extends SemesterRegistrationAggregateArgs> = {
        [P in keyof T & keyof AggregateSemesterRegistration]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSemesterRegistration[P]>
      : GetScalarType<T[P], AggregateSemesterRegistration[P]>
  }




  export type SemesterRegistrationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SemesterRegistrationWhereInput
    orderBy?: SemesterRegistrationOrderByWithAggregationInput | SemesterRegistrationOrderByWithAggregationInput[]
    by: SemesterRegistrationScalarFieldEnum[] | SemesterRegistrationScalarFieldEnum
    having?: SemesterRegistrationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SemesterRegistrationCountAggregateInputType | true
    _avg?: SemesterRegistrationAvgAggregateInputType
    _sum?: SemesterRegistrationSumAggregateInputType
    _min?: SemesterRegistrationMinAggregateInputType
    _max?: SemesterRegistrationMaxAggregateInputType
  }

  export type SemesterRegistrationGroupByOutputType = {
    id: string
    startDate: Date
    endDate: Date
    status: $Enums.SemesterRegistrationStatus | null
    paymentRecipt: string
    totalPayment: number
    createdAt: Date
    updateAt: Date
    academicSemesterId: string
    _count: SemesterRegistrationCountAggregateOutputType | null
    _avg: SemesterRegistrationAvgAggregateOutputType | null
    _sum: SemesterRegistrationSumAggregateOutputType | null
    _min: SemesterRegistrationMinAggregateOutputType | null
    _max: SemesterRegistrationMaxAggregateOutputType | null
  }

  type GetSemesterRegistrationGroupByPayload<T extends SemesterRegistrationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SemesterRegistrationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SemesterRegistrationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SemesterRegistrationGroupByOutputType[P]>
            : GetScalarType<T[P], SemesterRegistrationGroupByOutputType[P]>
        }
      >
    >


  export type SemesterRegistrationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    startDate?: boolean
    endDate?: boolean
    status?: boolean
    paymentRecipt?: boolean
    totalPayment?: boolean
    createdAt?: boolean
    updateAt?: boolean
    academicSemesterId?: boolean
    academicSemester?: boolean | AcademicSemesterDefaultArgs<ExtArgs>
    offeredCourses?: boolean | SemesterRegistration$offeredCoursesArgs<ExtArgs>
    offeredCourseSections?: boolean | SemesterRegistration$offeredCourseSectionsArgs<ExtArgs>
    offeredCourseClassSchedules?: boolean | SemesterRegistration$offeredCourseClassSchedulesArgs<ExtArgs>
    studentSemesterRegistrations?: boolean | SemesterRegistration$studentSemesterRegistrationsArgs<ExtArgs>
    studentSemesterRegistrationCourses?: boolean | SemesterRegistration$studentSemesterRegistrationCoursesArgs<ExtArgs>
    _count?: boolean | SemesterRegistrationCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["semesterRegistration"]>



  export type SemesterRegistrationSelectScalar = {
    id?: boolean
    startDate?: boolean
    endDate?: boolean
    status?: boolean
    paymentRecipt?: boolean
    totalPayment?: boolean
    createdAt?: boolean
    updateAt?: boolean
    academicSemesterId?: boolean
  }

  export type SemesterRegistrationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "startDate" | "endDate" | "status" | "paymentRecipt" | "totalPayment" | "createdAt" | "updateAt" | "academicSemesterId", ExtArgs["result"]["semesterRegistration"]>
  export type SemesterRegistrationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    academicSemester?: boolean | AcademicSemesterDefaultArgs<ExtArgs>
    offeredCourses?: boolean | SemesterRegistration$offeredCoursesArgs<ExtArgs>
    offeredCourseSections?: boolean | SemesterRegistration$offeredCourseSectionsArgs<ExtArgs>
    offeredCourseClassSchedules?: boolean | SemesterRegistration$offeredCourseClassSchedulesArgs<ExtArgs>
    studentSemesterRegistrations?: boolean | SemesterRegistration$studentSemesterRegistrationsArgs<ExtArgs>
    studentSemesterRegistrationCourses?: boolean | SemesterRegistration$studentSemesterRegistrationCoursesArgs<ExtArgs>
    _count?: boolean | SemesterRegistrationCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $SemesterRegistrationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SemesterRegistration"
    objects: {
      academicSemester: Prisma.$AcademicSemesterPayload<ExtArgs>
      offeredCourses: Prisma.$OfferedCoursePayload<ExtArgs>[]
      offeredCourseSections: Prisma.$OfferedCourseSectionPayload<ExtArgs>[]
      offeredCourseClassSchedules: Prisma.$OfferedCourseClassSchedulePayload<ExtArgs>[]
      studentSemesterRegistrations: Prisma.$StudentSemesterRegistrationPayload<ExtArgs>[]
      studentSemesterRegistrationCourses: Prisma.$StudentSemesterRegistrationCoursePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      startDate: Date
      endDate: Date
      status: $Enums.SemesterRegistrationStatus | null
      paymentRecipt: string
      totalPayment: number
      createdAt: Date
      updateAt: Date
      academicSemesterId: string
    }, ExtArgs["result"]["semesterRegistration"]>
    composites: {}
  }

  type SemesterRegistrationGetPayload<S extends boolean | null | undefined | SemesterRegistrationDefaultArgs> = $Result.GetResult<Prisma.$SemesterRegistrationPayload, S>

  type SemesterRegistrationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SemesterRegistrationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SemesterRegistrationCountAggregateInputType | true
    }

  export interface SemesterRegistrationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SemesterRegistration'], meta: { name: 'SemesterRegistration' } }
    /**
     * Find zero or one SemesterRegistration that matches the filter.
     * @param {SemesterRegistrationFindUniqueArgs} args - Arguments to find a SemesterRegistration
     * @example
     * // Get one SemesterRegistration
     * const semesterRegistration = await prisma.semesterRegistration.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SemesterRegistrationFindUniqueArgs>(args: SelectSubset<T, SemesterRegistrationFindUniqueArgs<ExtArgs>>): Prisma__SemesterRegistrationClient<$Result.GetResult<Prisma.$SemesterRegistrationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SemesterRegistration that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SemesterRegistrationFindUniqueOrThrowArgs} args - Arguments to find a SemesterRegistration
     * @example
     * // Get one SemesterRegistration
     * const semesterRegistration = await prisma.semesterRegistration.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SemesterRegistrationFindUniqueOrThrowArgs>(args: SelectSubset<T, SemesterRegistrationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SemesterRegistrationClient<$Result.GetResult<Prisma.$SemesterRegistrationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SemesterRegistration that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SemesterRegistrationFindFirstArgs} args - Arguments to find a SemesterRegistration
     * @example
     * // Get one SemesterRegistration
     * const semesterRegistration = await prisma.semesterRegistration.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SemesterRegistrationFindFirstArgs>(args?: SelectSubset<T, SemesterRegistrationFindFirstArgs<ExtArgs>>): Prisma__SemesterRegistrationClient<$Result.GetResult<Prisma.$SemesterRegistrationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SemesterRegistration that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SemesterRegistrationFindFirstOrThrowArgs} args - Arguments to find a SemesterRegistration
     * @example
     * // Get one SemesterRegistration
     * const semesterRegistration = await prisma.semesterRegistration.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SemesterRegistrationFindFirstOrThrowArgs>(args?: SelectSubset<T, SemesterRegistrationFindFirstOrThrowArgs<ExtArgs>>): Prisma__SemesterRegistrationClient<$Result.GetResult<Prisma.$SemesterRegistrationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SemesterRegistrations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SemesterRegistrationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SemesterRegistrations
     * const semesterRegistrations = await prisma.semesterRegistration.findMany()
     * 
     * // Get first 10 SemesterRegistrations
     * const semesterRegistrations = await prisma.semesterRegistration.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const semesterRegistrationWithIdOnly = await prisma.semesterRegistration.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SemesterRegistrationFindManyArgs>(args?: SelectSubset<T, SemesterRegistrationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SemesterRegistrationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SemesterRegistration.
     * @param {SemesterRegistrationCreateArgs} args - Arguments to create a SemesterRegistration.
     * @example
     * // Create one SemesterRegistration
     * const SemesterRegistration = await prisma.semesterRegistration.create({
     *   data: {
     *     // ... data to create a SemesterRegistration
     *   }
     * })
     * 
     */
    create<T extends SemesterRegistrationCreateArgs>(args: SelectSubset<T, SemesterRegistrationCreateArgs<ExtArgs>>): Prisma__SemesterRegistrationClient<$Result.GetResult<Prisma.$SemesterRegistrationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SemesterRegistrations.
     * @param {SemesterRegistrationCreateManyArgs} args - Arguments to create many SemesterRegistrations.
     * @example
     * // Create many SemesterRegistrations
     * const semesterRegistration = await prisma.semesterRegistration.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SemesterRegistrationCreateManyArgs>(args?: SelectSubset<T, SemesterRegistrationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a SemesterRegistration.
     * @param {SemesterRegistrationDeleteArgs} args - Arguments to delete one SemesterRegistration.
     * @example
     * // Delete one SemesterRegistration
     * const SemesterRegistration = await prisma.semesterRegistration.delete({
     *   where: {
     *     // ... filter to delete one SemesterRegistration
     *   }
     * })
     * 
     */
    delete<T extends SemesterRegistrationDeleteArgs>(args: SelectSubset<T, SemesterRegistrationDeleteArgs<ExtArgs>>): Prisma__SemesterRegistrationClient<$Result.GetResult<Prisma.$SemesterRegistrationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SemesterRegistration.
     * @param {SemesterRegistrationUpdateArgs} args - Arguments to update one SemesterRegistration.
     * @example
     * // Update one SemesterRegistration
     * const semesterRegistration = await prisma.semesterRegistration.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SemesterRegistrationUpdateArgs>(args: SelectSubset<T, SemesterRegistrationUpdateArgs<ExtArgs>>): Prisma__SemesterRegistrationClient<$Result.GetResult<Prisma.$SemesterRegistrationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SemesterRegistrations.
     * @param {SemesterRegistrationDeleteManyArgs} args - Arguments to filter SemesterRegistrations to delete.
     * @example
     * // Delete a few SemesterRegistrations
     * const { count } = await prisma.semesterRegistration.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SemesterRegistrationDeleteManyArgs>(args?: SelectSubset<T, SemesterRegistrationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SemesterRegistrations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SemesterRegistrationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SemesterRegistrations
     * const semesterRegistration = await prisma.semesterRegistration.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SemesterRegistrationUpdateManyArgs>(args: SelectSubset<T, SemesterRegistrationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SemesterRegistration.
     * @param {SemesterRegistrationUpsertArgs} args - Arguments to update or create a SemesterRegistration.
     * @example
     * // Update or create a SemesterRegistration
     * const semesterRegistration = await prisma.semesterRegistration.upsert({
     *   create: {
     *     // ... data to create a SemesterRegistration
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SemesterRegistration we want to update
     *   }
     * })
     */
    upsert<T extends SemesterRegistrationUpsertArgs>(args: SelectSubset<T, SemesterRegistrationUpsertArgs<ExtArgs>>): Prisma__SemesterRegistrationClient<$Result.GetResult<Prisma.$SemesterRegistrationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SemesterRegistrations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SemesterRegistrationCountArgs} args - Arguments to filter SemesterRegistrations to count.
     * @example
     * // Count the number of SemesterRegistrations
     * const count = await prisma.semesterRegistration.count({
     *   where: {
     *     // ... the filter for the SemesterRegistrations we want to count
     *   }
     * })
    **/
    count<T extends SemesterRegistrationCountArgs>(
      args?: Subset<T, SemesterRegistrationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SemesterRegistrationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SemesterRegistration.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SemesterRegistrationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SemesterRegistrationAggregateArgs>(args: Subset<T, SemesterRegistrationAggregateArgs>): Prisma.PrismaPromise<GetSemesterRegistrationAggregateType<T>>

    /**
     * Group by SemesterRegistration.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SemesterRegistrationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SemesterRegistrationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SemesterRegistrationGroupByArgs['orderBy'] }
        : { orderBy?: SemesterRegistrationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SemesterRegistrationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSemesterRegistrationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SemesterRegistration model
   */
  readonly fields: SemesterRegistrationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SemesterRegistration.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SemesterRegistrationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    academicSemester<T extends AcademicSemesterDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AcademicSemesterDefaultArgs<ExtArgs>>): Prisma__AcademicSemesterClient<$Result.GetResult<Prisma.$AcademicSemesterPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    offeredCourses<T extends SemesterRegistration$offeredCoursesArgs<ExtArgs> = {}>(args?: Subset<T, SemesterRegistration$offeredCoursesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OfferedCoursePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    offeredCourseSections<T extends SemesterRegistration$offeredCourseSectionsArgs<ExtArgs> = {}>(args?: Subset<T, SemesterRegistration$offeredCourseSectionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OfferedCourseSectionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    offeredCourseClassSchedules<T extends SemesterRegistration$offeredCourseClassSchedulesArgs<ExtArgs> = {}>(args?: Subset<T, SemesterRegistration$offeredCourseClassSchedulesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OfferedCourseClassSchedulePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    studentSemesterRegistrations<T extends SemesterRegistration$studentSemesterRegistrationsArgs<ExtArgs> = {}>(args?: Subset<T, SemesterRegistration$studentSemesterRegistrationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentSemesterRegistrationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    studentSemesterRegistrationCourses<T extends SemesterRegistration$studentSemesterRegistrationCoursesArgs<ExtArgs> = {}>(args?: Subset<T, SemesterRegistration$studentSemesterRegistrationCoursesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentSemesterRegistrationCoursePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SemesterRegistration model
   */
  interface SemesterRegistrationFieldRefs {
    readonly id: FieldRef<"SemesterRegistration", 'String'>
    readonly startDate: FieldRef<"SemesterRegistration", 'DateTime'>
    readonly endDate: FieldRef<"SemesterRegistration", 'DateTime'>
    readonly status: FieldRef<"SemesterRegistration", 'SemesterRegistrationStatus'>
    readonly paymentRecipt: FieldRef<"SemesterRegistration", 'String'>
    readonly totalPayment: FieldRef<"SemesterRegistration", 'Int'>
    readonly createdAt: FieldRef<"SemesterRegistration", 'DateTime'>
    readonly updateAt: FieldRef<"SemesterRegistration", 'DateTime'>
    readonly academicSemesterId: FieldRef<"SemesterRegistration", 'String'>
  }
    

  // Custom InputTypes
  /**
   * SemesterRegistration findUnique
   */
  export type SemesterRegistrationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SemesterRegistration
     */
    select?: SemesterRegistrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SemesterRegistration
     */
    omit?: SemesterRegistrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SemesterRegistrationInclude<ExtArgs> | null
    /**
     * Filter, which SemesterRegistration to fetch.
     */
    where: SemesterRegistrationWhereUniqueInput
  }

  /**
   * SemesterRegistration findUniqueOrThrow
   */
  export type SemesterRegistrationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SemesterRegistration
     */
    select?: SemesterRegistrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SemesterRegistration
     */
    omit?: SemesterRegistrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SemesterRegistrationInclude<ExtArgs> | null
    /**
     * Filter, which SemesterRegistration to fetch.
     */
    where: SemesterRegistrationWhereUniqueInput
  }

  /**
   * SemesterRegistration findFirst
   */
  export type SemesterRegistrationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SemesterRegistration
     */
    select?: SemesterRegistrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SemesterRegistration
     */
    omit?: SemesterRegistrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SemesterRegistrationInclude<ExtArgs> | null
    /**
     * Filter, which SemesterRegistration to fetch.
     */
    where?: SemesterRegistrationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SemesterRegistrations to fetch.
     */
    orderBy?: SemesterRegistrationOrderByWithRelationInput | SemesterRegistrationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SemesterRegistrations.
     */
    cursor?: SemesterRegistrationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SemesterRegistrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SemesterRegistrations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SemesterRegistrations.
     */
    distinct?: SemesterRegistrationScalarFieldEnum | SemesterRegistrationScalarFieldEnum[]
  }

  /**
   * SemesterRegistration findFirstOrThrow
   */
  export type SemesterRegistrationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SemesterRegistration
     */
    select?: SemesterRegistrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SemesterRegistration
     */
    omit?: SemesterRegistrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SemesterRegistrationInclude<ExtArgs> | null
    /**
     * Filter, which SemesterRegistration to fetch.
     */
    where?: SemesterRegistrationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SemesterRegistrations to fetch.
     */
    orderBy?: SemesterRegistrationOrderByWithRelationInput | SemesterRegistrationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SemesterRegistrations.
     */
    cursor?: SemesterRegistrationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SemesterRegistrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SemesterRegistrations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SemesterRegistrations.
     */
    distinct?: SemesterRegistrationScalarFieldEnum | SemesterRegistrationScalarFieldEnum[]
  }

  /**
   * SemesterRegistration findMany
   */
  export type SemesterRegistrationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SemesterRegistration
     */
    select?: SemesterRegistrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SemesterRegistration
     */
    omit?: SemesterRegistrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SemesterRegistrationInclude<ExtArgs> | null
    /**
     * Filter, which SemesterRegistrations to fetch.
     */
    where?: SemesterRegistrationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SemesterRegistrations to fetch.
     */
    orderBy?: SemesterRegistrationOrderByWithRelationInput | SemesterRegistrationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SemesterRegistrations.
     */
    cursor?: SemesterRegistrationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SemesterRegistrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SemesterRegistrations.
     */
    skip?: number
    distinct?: SemesterRegistrationScalarFieldEnum | SemesterRegistrationScalarFieldEnum[]
  }

  /**
   * SemesterRegistration create
   */
  export type SemesterRegistrationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SemesterRegistration
     */
    select?: SemesterRegistrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SemesterRegistration
     */
    omit?: SemesterRegistrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SemesterRegistrationInclude<ExtArgs> | null
    /**
     * The data needed to create a SemesterRegistration.
     */
    data: XOR<SemesterRegistrationCreateInput, SemesterRegistrationUncheckedCreateInput>
  }

  /**
   * SemesterRegistration createMany
   */
  export type SemesterRegistrationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SemesterRegistrations.
     */
    data: SemesterRegistrationCreateManyInput | SemesterRegistrationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SemesterRegistration update
   */
  export type SemesterRegistrationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SemesterRegistration
     */
    select?: SemesterRegistrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SemesterRegistration
     */
    omit?: SemesterRegistrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SemesterRegistrationInclude<ExtArgs> | null
    /**
     * The data needed to update a SemesterRegistration.
     */
    data: XOR<SemesterRegistrationUpdateInput, SemesterRegistrationUncheckedUpdateInput>
    /**
     * Choose, which SemesterRegistration to update.
     */
    where: SemesterRegistrationWhereUniqueInput
  }

  /**
   * SemesterRegistration updateMany
   */
  export type SemesterRegistrationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SemesterRegistrations.
     */
    data: XOR<SemesterRegistrationUpdateManyMutationInput, SemesterRegistrationUncheckedUpdateManyInput>
    /**
     * Filter which SemesterRegistrations to update
     */
    where?: SemesterRegistrationWhereInput
    /**
     * Limit how many SemesterRegistrations to update.
     */
    limit?: number
  }

  /**
   * SemesterRegistration upsert
   */
  export type SemesterRegistrationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SemesterRegistration
     */
    select?: SemesterRegistrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SemesterRegistration
     */
    omit?: SemesterRegistrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SemesterRegistrationInclude<ExtArgs> | null
    /**
     * The filter to search for the SemesterRegistration to update in case it exists.
     */
    where: SemesterRegistrationWhereUniqueInput
    /**
     * In case the SemesterRegistration found by the `where` argument doesn't exist, create a new SemesterRegistration with this data.
     */
    create: XOR<SemesterRegistrationCreateInput, SemesterRegistrationUncheckedCreateInput>
    /**
     * In case the SemesterRegistration was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SemesterRegistrationUpdateInput, SemesterRegistrationUncheckedUpdateInput>
  }

  /**
   * SemesterRegistration delete
   */
  export type SemesterRegistrationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SemesterRegistration
     */
    select?: SemesterRegistrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SemesterRegistration
     */
    omit?: SemesterRegistrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SemesterRegistrationInclude<ExtArgs> | null
    /**
     * Filter which SemesterRegistration to delete.
     */
    where: SemesterRegistrationWhereUniqueInput
  }

  /**
   * SemesterRegistration deleteMany
   */
  export type SemesterRegistrationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SemesterRegistrations to delete
     */
    where?: SemesterRegistrationWhereInput
    /**
     * Limit how many SemesterRegistrations to delete.
     */
    limit?: number
  }

  /**
   * SemesterRegistration.offeredCourses
   */
  export type SemesterRegistration$offeredCoursesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OfferedCourse
     */
    select?: OfferedCourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OfferedCourse
     */
    omit?: OfferedCourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OfferedCourseInclude<ExtArgs> | null
    where?: OfferedCourseWhereInput
    orderBy?: OfferedCourseOrderByWithRelationInput | OfferedCourseOrderByWithRelationInput[]
    cursor?: OfferedCourseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OfferedCourseScalarFieldEnum | OfferedCourseScalarFieldEnum[]
  }

  /**
   * SemesterRegistration.offeredCourseSections
   */
  export type SemesterRegistration$offeredCourseSectionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OfferedCourseSection
     */
    select?: OfferedCourseSectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OfferedCourseSection
     */
    omit?: OfferedCourseSectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OfferedCourseSectionInclude<ExtArgs> | null
    where?: OfferedCourseSectionWhereInput
    orderBy?: OfferedCourseSectionOrderByWithRelationInput | OfferedCourseSectionOrderByWithRelationInput[]
    cursor?: OfferedCourseSectionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OfferedCourseSectionScalarFieldEnum | OfferedCourseSectionScalarFieldEnum[]
  }

  /**
   * SemesterRegistration.offeredCourseClassSchedules
   */
  export type SemesterRegistration$offeredCourseClassSchedulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OfferedCourseClassSchedule
     */
    select?: OfferedCourseClassScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OfferedCourseClassSchedule
     */
    omit?: OfferedCourseClassScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OfferedCourseClassScheduleInclude<ExtArgs> | null
    where?: OfferedCourseClassScheduleWhereInput
    orderBy?: OfferedCourseClassScheduleOrderByWithRelationInput | OfferedCourseClassScheduleOrderByWithRelationInput[]
    cursor?: OfferedCourseClassScheduleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OfferedCourseClassScheduleScalarFieldEnum | OfferedCourseClassScheduleScalarFieldEnum[]
  }

  /**
   * SemesterRegistration.studentSemesterRegistrations
   */
  export type SemesterRegistration$studentSemesterRegistrationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentSemesterRegistration
     */
    select?: StudentSemesterRegistrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentSemesterRegistration
     */
    omit?: StudentSemesterRegistrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentSemesterRegistrationInclude<ExtArgs> | null
    where?: StudentSemesterRegistrationWhereInput
    orderBy?: StudentSemesterRegistrationOrderByWithRelationInput | StudentSemesterRegistrationOrderByWithRelationInput[]
    cursor?: StudentSemesterRegistrationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StudentSemesterRegistrationScalarFieldEnum | StudentSemesterRegistrationScalarFieldEnum[]
  }

  /**
   * SemesterRegistration.studentSemesterRegistrationCourses
   */
  export type SemesterRegistration$studentSemesterRegistrationCoursesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentSemesterRegistrationCourse
     */
    select?: StudentSemesterRegistrationCourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentSemesterRegistrationCourse
     */
    omit?: StudentSemesterRegistrationCourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentSemesterRegistrationCourseInclude<ExtArgs> | null
    where?: StudentSemesterRegistrationCourseWhereInput
    orderBy?: StudentSemesterRegistrationCourseOrderByWithRelationInput | StudentSemesterRegistrationCourseOrderByWithRelationInput[]
    cursor?: StudentSemesterRegistrationCourseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StudentSemesterRegistrationCourseScalarFieldEnum | StudentSemesterRegistrationCourseScalarFieldEnum[]
  }

  /**
   * SemesterRegistration without action
   */
  export type SemesterRegistrationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SemesterRegistration
     */
    select?: SemesterRegistrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SemesterRegistration
     */
    omit?: SemesterRegistrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SemesterRegistrationInclude<ExtArgs> | null
  }


  /**
   * Model AdmitionExameRegistration
   */

  export type AggregateAdmitionExameRegistration = {
    _count: AdmitionExameRegistrationCountAggregateOutputType | null
    _avg: AdmitionExameRegistrationAvgAggregateOutputType | null
    _sum: AdmitionExameRegistrationSumAggregateOutputType | null
    _min: AdmitionExameRegistrationMinAggregateOutputType | null
    _max: AdmitionExameRegistrationMaxAggregateOutputType | null
  }

  export type AdmitionExameRegistrationAvgAggregateOutputType = {
    paymentAmoute: number | null
    exameResults: number | null
    fase: number | null
  }

  export type AdmitionExameRegistrationSumAggregateOutputType = {
    paymentAmoute: number | null
    exameResults: number | null
    fase: number | null
  }

  export type AdmitionExameRegistrationMinAggregateOutputType = {
    id: string | null
    applicantName: string | null
    paymentRecipt: string | null
    document: string | null
    paymentAmoute: number | null
    aprovePayment: boolean | null
    exameResults: number | null
    passed: boolean | null
    fase: number | null
    exameDate: Date | null
    createdAt: Date | null
    updateAt: Date | null
    departmentId: string | null
  }

  export type AdmitionExameRegistrationMaxAggregateOutputType = {
    id: string | null
    applicantName: string | null
    paymentRecipt: string | null
    document: string | null
    paymentAmoute: number | null
    aprovePayment: boolean | null
    exameResults: number | null
    passed: boolean | null
    fase: number | null
    exameDate: Date | null
    createdAt: Date | null
    updateAt: Date | null
    departmentId: string | null
  }

  export type AdmitionExameRegistrationCountAggregateOutputType = {
    id: number
    applicantName: number
    paymentRecipt: number
    document: number
    paymentAmoute: number
    aprovePayment: number
    exameResults: number
    passed: number
    fase: number
    exameDate: number
    createdAt: number
    updateAt: number
    departmentId: number
    _all: number
  }


  export type AdmitionExameRegistrationAvgAggregateInputType = {
    paymentAmoute?: true
    exameResults?: true
    fase?: true
  }

  export type AdmitionExameRegistrationSumAggregateInputType = {
    paymentAmoute?: true
    exameResults?: true
    fase?: true
  }

  export type AdmitionExameRegistrationMinAggregateInputType = {
    id?: true
    applicantName?: true
    paymentRecipt?: true
    document?: true
    paymentAmoute?: true
    aprovePayment?: true
    exameResults?: true
    passed?: true
    fase?: true
    exameDate?: true
    createdAt?: true
    updateAt?: true
    departmentId?: true
  }

  export type AdmitionExameRegistrationMaxAggregateInputType = {
    id?: true
    applicantName?: true
    paymentRecipt?: true
    document?: true
    paymentAmoute?: true
    aprovePayment?: true
    exameResults?: true
    passed?: true
    fase?: true
    exameDate?: true
    createdAt?: true
    updateAt?: true
    departmentId?: true
  }

  export type AdmitionExameRegistrationCountAggregateInputType = {
    id?: true
    applicantName?: true
    paymentRecipt?: true
    document?: true
    paymentAmoute?: true
    aprovePayment?: true
    exameResults?: true
    passed?: true
    fase?: true
    exameDate?: true
    createdAt?: true
    updateAt?: true
    departmentId?: true
    _all?: true
  }

  export type AdmitionExameRegistrationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AdmitionExameRegistration to aggregate.
     */
    where?: AdmitionExameRegistrationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdmitionExameRegistrations to fetch.
     */
    orderBy?: AdmitionExameRegistrationOrderByWithRelationInput | AdmitionExameRegistrationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AdmitionExameRegistrationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdmitionExameRegistrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdmitionExameRegistrations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AdmitionExameRegistrations
    **/
    _count?: true | AdmitionExameRegistrationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AdmitionExameRegistrationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AdmitionExameRegistrationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AdmitionExameRegistrationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AdmitionExameRegistrationMaxAggregateInputType
  }

  export type GetAdmitionExameRegistrationAggregateType<T extends AdmitionExameRegistrationAggregateArgs> = {
        [P in keyof T & keyof AggregateAdmitionExameRegistration]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAdmitionExameRegistration[P]>
      : GetScalarType<T[P], AggregateAdmitionExameRegistration[P]>
  }




  export type AdmitionExameRegistrationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdmitionExameRegistrationWhereInput
    orderBy?: AdmitionExameRegistrationOrderByWithAggregationInput | AdmitionExameRegistrationOrderByWithAggregationInput[]
    by: AdmitionExameRegistrationScalarFieldEnum[] | AdmitionExameRegistrationScalarFieldEnum
    having?: AdmitionExameRegistrationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AdmitionExameRegistrationCountAggregateInputType | true
    _avg?: AdmitionExameRegistrationAvgAggregateInputType
    _sum?: AdmitionExameRegistrationSumAggregateInputType
    _min?: AdmitionExameRegistrationMinAggregateInputType
    _max?: AdmitionExameRegistrationMaxAggregateInputType
  }

  export type AdmitionExameRegistrationGroupByOutputType = {
    id: string
    applicantName: string
    paymentRecipt: string
    document: string
    paymentAmoute: number | null
    aprovePayment: boolean | null
    exameResults: number | null
    passed: boolean | null
    fase: number
    exameDate: Date
    createdAt: Date
    updateAt: Date
    departmentId: string
    _count: AdmitionExameRegistrationCountAggregateOutputType | null
    _avg: AdmitionExameRegistrationAvgAggregateOutputType | null
    _sum: AdmitionExameRegistrationSumAggregateOutputType | null
    _min: AdmitionExameRegistrationMinAggregateOutputType | null
    _max: AdmitionExameRegistrationMaxAggregateOutputType | null
  }

  type GetAdmitionExameRegistrationGroupByPayload<T extends AdmitionExameRegistrationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AdmitionExameRegistrationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AdmitionExameRegistrationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AdmitionExameRegistrationGroupByOutputType[P]>
            : GetScalarType<T[P], AdmitionExameRegistrationGroupByOutputType[P]>
        }
      >
    >


  export type AdmitionExameRegistrationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    applicantName?: boolean
    paymentRecipt?: boolean
    document?: boolean
    paymentAmoute?: boolean
    aprovePayment?: boolean
    exameResults?: boolean
    passed?: boolean
    fase?: boolean
    exameDate?: boolean
    createdAt?: boolean
    updateAt?: boolean
    departmentId?: boolean
    department?: boolean | AcademicDepartmentDefaultArgs<ExtArgs>
    Student?: boolean | AdmitionExameRegistration$StudentArgs<ExtArgs>
  }, ExtArgs["result"]["admitionExameRegistration"]>



  export type AdmitionExameRegistrationSelectScalar = {
    id?: boolean
    applicantName?: boolean
    paymentRecipt?: boolean
    document?: boolean
    paymentAmoute?: boolean
    aprovePayment?: boolean
    exameResults?: boolean
    passed?: boolean
    fase?: boolean
    exameDate?: boolean
    createdAt?: boolean
    updateAt?: boolean
    departmentId?: boolean
  }

  export type AdmitionExameRegistrationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "applicantName" | "paymentRecipt" | "document" | "paymentAmoute" | "aprovePayment" | "exameResults" | "passed" | "fase" | "exameDate" | "createdAt" | "updateAt" | "departmentId", ExtArgs["result"]["admitionExameRegistration"]>
  export type AdmitionExameRegistrationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    department?: boolean | AcademicDepartmentDefaultArgs<ExtArgs>
    Student?: boolean | AdmitionExameRegistration$StudentArgs<ExtArgs>
  }

  export type $AdmitionExameRegistrationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AdmitionExameRegistration"
    objects: {
      department: Prisma.$AcademicDepartmentPayload<ExtArgs>
      Student: Prisma.$StudentPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      applicantName: string
      paymentRecipt: string
      document: string
      paymentAmoute: number | null
      aprovePayment: boolean | null
      exameResults: number | null
      passed: boolean | null
      fase: number
      exameDate: Date
      createdAt: Date
      updateAt: Date
      departmentId: string
    }, ExtArgs["result"]["admitionExameRegistration"]>
    composites: {}
  }

  type AdmitionExameRegistrationGetPayload<S extends boolean | null | undefined | AdmitionExameRegistrationDefaultArgs> = $Result.GetResult<Prisma.$AdmitionExameRegistrationPayload, S>

  type AdmitionExameRegistrationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AdmitionExameRegistrationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AdmitionExameRegistrationCountAggregateInputType | true
    }

  export interface AdmitionExameRegistrationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AdmitionExameRegistration'], meta: { name: 'AdmitionExameRegistration' } }
    /**
     * Find zero or one AdmitionExameRegistration that matches the filter.
     * @param {AdmitionExameRegistrationFindUniqueArgs} args - Arguments to find a AdmitionExameRegistration
     * @example
     * // Get one AdmitionExameRegistration
     * const admitionExameRegistration = await prisma.admitionExameRegistration.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AdmitionExameRegistrationFindUniqueArgs>(args: SelectSubset<T, AdmitionExameRegistrationFindUniqueArgs<ExtArgs>>): Prisma__AdmitionExameRegistrationClient<$Result.GetResult<Prisma.$AdmitionExameRegistrationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AdmitionExameRegistration that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AdmitionExameRegistrationFindUniqueOrThrowArgs} args - Arguments to find a AdmitionExameRegistration
     * @example
     * // Get one AdmitionExameRegistration
     * const admitionExameRegistration = await prisma.admitionExameRegistration.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AdmitionExameRegistrationFindUniqueOrThrowArgs>(args: SelectSubset<T, AdmitionExameRegistrationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AdmitionExameRegistrationClient<$Result.GetResult<Prisma.$AdmitionExameRegistrationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AdmitionExameRegistration that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdmitionExameRegistrationFindFirstArgs} args - Arguments to find a AdmitionExameRegistration
     * @example
     * // Get one AdmitionExameRegistration
     * const admitionExameRegistration = await prisma.admitionExameRegistration.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AdmitionExameRegistrationFindFirstArgs>(args?: SelectSubset<T, AdmitionExameRegistrationFindFirstArgs<ExtArgs>>): Prisma__AdmitionExameRegistrationClient<$Result.GetResult<Prisma.$AdmitionExameRegistrationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AdmitionExameRegistration that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdmitionExameRegistrationFindFirstOrThrowArgs} args - Arguments to find a AdmitionExameRegistration
     * @example
     * // Get one AdmitionExameRegistration
     * const admitionExameRegistration = await prisma.admitionExameRegistration.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AdmitionExameRegistrationFindFirstOrThrowArgs>(args?: SelectSubset<T, AdmitionExameRegistrationFindFirstOrThrowArgs<ExtArgs>>): Prisma__AdmitionExameRegistrationClient<$Result.GetResult<Prisma.$AdmitionExameRegistrationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AdmitionExameRegistrations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdmitionExameRegistrationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AdmitionExameRegistrations
     * const admitionExameRegistrations = await prisma.admitionExameRegistration.findMany()
     * 
     * // Get first 10 AdmitionExameRegistrations
     * const admitionExameRegistrations = await prisma.admitionExameRegistration.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const admitionExameRegistrationWithIdOnly = await prisma.admitionExameRegistration.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AdmitionExameRegistrationFindManyArgs>(args?: SelectSubset<T, AdmitionExameRegistrationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdmitionExameRegistrationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AdmitionExameRegistration.
     * @param {AdmitionExameRegistrationCreateArgs} args - Arguments to create a AdmitionExameRegistration.
     * @example
     * // Create one AdmitionExameRegistration
     * const AdmitionExameRegistration = await prisma.admitionExameRegistration.create({
     *   data: {
     *     // ... data to create a AdmitionExameRegistration
     *   }
     * })
     * 
     */
    create<T extends AdmitionExameRegistrationCreateArgs>(args: SelectSubset<T, AdmitionExameRegistrationCreateArgs<ExtArgs>>): Prisma__AdmitionExameRegistrationClient<$Result.GetResult<Prisma.$AdmitionExameRegistrationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AdmitionExameRegistrations.
     * @param {AdmitionExameRegistrationCreateManyArgs} args - Arguments to create many AdmitionExameRegistrations.
     * @example
     * // Create many AdmitionExameRegistrations
     * const admitionExameRegistration = await prisma.admitionExameRegistration.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AdmitionExameRegistrationCreateManyArgs>(args?: SelectSubset<T, AdmitionExameRegistrationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a AdmitionExameRegistration.
     * @param {AdmitionExameRegistrationDeleteArgs} args - Arguments to delete one AdmitionExameRegistration.
     * @example
     * // Delete one AdmitionExameRegistration
     * const AdmitionExameRegistration = await prisma.admitionExameRegistration.delete({
     *   where: {
     *     // ... filter to delete one AdmitionExameRegistration
     *   }
     * })
     * 
     */
    delete<T extends AdmitionExameRegistrationDeleteArgs>(args: SelectSubset<T, AdmitionExameRegistrationDeleteArgs<ExtArgs>>): Prisma__AdmitionExameRegistrationClient<$Result.GetResult<Prisma.$AdmitionExameRegistrationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AdmitionExameRegistration.
     * @param {AdmitionExameRegistrationUpdateArgs} args - Arguments to update one AdmitionExameRegistration.
     * @example
     * // Update one AdmitionExameRegistration
     * const admitionExameRegistration = await prisma.admitionExameRegistration.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AdmitionExameRegistrationUpdateArgs>(args: SelectSubset<T, AdmitionExameRegistrationUpdateArgs<ExtArgs>>): Prisma__AdmitionExameRegistrationClient<$Result.GetResult<Prisma.$AdmitionExameRegistrationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AdmitionExameRegistrations.
     * @param {AdmitionExameRegistrationDeleteManyArgs} args - Arguments to filter AdmitionExameRegistrations to delete.
     * @example
     * // Delete a few AdmitionExameRegistrations
     * const { count } = await prisma.admitionExameRegistration.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AdmitionExameRegistrationDeleteManyArgs>(args?: SelectSubset<T, AdmitionExameRegistrationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AdmitionExameRegistrations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdmitionExameRegistrationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AdmitionExameRegistrations
     * const admitionExameRegistration = await prisma.admitionExameRegistration.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AdmitionExameRegistrationUpdateManyArgs>(args: SelectSubset<T, AdmitionExameRegistrationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AdmitionExameRegistration.
     * @param {AdmitionExameRegistrationUpsertArgs} args - Arguments to update or create a AdmitionExameRegistration.
     * @example
     * // Update or create a AdmitionExameRegistration
     * const admitionExameRegistration = await prisma.admitionExameRegistration.upsert({
     *   create: {
     *     // ... data to create a AdmitionExameRegistration
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AdmitionExameRegistration we want to update
     *   }
     * })
     */
    upsert<T extends AdmitionExameRegistrationUpsertArgs>(args: SelectSubset<T, AdmitionExameRegistrationUpsertArgs<ExtArgs>>): Prisma__AdmitionExameRegistrationClient<$Result.GetResult<Prisma.$AdmitionExameRegistrationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AdmitionExameRegistrations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdmitionExameRegistrationCountArgs} args - Arguments to filter AdmitionExameRegistrations to count.
     * @example
     * // Count the number of AdmitionExameRegistrations
     * const count = await prisma.admitionExameRegistration.count({
     *   where: {
     *     // ... the filter for the AdmitionExameRegistrations we want to count
     *   }
     * })
    **/
    count<T extends AdmitionExameRegistrationCountArgs>(
      args?: Subset<T, AdmitionExameRegistrationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AdmitionExameRegistrationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AdmitionExameRegistration.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdmitionExameRegistrationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AdmitionExameRegistrationAggregateArgs>(args: Subset<T, AdmitionExameRegistrationAggregateArgs>): Prisma.PrismaPromise<GetAdmitionExameRegistrationAggregateType<T>>

    /**
     * Group by AdmitionExameRegistration.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdmitionExameRegistrationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AdmitionExameRegistrationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AdmitionExameRegistrationGroupByArgs['orderBy'] }
        : { orderBy?: AdmitionExameRegistrationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AdmitionExameRegistrationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAdmitionExameRegistrationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AdmitionExameRegistration model
   */
  readonly fields: AdmitionExameRegistrationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AdmitionExameRegistration.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AdmitionExameRegistrationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    department<T extends AcademicDepartmentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AcademicDepartmentDefaultArgs<ExtArgs>>): Prisma__AcademicDepartmentClient<$Result.GetResult<Prisma.$AcademicDepartmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    Student<T extends AdmitionExameRegistration$StudentArgs<ExtArgs> = {}>(args?: Subset<T, AdmitionExameRegistration$StudentArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AdmitionExameRegistration model
   */
  interface AdmitionExameRegistrationFieldRefs {
    readonly id: FieldRef<"AdmitionExameRegistration", 'String'>
    readonly applicantName: FieldRef<"AdmitionExameRegistration", 'String'>
    readonly paymentRecipt: FieldRef<"AdmitionExameRegistration", 'String'>
    readonly document: FieldRef<"AdmitionExameRegistration", 'String'>
    readonly paymentAmoute: FieldRef<"AdmitionExameRegistration", 'Int'>
    readonly aprovePayment: FieldRef<"AdmitionExameRegistration", 'Boolean'>
    readonly exameResults: FieldRef<"AdmitionExameRegistration", 'Int'>
    readonly passed: FieldRef<"AdmitionExameRegistration", 'Boolean'>
    readonly fase: FieldRef<"AdmitionExameRegistration", 'Int'>
    readonly exameDate: FieldRef<"AdmitionExameRegistration", 'DateTime'>
    readonly createdAt: FieldRef<"AdmitionExameRegistration", 'DateTime'>
    readonly updateAt: FieldRef<"AdmitionExameRegistration", 'DateTime'>
    readonly departmentId: FieldRef<"AdmitionExameRegistration", 'String'>
  }
    

  // Custom InputTypes
  /**
   * AdmitionExameRegistration findUnique
   */
  export type AdmitionExameRegistrationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdmitionExameRegistration
     */
    select?: AdmitionExameRegistrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdmitionExameRegistration
     */
    omit?: AdmitionExameRegistrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdmitionExameRegistrationInclude<ExtArgs> | null
    /**
     * Filter, which AdmitionExameRegistration to fetch.
     */
    where: AdmitionExameRegistrationWhereUniqueInput
  }

  /**
   * AdmitionExameRegistration findUniqueOrThrow
   */
  export type AdmitionExameRegistrationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdmitionExameRegistration
     */
    select?: AdmitionExameRegistrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdmitionExameRegistration
     */
    omit?: AdmitionExameRegistrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdmitionExameRegistrationInclude<ExtArgs> | null
    /**
     * Filter, which AdmitionExameRegistration to fetch.
     */
    where: AdmitionExameRegistrationWhereUniqueInput
  }

  /**
   * AdmitionExameRegistration findFirst
   */
  export type AdmitionExameRegistrationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdmitionExameRegistration
     */
    select?: AdmitionExameRegistrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdmitionExameRegistration
     */
    omit?: AdmitionExameRegistrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdmitionExameRegistrationInclude<ExtArgs> | null
    /**
     * Filter, which AdmitionExameRegistration to fetch.
     */
    where?: AdmitionExameRegistrationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdmitionExameRegistrations to fetch.
     */
    orderBy?: AdmitionExameRegistrationOrderByWithRelationInput | AdmitionExameRegistrationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AdmitionExameRegistrations.
     */
    cursor?: AdmitionExameRegistrationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdmitionExameRegistrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdmitionExameRegistrations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AdmitionExameRegistrations.
     */
    distinct?: AdmitionExameRegistrationScalarFieldEnum | AdmitionExameRegistrationScalarFieldEnum[]
  }

  /**
   * AdmitionExameRegistration findFirstOrThrow
   */
  export type AdmitionExameRegistrationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdmitionExameRegistration
     */
    select?: AdmitionExameRegistrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdmitionExameRegistration
     */
    omit?: AdmitionExameRegistrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdmitionExameRegistrationInclude<ExtArgs> | null
    /**
     * Filter, which AdmitionExameRegistration to fetch.
     */
    where?: AdmitionExameRegistrationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdmitionExameRegistrations to fetch.
     */
    orderBy?: AdmitionExameRegistrationOrderByWithRelationInput | AdmitionExameRegistrationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AdmitionExameRegistrations.
     */
    cursor?: AdmitionExameRegistrationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdmitionExameRegistrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdmitionExameRegistrations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AdmitionExameRegistrations.
     */
    distinct?: AdmitionExameRegistrationScalarFieldEnum | AdmitionExameRegistrationScalarFieldEnum[]
  }

  /**
   * AdmitionExameRegistration findMany
   */
  export type AdmitionExameRegistrationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdmitionExameRegistration
     */
    select?: AdmitionExameRegistrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdmitionExameRegistration
     */
    omit?: AdmitionExameRegistrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdmitionExameRegistrationInclude<ExtArgs> | null
    /**
     * Filter, which AdmitionExameRegistrations to fetch.
     */
    where?: AdmitionExameRegistrationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdmitionExameRegistrations to fetch.
     */
    orderBy?: AdmitionExameRegistrationOrderByWithRelationInput | AdmitionExameRegistrationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AdmitionExameRegistrations.
     */
    cursor?: AdmitionExameRegistrationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdmitionExameRegistrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdmitionExameRegistrations.
     */
    skip?: number
    distinct?: AdmitionExameRegistrationScalarFieldEnum | AdmitionExameRegistrationScalarFieldEnum[]
  }

  /**
   * AdmitionExameRegistration create
   */
  export type AdmitionExameRegistrationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdmitionExameRegistration
     */
    select?: AdmitionExameRegistrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdmitionExameRegistration
     */
    omit?: AdmitionExameRegistrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdmitionExameRegistrationInclude<ExtArgs> | null
    /**
     * The data needed to create a AdmitionExameRegistration.
     */
    data: XOR<AdmitionExameRegistrationCreateInput, AdmitionExameRegistrationUncheckedCreateInput>
  }

  /**
   * AdmitionExameRegistration createMany
   */
  export type AdmitionExameRegistrationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AdmitionExameRegistrations.
     */
    data: AdmitionExameRegistrationCreateManyInput | AdmitionExameRegistrationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AdmitionExameRegistration update
   */
  export type AdmitionExameRegistrationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdmitionExameRegistration
     */
    select?: AdmitionExameRegistrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdmitionExameRegistration
     */
    omit?: AdmitionExameRegistrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdmitionExameRegistrationInclude<ExtArgs> | null
    /**
     * The data needed to update a AdmitionExameRegistration.
     */
    data: XOR<AdmitionExameRegistrationUpdateInput, AdmitionExameRegistrationUncheckedUpdateInput>
    /**
     * Choose, which AdmitionExameRegistration to update.
     */
    where: AdmitionExameRegistrationWhereUniqueInput
  }

  /**
   * AdmitionExameRegistration updateMany
   */
  export type AdmitionExameRegistrationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AdmitionExameRegistrations.
     */
    data: XOR<AdmitionExameRegistrationUpdateManyMutationInput, AdmitionExameRegistrationUncheckedUpdateManyInput>
    /**
     * Filter which AdmitionExameRegistrations to update
     */
    where?: AdmitionExameRegistrationWhereInput
    /**
     * Limit how many AdmitionExameRegistrations to update.
     */
    limit?: number
  }

  /**
   * AdmitionExameRegistration upsert
   */
  export type AdmitionExameRegistrationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdmitionExameRegistration
     */
    select?: AdmitionExameRegistrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdmitionExameRegistration
     */
    omit?: AdmitionExameRegistrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdmitionExameRegistrationInclude<ExtArgs> | null
    /**
     * The filter to search for the AdmitionExameRegistration to update in case it exists.
     */
    where: AdmitionExameRegistrationWhereUniqueInput
    /**
     * In case the AdmitionExameRegistration found by the `where` argument doesn't exist, create a new AdmitionExameRegistration with this data.
     */
    create: XOR<AdmitionExameRegistrationCreateInput, AdmitionExameRegistrationUncheckedCreateInput>
    /**
     * In case the AdmitionExameRegistration was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AdmitionExameRegistrationUpdateInput, AdmitionExameRegistrationUncheckedUpdateInput>
  }

  /**
   * AdmitionExameRegistration delete
   */
  export type AdmitionExameRegistrationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdmitionExameRegistration
     */
    select?: AdmitionExameRegistrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdmitionExameRegistration
     */
    omit?: AdmitionExameRegistrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdmitionExameRegistrationInclude<ExtArgs> | null
    /**
     * Filter which AdmitionExameRegistration to delete.
     */
    where: AdmitionExameRegistrationWhereUniqueInput
  }

  /**
   * AdmitionExameRegistration deleteMany
   */
  export type AdmitionExameRegistrationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AdmitionExameRegistrations to delete
     */
    where?: AdmitionExameRegistrationWhereInput
    /**
     * Limit how many AdmitionExameRegistrations to delete.
     */
    limit?: number
  }

  /**
   * AdmitionExameRegistration.Student
   */
  export type AdmitionExameRegistration$StudentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Student
     */
    omit?: StudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    where?: StudentWhereInput
  }

  /**
   * AdmitionExameRegistration without action
   */
  export type AdmitionExameRegistrationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdmitionExameRegistration
     */
    select?: AdmitionExameRegistrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdmitionExameRegistration
     */
    omit?: AdmitionExameRegistrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdmitionExameRegistrationInclude<ExtArgs> | null
  }


  /**
   * Model OfferedCourse
   */

  export type AggregateOfferedCourse = {
    _count: OfferedCourseCountAggregateOutputType | null
    _min: OfferedCourseMinAggregateOutputType | null
    _max: OfferedCourseMaxAggregateOutputType | null
  }

  export type OfferedCourseMinAggregateOutputType = {
    id: string | null
    academicDepartmentId: string | null
    courseId: string | null
    semesterRegistrationId: string | null
  }

  export type OfferedCourseMaxAggregateOutputType = {
    id: string | null
    academicDepartmentId: string | null
    courseId: string | null
    semesterRegistrationId: string | null
  }

  export type OfferedCourseCountAggregateOutputType = {
    id: number
    academicDepartmentId: number
    courseId: number
    semesterRegistrationId: number
    _all: number
  }


  export type OfferedCourseMinAggregateInputType = {
    id?: true
    academicDepartmentId?: true
    courseId?: true
    semesterRegistrationId?: true
  }

  export type OfferedCourseMaxAggregateInputType = {
    id?: true
    academicDepartmentId?: true
    courseId?: true
    semesterRegistrationId?: true
  }

  export type OfferedCourseCountAggregateInputType = {
    id?: true
    academicDepartmentId?: true
    courseId?: true
    semesterRegistrationId?: true
    _all?: true
  }

  export type OfferedCourseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OfferedCourse to aggregate.
     */
    where?: OfferedCourseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OfferedCourses to fetch.
     */
    orderBy?: OfferedCourseOrderByWithRelationInput | OfferedCourseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OfferedCourseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OfferedCourses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OfferedCourses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OfferedCourses
    **/
    _count?: true | OfferedCourseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OfferedCourseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OfferedCourseMaxAggregateInputType
  }

  export type GetOfferedCourseAggregateType<T extends OfferedCourseAggregateArgs> = {
        [P in keyof T & keyof AggregateOfferedCourse]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOfferedCourse[P]>
      : GetScalarType<T[P], AggregateOfferedCourse[P]>
  }




  export type OfferedCourseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OfferedCourseWhereInput
    orderBy?: OfferedCourseOrderByWithAggregationInput | OfferedCourseOrderByWithAggregationInput[]
    by: OfferedCourseScalarFieldEnum[] | OfferedCourseScalarFieldEnum
    having?: OfferedCourseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OfferedCourseCountAggregateInputType | true
    _min?: OfferedCourseMinAggregateInputType
    _max?: OfferedCourseMaxAggregateInputType
  }

  export type OfferedCourseGroupByOutputType = {
    id: string
    academicDepartmentId: string
    courseId: string
    semesterRegistrationId: string
    _count: OfferedCourseCountAggregateOutputType | null
    _min: OfferedCourseMinAggregateOutputType | null
    _max: OfferedCourseMaxAggregateOutputType | null
  }

  type GetOfferedCourseGroupByPayload<T extends OfferedCourseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OfferedCourseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OfferedCourseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OfferedCourseGroupByOutputType[P]>
            : GetScalarType<T[P], OfferedCourseGroupByOutputType[P]>
        }
      >
    >


  export type OfferedCourseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    academicDepartmentId?: boolean
    courseId?: boolean
    semesterRegistrationId?: boolean
    academicDepartment?: boolean | AcademicDepartmentDefaultArgs<ExtArgs>
    semesterRegistration?: boolean | SemesterRegistrationDefaultArgs<ExtArgs>
    course?: boolean | CourseDefaultArgs<ExtArgs>
    offeredCourseSections?: boolean | OfferedCourse$offeredCourseSectionsArgs<ExtArgs>
    studentSemesterRegistrationCourses?: boolean | OfferedCourse$studentSemesterRegistrationCoursesArgs<ExtArgs>
    _count?: boolean | OfferedCourseCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["offeredCourse"]>



  export type OfferedCourseSelectScalar = {
    id?: boolean
    academicDepartmentId?: boolean
    courseId?: boolean
    semesterRegistrationId?: boolean
  }

  export type OfferedCourseOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "academicDepartmentId" | "courseId" | "semesterRegistrationId", ExtArgs["result"]["offeredCourse"]>
  export type OfferedCourseInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    academicDepartment?: boolean | AcademicDepartmentDefaultArgs<ExtArgs>
    semesterRegistration?: boolean | SemesterRegistrationDefaultArgs<ExtArgs>
    course?: boolean | CourseDefaultArgs<ExtArgs>
    offeredCourseSections?: boolean | OfferedCourse$offeredCourseSectionsArgs<ExtArgs>
    studentSemesterRegistrationCourses?: boolean | OfferedCourse$studentSemesterRegistrationCoursesArgs<ExtArgs>
    _count?: boolean | OfferedCourseCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $OfferedCoursePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "OfferedCourse"
    objects: {
      academicDepartment: Prisma.$AcademicDepartmentPayload<ExtArgs>
      semesterRegistration: Prisma.$SemesterRegistrationPayload<ExtArgs>
      course: Prisma.$CoursePayload<ExtArgs>
      offeredCourseSections: Prisma.$OfferedCourseSectionPayload<ExtArgs>[]
      studentSemesterRegistrationCourses: Prisma.$StudentSemesterRegistrationCoursePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      academicDepartmentId: string
      courseId: string
      semesterRegistrationId: string
    }, ExtArgs["result"]["offeredCourse"]>
    composites: {}
  }

  type OfferedCourseGetPayload<S extends boolean | null | undefined | OfferedCourseDefaultArgs> = $Result.GetResult<Prisma.$OfferedCoursePayload, S>

  type OfferedCourseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OfferedCourseFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OfferedCourseCountAggregateInputType | true
    }

  export interface OfferedCourseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OfferedCourse'], meta: { name: 'OfferedCourse' } }
    /**
     * Find zero or one OfferedCourse that matches the filter.
     * @param {OfferedCourseFindUniqueArgs} args - Arguments to find a OfferedCourse
     * @example
     * // Get one OfferedCourse
     * const offeredCourse = await prisma.offeredCourse.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OfferedCourseFindUniqueArgs>(args: SelectSubset<T, OfferedCourseFindUniqueArgs<ExtArgs>>): Prisma__OfferedCourseClient<$Result.GetResult<Prisma.$OfferedCoursePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one OfferedCourse that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OfferedCourseFindUniqueOrThrowArgs} args - Arguments to find a OfferedCourse
     * @example
     * // Get one OfferedCourse
     * const offeredCourse = await prisma.offeredCourse.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OfferedCourseFindUniqueOrThrowArgs>(args: SelectSubset<T, OfferedCourseFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OfferedCourseClient<$Result.GetResult<Prisma.$OfferedCoursePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OfferedCourse that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OfferedCourseFindFirstArgs} args - Arguments to find a OfferedCourse
     * @example
     * // Get one OfferedCourse
     * const offeredCourse = await prisma.offeredCourse.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OfferedCourseFindFirstArgs>(args?: SelectSubset<T, OfferedCourseFindFirstArgs<ExtArgs>>): Prisma__OfferedCourseClient<$Result.GetResult<Prisma.$OfferedCoursePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OfferedCourse that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OfferedCourseFindFirstOrThrowArgs} args - Arguments to find a OfferedCourse
     * @example
     * // Get one OfferedCourse
     * const offeredCourse = await prisma.offeredCourse.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OfferedCourseFindFirstOrThrowArgs>(args?: SelectSubset<T, OfferedCourseFindFirstOrThrowArgs<ExtArgs>>): Prisma__OfferedCourseClient<$Result.GetResult<Prisma.$OfferedCoursePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more OfferedCourses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OfferedCourseFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OfferedCourses
     * const offeredCourses = await prisma.offeredCourse.findMany()
     * 
     * // Get first 10 OfferedCourses
     * const offeredCourses = await prisma.offeredCourse.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const offeredCourseWithIdOnly = await prisma.offeredCourse.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OfferedCourseFindManyArgs>(args?: SelectSubset<T, OfferedCourseFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OfferedCoursePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a OfferedCourse.
     * @param {OfferedCourseCreateArgs} args - Arguments to create a OfferedCourse.
     * @example
     * // Create one OfferedCourse
     * const OfferedCourse = await prisma.offeredCourse.create({
     *   data: {
     *     // ... data to create a OfferedCourse
     *   }
     * })
     * 
     */
    create<T extends OfferedCourseCreateArgs>(args: SelectSubset<T, OfferedCourseCreateArgs<ExtArgs>>): Prisma__OfferedCourseClient<$Result.GetResult<Prisma.$OfferedCoursePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many OfferedCourses.
     * @param {OfferedCourseCreateManyArgs} args - Arguments to create many OfferedCourses.
     * @example
     * // Create many OfferedCourses
     * const offeredCourse = await prisma.offeredCourse.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OfferedCourseCreateManyArgs>(args?: SelectSubset<T, OfferedCourseCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a OfferedCourse.
     * @param {OfferedCourseDeleteArgs} args - Arguments to delete one OfferedCourse.
     * @example
     * // Delete one OfferedCourse
     * const OfferedCourse = await prisma.offeredCourse.delete({
     *   where: {
     *     // ... filter to delete one OfferedCourse
     *   }
     * })
     * 
     */
    delete<T extends OfferedCourseDeleteArgs>(args: SelectSubset<T, OfferedCourseDeleteArgs<ExtArgs>>): Prisma__OfferedCourseClient<$Result.GetResult<Prisma.$OfferedCoursePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one OfferedCourse.
     * @param {OfferedCourseUpdateArgs} args - Arguments to update one OfferedCourse.
     * @example
     * // Update one OfferedCourse
     * const offeredCourse = await prisma.offeredCourse.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OfferedCourseUpdateArgs>(args: SelectSubset<T, OfferedCourseUpdateArgs<ExtArgs>>): Prisma__OfferedCourseClient<$Result.GetResult<Prisma.$OfferedCoursePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more OfferedCourses.
     * @param {OfferedCourseDeleteManyArgs} args - Arguments to filter OfferedCourses to delete.
     * @example
     * // Delete a few OfferedCourses
     * const { count } = await prisma.offeredCourse.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OfferedCourseDeleteManyArgs>(args?: SelectSubset<T, OfferedCourseDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OfferedCourses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OfferedCourseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OfferedCourses
     * const offeredCourse = await prisma.offeredCourse.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OfferedCourseUpdateManyArgs>(args: SelectSubset<T, OfferedCourseUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one OfferedCourse.
     * @param {OfferedCourseUpsertArgs} args - Arguments to update or create a OfferedCourse.
     * @example
     * // Update or create a OfferedCourse
     * const offeredCourse = await prisma.offeredCourse.upsert({
     *   create: {
     *     // ... data to create a OfferedCourse
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OfferedCourse we want to update
     *   }
     * })
     */
    upsert<T extends OfferedCourseUpsertArgs>(args: SelectSubset<T, OfferedCourseUpsertArgs<ExtArgs>>): Prisma__OfferedCourseClient<$Result.GetResult<Prisma.$OfferedCoursePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of OfferedCourses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OfferedCourseCountArgs} args - Arguments to filter OfferedCourses to count.
     * @example
     * // Count the number of OfferedCourses
     * const count = await prisma.offeredCourse.count({
     *   where: {
     *     // ... the filter for the OfferedCourses we want to count
     *   }
     * })
    **/
    count<T extends OfferedCourseCountArgs>(
      args?: Subset<T, OfferedCourseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OfferedCourseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OfferedCourse.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OfferedCourseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OfferedCourseAggregateArgs>(args: Subset<T, OfferedCourseAggregateArgs>): Prisma.PrismaPromise<GetOfferedCourseAggregateType<T>>

    /**
     * Group by OfferedCourse.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OfferedCourseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OfferedCourseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OfferedCourseGroupByArgs['orderBy'] }
        : { orderBy?: OfferedCourseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OfferedCourseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOfferedCourseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the OfferedCourse model
   */
  readonly fields: OfferedCourseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OfferedCourse.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OfferedCourseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    academicDepartment<T extends AcademicDepartmentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AcademicDepartmentDefaultArgs<ExtArgs>>): Prisma__AcademicDepartmentClient<$Result.GetResult<Prisma.$AcademicDepartmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    semesterRegistration<T extends SemesterRegistrationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SemesterRegistrationDefaultArgs<ExtArgs>>): Prisma__SemesterRegistrationClient<$Result.GetResult<Prisma.$SemesterRegistrationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    course<T extends CourseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CourseDefaultArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    offeredCourseSections<T extends OfferedCourse$offeredCourseSectionsArgs<ExtArgs> = {}>(args?: Subset<T, OfferedCourse$offeredCourseSectionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OfferedCourseSectionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    studentSemesterRegistrationCourses<T extends OfferedCourse$studentSemesterRegistrationCoursesArgs<ExtArgs> = {}>(args?: Subset<T, OfferedCourse$studentSemesterRegistrationCoursesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentSemesterRegistrationCoursePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the OfferedCourse model
   */
  interface OfferedCourseFieldRefs {
    readonly id: FieldRef<"OfferedCourse", 'String'>
    readonly academicDepartmentId: FieldRef<"OfferedCourse", 'String'>
    readonly courseId: FieldRef<"OfferedCourse", 'String'>
    readonly semesterRegistrationId: FieldRef<"OfferedCourse", 'String'>
  }
    

  // Custom InputTypes
  /**
   * OfferedCourse findUnique
   */
  export type OfferedCourseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OfferedCourse
     */
    select?: OfferedCourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OfferedCourse
     */
    omit?: OfferedCourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OfferedCourseInclude<ExtArgs> | null
    /**
     * Filter, which OfferedCourse to fetch.
     */
    where: OfferedCourseWhereUniqueInput
  }

  /**
   * OfferedCourse findUniqueOrThrow
   */
  export type OfferedCourseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OfferedCourse
     */
    select?: OfferedCourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OfferedCourse
     */
    omit?: OfferedCourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OfferedCourseInclude<ExtArgs> | null
    /**
     * Filter, which OfferedCourse to fetch.
     */
    where: OfferedCourseWhereUniqueInput
  }

  /**
   * OfferedCourse findFirst
   */
  export type OfferedCourseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OfferedCourse
     */
    select?: OfferedCourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OfferedCourse
     */
    omit?: OfferedCourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OfferedCourseInclude<ExtArgs> | null
    /**
     * Filter, which OfferedCourse to fetch.
     */
    where?: OfferedCourseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OfferedCourses to fetch.
     */
    orderBy?: OfferedCourseOrderByWithRelationInput | OfferedCourseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OfferedCourses.
     */
    cursor?: OfferedCourseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OfferedCourses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OfferedCourses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OfferedCourses.
     */
    distinct?: OfferedCourseScalarFieldEnum | OfferedCourseScalarFieldEnum[]
  }

  /**
   * OfferedCourse findFirstOrThrow
   */
  export type OfferedCourseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OfferedCourse
     */
    select?: OfferedCourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OfferedCourse
     */
    omit?: OfferedCourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OfferedCourseInclude<ExtArgs> | null
    /**
     * Filter, which OfferedCourse to fetch.
     */
    where?: OfferedCourseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OfferedCourses to fetch.
     */
    orderBy?: OfferedCourseOrderByWithRelationInput | OfferedCourseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OfferedCourses.
     */
    cursor?: OfferedCourseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OfferedCourses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OfferedCourses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OfferedCourses.
     */
    distinct?: OfferedCourseScalarFieldEnum | OfferedCourseScalarFieldEnum[]
  }

  /**
   * OfferedCourse findMany
   */
  export type OfferedCourseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OfferedCourse
     */
    select?: OfferedCourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OfferedCourse
     */
    omit?: OfferedCourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OfferedCourseInclude<ExtArgs> | null
    /**
     * Filter, which OfferedCourses to fetch.
     */
    where?: OfferedCourseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OfferedCourses to fetch.
     */
    orderBy?: OfferedCourseOrderByWithRelationInput | OfferedCourseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OfferedCourses.
     */
    cursor?: OfferedCourseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OfferedCourses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OfferedCourses.
     */
    skip?: number
    distinct?: OfferedCourseScalarFieldEnum | OfferedCourseScalarFieldEnum[]
  }

  /**
   * OfferedCourse create
   */
  export type OfferedCourseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OfferedCourse
     */
    select?: OfferedCourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OfferedCourse
     */
    omit?: OfferedCourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OfferedCourseInclude<ExtArgs> | null
    /**
     * The data needed to create a OfferedCourse.
     */
    data: XOR<OfferedCourseCreateInput, OfferedCourseUncheckedCreateInput>
  }

  /**
   * OfferedCourse createMany
   */
  export type OfferedCourseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OfferedCourses.
     */
    data: OfferedCourseCreateManyInput | OfferedCourseCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * OfferedCourse update
   */
  export type OfferedCourseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OfferedCourse
     */
    select?: OfferedCourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OfferedCourse
     */
    omit?: OfferedCourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OfferedCourseInclude<ExtArgs> | null
    /**
     * The data needed to update a OfferedCourse.
     */
    data: XOR<OfferedCourseUpdateInput, OfferedCourseUncheckedUpdateInput>
    /**
     * Choose, which OfferedCourse to update.
     */
    where: OfferedCourseWhereUniqueInput
  }

  /**
   * OfferedCourse updateMany
   */
  export type OfferedCourseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OfferedCourses.
     */
    data: XOR<OfferedCourseUpdateManyMutationInput, OfferedCourseUncheckedUpdateManyInput>
    /**
     * Filter which OfferedCourses to update
     */
    where?: OfferedCourseWhereInput
    /**
     * Limit how many OfferedCourses to update.
     */
    limit?: number
  }

  /**
   * OfferedCourse upsert
   */
  export type OfferedCourseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OfferedCourse
     */
    select?: OfferedCourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OfferedCourse
     */
    omit?: OfferedCourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OfferedCourseInclude<ExtArgs> | null
    /**
     * The filter to search for the OfferedCourse to update in case it exists.
     */
    where: OfferedCourseWhereUniqueInput
    /**
     * In case the OfferedCourse found by the `where` argument doesn't exist, create a new OfferedCourse with this data.
     */
    create: XOR<OfferedCourseCreateInput, OfferedCourseUncheckedCreateInput>
    /**
     * In case the OfferedCourse was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OfferedCourseUpdateInput, OfferedCourseUncheckedUpdateInput>
  }

  /**
   * OfferedCourse delete
   */
  export type OfferedCourseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OfferedCourse
     */
    select?: OfferedCourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OfferedCourse
     */
    omit?: OfferedCourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OfferedCourseInclude<ExtArgs> | null
    /**
     * Filter which OfferedCourse to delete.
     */
    where: OfferedCourseWhereUniqueInput
  }

  /**
   * OfferedCourse deleteMany
   */
  export type OfferedCourseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OfferedCourses to delete
     */
    where?: OfferedCourseWhereInput
    /**
     * Limit how many OfferedCourses to delete.
     */
    limit?: number
  }

  /**
   * OfferedCourse.offeredCourseSections
   */
  export type OfferedCourse$offeredCourseSectionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OfferedCourseSection
     */
    select?: OfferedCourseSectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OfferedCourseSection
     */
    omit?: OfferedCourseSectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OfferedCourseSectionInclude<ExtArgs> | null
    where?: OfferedCourseSectionWhereInput
    orderBy?: OfferedCourseSectionOrderByWithRelationInput | OfferedCourseSectionOrderByWithRelationInput[]
    cursor?: OfferedCourseSectionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OfferedCourseSectionScalarFieldEnum | OfferedCourseSectionScalarFieldEnum[]
  }

  /**
   * OfferedCourse.studentSemesterRegistrationCourses
   */
  export type OfferedCourse$studentSemesterRegistrationCoursesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentSemesterRegistrationCourse
     */
    select?: StudentSemesterRegistrationCourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentSemesterRegistrationCourse
     */
    omit?: StudentSemesterRegistrationCourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentSemesterRegistrationCourseInclude<ExtArgs> | null
    where?: StudentSemesterRegistrationCourseWhereInput
    orderBy?: StudentSemesterRegistrationCourseOrderByWithRelationInput | StudentSemesterRegistrationCourseOrderByWithRelationInput[]
    cursor?: StudentSemesterRegistrationCourseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StudentSemesterRegistrationCourseScalarFieldEnum | StudentSemesterRegistrationCourseScalarFieldEnum[]
  }

  /**
   * OfferedCourse without action
   */
  export type OfferedCourseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OfferedCourse
     */
    select?: OfferedCourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OfferedCourse
     */
    omit?: OfferedCourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OfferedCourseInclude<ExtArgs> | null
  }


  /**
   * Model OfferedCourseSection
   */

  export type AggregateOfferedCourseSection = {
    _count: OfferedCourseSectionCountAggregateOutputType | null
    _avg: OfferedCourseSectionAvgAggregateOutputType | null
    _sum: OfferedCourseSectionSumAggregateOutputType | null
    _min: OfferedCourseSectionMinAggregateOutputType | null
    _max: OfferedCourseSectionMaxAggregateOutputType | null
  }

  export type OfferedCourseSectionAvgAggregateOutputType = {
    maxCapacity: number | null
    currentlyEnrolledStudent: number | null
  }

  export type OfferedCourseSectionSumAggregateOutputType = {
    maxCapacity: number | null
    currentlyEnrolledStudent: number | null
  }

  export type OfferedCourseSectionMinAggregateOutputType = {
    id: string | null
    title: string | null
    maxCapacity: number | null
    currentlyEnrolledStudent: number | null
    createdAt: Date | null
    updatedAt: Date | null
    semesterRegistrationId: string | null
    offeredCourseId: string | null
  }

  export type OfferedCourseSectionMaxAggregateOutputType = {
    id: string | null
    title: string | null
    maxCapacity: number | null
    currentlyEnrolledStudent: number | null
    createdAt: Date | null
    updatedAt: Date | null
    semesterRegistrationId: string | null
    offeredCourseId: string | null
  }

  export type OfferedCourseSectionCountAggregateOutputType = {
    id: number
    title: number
    maxCapacity: number
    currentlyEnrolledStudent: number
    createdAt: number
    updatedAt: number
    semesterRegistrationId: number
    offeredCourseId: number
    _all: number
  }


  export type OfferedCourseSectionAvgAggregateInputType = {
    maxCapacity?: true
    currentlyEnrolledStudent?: true
  }

  export type OfferedCourseSectionSumAggregateInputType = {
    maxCapacity?: true
    currentlyEnrolledStudent?: true
  }

  export type OfferedCourseSectionMinAggregateInputType = {
    id?: true
    title?: true
    maxCapacity?: true
    currentlyEnrolledStudent?: true
    createdAt?: true
    updatedAt?: true
    semesterRegistrationId?: true
    offeredCourseId?: true
  }

  export type OfferedCourseSectionMaxAggregateInputType = {
    id?: true
    title?: true
    maxCapacity?: true
    currentlyEnrolledStudent?: true
    createdAt?: true
    updatedAt?: true
    semesterRegistrationId?: true
    offeredCourseId?: true
  }

  export type OfferedCourseSectionCountAggregateInputType = {
    id?: true
    title?: true
    maxCapacity?: true
    currentlyEnrolledStudent?: true
    createdAt?: true
    updatedAt?: true
    semesterRegistrationId?: true
    offeredCourseId?: true
    _all?: true
  }

  export type OfferedCourseSectionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OfferedCourseSection to aggregate.
     */
    where?: OfferedCourseSectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OfferedCourseSections to fetch.
     */
    orderBy?: OfferedCourseSectionOrderByWithRelationInput | OfferedCourseSectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OfferedCourseSectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OfferedCourseSections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OfferedCourseSections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OfferedCourseSections
    **/
    _count?: true | OfferedCourseSectionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OfferedCourseSectionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OfferedCourseSectionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OfferedCourseSectionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OfferedCourseSectionMaxAggregateInputType
  }

  export type GetOfferedCourseSectionAggregateType<T extends OfferedCourseSectionAggregateArgs> = {
        [P in keyof T & keyof AggregateOfferedCourseSection]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOfferedCourseSection[P]>
      : GetScalarType<T[P], AggregateOfferedCourseSection[P]>
  }




  export type OfferedCourseSectionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OfferedCourseSectionWhereInput
    orderBy?: OfferedCourseSectionOrderByWithAggregationInput | OfferedCourseSectionOrderByWithAggregationInput[]
    by: OfferedCourseSectionScalarFieldEnum[] | OfferedCourseSectionScalarFieldEnum
    having?: OfferedCourseSectionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OfferedCourseSectionCountAggregateInputType | true
    _avg?: OfferedCourseSectionAvgAggregateInputType
    _sum?: OfferedCourseSectionSumAggregateInputType
    _min?: OfferedCourseSectionMinAggregateInputType
    _max?: OfferedCourseSectionMaxAggregateInputType
  }

  export type OfferedCourseSectionGroupByOutputType = {
    id: string
    title: string
    maxCapacity: number
    currentlyEnrolledStudent: number
    createdAt: Date
    updatedAt: Date
    semesterRegistrationId: string
    offeredCourseId: string
    _count: OfferedCourseSectionCountAggregateOutputType | null
    _avg: OfferedCourseSectionAvgAggregateOutputType | null
    _sum: OfferedCourseSectionSumAggregateOutputType | null
    _min: OfferedCourseSectionMinAggregateOutputType | null
    _max: OfferedCourseSectionMaxAggregateOutputType | null
  }

  type GetOfferedCourseSectionGroupByPayload<T extends OfferedCourseSectionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OfferedCourseSectionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OfferedCourseSectionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OfferedCourseSectionGroupByOutputType[P]>
            : GetScalarType<T[P], OfferedCourseSectionGroupByOutputType[P]>
        }
      >
    >


  export type OfferedCourseSectionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    maxCapacity?: boolean
    currentlyEnrolledStudent?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    semesterRegistrationId?: boolean
    offeredCourseId?: boolean
    semesterRegistration?: boolean | SemesterRegistrationDefaultArgs<ExtArgs>
    offeredCourse?: boolean | OfferedCourseDefaultArgs<ExtArgs>
    offeredCourseClassSchedules?: boolean | OfferedCourseSection$offeredCourseClassSchedulesArgs<ExtArgs>
    studentSemesterRegistrationCourses?: boolean | OfferedCourseSection$studentSemesterRegistrationCoursesArgs<ExtArgs>
    _count?: boolean | OfferedCourseSectionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["offeredCourseSection"]>



  export type OfferedCourseSectionSelectScalar = {
    id?: boolean
    title?: boolean
    maxCapacity?: boolean
    currentlyEnrolledStudent?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    semesterRegistrationId?: boolean
    offeredCourseId?: boolean
  }

  export type OfferedCourseSectionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "maxCapacity" | "currentlyEnrolledStudent" | "createdAt" | "updatedAt" | "semesterRegistrationId" | "offeredCourseId", ExtArgs["result"]["offeredCourseSection"]>
  export type OfferedCourseSectionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    semesterRegistration?: boolean | SemesterRegistrationDefaultArgs<ExtArgs>
    offeredCourse?: boolean | OfferedCourseDefaultArgs<ExtArgs>
    offeredCourseClassSchedules?: boolean | OfferedCourseSection$offeredCourseClassSchedulesArgs<ExtArgs>
    studentSemesterRegistrationCourses?: boolean | OfferedCourseSection$studentSemesterRegistrationCoursesArgs<ExtArgs>
    _count?: boolean | OfferedCourseSectionCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $OfferedCourseSectionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "OfferedCourseSection"
    objects: {
      semesterRegistration: Prisma.$SemesterRegistrationPayload<ExtArgs>
      offeredCourse: Prisma.$OfferedCoursePayload<ExtArgs>
      offeredCourseClassSchedules: Prisma.$OfferedCourseClassSchedulePayload<ExtArgs>[]
      studentSemesterRegistrationCourses: Prisma.$StudentSemesterRegistrationCoursePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      maxCapacity: number
      currentlyEnrolledStudent: number
      createdAt: Date
      updatedAt: Date
      semesterRegistrationId: string
      offeredCourseId: string
    }, ExtArgs["result"]["offeredCourseSection"]>
    composites: {}
  }

  type OfferedCourseSectionGetPayload<S extends boolean | null | undefined | OfferedCourseSectionDefaultArgs> = $Result.GetResult<Prisma.$OfferedCourseSectionPayload, S>

  type OfferedCourseSectionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OfferedCourseSectionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OfferedCourseSectionCountAggregateInputType | true
    }

  export interface OfferedCourseSectionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OfferedCourseSection'], meta: { name: 'OfferedCourseSection' } }
    /**
     * Find zero or one OfferedCourseSection that matches the filter.
     * @param {OfferedCourseSectionFindUniqueArgs} args - Arguments to find a OfferedCourseSection
     * @example
     * // Get one OfferedCourseSection
     * const offeredCourseSection = await prisma.offeredCourseSection.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OfferedCourseSectionFindUniqueArgs>(args: SelectSubset<T, OfferedCourseSectionFindUniqueArgs<ExtArgs>>): Prisma__OfferedCourseSectionClient<$Result.GetResult<Prisma.$OfferedCourseSectionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one OfferedCourseSection that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OfferedCourseSectionFindUniqueOrThrowArgs} args - Arguments to find a OfferedCourseSection
     * @example
     * // Get one OfferedCourseSection
     * const offeredCourseSection = await prisma.offeredCourseSection.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OfferedCourseSectionFindUniqueOrThrowArgs>(args: SelectSubset<T, OfferedCourseSectionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OfferedCourseSectionClient<$Result.GetResult<Prisma.$OfferedCourseSectionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OfferedCourseSection that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OfferedCourseSectionFindFirstArgs} args - Arguments to find a OfferedCourseSection
     * @example
     * // Get one OfferedCourseSection
     * const offeredCourseSection = await prisma.offeredCourseSection.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OfferedCourseSectionFindFirstArgs>(args?: SelectSubset<T, OfferedCourseSectionFindFirstArgs<ExtArgs>>): Prisma__OfferedCourseSectionClient<$Result.GetResult<Prisma.$OfferedCourseSectionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OfferedCourseSection that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OfferedCourseSectionFindFirstOrThrowArgs} args - Arguments to find a OfferedCourseSection
     * @example
     * // Get one OfferedCourseSection
     * const offeredCourseSection = await prisma.offeredCourseSection.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OfferedCourseSectionFindFirstOrThrowArgs>(args?: SelectSubset<T, OfferedCourseSectionFindFirstOrThrowArgs<ExtArgs>>): Prisma__OfferedCourseSectionClient<$Result.GetResult<Prisma.$OfferedCourseSectionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more OfferedCourseSections that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OfferedCourseSectionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OfferedCourseSections
     * const offeredCourseSections = await prisma.offeredCourseSection.findMany()
     * 
     * // Get first 10 OfferedCourseSections
     * const offeredCourseSections = await prisma.offeredCourseSection.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const offeredCourseSectionWithIdOnly = await prisma.offeredCourseSection.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OfferedCourseSectionFindManyArgs>(args?: SelectSubset<T, OfferedCourseSectionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OfferedCourseSectionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a OfferedCourseSection.
     * @param {OfferedCourseSectionCreateArgs} args - Arguments to create a OfferedCourseSection.
     * @example
     * // Create one OfferedCourseSection
     * const OfferedCourseSection = await prisma.offeredCourseSection.create({
     *   data: {
     *     // ... data to create a OfferedCourseSection
     *   }
     * })
     * 
     */
    create<T extends OfferedCourseSectionCreateArgs>(args: SelectSubset<T, OfferedCourseSectionCreateArgs<ExtArgs>>): Prisma__OfferedCourseSectionClient<$Result.GetResult<Prisma.$OfferedCourseSectionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many OfferedCourseSections.
     * @param {OfferedCourseSectionCreateManyArgs} args - Arguments to create many OfferedCourseSections.
     * @example
     * // Create many OfferedCourseSections
     * const offeredCourseSection = await prisma.offeredCourseSection.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OfferedCourseSectionCreateManyArgs>(args?: SelectSubset<T, OfferedCourseSectionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a OfferedCourseSection.
     * @param {OfferedCourseSectionDeleteArgs} args - Arguments to delete one OfferedCourseSection.
     * @example
     * // Delete one OfferedCourseSection
     * const OfferedCourseSection = await prisma.offeredCourseSection.delete({
     *   where: {
     *     // ... filter to delete one OfferedCourseSection
     *   }
     * })
     * 
     */
    delete<T extends OfferedCourseSectionDeleteArgs>(args: SelectSubset<T, OfferedCourseSectionDeleteArgs<ExtArgs>>): Prisma__OfferedCourseSectionClient<$Result.GetResult<Prisma.$OfferedCourseSectionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one OfferedCourseSection.
     * @param {OfferedCourseSectionUpdateArgs} args - Arguments to update one OfferedCourseSection.
     * @example
     * // Update one OfferedCourseSection
     * const offeredCourseSection = await prisma.offeredCourseSection.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OfferedCourseSectionUpdateArgs>(args: SelectSubset<T, OfferedCourseSectionUpdateArgs<ExtArgs>>): Prisma__OfferedCourseSectionClient<$Result.GetResult<Prisma.$OfferedCourseSectionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more OfferedCourseSections.
     * @param {OfferedCourseSectionDeleteManyArgs} args - Arguments to filter OfferedCourseSections to delete.
     * @example
     * // Delete a few OfferedCourseSections
     * const { count } = await prisma.offeredCourseSection.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OfferedCourseSectionDeleteManyArgs>(args?: SelectSubset<T, OfferedCourseSectionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OfferedCourseSections.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OfferedCourseSectionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OfferedCourseSections
     * const offeredCourseSection = await prisma.offeredCourseSection.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OfferedCourseSectionUpdateManyArgs>(args: SelectSubset<T, OfferedCourseSectionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one OfferedCourseSection.
     * @param {OfferedCourseSectionUpsertArgs} args - Arguments to update or create a OfferedCourseSection.
     * @example
     * // Update or create a OfferedCourseSection
     * const offeredCourseSection = await prisma.offeredCourseSection.upsert({
     *   create: {
     *     // ... data to create a OfferedCourseSection
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OfferedCourseSection we want to update
     *   }
     * })
     */
    upsert<T extends OfferedCourseSectionUpsertArgs>(args: SelectSubset<T, OfferedCourseSectionUpsertArgs<ExtArgs>>): Prisma__OfferedCourseSectionClient<$Result.GetResult<Prisma.$OfferedCourseSectionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of OfferedCourseSections.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OfferedCourseSectionCountArgs} args - Arguments to filter OfferedCourseSections to count.
     * @example
     * // Count the number of OfferedCourseSections
     * const count = await prisma.offeredCourseSection.count({
     *   where: {
     *     // ... the filter for the OfferedCourseSections we want to count
     *   }
     * })
    **/
    count<T extends OfferedCourseSectionCountArgs>(
      args?: Subset<T, OfferedCourseSectionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OfferedCourseSectionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OfferedCourseSection.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OfferedCourseSectionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OfferedCourseSectionAggregateArgs>(args: Subset<T, OfferedCourseSectionAggregateArgs>): Prisma.PrismaPromise<GetOfferedCourseSectionAggregateType<T>>

    /**
     * Group by OfferedCourseSection.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OfferedCourseSectionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OfferedCourseSectionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OfferedCourseSectionGroupByArgs['orderBy'] }
        : { orderBy?: OfferedCourseSectionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OfferedCourseSectionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOfferedCourseSectionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the OfferedCourseSection model
   */
  readonly fields: OfferedCourseSectionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OfferedCourseSection.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OfferedCourseSectionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    semesterRegistration<T extends SemesterRegistrationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SemesterRegistrationDefaultArgs<ExtArgs>>): Prisma__SemesterRegistrationClient<$Result.GetResult<Prisma.$SemesterRegistrationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    offeredCourse<T extends OfferedCourseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OfferedCourseDefaultArgs<ExtArgs>>): Prisma__OfferedCourseClient<$Result.GetResult<Prisma.$OfferedCoursePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    offeredCourseClassSchedules<T extends OfferedCourseSection$offeredCourseClassSchedulesArgs<ExtArgs> = {}>(args?: Subset<T, OfferedCourseSection$offeredCourseClassSchedulesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OfferedCourseClassSchedulePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    studentSemesterRegistrationCourses<T extends OfferedCourseSection$studentSemesterRegistrationCoursesArgs<ExtArgs> = {}>(args?: Subset<T, OfferedCourseSection$studentSemesterRegistrationCoursesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentSemesterRegistrationCoursePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the OfferedCourseSection model
   */
  interface OfferedCourseSectionFieldRefs {
    readonly id: FieldRef<"OfferedCourseSection", 'String'>
    readonly title: FieldRef<"OfferedCourseSection", 'String'>
    readonly maxCapacity: FieldRef<"OfferedCourseSection", 'Int'>
    readonly currentlyEnrolledStudent: FieldRef<"OfferedCourseSection", 'Int'>
    readonly createdAt: FieldRef<"OfferedCourseSection", 'DateTime'>
    readonly updatedAt: FieldRef<"OfferedCourseSection", 'DateTime'>
    readonly semesterRegistrationId: FieldRef<"OfferedCourseSection", 'String'>
    readonly offeredCourseId: FieldRef<"OfferedCourseSection", 'String'>
  }
    

  // Custom InputTypes
  /**
   * OfferedCourseSection findUnique
   */
  export type OfferedCourseSectionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OfferedCourseSection
     */
    select?: OfferedCourseSectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OfferedCourseSection
     */
    omit?: OfferedCourseSectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OfferedCourseSectionInclude<ExtArgs> | null
    /**
     * Filter, which OfferedCourseSection to fetch.
     */
    where: OfferedCourseSectionWhereUniqueInput
  }

  /**
   * OfferedCourseSection findUniqueOrThrow
   */
  export type OfferedCourseSectionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OfferedCourseSection
     */
    select?: OfferedCourseSectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OfferedCourseSection
     */
    omit?: OfferedCourseSectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OfferedCourseSectionInclude<ExtArgs> | null
    /**
     * Filter, which OfferedCourseSection to fetch.
     */
    where: OfferedCourseSectionWhereUniqueInput
  }

  /**
   * OfferedCourseSection findFirst
   */
  export type OfferedCourseSectionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OfferedCourseSection
     */
    select?: OfferedCourseSectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OfferedCourseSection
     */
    omit?: OfferedCourseSectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OfferedCourseSectionInclude<ExtArgs> | null
    /**
     * Filter, which OfferedCourseSection to fetch.
     */
    where?: OfferedCourseSectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OfferedCourseSections to fetch.
     */
    orderBy?: OfferedCourseSectionOrderByWithRelationInput | OfferedCourseSectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OfferedCourseSections.
     */
    cursor?: OfferedCourseSectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OfferedCourseSections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OfferedCourseSections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OfferedCourseSections.
     */
    distinct?: OfferedCourseSectionScalarFieldEnum | OfferedCourseSectionScalarFieldEnum[]
  }

  /**
   * OfferedCourseSection findFirstOrThrow
   */
  export type OfferedCourseSectionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OfferedCourseSection
     */
    select?: OfferedCourseSectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OfferedCourseSection
     */
    omit?: OfferedCourseSectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OfferedCourseSectionInclude<ExtArgs> | null
    /**
     * Filter, which OfferedCourseSection to fetch.
     */
    where?: OfferedCourseSectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OfferedCourseSections to fetch.
     */
    orderBy?: OfferedCourseSectionOrderByWithRelationInput | OfferedCourseSectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OfferedCourseSections.
     */
    cursor?: OfferedCourseSectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OfferedCourseSections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OfferedCourseSections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OfferedCourseSections.
     */
    distinct?: OfferedCourseSectionScalarFieldEnum | OfferedCourseSectionScalarFieldEnum[]
  }

  /**
   * OfferedCourseSection findMany
   */
  export type OfferedCourseSectionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OfferedCourseSection
     */
    select?: OfferedCourseSectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OfferedCourseSection
     */
    omit?: OfferedCourseSectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OfferedCourseSectionInclude<ExtArgs> | null
    /**
     * Filter, which OfferedCourseSections to fetch.
     */
    where?: OfferedCourseSectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OfferedCourseSections to fetch.
     */
    orderBy?: OfferedCourseSectionOrderByWithRelationInput | OfferedCourseSectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OfferedCourseSections.
     */
    cursor?: OfferedCourseSectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OfferedCourseSections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OfferedCourseSections.
     */
    skip?: number
    distinct?: OfferedCourseSectionScalarFieldEnum | OfferedCourseSectionScalarFieldEnum[]
  }

  /**
   * OfferedCourseSection create
   */
  export type OfferedCourseSectionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OfferedCourseSection
     */
    select?: OfferedCourseSectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OfferedCourseSection
     */
    omit?: OfferedCourseSectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OfferedCourseSectionInclude<ExtArgs> | null
    /**
     * The data needed to create a OfferedCourseSection.
     */
    data: XOR<OfferedCourseSectionCreateInput, OfferedCourseSectionUncheckedCreateInput>
  }

  /**
   * OfferedCourseSection createMany
   */
  export type OfferedCourseSectionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OfferedCourseSections.
     */
    data: OfferedCourseSectionCreateManyInput | OfferedCourseSectionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * OfferedCourseSection update
   */
  export type OfferedCourseSectionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OfferedCourseSection
     */
    select?: OfferedCourseSectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OfferedCourseSection
     */
    omit?: OfferedCourseSectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OfferedCourseSectionInclude<ExtArgs> | null
    /**
     * The data needed to update a OfferedCourseSection.
     */
    data: XOR<OfferedCourseSectionUpdateInput, OfferedCourseSectionUncheckedUpdateInput>
    /**
     * Choose, which OfferedCourseSection to update.
     */
    where: OfferedCourseSectionWhereUniqueInput
  }

  /**
   * OfferedCourseSection updateMany
   */
  export type OfferedCourseSectionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OfferedCourseSections.
     */
    data: XOR<OfferedCourseSectionUpdateManyMutationInput, OfferedCourseSectionUncheckedUpdateManyInput>
    /**
     * Filter which OfferedCourseSections to update
     */
    where?: OfferedCourseSectionWhereInput
    /**
     * Limit how many OfferedCourseSections to update.
     */
    limit?: number
  }

  /**
   * OfferedCourseSection upsert
   */
  export type OfferedCourseSectionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OfferedCourseSection
     */
    select?: OfferedCourseSectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OfferedCourseSection
     */
    omit?: OfferedCourseSectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OfferedCourseSectionInclude<ExtArgs> | null
    /**
     * The filter to search for the OfferedCourseSection to update in case it exists.
     */
    where: OfferedCourseSectionWhereUniqueInput
    /**
     * In case the OfferedCourseSection found by the `where` argument doesn't exist, create a new OfferedCourseSection with this data.
     */
    create: XOR<OfferedCourseSectionCreateInput, OfferedCourseSectionUncheckedCreateInput>
    /**
     * In case the OfferedCourseSection was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OfferedCourseSectionUpdateInput, OfferedCourseSectionUncheckedUpdateInput>
  }

  /**
   * OfferedCourseSection delete
   */
  export type OfferedCourseSectionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OfferedCourseSection
     */
    select?: OfferedCourseSectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OfferedCourseSection
     */
    omit?: OfferedCourseSectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OfferedCourseSectionInclude<ExtArgs> | null
    /**
     * Filter which OfferedCourseSection to delete.
     */
    where: OfferedCourseSectionWhereUniqueInput
  }

  /**
   * OfferedCourseSection deleteMany
   */
  export type OfferedCourseSectionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OfferedCourseSections to delete
     */
    where?: OfferedCourseSectionWhereInput
    /**
     * Limit how many OfferedCourseSections to delete.
     */
    limit?: number
  }

  /**
   * OfferedCourseSection.offeredCourseClassSchedules
   */
  export type OfferedCourseSection$offeredCourseClassSchedulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OfferedCourseClassSchedule
     */
    select?: OfferedCourseClassScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OfferedCourseClassSchedule
     */
    omit?: OfferedCourseClassScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OfferedCourseClassScheduleInclude<ExtArgs> | null
    where?: OfferedCourseClassScheduleWhereInput
    orderBy?: OfferedCourseClassScheduleOrderByWithRelationInput | OfferedCourseClassScheduleOrderByWithRelationInput[]
    cursor?: OfferedCourseClassScheduleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OfferedCourseClassScheduleScalarFieldEnum | OfferedCourseClassScheduleScalarFieldEnum[]
  }

  /**
   * OfferedCourseSection.studentSemesterRegistrationCourses
   */
  export type OfferedCourseSection$studentSemesterRegistrationCoursesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentSemesterRegistrationCourse
     */
    select?: StudentSemesterRegistrationCourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentSemesterRegistrationCourse
     */
    omit?: StudentSemesterRegistrationCourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentSemesterRegistrationCourseInclude<ExtArgs> | null
    where?: StudentSemesterRegistrationCourseWhereInput
    orderBy?: StudentSemesterRegistrationCourseOrderByWithRelationInput | StudentSemesterRegistrationCourseOrderByWithRelationInput[]
    cursor?: StudentSemesterRegistrationCourseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StudentSemesterRegistrationCourseScalarFieldEnum | StudentSemesterRegistrationCourseScalarFieldEnum[]
  }

  /**
   * OfferedCourseSection without action
   */
  export type OfferedCourseSectionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OfferedCourseSection
     */
    select?: OfferedCourseSectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OfferedCourseSection
     */
    omit?: OfferedCourseSectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OfferedCourseSectionInclude<ExtArgs> | null
  }


  /**
   * Model OfferedCourseClassSchedule
   */

  export type AggregateOfferedCourseClassSchedule = {
    _count: OfferedCourseClassScheduleCountAggregateOutputType | null
    _min: OfferedCourseClassScheduleMinAggregateOutputType | null
    _max: OfferedCourseClassScheduleMaxAggregateOutputType | null
  }

  export type OfferedCourseClassScheduleMinAggregateOutputType = {
    id: string | null
    startTime: string | null
    endTime: string | null
    dayOfWeek: $Enums.WeekDays | null
    createdAt: Date | null
    updatedAt: Date | null
    offeredCourseSectionId: string | null
    semesterRegistrationId: string | null
    roomId: string | null
    facultyId: string | null
  }

  export type OfferedCourseClassScheduleMaxAggregateOutputType = {
    id: string | null
    startTime: string | null
    endTime: string | null
    dayOfWeek: $Enums.WeekDays | null
    createdAt: Date | null
    updatedAt: Date | null
    offeredCourseSectionId: string | null
    semesterRegistrationId: string | null
    roomId: string | null
    facultyId: string | null
  }

  export type OfferedCourseClassScheduleCountAggregateOutputType = {
    id: number
    startTime: number
    endTime: number
    dayOfWeek: number
    createdAt: number
    updatedAt: number
    offeredCourseSectionId: number
    semesterRegistrationId: number
    roomId: number
    facultyId: number
    _all: number
  }


  export type OfferedCourseClassScheduleMinAggregateInputType = {
    id?: true
    startTime?: true
    endTime?: true
    dayOfWeek?: true
    createdAt?: true
    updatedAt?: true
    offeredCourseSectionId?: true
    semesterRegistrationId?: true
    roomId?: true
    facultyId?: true
  }

  export type OfferedCourseClassScheduleMaxAggregateInputType = {
    id?: true
    startTime?: true
    endTime?: true
    dayOfWeek?: true
    createdAt?: true
    updatedAt?: true
    offeredCourseSectionId?: true
    semesterRegistrationId?: true
    roomId?: true
    facultyId?: true
  }

  export type OfferedCourseClassScheduleCountAggregateInputType = {
    id?: true
    startTime?: true
    endTime?: true
    dayOfWeek?: true
    createdAt?: true
    updatedAt?: true
    offeredCourseSectionId?: true
    semesterRegistrationId?: true
    roomId?: true
    facultyId?: true
    _all?: true
  }

  export type OfferedCourseClassScheduleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OfferedCourseClassSchedule to aggregate.
     */
    where?: OfferedCourseClassScheduleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OfferedCourseClassSchedules to fetch.
     */
    orderBy?: OfferedCourseClassScheduleOrderByWithRelationInput | OfferedCourseClassScheduleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OfferedCourseClassScheduleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OfferedCourseClassSchedules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OfferedCourseClassSchedules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OfferedCourseClassSchedules
    **/
    _count?: true | OfferedCourseClassScheduleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OfferedCourseClassScheduleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OfferedCourseClassScheduleMaxAggregateInputType
  }

  export type GetOfferedCourseClassScheduleAggregateType<T extends OfferedCourseClassScheduleAggregateArgs> = {
        [P in keyof T & keyof AggregateOfferedCourseClassSchedule]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOfferedCourseClassSchedule[P]>
      : GetScalarType<T[P], AggregateOfferedCourseClassSchedule[P]>
  }




  export type OfferedCourseClassScheduleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OfferedCourseClassScheduleWhereInput
    orderBy?: OfferedCourseClassScheduleOrderByWithAggregationInput | OfferedCourseClassScheduleOrderByWithAggregationInput[]
    by: OfferedCourseClassScheduleScalarFieldEnum[] | OfferedCourseClassScheduleScalarFieldEnum
    having?: OfferedCourseClassScheduleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OfferedCourseClassScheduleCountAggregateInputType | true
    _min?: OfferedCourseClassScheduleMinAggregateInputType
    _max?: OfferedCourseClassScheduleMaxAggregateInputType
  }

  export type OfferedCourseClassScheduleGroupByOutputType = {
    id: string
    startTime: string
    endTime: string
    dayOfWeek: $Enums.WeekDays
    createdAt: Date
    updatedAt: Date
    offeredCourseSectionId: string
    semesterRegistrationId: string
    roomId: string
    facultyId: string
    _count: OfferedCourseClassScheduleCountAggregateOutputType | null
    _min: OfferedCourseClassScheduleMinAggregateOutputType | null
    _max: OfferedCourseClassScheduleMaxAggregateOutputType | null
  }

  type GetOfferedCourseClassScheduleGroupByPayload<T extends OfferedCourseClassScheduleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OfferedCourseClassScheduleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OfferedCourseClassScheduleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OfferedCourseClassScheduleGroupByOutputType[P]>
            : GetScalarType<T[P], OfferedCourseClassScheduleGroupByOutputType[P]>
        }
      >
    >


  export type OfferedCourseClassScheduleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    startTime?: boolean
    endTime?: boolean
    dayOfWeek?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    offeredCourseSectionId?: boolean
    semesterRegistrationId?: boolean
    roomId?: boolean
    facultyId?: boolean
    offeredCourseSection?: boolean | OfferedCourseSectionDefaultArgs<ExtArgs>
    semesterRegistration?: boolean | SemesterRegistrationDefaultArgs<ExtArgs>
    room?: boolean | RoomDefaultArgs<ExtArgs>
    faculty?: boolean | FacultyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["offeredCourseClassSchedule"]>



  export type OfferedCourseClassScheduleSelectScalar = {
    id?: boolean
    startTime?: boolean
    endTime?: boolean
    dayOfWeek?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    offeredCourseSectionId?: boolean
    semesterRegistrationId?: boolean
    roomId?: boolean
    facultyId?: boolean
  }

  export type OfferedCourseClassScheduleOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "startTime" | "endTime" | "dayOfWeek" | "createdAt" | "updatedAt" | "offeredCourseSectionId" | "semesterRegistrationId" | "roomId" | "facultyId", ExtArgs["result"]["offeredCourseClassSchedule"]>
  export type OfferedCourseClassScheduleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    offeredCourseSection?: boolean | OfferedCourseSectionDefaultArgs<ExtArgs>
    semesterRegistration?: boolean | SemesterRegistrationDefaultArgs<ExtArgs>
    room?: boolean | RoomDefaultArgs<ExtArgs>
    faculty?: boolean | FacultyDefaultArgs<ExtArgs>
  }

  export type $OfferedCourseClassSchedulePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "OfferedCourseClassSchedule"
    objects: {
      offeredCourseSection: Prisma.$OfferedCourseSectionPayload<ExtArgs>
      semesterRegistration: Prisma.$SemesterRegistrationPayload<ExtArgs>
      room: Prisma.$RoomPayload<ExtArgs>
      faculty: Prisma.$FacultyPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      startTime: string
      endTime: string
      dayOfWeek: $Enums.WeekDays
      createdAt: Date
      updatedAt: Date
      offeredCourseSectionId: string
      semesterRegistrationId: string
      roomId: string
      facultyId: string
    }, ExtArgs["result"]["offeredCourseClassSchedule"]>
    composites: {}
  }

  type OfferedCourseClassScheduleGetPayload<S extends boolean | null | undefined | OfferedCourseClassScheduleDefaultArgs> = $Result.GetResult<Prisma.$OfferedCourseClassSchedulePayload, S>

  type OfferedCourseClassScheduleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OfferedCourseClassScheduleFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OfferedCourseClassScheduleCountAggregateInputType | true
    }

  export interface OfferedCourseClassScheduleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OfferedCourseClassSchedule'], meta: { name: 'OfferedCourseClassSchedule' } }
    /**
     * Find zero or one OfferedCourseClassSchedule that matches the filter.
     * @param {OfferedCourseClassScheduleFindUniqueArgs} args - Arguments to find a OfferedCourseClassSchedule
     * @example
     * // Get one OfferedCourseClassSchedule
     * const offeredCourseClassSchedule = await prisma.offeredCourseClassSchedule.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OfferedCourseClassScheduleFindUniqueArgs>(args: SelectSubset<T, OfferedCourseClassScheduleFindUniqueArgs<ExtArgs>>): Prisma__OfferedCourseClassScheduleClient<$Result.GetResult<Prisma.$OfferedCourseClassSchedulePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one OfferedCourseClassSchedule that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OfferedCourseClassScheduleFindUniqueOrThrowArgs} args - Arguments to find a OfferedCourseClassSchedule
     * @example
     * // Get one OfferedCourseClassSchedule
     * const offeredCourseClassSchedule = await prisma.offeredCourseClassSchedule.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OfferedCourseClassScheduleFindUniqueOrThrowArgs>(args: SelectSubset<T, OfferedCourseClassScheduleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OfferedCourseClassScheduleClient<$Result.GetResult<Prisma.$OfferedCourseClassSchedulePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OfferedCourseClassSchedule that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OfferedCourseClassScheduleFindFirstArgs} args - Arguments to find a OfferedCourseClassSchedule
     * @example
     * // Get one OfferedCourseClassSchedule
     * const offeredCourseClassSchedule = await prisma.offeredCourseClassSchedule.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OfferedCourseClassScheduleFindFirstArgs>(args?: SelectSubset<T, OfferedCourseClassScheduleFindFirstArgs<ExtArgs>>): Prisma__OfferedCourseClassScheduleClient<$Result.GetResult<Prisma.$OfferedCourseClassSchedulePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OfferedCourseClassSchedule that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OfferedCourseClassScheduleFindFirstOrThrowArgs} args - Arguments to find a OfferedCourseClassSchedule
     * @example
     * // Get one OfferedCourseClassSchedule
     * const offeredCourseClassSchedule = await prisma.offeredCourseClassSchedule.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OfferedCourseClassScheduleFindFirstOrThrowArgs>(args?: SelectSubset<T, OfferedCourseClassScheduleFindFirstOrThrowArgs<ExtArgs>>): Prisma__OfferedCourseClassScheduleClient<$Result.GetResult<Prisma.$OfferedCourseClassSchedulePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more OfferedCourseClassSchedules that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OfferedCourseClassScheduleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OfferedCourseClassSchedules
     * const offeredCourseClassSchedules = await prisma.offeredCourseClassSchedule.findMany()
     * 
     * // Get first 10 OfferedCourseClassSchedules
     * const offeredCourseClassSchedules = await prisma.offeredCourseClassSchedule.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const offeredCourseClassScheduleWithIdOnly = await prisma.offeredCourseClassSchedule.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OfferedCourseClassScheduleFindManyArgs>(args?: SelectSubset<T, OfferedCourseClassScheduleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OfferedCourseClassSchedulePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a OfferedCourseClassSchedule.
     * @param {OfferedCourseClassScheduleCreateArgs} args - Arguments to create a OfferedCourseClassSchedule.
     * @example
     * // Create one OfferedCourseClassSchedule
     * const OfferedCourseClassSchedule = await prisma.offeredCourseClassSchedule.create({
     *   data: {
     *     // ... data to create a OfferedCourseClassSchedule
     *   }
     * })
     * 
     */
    create<T extends OfferedCourseClassScheduleCreateArgs>(args: SelectSubset<T, OfferedCourseClassScheduleCreateArgs<ExtArgs>>): Prisma__OfferedCourseClassScheduleClient<$Result.GetResult<Prisma.$OfferedCourseClassSchedulePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many OfferedCourseClassSchedules.
     * @param {OfferedCourseClassScheduleCreateManyArgs} args - Arguments to create many OfferedCourseClassSchedules.
     * @example
     * // Create many OfferedCourseClassSchedules
     * const offeredCourseClassSchedule = await prisma.offeredCourseClassSchedule.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OfferedCourseClassScheduleCreateManyArgs>(args?: SelectSubset<T, OfferedCourseClassScheduleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a OfferedCourseClassSchedule.
     * @param {OfferedCourseClassScheduleDeleteArgs} args - Arguments to delete one OfferedCourseClassSchedule.
     * @example
     * // Delete one OfferedCourseClassSchedule
     * const OfferedCourseClassSchedule = await prisma.offeredCourseClassSchedule.delete({
     *   where: {
     *     // ... filter to delete one OfferedCourseClassSchedule
     *   }
     * })
     * 
     */
    delete<T extends OfferedCourseClassScheduleDeleteArgs>(args: SelectSubset<T, OfferedCourseClassScheduleDeleteArgs<ExtArgs>>): Prisma__OfferedCourseClassScheduleClient<$Result.GetResult<Prisma.$OfferedCourseClassSchedulePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one OfferedCourseClassSchedule.
     * @param {OfferedCourseClassScheduleUpdateArgs} args - Arguments to update one OfferedCourseClassSchedule.
     * @example
     * // Update one OfferedCourseClassSchedule
     * const offeredCourseClassSchedule = await prisma.offeredCourseClassSchedule.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OfferedCourseClassScheduleUpdateArgs>(args: SelectSubset<T, OfferedCourseClassScheduleUpdateArgs<ExtArgs>>): Prisma__OfferedCourseClassScheduleClient<$Result.GetResult<Prisma.$OfferedCourseClassSchedulePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more OfferedCourseClassSchedules.
     * @param {OfferedCourseClassScheduleDeleteManyArgs} args - Arguments to filter OfferedCourseClassSchedules to delete.
     * @example
     * // Delete a few OfferedCourseClassSchedules
     * const { count } = await prisma.offeredCourseClassSchedule.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OfferedCourseClassScheduleDeleteManyArgs>(args?: SelectSubset<T, OfferedCourseClassScheduleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OfferedCourseClassSchedules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OfferedCourseClassScheduleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OfferedCourseClassSchedules
     * const offeredCourseClassSchedule = await prisma.offeredCourseClassSchedule.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OfferedCourseClassScheduleUpdateManyArgs>(args: SelectSubset<T, OfferedCourseClassScheduleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one OfferedCourseClassSchedule.
     * @param {OfferedCourseClassScheduleUpsertArgs} args - Arguments to update or create a OfferedCourseClassSchedule.
     * @example
     * // Update or create a OfferedCourseClassSchedule
     * const offeredCourseClassSchedule = await prisma.offeredCourseClassSchedule.upsert({
     *   create: {
     *     // ... data to create a OfferedCourseClassSchedule
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OfferedCourseClassSchedule we want to update
     *   }
     * })
     */
    upsert<T extends OfferedCourseClassScheduleUpsertArgs>(args: SelectSubset<T, OfferedCourseClassScheduleUpsertArgs<ExtArgs>>): Prisma__OfferedCourseClassScheduleClient<$Result.GetResult<Prisma.$OfferedCourseClassSchedulePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of OfferedCourseClassSchedules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OfferedCourseClassScheduleCountArgs} args - Arguments to filter OfferedCourseClassSchedules to count.
     * @example
     * // Count the number of OfferedCourseClassSchedules
     * const count = await prisma.offeredCourseClassSchedule.count({
     *   where: {
     *     // ... the filter for the OfferedCourseClassSchedules we want to count
     *   }
     * })
    **/
    count<T extends OfferedCourseClassScheduleCountArgs>(
      args?: Subset<T, OfferedCourseClassScheduleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OfferedCourseClassScheduleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OfferedCourseClassSchedule.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OfferedCourseClassScheduleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OfferedCourseClassScheduleAggregateArgs>(args: Subset<T, OfferedCourseClassScheduleAggregateArgs>): Prisma.PrismaPromise<GetOfferedCourseClassScheduleAggregateType<T>>

    /**
     * Group by OfferedCourseClassSchedule.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OfferedCourseClassScheduleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OfferedCourseClassScheduleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OfferedCourseClassScheduleGroupByArgs['orderBy'] }
        : { orderBy?: OfferedCourseClassScheduleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OfferedCourseClassScheduleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOfferedCourseClassScheduleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the OfferedCourseClassSchedule model
   */
  readonly fields: OfferedCourseClassScheduleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OfferedCourseClassSchedule.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OfferedCourseClassScheduleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    offeredCourseSection<T extends OfferedCourseSectionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OfferedCourseSectionDefaultArgs<ExtArgs>>): Prisma__OfferedCourseSectionClient<$Result.GetResult<Prisma.$OfferedCourseSectionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    semesterRegistration<T extends SemesterRegistrationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SemesterRegistrationDefaultArgs<ExtArgs>>): Prisma__SemesterRegistrationClient<$Result.GetResult<Prisma.$SemesterRegistrationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    room<T extends RoomDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RoomDefaultArgs<ExtArgs>>): Prisma__RoomClient<$Result.GetResult<Prisma.$RoomPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    faculty<T extends FacultyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FacultyDefaultArgs<ExtArgs>>): Prisma__FacultyClient<$Result.GetResult<Prisma.$FacultyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the OfferedCourseClassSchedule model
   */
  interface OfferedCourseClassScheduleFieldRefs {
    readonly id: FieldRef<"OfferedCourseClassSchedule", 'String'>
    readonly startTime: FieldRef<"OfferedCourseClassSchedule", 'String'>
    readonly endTime: FieldRef<"OfferedCourseClassSchedule", 'String'>
    readonly dayOfWeek: FieldRef<"OfferedCourseClassSchedule", 'WeekDays'>
    readonly createdAt: FieldRef<"OfferedCourseClassSchedule", 'DateTime'>
    readonly updatedAt: FieldRef<"OfferedCourseClassSchedule", 'DateTime'>
    readonly offeredCourseSectionId: FieldRef<"OfferedCourseClassSchedule", 'String'>
    readonly semesterRegistrationId: FieldRef<"OfferedCourseClassSchedule", 'String'>
    readonly roomId: FieldRef<"OfferedCourseClassSchedule", 'String'>
    readonly facultyId: FieldRef<"OfferedCourseClassSchedule", 'String'>
  }
    

  // Custom InputTypes
  /**
   * OfferedCourseClassSchedule findUnique
   */
  export type OfferedCourseClassScheduleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OfferedCourseClassSchedule
     */
    select?: OfferedCourseClassScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OfferedCourseClassSchedule
     */
    omit?: OfferedCourseClassScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OfferedCourseClassScheduleInclude<ExtArgs> | null
    /**
     * Filter, which OfferedCourseClassSchedule to fetch.
     */
    where: OfferedCourseClassScheduleWhereUniqueInput
  }

  /**
   * OfferedCourseClassSchedule findUniqueOrThrow
   */
  export type OfferedCourseClassScheduleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OfferedCourseClassSchedule
     */
    select?: OfferedCourseClassScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OfferedCourseClassSchedule
     */
    omit?: OfferedCourseClassScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OfferedCourseClassScheduleInclude<ExtArgs> | null
    /**
     * Filter, which OfferedCourseClassSchedule to fetch.
     */
    where: OfferedCourseClassScheduleWhereUniqueInput
  }

  /**
   * OfferedCourseClassSchedule findFirst
   */
  export type OfferedCourseClassScheduleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OfferedCourseClassSchedule
     */
    select?: OfferedCourseClassScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OfferedCourseClassSchedule
     */
    omit?: OfferedCourseClassScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OfferedCourseClassScheduleInclude<ExtArgs> | null
    /**
     * Filter, which OfferedCourseClassSchedule to fetch.
     */
    where?: OfferedCourseClassScheduleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OfferedCourseClassSchedules to fetch.
     */
    orderBy?: OfferedCourseClassScheduleOrderByWithRelationInput | OfferedCourseClassScheduleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OfferedCourseClassSchedules.
     */
    cursor?: OfferedCourseClassScheduleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OfferedCourseClassSchedules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OfferedCourseClassSchedules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OfferedCourseClassSchedules.
     */
    distinct?: OfferedCourseClassScheduleScalarFieldEnum | OfferedCourseClassScheduleScalarFieldEnum[]
  }

  /**
   * OfferedCourseClassSchedule findFirstOrThrow
   */
  export type OfferedCourseClassScheduleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OfferedCourseClassSchedule
     */
    select?: OfferedCourseClassScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OfferedCourseClassSchedule
     */
    omit?: OfferedCourseClassScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OfferedCourseClassScheduleInclude<ExtArgs> | null
    /**
     * Filter, which OfferedCourseClassSchedule to fetch.
     */
    where?: OfferedCourseClassScheduleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OfferedCourseClassSchedules to fetch.
     */
    orderBy?: OfferedCourseClassScheduleOrderByWithRelationInput | OfferedCourseClassScheduleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OfferedCourseClassSchedules.
     */
    cursor?: OfferedCourseClassScheduleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OfferedCourseClassSchedules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OfferedCourseClassSchedules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OfferedCourseClassSchedules.
     */
    distinct?: OfferedCourseClassScheduleScalarFieldEnum | OfferedCourseClassScheduleScalarFieldEnum[]
  }

  /**
   * OfferedCourseClassSchedule findMany
   */
  export type OfferedCourseClassScheduleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OfferedCourseClassSchedule
     */
    select?: OfferedCourseClassScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OfferedCourseClassSchedule
     */
    omit?: OfferedCourseClassScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OfferedCourseClassScheduleInclude<ExtArgs> | null
    /**
     * Filter, which OfferedCourseClassSchedules to fetch.
     */
    where?: OfferedCourseClassScheduleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OfferedCourseClassSchedules to fetch.
     */
    orderBy?: OfferedCourseClassScheduleOrderByWithRelationInput | OfferedCourseClassScheduleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OfferedCourseClassSchedules.
     */
    cursor?: OfferedCourseClassScheduleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OfferedCourseClassSchedules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OfferedCourseClassSchedules.
     */
    skip?: number
    distinct?: OfferedCourseClassScheduleScalarFieldEnum | OfferedCourseClassScheduleScalarFieldEnum[]
  }

  /**
   * OfferedCourseClassSchedule create
   */
  export type OfferedCourseClassScheduleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OfferedCourseClassSchedule
     */
    select?: OfferedCourseClassScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OfferedCourseClassSchedule
     */
    omit?: OfferedCourseClassScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OfferedCourseClassScheduleInclude<ExtArgs> | null
    /**
     * The data needed to create a OfferedCourseClassSchedule.
     */
    data: XOR<OfferedCourseClassScheduleCreateInput, OfferedCourseClassScheduleUncheckedCreateInput>
  }

  /**
   * OfferedCourseClassSchedule createMany
   */
  export type OfferedCourseClassScheduleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OfferedCourseClassSchedules.
     */
    data: OfferedCourseClassScheduleCreateManyInput | OfferedCourseClassScheduleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * OfferedCourseClassSchedule update
   */
  export type OfferedCourseClassScheduleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OfferedCourseClassSchedule
     */
    select?: OfferedCourseClassScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OfferedCourseClassSchedule
     */
    omit?: OfferedCourseClassScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OfferedCourseClassScheduleInclude<ExtArgs> | null
    /**
     * The data needed to update a OfferedCourseClassSchedule.
     */
    data: XOR<OfferedCourseClassScheduleUpdateInput, OfferedCourseClassScheduleUncheckedUpdateInput>
    /**
     * Choose, which OfferedCourseClassSchedule to update.
     */
    where: OfferedCourseClassScheduleWhereUniqueInput
  }

  /**
   * OfferedCourseClassSchedule updateMany
   */
  export type OfferedCourseClassScheduleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OfferedCourseClassSchedules.
     */
    data: XOR<OfferedCourseClassScheduleUpdateManyMutationInput, OfferedCourseClassScheduleUncheckedUpdateManyInput>
    /**
     * Filter which OfferedCourseClassSchedules to update
     */
    where?: OfferedCourseClassScheduleWhereInput
    /**
     * Limit how many OfferedCourseClassSchedules to update.
     */
    limit?: number
  }

  /**
   * OfferedCourseClassSchedule upsert
   */
  export type OfferedCourseClassScheduleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OfferedCourseClassSchedule
     */
    select?: OfferedCourseClassScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OfferedCourseClassSchedule
     */
    omit?: OfferedCourseClassScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OfferedCourseClassScheduleInclude<ExtArgs> | null
    /**
     * The filter to search for the OfferedCourseClassSchedule to update in case it exists.
     */
    where: OfferedCourseClassScheduleWhereUniqueInput
    /**
     * In case the OfferedCourseClassSchedule found by the `where` argument doesn't exist, create a new OfferedCourseClassSchedule with this data.
     */
    create: XOR<OfferedCourseClassScheduleCreateInput, OfferedCourseClassScheduleUncheckedCreateInput>
    /**
     * In case the OfferedCourseClassSchedule was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OfferedCourseClassScheduleUpdateInput, OfferedCourseClassScheduleUncheckedUpdateInput>
  }

  /**
   * OfferedCourseClassSchedule delete
   */
  export type OfferedCourseClassScheduleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OfferedCourseClassSchedule
     */
    select?: OfferedCourseClassScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OfferedCourseClassSchedule
     */
    omit?: OfferedCourseClassScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OfferedCourseClassScheduleInclude<ExtArgs> | null
    /**
     * Filter which OfferedCourseClassSchedule to delete.
     */
    where: OfferedCourseClassScheduleWhereUniqueInput
  }

  /**
   * OfferedCourseClassSchedule deleteMany
   */
  export type OfferedCourseClassScheduleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OfferedCourseClassSchedules to delete
     */
    where?: OfferedCourseClassScheduleWhereInput
    /**
     * Limit how many OfferedCourseClassSchedules to delete.
     */
    limit?: number
  }

  /**
   * OfferedCourseClassSchedule without action
   */
  export type OfferedCourseClassScheduleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OfferedCourseClassSchedule
     */
    select?: OfferedCourseClassScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OfferedCourseClassSchedule
     */
    omit?: OfferedCourseClassScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OfferedCourseClassScheduleInclude<ExtArgs> | null
  }


  /**
   * Model StudentSemesterRegistration
   */

  export type AggregateStudentSemesterRegistration = {
    _count: StudentSemesterRegistrationCountAggregateOutputType | null
    _avg: StudentSemesterRegistrationAvgAggregateOutputType | null
    _sum: StudentSemesterRegistrationSumAggregateOutputType | null
    _min: StudentSemesterRegistrationMinAggregateOutputType | null
    _max: StudentSemesterRegistrationMaxAggregateOutputType | null
  }

  export type StudentSemesterRegistrationAvgAggregateOutputType = {
    totalCreditsTaken: number | null
  }

  export type StudentSemesterRegistrationSumAggregateOutputType = {
    totalCreditsTaken: number | null
  }

  export type StudentSemesterRegistrationMinAggregateOutputType = {
    id: string | null
    isConfirmed: boolean | null
    totalCreditsTaken: number | null
    paymentRecipt: string | null
    createdAt: Date | null
    updatedAt: Date | null
    studentId: string | null
    semesterRegistrationId: string | null
  }

  export type StudentSemesterRegistrationMaxAggregateOutputType = {
    id: string | null
    isConfirmed: boolean | null
    totalCreditsTaken: number | null
    paymentRecipt: string | null
    createdAt: Date | null
    updatedAt: Date | null
    studentId: string | null
    semesterRegistrationId: string | null
  }

  export type StudentSemesterRegistrationCountAggregateOutputType = {
    id: number
    isConfirmed: number
    totalCreditsTaken: number
    paymentRecipt: number
    createdAt: number
    updatedAt: number
    studentId: number
    semesterRegistrationId: number
    _all: number
  }


  export type StudentSemesterRegistrationAvgAggregateInputType = {
    totalCreditsTaken?: true
  }

  export type StudentSemesterRegistrationSumAggregateInputType = {
    totalCreditsTaken?: true
  }

  export type StudentSemesterRegistrationMinAggregateInputType = {
    id?: true
    isConfirmed?: true
    totalCreditsTaken?: true
    paymentRecipt?: true
    createdAt?: true
    updatedAt?: true
    studentId?: true
    semesterRegistrationId?: true
  }

  export type StudentSemesterRegistrationMaxAggregateInputType = {
    id?: true
    isConfirmed?: true
    totalCreditsTaken?: true
    paymentRecipt?: true
    createdAt?: true
    updatedAt?: true
    studentId?: true
    semesterRegistrationId?: true
  }

  export type StudentSemesterRegistrationCountAggregateInputType = {
    id?: true
    isConfirmed?: true
    totalCreditsTaken?: true
    paymentRecipt?: true
    createdAt?: true
    updatedAt?: true
    studentId?: true
    semesterRegistrationId?: true
    _all?: true
  }

  export type StudentSemesterRegistrationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StudentSemesterRegistration to aggregate.
     */
    where?: StudentSemesterRegistrationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentSemesterRegistrations to fetch.
     */
    orderBy?: StudentSemesterRegistrationOrderByWithRelationInput | StudentSemesterRegistrationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StudentSemesterRegistrationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentSemesterRegistrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentSemesterRegistrations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StudentSemesterRegistrations
    **/
    _count?: true | StudentSemesterRegistrationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StudentSemesterRegistrationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StudentSemesterRegistrationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StudentSemesterRegistrationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StudentSemesterRegistrationMaxAggregateInputType
  }

  export type GetStudentSemesterRegistrationAggregateType<T extends StudentSemesterRegistrationAggregateArgs> = {
        [P in keyof T & keyof AggregateStudentSemesterRegistration]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStudentSemesterRegistration[P]>
      : GetScalarType<T[P], AggregateStudentSemesterRegistration[P]>
  }




  export type StudentSemesterRegistrationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentSemesterRegistrationWhereInput
    orderBy?: StudentSemesterRegistrationOrderByWithAggregationInput | StudentSemesterRegistrationOrderByWithAggregationInput[]
    by: StudentSemesterRegistrationScalarFieldEnum[] | StudentSemesterRegistrationScalarFieldEnum
    having?: StudentSemesterRegistrationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StudentSemesterRegistrationCountAggregateInputType | true
    _avg?: StudentSemesterRegistrationAvgAggregateInputType
    _sum?: StudentSemesterRegistrationSumAggregateInputType
    _min?: StudentSemesterRegistrationMinAggregateInputType
    _max?: StudentSemesterRegistrationMaxAggregateInputType
  }

  export type StudentSemesterRegistrationGroupByOutputType = {
    id: string
    isConfirmed: boolean | null
    totalCreditsTaken: number | null
    paymentRecipt: string | null
    createdAt: Date
    updatedAt: Date
    studentId: string
    semesterRegistrationId: string
    _count: StudentSemesterRegistrationCountAggregateOutputType | null
    _avg: StudentSemesterRegistrationAvgAggregateOutputType | null
    _sum: StudentSemesterRegistrationSumAggregateOutputType | null
    _min: StudentSemesterRegistrationMinAggregateOutputType | null
    _max: StudentSemesterRegistrationMaxAggregateOutputType | null
  }

  type GetStudentSemesterRegistrationGroupByPayload<T extends StudentSemesterRegistrationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StudentSemesterRegistrationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StudentSemesterRegistrationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StudentSemesterRegistrationGroupByOutputType[P]>
            : GetScalarType<T[P], StudentSemesterRegistrationGroupByOutputType[P]>
        }
      >
    >


  export type StudentSemesterRegistrationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    isConfirmed?: boolean
    totalCreditsTaken?: boolean
    paymentRecipt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    studentId?: boolean
    semesterRegistrationId?: boolean
    student?: boolean | StudentDefaultArgs<ExtArgs>
    semesterRegistration?: boolean | SemesterRegistrationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["studentSemesterRegistration"]>



  export type StudentSemesterRegistrationSelectScalar = {
    id?: boolean
    isConfirmed?: boolean
    totalCreditsTaken?: boolean
    paymentRecipt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    studentId?: boolean
    semesterRegistrationId?: boolean
  }

  export type StudentSemesterRegistrationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "isConfirmed" | "totalCreditsTaken" | "paymentRecipt" | "createdAt" | "updatedAt" | "studentId" | "semesterRegistrationId", ExtArgs["result"]["studentSemesterRegistration"]>
  export type StudentSemesterRegistrationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentDefaultArgs<ExtArgs>
    semesterRegistration?: boolean | SemesterRegistrationDefaultArgs<ExtArgs>
  }

  export type $StudentSemesterRegistrationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "StudentSemesterRegistration"
    objects: {
      student: Prisma.$StudentPayload<ExtArgs>
      semesterRegistration: Prisma.$SemesterRegistrationPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      isConfirmed: boolean | null
      totalCreditsTaken: number | null
      paymentRecipt: string | null
      createdAt: Date
      updatedAt: Date
      studentId: string
      semesterRegistrationId: string
    }, ExtArgs["result"]["studentSemesterRegistration"]>
    composites: {}
  }

  type StudentSemesterRegistrationGetPayload<S extends boolean | null | undefined | StudentSemesterRegistrationDefaultArgs> = $Result.GetResult<Prisma.$StudentSemesterRegistrationPayload, S>

  type StudentSemesterRegistrationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<StudentSemesterRegistrationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: StudentSemesterRegistrationCountAggregateInputType | true
    }

  export interface StudentSemesterRegistrationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['StudentSemesterRegistration'], meta: { name: 'StudentSemesterRegistration' } }
    /**
     * Find zero or one StudentSemesterRegistration that matches the filter.
     * @param {StudentSemesterRegistrationFindUniqueArgs} args - Arguments to find a StudentSemesterRegistration
     * @example
     * // Get one StudentSemesterRegistration
     * const studentSemesterRegistration = await prisma.studentSemesterRegistration.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StudentSemesterRegistrationFindUniqueArgs>(args: SelectSubset<T, StudentSemesterRegistrationFindUniqueArgs<ExtArgs>>): Prisma__StudentSemesterRegistrationClient<$Result.GetResult<Prisma.$StudentSemesterRegistrationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one StudentSemesterRegistration that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {StudentSemesterRegistrationFindUniqueOrThrowArgs} args - Arguments to find a StudentSemesterRegistration
     * @example
     * // Get one StudentSemesterRegistration
     * const studentSemesterRegistration = await prisma.studentSemesterRegistration.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StudentSemesterRegistrationFindUniqueOrThrowArgs>(args: SelectSubset<T, StudentSemesterRegistrationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StudentSemesterRegistrationClient<$Result.GetResult<Prisma.$StudentSemesterRegistrationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StudentSemesterRegistration that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentSemesterRegistrationFindFirstArgs} args - Arguments to find a StudentSemesterRegistration
     * @example
     * // Get one StudentSemesterRegistration
     * const studentSemesterRegistration = await prisma.studentSemesterRegistration.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StudentSemesterRegistrationFindFirstArgs>(args?: SelectSubset<T, StudentSemesterRegistrationFindFirstArgs<ExtArgs>>): Prisma__StudentSemesterRegistrationClient<$Result.GetResult<Prisma.$StudentSemesterRegistrationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StudentSemesterRegistration that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentSemesterRegistrationFindFirstOrThrowArgs} args - Arguments to find a StudentSemesterRegistration
     * @example
     * // Get one StudentSemesterRegistration
     * const studentSemesterRegistration = await prisma.studentSemesterRegistration.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StudentSemesterRegistrationFindFirstOrThrowArgs>(args?: SelectSubset<T, StudentSemesterRegistrationFindFirstOrThrowArgs<ExtArgs>>): Prisma__StudentSemesterRegistrationClient<$Result.GetResult<Prisma.$StudentSemesterRegistrationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more StudentSemesterRegistrations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentSemesterRegistrationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StudentSemesterRegistrations
     * const studentSemesterRegistrations = await prisma.studentSemesterRegistration.findMany()
     * 
     * // Get first 10 StudentSemesterRegistrations
     * const studentSemesterRegistrations = await prisma.studentSemesterRegistration.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const studentSemesterRegistrationWithIdOnly = await prisma.studentSemesterRegistration.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StudentSemesterRegistrationFindManyArgs>(args?: SelectSubset<T, StudentSemesterRegistrationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentSemesterRegistrationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a StudentSemesterRegistration.
     * @param {StudentSemesterRegistrationCreateArgs} args - Arguments to create a StudentSemesterRegistration.
     * @example
     * // Create one StudentSemesterRegistration
     * const StudentSemesterRegistration = await prisma.studentSemesterRegistration.create({
     *   data: {
     *     // ... data to create a StudentSemesterRegistration
     *   }
     * })
     * 
     */
    create<T extends StudentSemesterRegistrationCreateArgs>(args: SelectSubset<T, StudentSemesterRegistrationCreateArgs<ExtArgs>>): Prisma__StudentSemesterRegistrationClient<$Result.GetResult<Prisma.$StudentSemesterRegistrationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many StudentSemesterRegistrations.
     * @param {StudentSemesterRegistrationCreateManyArgs} args - Arguments to create many StudentSemesterRegistrations.
     * @example
     * // Create many StudentSemesterRegistrations
     * const studentSemesterRegistration = await prisma.studentSemesterRegistration.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StudentSemesterRegistrationCreateManyArgs>(args?: SelectSubset<T, StudentSemesterRegistrationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a StudentSemesterRegistration.
     * @param {StudentSemesterRegistrationDeleteArgs} args - Arguments to delete one StudentSemesterRegistration.
     * @example
     * // Delete one StudentSemesterRegistration
     * const StudentSemesterRegistration = await prisma.studentSemesterRegistration.delete({
     *   where: {
     *     // ... filter to delete one StudentSemesterRegistration
     *   }
     * })
     * 
     */
    delete<T extends StudentSemesterRegistrationDeleteArgs>(args: SelectSubset<T, StudentSemesterRegistrationDeleteArgs<ExtArgs>>): Prisma__StudentSemesterRegistrationClient<$Result.GetResult<Prisma.$StudentSemesterRegistrationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one StudentSemesterRegistration.
     * @param {StudentSemesterRegistrationUpdateArgs} args - Arguments to update one StudentSemesterRegistration.
     * @example
     * // Update one StudentSemesterRegistration
     * const studentSemesterRegistration = await prisma.studentSemesterRegistration.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StudentSemesterRegistrationUpdateArgs>(args: SelectSubset<T, StudentSemesterRegistrationUpdateArgs<ExtArgs>>): Prisma__StudentSemesterRegistrationClient<$Result.GetResult<Prisma.$StudentSemesterRegistrationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more StudentSemesterRegistrations.
     * @param {StudentSemesterRegistrationDeleteManyArgs} args - Arguments to filter StudentSemesterRegistrations to delete.
     * @example
     * // Delete a few StudentSemesterRegistrations
     * const { count } = await prisma.studentSemesterRegistration.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StudentSemesterRegistrationDeleteManyArgs>(args?: SelectSubset<T, StudentSemesterRegistrationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StudentSemesterRegistrations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentSemesterRegistrationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StudentSemesterRegistrations
     * const studentSemesterRegistration = await prisma.studentSemesterRegistration.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StudentSemesterRegistrationUpdateManyArgs>(args: SelectSubset<T, StudentSemesterRegistrationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one StudentSemesterRegistration.
     * @param {StudentSemesterRegistrationUpsertArgs} args - Arguments to update or create a StudentSemesterRegistration.
     * @example
     * // Update or create a StudentSemesterRegistration
     * const studentSemesterRegistration = await prisma.studentSemesterRegistration.upsert({
     *   create: {
     *     // ... data to create a StudentSemesterRegistration
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StudentSemesterRegistration we want to update
     *   }
     * })
     */
    upsert<T extends StudentSemesterRegistrationUpsertArgs>(args: SelectSubset<T, StudentSemesterRegistrationUpsertArgs<ExtArgs>>): Prisma__StudentSemesterRegistrationClient<$Result.GetResult<Prisma.$StudentSemesterRegistrationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of StudentSemesterRegistrations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentSemesterRegistrationCountArgs} args - Arguments to filter StudentSemesterRegistrations to count.
     * @example
     * // Count the number of StudentSemesterRegistrations
     * const count = await prisma.studentSemesterRegistration.count({
     *   where: {
     *     // ... the filter for the StudentSemesterRegistrations we want to count
     *   }
     * })
    **/
    count<T extends StudentSemesterRegistrationCountArgs>(
      args?: Subset<T, StudentSemesterRegistrationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StudentSemesterRegistrationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StudentSemesterRegistration.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentSemesterRegistrationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StudentSemesterRegistrationAggregateArgs>(args: Subset<T, StudentSemesterRegistrationAggregateArgs>): Prisma.PrismaPromise<GetStudentSemesterRegistrationAggregateType<T>>

    /**
     * Group by StudentSemesterRegistration.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentSemesterRegistrationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StudentSemesterRegistrationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StudentSemesterRegistrationGroupByArgs['orderBy'] }
        : { orderBy?: StudentSemesterRegistrationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StudentSemesterRegistrationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStudentSemesterRegistrationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the StudentSemesterRegistration model
   */
  readonly fields: StudentSemesterRegistrationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for StudentSemesterRegistration.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StudentSemesterRegistrationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    student<T extends StudentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StudentDefaultArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    semesterRegistration<T extends SemesterRegistrationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SemesterRegistrationDefaultArgs<ExtArgs>>): Prisma__SemesterRegistrationClient<$Result.GetResult<Prisma.$SemesterRegistrationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the StudentSemesterRegistration model
   */
  interface StudentSemesterRegistrationFieldRefs {
    readonly id: FieldRef<"StudentSemesterRegistration", 'String'>
    readonly isConfirmed: FieldRef<"StudentSemesterRegistration", 'Boolean'>
    readonly totalCreditsTaken: FieldRef<"StudentSemesterRegistration", 'Int'>
    readonly paymentRecipt: FieldRef<"StudentSemesterRegistration", 'String'>
    readonly createdAt: FieldRef<"StudentSemesterRegistration", 'DateTime'>
    readonly updatedAt: FieldRef<"StudentSemesterRegistration", 'DateTime'>
    readonly studentId: FieldRef<"StudentSemesterRegistration", 'String'>
    readonly semesterRegistrationId: FieldRef<"StudentSemesterRegistration", 'String'>
  }
    

  // Custom InputTypes
  /**
   * StudentSemesterRegistration findUnique
   */
  export type StudentSemesterRegistrationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentSemesterRegistration
     */
    select?: StudentSemesterRegistrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentSemesterRegistration
     */
    omit?: StudentSemesterRegistrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentSemesterRegistrationInclude<ExtArgs> | null
    /**
     * Filter, which StudentSemesterRegistration to fetch.
     */
    where: StudentSemesterRegistrationWhereUniqueInput
  }

  /**
   * StudentSemesterRegistration findUniqueOrThrow
   */
  export type StudentSemesterRegistrationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentSemesterRegistration
     */
    select?: StudentSemesterRegistrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentSemesterRegistration
     */
    omit?: StudentSemesterRegistrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentSemesterRegistrationInclude<ExtArgs> | null
    /**
     * Filter, which StudentSemesterRegistration to fetch.
     */
    where: StudentSemesterRegistrationWhereUniqueInput
  }

  /**
   * StudentSemesterRegistration findFirst
   */
  export type StudentSemesterRegistrationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentSemesterRegistration
     */
    select?: StudentSemesterRegistrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentSemesterRegistration
     */
    omit?: StudentSemesterRegistrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentSemesterRegistrationInclude<ExtArgs> | null
    /**
     * Filter, which StudentSemesterRegistration to fetch.
     */
    where?: StudentSemesterRegistrationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentSemesterRegistrations to fetch.
     */
    orderBy?: StudentSemesterRegistrationOrderByWithRelationInput | StudentSemesterRegistrationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StudentSemesterRegistrations.
     */
    cursor?: StudentSemesterRegistrationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentSemesterRegistrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentSemesterRegistrations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StudentSemesterRegistrations.
     */
    distinct?: StudentSemesterRegistrationScalarFieldEnum | StudentSemesterRegistrationScalarFieldEnum[]
  }

  /**
   * StudentSemesterRegistration findFirstOrThrow
   */
  export type StudentSemesterRegistrationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentSemesterRegistration
     */
    select?: StudentSemesterRegistrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentSemesterRegistration
     */
    omit?: StudentSemesterRegistrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentSemesterRegistrationInclude<ExtArgs> | null
    /**
     * Filter, which StudentSemesterRegistration to fetch.
     */
    where?: StudentSemesterRegistrationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentSemesterRegistrations to fetch.
     */
    orderBy?: StudentSemesterRegistrationOrderByWithRelationInput | StudentSemesterRegistrationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StudentSemesterRegistrations.
     */
    cursor?: StudentSemesterRegistrationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentSemesterRegistrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentSemesterRegistrations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StudentSemesterRegistrations.
     */
    distinct?: StudentSemesterRegistrationScalarFieldEnum | StudentSemesterRegistrationScalarFieldEnum[]
  }

  /**
   * StudentSemesterRegistration findMany
   */
  export type StudentSemesterRegistrationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentSemesterRegistration
     */
    select?: StudentSemesterRegistrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentSemesterRegistration
     */
    omit?: StudentSemesterRegistrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentSemesterRegistrationInclude<ExtArgs> | null
    /**
     * Filter, which StudentSemesterRegistrations to fetch.
     */
    where?: StudentSemesterRegistrationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentSemesterRegistrations to fetch.
     */
    orderBy?: StudentSemesterRegistrationOrderByWithRelationInput | StudentSemesterRegistrationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StudentSemesterRegistrations.
     */
    cursor?: StudentSemesterRegistrationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentSemesterRegistrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentSemesterRegistrations.
     */
    skip?: number
    distinct?: StudentSemesterRegistrationScalarFieldEnum | StudentSemesterRegistrationScalarFieldEnum[]
  }

  /**
   * StudentSemesterRegistration create
   */
  export type StudentSemesterRegistrationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentSemesterRegistration
     */
    select?: StudentSemesterRegistrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentSemesterRegistration
     */
    omit?: StudentSemesterRegistrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentSemesterRegistrationInclude<ExtArgs> | null
    /**
     * The data needed to create a StudentSemesterRegistration.
     */
    data: XOR<StudentSemesterRegistrationCreateInput, StudentSemesterRegistrationUncheckedCreateInput>
  }

  /**
   * StudentSemesterRegistration createMany
   */
  export type StudentSemesterRegistrationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many StudentSemesterRegistrations.
     */
    data: StudentSemesterRegistrationCreateManyInput | StudentSemesterRegistrationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * StudentSemesterRegistration update
   */
  export type StudentSemesterRegistrationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentSemesterRegistration
     */
    select?: StudentSemesterRegistrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentSemesterRegistration
     */
    omit?: StudentSemesterRegistrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentSemesterRegistrationInclude<ExtArgs> | null
    /**
     * The data needed to update a StudentSemesterRegistration.
     */
    data: XOR<StudentSemesterRegistrationUpdateInput, StudentSemesterRegistrationUncheckedUpdateInput>
    /**
     * Choose, which StudentSemesterRegistration to update.
     */
    where: StudentSemesterRegistrationWhereUniqueInput
  }

  /**
   * StudentSemesterRegistration updateMany
   */
  export type StudentSemesterRegistrationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update StudentSemesterRegistrations.
     */
    data: XOR<StudentSemesterRegistrationUpdateManyMutationInput, StudentSemesterRegistrationUncheckedUpdateManyInput>
    /**
     * Filter which StudentSemesterRegistrations to update
     */
    where?: StudentSemesterRegistrationWhereInput
    /**
     * Limit how many StudentSemesterRegistrations to update.
     */
    limit?: number
  }

  /**
   * StudentSemesterRegistration upsert
   */
  export type StudentSemesterRegistrationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentSemesterRegistration
     */
    select?: StudentSemesterRegistrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentSemesterRegistration
     */
    omit?: StudentSemesterRegistrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentSemesterRegistrationInclude<ExtArgs> | null
    /**
     * The filter to search for the StudentSemesterRegistration to update in case it exists.
     */
    where: StudentSemesterRegistrationWhereUniqueInput
    /**
     * In case the StudentSemesterRegistration found by the `where` argument doesn't exist, create a new StudentSemesterRegistration with this data.
     */
    create: XOR<StudentSemesterRegistrationCreateInput, StudentSemesterRegistrationUncheckedCreateInput>
    /**
     * In case the StudentSemesterRegistration was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StudentSemesterRegistrationUpdateInput, StudentSemesterRegistrationUncheckedUpdateInput>
  }

  /**
   * StudentSemesterRegistration delete
   */
  export type StudentSemesterRegistrationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentSemesterRegistration
     */
    select?: StudentSemesterRegistrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentSemesterRegistration
     */
    omit?: StudentSemesterRegistrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentSemesterRegistrationInclude<ExtArgs> | null
    /**
     * Filter which StudentSemesterRegistration to delete.
     */
    where: StudentSemesterRegistrationWhereUniqueInput
  }

  /**
   * StudentSemesterRegistration deleteMany
   */
  export type StudentSemesterRegistrationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StudentSemesterRegistrations to delete
     */
    where?: StudentSemesterRegistrationWhereInput
    /**
     * Limit how many StudentSemesterRegistrations to delete.
     */
    limit?: number
  }

  /**
   * StudentSemesterRegistration without action
   */
  export type StudentSemesterRegistrationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentSemesterRegistration
     */
    select?: StudentSemesterRegistrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentSemesterRegistration
     */
    omit?: StudentSemesterRegistrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentSemesterRegistrationInclude<ExtArgs> | null
  }


  /**
   * Model StudentSemesterRegistrationCourse
   */

  export type AggregateStudentSemesterRegistrationCourse = {
    _count: StudentSemesterRegistrationCourseCountAggregateOutputType | null
    _min: StudentSemesterRegistrationCourseMinAggregateOutputType | null
    _max: StudentSemesterRegistrationCourseMaxAggregateOutputType | null
  }

  export type StudentSemesterRegistrationCourseMinAggregateOutputType = {
    semesterRegistrationId: string | null
    studentId: string | null
    offeredCourseId: string | null
    offeredCourseSectionId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StudentSemesterRegistrationCourseMaxAggregateOutputType = {
    semesterRegistrationId: string | null
    studentId: string | null
    offeredCourseId: string | null
    offeredCourseSectionId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StudentSemesterRegistrationCourseCountAggregateOutputType = {
    semesterRegistrationId: number
    studentId: number
    offeredCourseId: number
    offeredCourseSectionId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type StudentSemesterRegistrationCourseMinAggregateInputType = {
    semesterRegistrationId?: true
    studentId?: true
    offeredCourseId?: true
    offeredCourseSectionId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StudentSemesterRegistrationCourseMaxAggregateInputType = {
    semesterRegistrationId?: true
    studentId?: true
    offeredCourseId?: true
    offeredCourseSectionId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StudentSemesterRegistrationCourseCountAggregateInputType = {
    semesterRegistrationId?: true
    studentId?: true
    offeredCourseId?: true
    offeredCourseSectionId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type StudentSemesterRegistrationCourseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StudentSemesterRegistrationCourse to aggregate.
     */
    where?: StudentSemesterRegistrationCourseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentSemesterRegistrationCourses to fetch.
     */
    orderBy?: StudentSemesterRegistrationCourseOrderByWithRelationInput | StudentSemesterRegistrationCourseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StudentSemesterRegistrationCourseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentSemesterRegistrationCourses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentSemesterRegistrationCourses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StudentSemesterRegistrationCourses
    **/
    _count?: true | StudentSemesterRegistrationCourseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StudentSemesterRegistrationCourseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StudentSemesterRegistrationCourseMaxAggregateInputType
  }

  export type GetStudentSemesterRegistrationCourseAggregateType<T extends StudentSemesterRegistrationCourseAggregateArgs> = {
        [P in keyof T & keyof AggregateStudentSemesterRegistrationCourse]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStudentSemesterRegistrationCourse[P]>
      : GetScalarType<T[P], AggregateStudentSemesterRegistrationCourse[P]>
  }




  export type StudentSemesterRegistrationCourseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentSemesterRegistrationCourseWhereInput
    orderBy?: StudentSemesterRegistrationCourseOrderByWithAggregationInput | StudentSemesterRegistrationCourseOrderByWithAggregationInput[]
    by: StudentSemesterRegistrationCourseScalarFieldEnum[] | StudentSemesterRegistrationCourseScalarFieldEnum
    having?: StudentSemesterRegistrationCourseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StudentSemesterRegistrationCourseCountAggregateInputType | true
    _min?: StudentSemesterRegistrationCourseMinAggregateInputType
    _max?: StudentSemesterRegistrationCourseMaxAggregateInputType
  }

  export type StudentSemesterRegistrationCourseGroupByOutputType = {
    semesterRegistrationId: string
    studentId: string
    offeredCourseId: string
    offeredCourseSectionId: string
    createdAt: Date
    updatedAt: Date
    _count: StudentSemesterRegistrationCourseCountAggregateOutputType | null
    _min: StudentSemesterRegistrationCourseMinAggregateOutputType | null
    _max: StudentSemesterRegistrationCourseMaxAggregateOutputType | null
  }

  type GetStudentSemesterRegistrationCourseGroupByPayload<T extends StudentSemesterRegistrationCourseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StudentSemesterRegistrationCourseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StudentSemesterRegistrationCourseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StudentSemesterRegistrationCourseGroupByOutputType[P]>
            : GetScalarType<T[P], StudentSemesterRegistrationCourseGroupByOutputType[P]>
        }
      >
    >


  export type StudentSemesterRegistrationCourseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    semesterRegistrationId?: boolean
    studentId?: boolean
    offeredCourseId?: boolean
    offeredCourseSectionId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    semesterRegistration?: boolean | SemesterRegistrationDefaultArgs<ExtArgs>
    student?: boolean | StudentDefaultArgs<ExtArgs>
    offeredCourse?: boolean | OfferedCourseDefaultArgs<ExtArgs>
    offeredCourseSection?: boolean | OfferedCourseSectionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["studentSemesterRegistrationCourse"]>



  export type StudentSemesterRegistrationCourseSelectScalar = {
    semesterRegistrationId?: boolean
    studentId?: boolean
    offeredCourseId?: boolean
    offeredCourseSectionId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type StudentSemesterRegistrationCourseOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"semesterRegistrationId" | "studentId" | "offeredCourseId" | "offeredCourseSectionId" | "createdAt" | "updatedAt", ExtArgs["result"]["studentSemesterRegistrationCourse"]>
  export type StudentSemesterRegistrationCourseInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    semesterRegistration?: boolean | SemesterRegistrationDefaultArgs<ExtArgs>
    student?: boolean | StudentDefaultArgs<ExtArgs>
    offeredCourse?: boolean | OfferedCourseDefaultArgs<ExtArgs>
    offeredCourseSection?: boolean | OfferedCourseSectionDefaultArgs<ExtArgs>
  }

  export type $StudentSemesterRegistrationCoursePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "StudentSemesterRegistrationCourse"
    objects: {
      semesterRegistration: Prisma.$SemesterRegistrationPayload<ExtArgs>
      student: Prisma.$StudentPayload<ExtArgs>
      offeredCourse: Prisma.$OfferedCoursePayload<ExtArgs>
      offeredCourseSection: Prisma.$OfferedCourseSectionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      semesterRegistrationId: string
      studentId: string
      offeredCourseId: string
      offeredCourseSectionId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["studentSemesterRegistrationCourse"]>
    composites: {}
  }

  type StudentSemesterRegistrationCourseGetPayload<S extends boolean | null | undefined | StudentSemesterRegistrationCourseDefaultArgs> = $Result.GetResult<Prisma.$StudentSemesterRegistrationCoursePayload, S>

  type StudentSemesterRegistrationCourseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<StudentSemesterRegistrationCourseFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: StudentSemesterRegistrationCourseCountAggregateInputType | true
    }

  export interface StudentSemesterRegistrationCourseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['StudentSemesterRegistrationCourse'], meta: { name: 'StudentSemesterRegistrationCourse' } }
    /**
     * Find zero or one StudentSemesterRegistrationCourse that matches the filter.
     * @param {StudentSemesterRegistrationCourseFindUniqueArgs} args - Arguments to find a StudentSemesterRegistrationCourse
     * @example
     * // Get one StudentSemesterRegistrationCourse
     * const studentSemesterRegistrationCourse = await prisma.studentSemesterRegistrationCourse.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StudentSemesterRegistrationCourseFindUniqueArgs>(args: SelectSubset<T, StudentSemesterRegistrationCourseFindUniqueArgs<ExtArgs>>): Prisma__StudentSemesterRegistrationCourseClient<$Result.GetResult<Prisma.$StudentSemesterRegistrationCoursePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one StudentSemesterRegistrationCourse that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {StudentSemesterRegistrationCourseFindUniqueOrThrowArgs} args - Arguments to find a StudentSemesterRegistrationCourse
     * @example
     * // Get one StudentSemesterRegistrationCourse
     * const studentSemesterRegistrationCourse = await prisma.studentSemesterRegistrationCourse.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StudentSemesterRegistrationCourseFindUniqueOrThrowArgs>(args: SelectSubset<T, StudentSemesterRegistrationCourseFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StudentSemesterRegistrationCourseClient<$Result.GetResult<Prisma.$StudentSemesterRegistrationCoursePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StudentSemesterRegistrationCourse that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentSemesterRegistrationCourseFindFirstArgs} args - Arguments to find a StudentSemesterRegistrationCourse
     * @example
     * // Get one StudentSemesterRegistrationCourse
     * const studentSemesterRegistrationCourse = await prisma.studentSemesterRegistrationCourse.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StudentSemesterRegistrationCourseFindFirstArgs>(args?: SelectSubset<T, StudentSemesterRegistrationCourseFindFirstArgs<ExtArgs>>): Prisma__StudentSemesterRegistrationCourseClient<$Result.GetResult<Prisma.$StudentSemesterRegistrationCoursePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StudentSemesterRegistrationCourse that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentSemesterRegistrationCourseFindFirstOrThrowArgs} args - Arguments to find a StudentSemesterRegistrationCourse
     * @example
     * // Get one StudentSemesterRegistrationCourse
     * const studentSemesterRegistrationCourse = await prisma.studentSemesterRegistrationCourse.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StudentSemesterRegistrationCourseFindFirstOrThrowArgs>(args?: SelectSubset<T, StudentSemesterRegistrationCourseFindFirstOrThrowArgs<ExtArgs>>): Prisma__StudentSemesterRegistrationCourseClient<$Result.GetResult<Prisma.$StudentSemesterRegistrationCoursePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more StudentSemesterRegistrationCourses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentSemesterRegistrationCourseFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StudentSemesterRegistrationCourses
     * const studentSemesterRegistrationCourses = await prisma.studentSemesterRegistrationCourse.findMany()
     * 
     * // Get first 10 StudentSemesterRegistrationCourses
     * const studentSemesterRegistrationCourses = await prisma.studentSemesterRegistrationCourse.findMany({ take: 10 })
     * 
     * // Only select the `semesterRegistrationId`
     * const studentSemesterRegistrationCourseWithSemesterRegistrationIdOnly = await prisma.studentSemesterRegistrationCourse.findMany({ select: { semesterRegistrationId: true } })
     * 
     */
    findMany<T extends StudentSemesterRegistrationCourseFindManyArgs>(args?: SelectSubset<T, StudentSemesterRegistrationCourseFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentSemesterRegistrationCoursePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a StudentSemesterRegistrationCourse.
     * @param {StudentSemesterRegistrationCourseCreateArgs} args - Arguments to create a StudentSemesterRegistrationCourse.
     * @example
     * // Create one StudentSemesterRegistrationCourse
     * const StudentSemesterRegistrationCourse = await prisma.studentSemesterRegistrationCourse.create({
     *   data: {
     *     // ... data to create a StudentSemesterRegistrationCourse
     *   }
     * })
     * 
     */
    create<T extends StudentSemesterRegistrationCourseCreateArgs>(args: SelectSubset<T, StudentSemesterRegistrationCourseCreateArgs<ExtArgs>>): Prisma__StudentSemesterRegistrationCourseClient<$Result.GetResult<Prisma.$StudentSemesterRegistrationCoursePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many StudentSemesterRegistrationCourses.
     * @param {StudentSemesterRegistrationCourseCreateManyArgs} args - Arguments to create many StudentSemesterRegistrationCourses.
     * @example
     * // Create many StudentSemesterRegistrationCourses
     * const studentSemesterRegistrationCourse = await prisma.studentSemesterRegistrationCourse.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StudentSemesterRegistrationCourseCreateManyArgs>(args?: SelectSubset<T, StudentSemesterRegistrationCourseCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a StudentSemesterRegistrationCourse.
     * @param {StudentSemesterRegistrationCourseDeleteArgs} args - Arguments to delete one StudentSemesterRegistrationCourse.
     * @example
     * // Delete one StudentSemesterRegistrationCourse
     * const StudentSemesterRegistrationCourse = await prisma.studentSemesterRegistrationCourse.delete({
     *   where: {
     *     // ... filter to delete one StudentSemesterRegistrationCourse
     *   }
     * })
     * 
     */
    delete<T extends StudentSemesterRegistrationCourseDeleteArgs>(args: SelectSubset<T, StudentSemesterRegistrationCourseDeleteArgs<ExtArgs>>): Prisma__StudentSemesterRegistrationCourseClient<$Result.GetResult<Prisma.$StudentSemesterRegistrationCoursePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one StudentSemesterRegistrationCourse.
     * @param {StudentSemesterRegistrationCourseUpdateArgs} args - Arguments to update one StudentSemesterRegistrationCourse.
     * @example
     * // Update one StudentSemesterRegistrationCourse
     * const studentSemesterRegistrationCourse = await prisma.studentSemesterRegistrationCourse.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StudentSemesterRegistrationCourseUpdateArgs>(args: SelectSubset<T, StudentSemesterRegistrationCourseUpdateArgs<ExtArgs>>): Prisma__StudentSemesterRegistrationCourseClient<$Result.GetResult<Prisma.$StudentSemesterRegistrationCoursePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more StudentSemesterRegistrationCourses.
     * @param {StudentSemesterRegistrationCourseDeleteManyArgs} args - Arguments to filter StudentSemesterRegistrationCourses to delete.
     * @example
     * // Delete a few StudentSemesterRegistrationCourses
     * const { count } = await prisma.studentSemesterRegistrationCourse.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StudentSemesterRegistrationCourseDeleteManyArgs>(args?: SelectSubset<T, StudentSemesterRegistrationCourseDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StudentSemesterRegistrationCourses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentSemesterRegistrationCourseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StudentSemesterRegistrationCourses
     * const studentSemesterRegistrationCourse = await prisma.studentSemesterRegistrationCourse.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StudentSemesterRegistrationCourseUpdateManyArgs>(args: SelectSubset<T, StudentSemesterRegistrationCourseUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one StudentSemesterRegistrationCourse.
     * @param {StudentSemesterRegistrationCourseUpsertArgs} args - Arguments to update or create a StudentSemesterRegistrationCourse.
     * @example
     * // Update or create a StudentSemesterRegistrationCourse
     * const studentSemesterRegistrationCourse = await prisma.studentSemesterRegistrationCourse.upsert({
     *   create: {
     *     // ... data to create a StudentSemesterRegistrationCourse
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StudentSemesterRegistrationCourse we want to update
     *   }
     * })
     */
    upsert<T extends StudentSemesterRegistrationCourseUpsertArgs>(args: SelectSubset<T, StudentSemesterRegistrationCourseUpsertArgs<ExtArgs>>): Prisma__StudentSemesterRegistrationCourseClient<$Result.GetResult<Prisma.$StudentSemesterRegistrationCoursePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of StudentSemesterRegistrationCourses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentSemesterRegistrationCourseCountArgs} args - Arguments to filter StudentSemesterRegistrationCourses to count.
     * @example
     * // Count the number of StudentSemesterRegistrationCourses
     * const count = await prisma.studentSemesterRegistrationCourse.count({
     *   where: {
     *     // ... the filter for the StudentSemesterRegistrationCourses we want to count
     *   }
     * })
    **/
    count<T extends StudentSemesterRegistrationCourseCountArgs>(
      args?: Subset<T, StudentSemesterRegistrationCourseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StudentSemesterRegistrationCourseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StudentSemesterRegistrationCourse.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentSemesterRegistrationCourseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StudentSemesterRegistrationCourseAggregateArgs>(args: Subset<T, StudentSemesterRegistrationCourseAggregateArgs>): Prisma.PrismaPromise<GetStudentSemesterRegistrationCourseAggregateType<T>>

    /**
     * Group by StudentSemesterRegistrationCourse.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentSemesterRegistrationCourseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StudentSemesterRegistrationCourseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StudentSemesterRegistrationCourseGroupByArgs['orderBy'] }
        : { orderBy?: StudentSemesterRegistrationCourseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StudentSemesterRegistrationCourseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStudentSemesterRegistrationCourseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the StudentSemesterRegistrationCourse model
   */
  readonly fields: StudentSemesterRegistrationCourseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for StudentSemesterRegistrationCourse.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StudentSemesterRegistrationCourseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    semesterRegistration<T extends SemesterRegistrationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SemesterRegistrationDefaultArgs<ExtArgs>>): Prisma__SemesterRegistrationClient<$Result.GetResult<Prisma.$SemesterRegistrationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    student<T extends StudentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StudentDefaultArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    offeredCourse<T extends OfferedCourseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OfferedCourseDefaultArgs<ExtArgs>>): Prisma__OfferedCourseClient<$Result.GetResult<Prisma.$OfferedCoursePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    offeredCourseSection<T extends OfferedCourseSectionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OfferedCourseSectionDefaultArgs<ExtArgs>>): Prisma__OfferedCourseSectionClient<$Result.GetResult<Prisma.$OfferedCourseSectionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the StudentSemesterRegistrationCourse model
   */
  interface StudentSemesterRegistrationCourseFieldRefs {
    readonly semesterRegistrationId: FieldRef<"StudentSemesterRegistrationCourse", 'String'>
    readonly studentId: FieldRef<"StudentSemesterRegistrationCourse", 'String'>
    readonly offeredCourseId: FieldRef<"StudentSemesterRegistrationCourse", 'String'>
    readonly offeredCourseSectionId: FieldRef<"StudentSemesterRegistrationCourse", 'String'>
    readonly createdAt: FieldRef<"StudentSemesterRegistrationCourse", 'DateTime'>
    readonly updatedAt: FieldRef<"StudentSemesterRegistrationCourse", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * StudentSemesterRegistrationCourse findUnique
   */
  export type StudentSemesterRegistrationCourseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentSemesterRegistrationCourse
     */
    select?: StudentSemesterRegistrationCourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentSemesterRegistrationCourse
     */
    omit?: StudentSemesterRegistrationCourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentSemesterRegistrationCourseInclude<ExtArgs> | null
    /**
     * Filter, which StudentSemesterRegistrationCourse to fetch.
     */
    where: StudentSemesterRegistrationCourseWhereUniqueInput
  }

  /**
   * StudentSemesterRegistrationCourse findUniqueOrThrow
   */
  export type StudentSemesterRegistrationCourseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentSemesterRegistrationCourse
     */
    select?: StudentSemesterRegistrationCourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentSemesterRegistrationCourse
     */
    omit?: StudentSemesterRegistrationCourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentSemesterRegistrationCourseInclude<ExtArgs> | null
    /**
     * Filter, which StudentSemesterRegistrationCourse to fetch.
     */
    where: StudentSemesterRegistrationCourseWhereUniqueInput
  }

  /**
   * StudentSemesterRegistrationCourse findFirst
   */
  export type StudentSemesterRegistrationCourseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentSemesterRegistrationCourse
     */
    select?: StudentSemesterRegistrationCourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentSemesterRegistrationCourse
     */
    omit?: StudentSemesterRegistrationCourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentSemesterRegistrationCourseInclude<ExtArgs> | null
    /**
     * Filter, which StudentSemesterRegistrationCourse to fetch.
     */
    where?: StudentSemesterRegistrationCourseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentSemesterRegistrationCourses to fetch.
     */
    orderBy?: StudentSemesterRegistrationCourseOrderByWithRelationInput | StudentSemesterRegistrationCourseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StudentSemesterRegistrationCourses.
     */
    cursor?: StudentSemesterRegistrationCourseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentSemesterRegistrationCourses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentSemesterRegistrationCourses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StudentSemesterRegistrationCourses.
     */
    distinct?: StudentSemesterRegistrationCourseScalarFieldEnum | StudentSemesterRegistrationCourseScalarFieldEnum[]
  }

  /**
   * StudentSemesterRegistrationCourse findFirstOrThrow
   */
  export type StudentSemesterRegistrationCourseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentSemesterRegistrationCourse
     */
    select?: StudentSemesterRegistrationCourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentSemesterRegistrationCourse
     */
    omit?: StudentSemesterRegistrationCourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentSemesterRegistrationCourseInclude<ExtArgs> | null
    /**
     * Filter, which StudentSemesterRegistrationCourse to fetch.
     */
    where?: StudentSemesterRegistrationCourseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentSemesterRegistrationCourses to fetch.
     */
    orderBy?: StudentSemesterRegistrationCourseOrderByWithRelationInput | StudentSemesterRegistrationCourseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StudentSemesterRegistrationCourses.
     */
    cursor?: StudentSemesterRegistrationCourseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentSemesterRegistrationCourses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentSemesterRegistrationCourses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StudentSemesterRegistrationCourses.
     */
    distinct?: StudentSemesterRegistrationCourseScalarFieldEnum | StudentSemesterRegistrationCourseScalarFieldEnum[]
  }

  /**
   * StudentSemesterRegistrationCourse findMany
   */
  export type StudentSemesterRegistrationCourseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentSemesterRegistrationCourse
     */
    select?: StudentSemesterRegistrationCourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentSemesterRegistrationCourse
     */
    omit?: StudentSemesterRegistrationCourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentSemesterRegistrationCourseInclude<ExtArgs> | null
    /**
     * Filter, which StudentSemesterRegistrationCourses to fetch.
     */
    where?: StudentSemesterRegistrationCourseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentSemesterRegistrationCourses to fetch.
     */
    orderBy?: StudentSemesterRegistrationCourseOrderByWithRelationInput | StudentSemesterRegistrationCourseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StudentSemesterRegistrationCourses.
     */
    cursor?: StudentSemesterRegistrationCourseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentSemesterRegistrationCourses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentSemesterRegistrationCourses.
     */
    skip?: number
    distinct?: StudentSemesterRegistrationCourseScalarFieldEnum | StudentSemesterRegistrationCourseScalarFieldEnum[]
  }

  /**
   * StudentSemesterRegistrationCourse create
   */
  export type StudentSemesterRegistrationCourseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentSemesterRegistrationCourse
     */
    select?: StudentSemesterRegistrationCourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentSemesterRegistrationCourse
     */
    omit?: StudentSemesterRegistrationCourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentSemesterRegistrationCourseInclude<ExtArgs> | null
    /**
     * The data needed to create a StudentSemesterRegistrationCourse.
     */
    data: XOR<StudentSemesterRegistrationCourseCreateInput, StudentSemesterRegistrationCourseUncheckedCreateInput>
  }

  /**
   * StudentSemesterRegistrationCourse createMany
   */
  export type StudentSemesterRegistrationCourseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many StudentSemesterRegistrationCourses.
     */
    data: StudentSemesterRegistrationCourseCreateManyInput | StudentSemesterRegistrationCourseCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * StudentSemesterRegistrationCourse update
   */
  export type StudentSemesterRegistrationCourseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentSemesterRegistrationCourse
     */
    select?: StudentSemesterRegistrationCourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentSemesterRegistrationCourse
     */
    omit?: StudentSemesterRegistrationCourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentSemesterRegistrationCourseInclude<ExtArgs> | null
    /**
     * The data needed to update a StudentSemesterRegistrationCourse.
     */
    data: XOR<StudentSemesterRegistrationCourseUpdateInput, StudentSemesterRegistrationCourseUncheckedUpdateInput>
    /**
     * Choose, which StudentSemesterRegistrationCourse to update.
     */
    where: StudentSemesterRegistrationCourseWhereUniqueInput
  }

  /**
   * StudentSemesterRegistrationCourse updateMany
   */
  export type StudentSemesterRegistrationCourseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update StudentSemesterRegistrationCourses.
     */
    data: XOR<StudentSemesterRegistrationCourseUpdateManyMutationInput, StudentSemesterRegistrationCourseUncheckedUpdateManyInput>
    /**
     * Filter which StudentSemesterRegistrationCourses to update
     */
    where?: StudentSemesterRegistrationCourseWhereInput
    /**
     * Limit how many StudentSemesterRegistrationCourses to update.
     */
    limit?: number
  }

  /**
   * StudentSemesterRegistrationCourse upsert
   */
  export type StudentSemesterRegistrationCourseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentSemesterRegistrationCourse
     */
    select?: StudentSemesterRegistrationCourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentSemesterRegistrationCourse
     */
    omit?: StudentSemesterRegistrationCourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentSemesterRegistrationCourseInclude<ExtArgs> | null
    /**
     * The filter to search for the StudentSemesterRegistrationCourse to update in case it exists.
     */
    where: StudentSemesterRegistrationCourseWhereUniqueInput
    /**
     * In case the StudentSemesterRegistrationCourse found by the `where` argument doesn't exist, create a new StudentSemesterRegistrationCourse with this data.
     */
    create: XOR<StudentSemesterRegistrationCourseCreateInput, StudentSemesterRegistrationCourseUncheckedCreateInput>
    /**
     * In case the StudentSemesterRegistrationCourse was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StudentSemesterRegistrationCourseUpdateInput, StudentSemesterRegistrationCourseUncheckedUpdateInput>
  }

  /**
   * StudentSemesterRegistrationCourse delete
   */
  export type StudentSemesterRegistrationCourseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentSemesterRegistrationCourse
     */
    select?: StudentSemesterRegistrationCourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentSemesterRegistrationCourse
     */
    omit?: StudentSemesterRegistrationCourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentSemesterRegistrationCourseInclude<ExtArgs> | null
    /**
     * Filter which StudentSemesterRegistrationCourse to delete.
     */
    where: StudentSemesterRegistrationCourseWhereUniqueInput
  }

  /**
   * StudentSemesterRegistrationCourse deleteMany
   */
  export type StudentSemesterRegistrationCourseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StudentSemesterRegistrationCourses to delete
     */
    where?: StudentSemesterRegistrationCourseWhereInput
    /**
     * Limit how many StudentSemesterRegistrationCourses to delete.
     */
    limit?: number
  }

  /**
   * StudentSemesterRegistrationCourse without action
   */
  export type StudentSemesterRegistrationCourseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentSemesterRegistrationCourse
     */
    select?: StudentSemesterRegistrationCourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentSemesterRegistrationCourse
     */
    omit?: StudentSemesterRegistrationCourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentSemesterRegistrationCourseInclude<ExtArgs> | null
  }


  /**
   * Model StudentEnrolledCourse
   */

  export type AggregateStudentEnrolledCourse = {
    _count: StudentEnrolledCourseCountAggregateOutputType | null
    _avg: StudentEnrolledCourseAvgAggregateOutputType | null
    _sum: StudentEnrolledCourseSumAggregateOutputType | null
    _min: StudentEnrolledCourseMinAggregateOutputType | null
    _max: StudentEnrolledCourseMaxAggregateOutputType | null
  }

  export type StudentEnrolledCourseAvgAggregateOutputType = {
    point: number | null
    totalMarks: number | null
  }

  export type StudentEnrolledCourseSumAggregateOutputType = {
    point: number | null
    totalMarks: number | null
  }

  export type StudentEnrolledCourseMinAggregateOutputType = {
    id: string | null
    grade: string | null
    point: number | null
    totalMarks: number | null
    status: $Enums.StudentEnrolledCourseStatus | null
    createdAt: Date | null
    updatedAt: Date | null
    studentId: string | null
    academicSemesterId: string | null
    courseId: string | null
  }

  export type StudentEnrolledCourseMaxAggregateOutputType = {
    id: string | null
    grade: string | null
    point: number | null
    totalMarks: number | null
    status: $Enums.StudentEnrolledCourseStatus | null
    createdAt: Date | null
    updatedAt: Date | null
    studentId: string | null
    academicSemesterId: string | null
    courseId: string | null
  }

  export type StudentEnrolledCourseCountAggregateOutputType = {
    id: number
    grade: number
    point: number
    totalMarks: number
    status: number
    createdAt: number
    updatedAt: number
    studentId: number
    academicSemesterId: number
    courseId: number
    _all: number
  }


  export type StudentEnrolledCourseAvgAggregateInputType = {
    point?: true
    totalMarks?: true
  }

  export type StudentEnrolledCourseSumAggregateInputType = {
    point?: true
    totalMarks?: true
  }

  export type StudentEnrolledCourseMinAggregateInputType = {
    id?: true
    grade?: true
    point?: true
    totalMarks?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    studentId?: true
    academicSemesterId?: true
    courseId?: true
  }

  export type StudentEnrolledCourseMaxAggregateInputType = {
    id?: true
    grade?: true
    point?: true
    totalMarks?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    studentId?: true
    academicSemesterId?: true
    courseId?: true
  }

  export type StudentEnrolledCourseCountAggregateInputType = {
    id?: true
    grade?: true
    point?: true
    totalMarks?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    studentId?: true
    academicSemesterId?: true
    courseId?: true
    _all?: true
  }

  export type StudentEnrolledCourseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StudentEnrolledCourse to aggregate.
     */
    where?: StudentEnrolledCourseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentEnrolledCourses to fetch.
     */
    orderBy?: StudentEnrolledCourseOrderByWithRelationInput | StudentEnrolledCourseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StudentEnrolledCourseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentEnrolledCourses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentEnrolledCourses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StudentEnrolledCourses
    **/
    _count?: true | StudentEnrolledCourseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StudentEnrolledCourseAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StudentEnrolledCourseSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StudentEnrolledCourseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StudentEnrolledCourseMaxAggregateInputType
  }

  export type GetStudentEnrolledCourseAggregateType<T extends StudentEnrolledCourseAggregateArgs> = {
        [P in keyof T & keyof AggregateStudentEnrolledCourse]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStudentEnrolledCourse[P]>
      : GetScalarType<T[P], AggregateStudentEnrolledCourse[P]>
  }




  export type StudentEnrolledCourseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentEnrolledCourseWhereInput
    orderBy?: StudentEnrolledCourseOrderByWithAggregationInput | StudentEnrolledCourseOrderByWithAggregationInput[]
    by: StudentEnrolledCourseScalarFieldEnum[] | StudentEnrolledCourseScalarFieldEnum
    having?: StudentEnrolledCourseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StudentEnrolledCourseCountAggregateInputType | true
    _avg?: StudentEnrolledCourseAvgAggregateInputType
    _sum?: StudentEnrolledCourseSumAggregateInputType
    _min?: StudentEnrolledCourseMinAggregateInputType
    _max?: StudentEnrolledCourseMaxAggregateInputType
  }

  export type StudentEnrolledCourseGroupByOutputType = {
    id: string
    grade: string | null
    point: number | null
    totalMarks: number | null
    status: $Enums.StudentEnrolledCourseStatus | null
    createdAt: Date
    updatedAt: Date
    studentId: string
    academicSemesterId: string
    courseId: string
    _count: StudentEnrolledCourseCountAggregateOutputType | null
    _avg: StudentEnrolledCourseAvgAggregateOutputType | null
    _sum: StudentEnrolledCourseSumAggregateOutputType | null
    _min: StudentEnrolledCourseMinAggregateOutputType | null
    _max: StudentEnrolledCourseMaxAggregateOutputType | null
  }

  type GetStudentEnrolledCourseGroupByPayload<T extends StudentEnrolledCourseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StudentEnrolledCourseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StudentEnrolledCourseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StudentEnrolledCourseGroupByOutputType[P]>
            : GetScalarType<T[P], StudentEnrolledCourseGroupByOutputType[P]>
        }
      >
    >


  export type StudentEnrolledCourseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    grade?: boolean
    point?: boolean
    totalMarks?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    studentId?: boolean
    academicSemesterId?: boolean
    courseId?: boolean
    student?: boolean | StudentDefaultArgs<ExtArgs>
    academicSemester?: boolean | AcademicSemesterDefaultArgs<ExtArgs>
    course?: boolean | CourseDefaultArgs<ExtArgs>
    studentEnrolledCourseMarks?: boolean | StudentEnrolledCourse$studentEnrolledCourseMarksArgs<ExtArgs>
    _count?: boolean | StudentEnrolledCourseCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["studentEnrolledCourse"]>



  export type StudentEnrolledCourseSelectScalar = {
    id?: boolean
    grade?: boolean
    point?: boolean
    totalMarks?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    studentId?: boolean
    academicSemesterId?: boolean
    courseId?: boolean
  }

  export type StudentEnrolledCourseOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "grade" | "point" | "totalMarks" | "status" | "createdAt" | "updatedAt" | "studentId" | "academicSemesterId" | "courseId", ExtArgs["result"]["studentEnrolledCourse"]>
  export type StudentEnrolledCourseInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentDefaultArgs<ExtArgs>
    academicSemester?: boolean | AcademicSemesterDefaultArgs<ExtArgs>
    course?: boolean | CourseDefaultArgs<ExtArgs>
    studentEnrolledCourseMarks?: boolean | StudentEnrolledCourse$studentEnrolledCourseMarksArgs<ExtArgs>
    _count?: boolean | StudentEnrolledCourseCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $StudentEnrolledCoursePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "StudentEnrolledCourse"
    objects: {
      student: Prisma.$StudentPayload<ExtArgs>
      academicSemester: Prisma.$AcademicSemesterPayload<ExtArgs>
      course: Prisma.$CoursePayload<ExtArgs>
      studentEnrolledCourseMarks: Prisma.$StudentEnrolledCourseMarkPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      grade: string | null
      point: number | null
      totalMarks: number | null
      status: $Enums.StudentEnrolledCourseStatus | null
      createdAt: Date
      updatedAt: Date
      studentId: string
      academicSemesterId: string
      courseId: string
    }, ExtArgs["result"]["studentEnrolledCourse"]>
    composites: {}
  }

  type StudentEnrolledCourseGetPayload<S extends boolean | null | undefined | StudentEnrolledCourseDefaultArgs> = $Result.GetResult<Prisma.$StudentEnrolledCoursePayload, S>

  type StudentEnrolledCourseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<StudentEnrolledCourseFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: StudentEnrolledCourseCountAggregateInputType | true
    }

  export interface StudentEnrolledCourseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['StudentEnrolledCourse'], meta: { name: 'StudentEnrolledCourse' } }
    /**
     * Find zero or one StudentEnrolledCourse that matches the filter.
     * @param {StudentEnrolledCourseFindUniqueArgs} args - Arguments to find a StudentEnrolledCourse
     * @example
     * // Get one StudentEnrolledCourse
     * const studentEnrolledCourse = await prisma.studentEnrolledCourse.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StudentEnrolledCourseFindUniqueArgs>(args: SelectSubset<T, StudentEnrolledCourseFindUniqueArgs<ExtArgs>>): Prisma__StudentEnrolledCourseClient<$Result.GetResult<Prisma.$StudentEnrolledCoursePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one StudentEnrolledCourse that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {StudentEnrolledCourseFindUniqueOrThrowArgs} args - Arguments to find a StudentEnrolledCourse
     * @example
     * // Get one StudentEnrolledCourse
     * const studentEnrolledCourse = await prisma.studentEnrolledCourse.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StudentEnrolledCourseFindUniqueOrThrowArgs>(args: SelectSubset<T, StudentEnrolledCourseFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StudentEnrolledCourseClient<$Result.GetResult<Prisma.$StudentEnrolledCoursePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StudentEnrolledCourse that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentEnrolledCourseFindFirstArgs} args - Arguments to find a StudentEnrolledCourse
     * @example
     * // Get one StudentEnrolledCourse
     * const studentEnrolledCourse = await prisma.studentEnrolledCourse.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StudentEnrolledCourseFindFirstArgs>(args?: SelectSubset<T, StudentEnrolledCourseFindFirstArgs<ExtArgs>>): Prisma__StudentEnrolledCourseClient<$Result.GetResult<Prisma.$StudentEnrolledCoursePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StudentEnrolledCourse that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentEnrolledCourseFindFirstOrThrowArgs} args - Arguments to find a StudentEnrolledCourse
     * @example
     * // Get one StudentEnrolledCourse
     * const studentEnrolledCourse = await prisma.studentEnrolledCourse.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StudentEnrolledCourseFindFirstOrThrowArgs>(args?: SelectSubset<T, StudentEnrolledCourseFindFirstOrThrowArgs<ExtArgs>>): Prisma__StudentEnrolledCourseClient<$Result.GetResult<Prisma.$StudentEnrolledCoursePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more StudentEnrolledCourses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentEnrolledCourseFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StudentEnrolledCourses
     * const studentEnrolledCourses = await prisma.studentEnrolledCourse.findMany()
     * 
     * // Get first 10 StudentEnrolledCourses
     * const studentEnrolledCourses = await prisma.studentEnrolledCourse.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const studentEnrolledCourseWithIdOnly = await prisma.studentEnrolledCourse.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StudentEnrolledCourseFindManyArgs>(args?: SelectSubset<T, StudentEnrolledCourseFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentEnrolledCoursePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a StudentEnrolledCourse.
     * @param {StudentEnrolledCourseCreateArgs} args - Arguments to create a StudentEnrolledCourse.
     * @example
     * // Create one StudentEnrolledCourse
     * const StudentEnrolledCourse = await prisma.studentEnrolledCourse.create({
     *   data: {
     *     // ... data to create a StudentEnrolledCourse
     *   }
     * })
     * 
     */
    create<T extends StudentEnrolledCourseCreateArgs>(args: SelectSubset<T, StudentEnrolledCourseCreateArgs<ExtArgs>>): Prisma__StudentEnrolledCourseClient<$Result.GetResult<Prisma.$StudentEnrolledCoursePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many StudentEnrolledCourses.
     * @param {StudentEnrolledCourseCreateManyArgs} args - Arguments to create many StudentEnrolledCourses.
     * @example
     * // Create many StudentEnrolledCourses
     * const studentEnrolledCourse = await prisma.studentEnrolledCourse.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StudentEnrolledCourseCreateManyArgs>(args?: SelectSubset<T, StudentEnrolledCourseCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a StudentEnrolledCourse.
     * @param {StudentEnrolledCourseDeleteArgs} args - Arguments to delete one StudentEnrolledCourse.
     * @example
     * // Delete one StudentEnrolledCourse
     * const StudentEnrolledCourse = await prisma.studentEnrolledCourse.delete({
     *   where: {
     *     // ... filter to delete one StudentEnrolledCourse
     *   }
     * })
     * 
     */
    delete<T extends StudentEnrolledCourseDeleteArgs>(args: SelectSubset<T, StudentEnrolledCourseDeleteArgs<ExtArgs>>): Prisma__StudentEnrolledCourseClient<$Result.GetResult<Prisma.$StudentEnrolledCoursePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one StudentEnrolledCourse.
     * @param {StudentEnrolledCourseUpdateArgs} args - Arguments to update one StudentEnrolledCourse.
     * @example
     * // Update one StudentEnrolledCourse
     * const studentEnrolledCourse = await prisma.studentEnrolledCourse.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StudentEnrolledCourseUpdateArgs>(args: SelectSubset<T, StudentEnrolledCourseUpdateArgs<ExtArgs>>): Prisma__StudentEnrolledCourseClient<$Result.GetResult<Prisma.$StudentEnrolledCoursePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more StudentEnrolledCourses.
     * @param {StudentEnrolledCourseDeleteManyArgs} args - Arguments to filter StudentEnrolledCourses to delete.
     * @example
     * // Delete a few StudentEnrolledCourses
     * const { count } = await prisma.studentEnrolledCourse.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StudentEnrolledCourseDeleteManyArgs>(args?: SelectSubset<T, StudentEnrolledCourseDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StudentEnrolledCourses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentEnrolledCourseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StudentEnrolledCourses
     * const studentEnrolledCourse = await prisma.studentEnrolledCourse.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StudentEnrolledCourseUpdateManyArgs>(args: SelectSubset<T, StudentEnrolledCourseUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one StudentEnrolledCourse.
     * @param {StudentEnrolledCourseUpsertArgs} args - Arguments to update or create a StudentEnrolledCourse.
     * @example
     * // Update or create a StudentEnrolledCourse
     * const studentEnrolledCourse = await prisma.studentEnrolledCourse.upsert({
     *   create: {
     *     // ... data to create a StudentEnrolledCourse
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StudentEnrolledCourse we want to update
     *   }
     * })
     */
    upsert<T extends StudentEnrolledCourseUpsertArgs>(args: SelectSubset<T, StudentEnrolledCourseUpsertArgs<ExtArgs>>): Prisma__StudentEnrolledCourseClient<$Result.GetResult<Prisma.$StudentEnrolledCoursePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of StudentEnrolledCourses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentEnrolledCourseCountArgs} args - Arguments to filter StudentEnrolledCourses to count.
     * @example
     * // Count the number of StudentEnrolledCourses
     * const count = await prisma.studentEnrolledCourse.count({
     *   where: {
     *     // ... the filter for the StudentEnrolledCourses we want to count
     *   }
     * })
    **/
    count<T extends StudentEnrolledCourseCountArgs>(
      args?: Subset<T, StudentEnrolledCourseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StudentEnrolledCourseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StudentEnrolledCourse.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentEnrolledCourseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StudentEnrolledCourseAggregateArgs>(args: Subset<T, StudentEnrolledCourseAggregateArgs>): Prisma.PrismaPromise<GetStudentEnrolledCourseAggregateType<T>>

    /**
     * Group by StudentEnrolledCourse.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentEnrolledCourseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StudentEnrolledCourseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StudentEnrolledCourseGroupByArgs['orderBy'] }
        : { orderBy?: StudentEnrolledCourseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StudentEnrolledCourseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStudentEnrolledCourseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the StudentEnrolledCourse model
   */
  readonly fields: StudentEnrolledCourseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for StudentEnrolledCourse.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StudentEnrolledCourseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    student<T extends StudentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StudentDefaultArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    academicSemester<T extends AcademicSemesterDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AcademicSemesterDefaultArgs<ExtArgs>>): Prisma__AcademicSemesterClient<$Result.GetResult<Prisma.$AcademicSemesterPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    course<T extends CourseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CourseDefaultArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    studentEnrolledCourseMarks<T extends StudentEnrolledCourse$studentEnrolledCourseMarksArgs<ExtArgs> = {}>(args?: Subset<T, StudentEnrolledCourse$studentEnrolledCourseMarksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentEnrolledCourseMarkPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the StudentEnrolledCourse model
   */
  interface StudentEnrolledCourseFieldRefs {
    readonly id: FieldRef<"StudentEnrolledCourse", 'String'>
    readonly grade: FieldRef<"StudentEnrolledCourse", 'String'>
    readonly point: FieldRef<"StudentEnrolledCourse", 'Float'>
    readonly totalMarks: FieldRef<"StudentEnrolledCourse", 'Int'>
    readonly status: FieldRef<"StudentEnrolledCourse", 'StudentEnrolledCourseStatus'>
    readonly createdAt: FieldRef<"StudentEnrolledCourse", 'DateTime'>
    readonly updatedAt: FieldRef<"StudentEnrolledCourse", 'DateTime'>
    readonly studentId: FieldRef<"StudentEnrolledCourse", 'String'>
    readonly academicSemesterId: FieldRef<"StudentEnrolledCourse", 'String'>
    readonly courseId: FieldRef<"StudentEnrolledCourse", 'String'>
  }
    

  // Custom InputTypes
  /**
   * StudentEnrolledCourse findUnique
   */
  export type StudentEnrolledCourseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentEnrolledCourse
     */
    select?: StudentEnrolledCourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentEnrolledCourse
     */
    omit?: StudentEnrolledCourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentEnrolledCourseInclude<ExtArgs> | null
    /**
     * Filter, which StudentEnrolledCourse to fetch.
     */
    where: StudentEnrolledCourseWhereUniqueInput
  }

  /**
   * StudentEnrolledCourse findUniqueOrThrow
   */
  export type StudentEnrolledCourseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentEnrolledCourse
     */
    select?: StudentEnrolledCourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentEnrolledCourse
     */
    omit?: StudentEnrolledCourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentEnrolledCourseInclude<ExtArgs> | null
    /**
     * Filter, which StudentEnrolledCourse to fetch.
     */
    where: StudentEnrolledCourseWhereUniqueInput
  }

  /**
   * StudentEnrolledCourse findFirst
   */
  export type StudentEnrolledCourseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentEnrolledCourse
     */
    select?: StudentEnrolledCourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentEnrolledCourse
     */
    omit?: StudentEnrolledCourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentEnrolledCourseInclude<ExtArgs> | null
    /**
     * Filter, which StudentEnrolledCourse to fetch.
     */
    where?: StudentEnrolledCourseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentEnrolledCourses to fetch.
     */
    orderBy?: StudentEnrolledCourseOrderByWithRelationInput | StudentEnrolledCourseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StudentEnrolledCourses.
     */
    cursor?: StudentEnrolledCourseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentEnrolledCourses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentEnrolledCourses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StudentEnrolledCourses.
     */
    distinct?: StudentEnrolledCourseScalarFieldEnum | StudentEnrolledCourseScalarFieldEnum[]
  }

  /**
   * StudentEnrolledCourse findFirstOrThrow
   */
  export type StudentEnrolledCourseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentEnrolledCourse
     */
    select?: StudentEnrolledCourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentEnrolledCourse
     */
    omit?: StudentEnrolledCourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentEnrolledCourseInclude<ExtArgs> | null
    /**
     * Filter, which StudentEnrolledCourse to fetch.
     */
    where?: StudentEnrolledCourseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentEnrolledCourses to fetch.
     */
    orderBy?: StudentEnrolledCourseOrderByWithRelationInput | StudentEnrolledCourseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StudentEnrolledCourses.
     */
    cursor?: StudentEnrolledCourseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentEnrolledCourses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentEnrolledCourses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StudentEnrolledCourses.
     */
    distinct?: StudentEnrolledCourseScalarFieldEnum | StudentEnrolledCourseScalarFieldEnum[]
  }

  /**
   * StudentEnrolledCourse findMany
   */
  export type StudentEnrolledCourseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentEnrolledCourse
     */
    select?: StudentEnrolledCourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentEnrolledCourse
     */
    omit?: StudentEnrolledCourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentEnrolledCourseInclude<ExtArgs> | null
    /**
     * Filter, which StudentEnrolledCourses to fetch.
     */
    where?: StudentEnrolledCourseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentEnrolledCourses to fetch.
     */
    orderBy?: StudentEnrolledCourseOrderByWithRelationInput | StudentEnrolledCourseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StudentEnrolledCourses.
     */
    cursor?: StudentEnrolledCourseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentEnrolledCourses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentEnrolledCourses.
     */
    skip?: number
    distinct?: StudentEnrolledCourseScalarFieldEnum | StudentEnrolledCourseScalarFieldEnum[]
  }

  /**
   * StudentEnrolledCourse create
   */
  export type StudentEnrolledCourseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentEnrolledCourse
     */
    select?: StudentEnrolledCourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentEnrolledCourse
     */
    omit?: StudentEnrolledCourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentEnrolledCourseInclude<ExtArgs> | null
    /**
     * The data needed to create a StudentEnrolledCourse.
     */
    data: XOR<StudentEnrolledCourseCreateInput, StudentEnrolledCourseUncheckedCreateInput>
  }

  /**
   * StudentEnrolledCourse createMany
   */
  export type StudentEnrolledCourseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many StudentEnrolledCourses.
     */
    data: StudentEnrolledCourseCreateManyInput | StudentEnrolledCourseCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * StudentEnrolledCourse update
   */
  export type StudentEnrolledCourseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentEnrolledCourse
     */
    select?: StudentEnrolledCourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentEnrolledCourse
     */
    omit?: StudentEnrolledCourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentEnrolledCourseInclude<ExtArgs> | null
    /**
     * The data needed to update a StudentEnrolledCourse.
     */
    data: XOR<StudentEnrolledCourseUpdateInput, StudentEnrolledCourseUncheckedUpdateInput>
    /**
     * Choose, which StudentEnrolledCourse to update.
     */
    where: StudentEnrolledCourseWhereUniqueInput
  }

  /**
   * StudentEnrolledCourse updateMany
   */
  export type StudentEnrolledCourseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update StudentEnrolledCourses.
     */
    data: XOR<StudentEnrolledCourseUpdateManyMutationInput, StudentEnrolledCourseUncheckedUpdateManyInput>
    /**
     * Filter which StudentEnrolledCourses to update
     */
    where?: StudentEnrolledCourseWhereInput
    /**
     * Limit how many StudentEnrolledCourses to update.
     */
    limit?: number
  }

  /**
   * StudentEnrolledCourse upsert
   */
  export type StudentEnrolledCourseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentEnrolledCourse
     */
    select?: StudentEnrolledCourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentEnrolledCourse
     */
    omit?: StudentEnrolledCourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentEnrolledCourseInclude<ExtArgs> | null
    /**
     * The filter to search for the StudentEnrolledCourse to update in case it exists.
     */
    where: StudentEnrolledCourseWhereUniqueInput
    /**
     * In case the StudentEnrolledCourse found by the `where` argument doesn't exist, create a new StudentEnrolledCourse with this data.
     */
    create: XOR<StudentEnrolledCourseCreateInput, StudentEnrolledCourseUncheckedCreateInput>
    /**
     * In case the StudentEnrolledCourse was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StudentEnrolledCourseUpdateInput, StudentEnrolledCourseUncheckedUpdateInput>
  }

  /**
   * StudentEnrolledCourse delete
   */
  export type StudentEnrolledCourseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentEnrolledCourse
     */
    select?: StudentEnrolledCourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentEnrolledCourse
     */
    omit?: StudentEnrolledCourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentEnrolledCourseInclude<ExtArgs> | null
    /**
     * Filter which StudentEnrolledCourse to delete.
     */
    where: StudentEnrolledCourseWhereUniqueInput
  }

  /**
   * StudentEnrolledCourse deleteMany
   */
  export type StudentEnrolledCourseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StudentEnrolledCourses to delete
     */
    where?: StudentEnrolledCourseWhereInput
    /**
     * Limit how many StudentEnrolledCourses to delete.
     */
    limit?: number
  }

  /**
   * StudentEnrolledCourse.studentEnrolledCourseMarks
   */
  export type StudentEnrolledCourse$studentEnrolledCourseMarksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentEnrolledCourseMark
     */
    select?: StudentEnrolledCourseMarkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentEnrolledCourseMark
     */
    omit?: StudentEnrolledCourseMarkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentEnrolledCourseMarkInclude<ExtArgs> | null
    where?: StudentEnrolledCourseMarkWhereInput
    orderBy?: StudentEnrolledCourseMarkOrderByWithRelationInput | StudentEnrolledCourseMarkOrderByWithRelationInput[]
    cursor?: StudentEnrolledCourseMarkWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StudentEnrolledCourseMarkScalarFieldEnum | StudentEnrolledCourseMarkScalarFieldEnum[]
  }

  /**
   * StudentEnrolledCourse without action
   */
  export type StudentEnrolledCourseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentEnrolledCourse
     */
    select?: StudentEnrolledCourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentEnrolledCourse
     */
    omit?: StudentEnrolledCourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentEnrolledCourseInclude<ExtArgs> | null
  }


  /**
   * Model StudentEnrolledCourseMark
   */

  export type AggregateStudentEnrolledCourseMark = {
    _count: StudentEnrolledCourseMarkCountAggregateOutputType | null
    _avg: StudentEnrolledCourseMarkAvgAggregateOutputType | null
    _sum: StudentEnrolledCourseMarkSumAggregateOutputType | null
    _min: StudentEnrolledCourseMarkMinAggregateOutputType | null
    _max: StudentEnrolledCourseMarkMaxAggregateOutputType | null
  }

  export type StudentEnrolledCourseMarkAvgAggregateOutputType = {
    exam1: number | null
    exam2: number | null
    exam3: number | null
    exam4: number | null
    exam5: number | null
    exam6: number | null
    finalExam: number | null
    totalMarks: number | null
    grade: number | null
  }

  export type StudentEnrolledCourseMarkSumAggregateOutputType = {
    exam1: number | null
    exam2: number | null
    exam3: number | null
    exam4: number | null
    exam5: number | null
    exam6: number | null
    finalExam: number | null
    totalMarks: number | null
    grade: number | null
  }

  export type StudentEnrolledCourseMarkMinAggregateOutputType = {
    id: string | null
    examType: $Enums.ExamType | null
    createdAt: Date | null
    updatedAt: Date | null
    studentId: string | null
    studentEnrolledCourseId: string | null
    academicSemesterId: string | null
    exam1: number | null
    exam2: number | null
    exam3: number | null
    exam4: number | null
    exam5: number | null
    exam6: number | null
    finalExam: number | null
    totalMarks: number | null
    grade: number | null
  }

  export type StudentEnrolledCourseMarkMaxAggregateOutputType = {
    id: string | null
    examType: $Enums.ExamType | null
    createdAt: Date | null
    updatedAt: Date | null
    studentId: string | null
    studentEnrolledCourseId: string | null
    academicSemesterId: string | null
    exam1: number | null
    exam2: number | null
    exam3: number | null
    exam4: number | null
    exam5: number | null
    exam6: number | null
    finalExam: number | null
    totalMarks: number | null
    grade: number | null
  }

  export type StudentEnrolledCourseMarkCountAggregateOutputType = {
    id: number
    examType: number
    createdAt: number
    updatedAt: number
    studentId: number
    studentEnrolledCourseId: number
    academicSemesterId: number
    exam1: number
    exam2: number
    exam3: number
    exam4: number
    exam5: number
    exam6: number
    finalExam: number
    totalMarks: number
    grade: number
    _all: number
  }


  export type StudentEnrolledCourseMarkAvgAggregateInputType = {
    exam1?: true
    exam2?: true
    exam3?: true
    exam4?: true
    exam5?: true
    exam6?: true
    finalExam?: true
    totalMarks?: true
    grade?: true
  }

  export type StudentEnrolledCourseMarkSumAggregateInputType = {
    exam1?: true
    exam2?: true
    exam3?: true
    exam4?: true
    exam5?: true
    exam6?: true
    finalExam?: true
    totalMarks?: true
    grade?: true
  }

  export type StudentEnrolledCourseMarkMinAggregateInputType = {
    id?: true
    examType?: true
    createdAt?: true
    updatedAt?: true
    studentId?: true
    studentEnrolledCourseId?: true
    academicSemesterId?: true
    exam1?: true
    exam2?: true
    exam3?: true
    exam4?: true
    exam5?: true
    exam6?: true
    finalExam?: true
    totalMarks?: true
    grade?: true
  }

  export type StudentEnrolledCourseMarkMaxAggregateInputType = {
    id?: true
    examType?: true
    createdAt?: true
    updatedAt?: true
    studentId?: true
    studentEnrolledCourseId?: true
    academicSemesterId?: true
    exam1?: true
    exam2?: true
    exam3?: true
    exam4?: true
    exam5?: true
    exam6?: true
    finalExam?: true
    totalMarks?: true
    grade?: true
  }

  export type StudentEnrolledCourseMarkCountAggregateInputType = {
    id?: true
    examType?: true
    createdAt?: true
    updatedAt?: true
    studentId?: true
    studentEnrolledCourseId?: true
    academicSemesterId?: true
    exam1?: true
    exam2?: true
    exam3?: true
    exam4?: true
    exam5?: true
    exam6?: true
    finalExam?: true
    totalMarks?: true
    grade?: true
    _all?: true
  }

  export type StudentEnrolledCourseMarkAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StudentEnrolledCourseMark to aggregate.
     */
    where?: StudentEnrolledCourseMarkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentEnrolledCourseMarks to fetch.
     */
    orderBy?: StudentEnrolledCourseMarkOrderByWithRelationInput | StudentEnrolledCourseMarkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StudentEnrolledCourseMarkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentEnrolledCourseMarks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentEnrolledCourseMarks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StudentEnrolledCourseMarks
    **/
    _count?: true | StudentEnrolledCourseMarkCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StudentEnrolledCourseMarkAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StudentEnrolledCourseMarkSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StudentEnrolledCourseMarkMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StudentEnrolledCourseMarkMaxAggregateInputType
  }

  export type GetStudentEnrolledCourseMarkAggregateType<T extends StudentEnrolledCourseMarkAggregateArgs> = {
        [P in keyof T & keyof AggregateStudentEnrolledCourseMark]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStudentEnrolledCourseMark[P]>
      : GetScalarType<T[P], AggregateStudentEnrolledCourseMark[P]>
  }




  export type StudentEnrolledCourseMarkGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentEnrolledCourseMarkWhereInput
    orderBy?: StudentEnrolledCourseMarkOrderByWithAggregationInput | StudentEnrolledCourseMarkOrderByWithAggregationInput[]
    by: StudentEnrolledCourseMarkScalarFieldEnum[] | StudentEnrolledCourseMarkScalarFieldEnum
    having?: StudentEnrolledCourseMarkScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StudentEnrolledCourseMarkCountAggregateInputType | true
    _avg?: StudentEnrolledCourseMarkAvgAggregateInputType
    _sum?: StudentEnrolledCourseMarkSumAggregateInputType
    _min?: StudentEnrolledCourseMarkMinAggregateInputType
    _max?: StudentEnrolledCourseMarkMaxAggregateInputType
  }

  export type StudentEnrolledCourseMarkGroupByOutputType = {
    id: string
    examType: $Enums.ExamType | null
    createdAt: Date
    updatedAt: Date
    studentId: string
    studentEnrolledCourseId: string
    academicSemesterId: string
    exam1: number
    exam2: number
    exam3: number
    exam4: number
    exam5: number
    exam6: number
    finalExam: number
    totalMarks: number
    grade: number
    _count: StudentEnrolledCourseMarkCountAggregateOutputType | null
    _avg: StudentEnrolledCourseMarkAvgAggregateOutputType | null
    _sum: StudentEnrolledCourseMarkSumAggregateOutputType | null
    _min: StudentEnrolledCourseMarkMinAggregateOutputType | null
    _max: StudentEnrolledCourseMarkMaxAggregateOutputType | null
  }

  type GetStudentEnrolledCourseMarkGroupByPayload<T extends StudentEnrolledCourseMarkGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StudentEnrolledCourseMarkGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StudentEnrolledCourseMarkGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StudentEnrolledCourseMarkGroupByOutputType[P]>
            : GetScalarType<T[P], StudentEnrolledCourseMarkGroupByOutputType[P]>
        }
      >
    >


  export type StudentEnrolledCourseMarkSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    examType?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    studentId?: boolean
    studentEnrolledCourseId?: boolean
    academicSemesterId?: boolean
    exam1?: boolean
    exam2?: boolean
    exam3?: boolean
    exam4?: boolean
    exam5?: boolean
    exam6?: boolean
    finalExam?: boolean
    totalMarks?: boolean
    grade?: boolean
    student?: boolean | StudentDefaultArgs<ExtArgs>
    studentEnrolledCourse?: boolean | StudentEnrolledCourseDefaultArgs<ExtArgs>
    academicSemester?: boolean | AcademicSemesterDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["studentEnrolledCourseMark"]>



  export type StudentEnrolledCourseMarkSelectScalar = {
    id?: boolean
    examType?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    studentId?: boolean
    studentEnrolledCourseId?: boolean
    academicSemesterId?: boolean
    exam1?: boolean
    exam2?: boolean
    exam3?: boolean
    exam4?: boolean
    exam5?: boolean
    exam6?: boolean
    finalExam?: boolean
    totalMarks?: boolean
    grade?: boolean
  }

  export type StudentEnrolledCourseMarkOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "examType" | "createdAt" | "updatedAt" | "studentId" | "studentEnrolledCourseId" | "academicSemesterId" | "exam1" | "exam2" | "exam3" | "exam4" | "exam5" | "exam6" | "finalExam" | "totalMarks" | "grade", ExtArgs["result"]["studentEnrolledCourseMark"]>
  export type StudentEnrolledCourseMarkInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentDefaultArgs<ExtArgs>
    studentEnrolledCourse?: boolean | StudentEnrolledCourseDefaultArgs<ExtArgs>
    academicSemester?: boolean | AcademicSemesterDefaultArgs<ExtArgs>
  }

  export type $StudentEnrolledCourseMarkPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "StudentEnrolledCourseMark"
    objects: {
      student: Prisma.$StudentPayload<ExtArgs>
      studentEnrolledCourse: Prisma.$StudentEnrolledCoursePayload<ExtArgs>
      academicSemester: Prisma.$AcademicSemesterPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      examType: $Enums.ExamType | null
      createdAt: Date
      updatedAt: Date
      studentId: string
      studentEnrolledCourseId: string
      academicSemesterId: string
      exam1: number
      exam2: number
      exam3: number
      exam4: number
      exam5: number
      exam6: number
      finalExam: number
      totalMarks: number
      grade: number
    }, ExtArgs["result"]["studentEnrolledCourseMark"]>
    composites: {}
  }

  type StudentEnrolledCourseMarkGetPayload<S extends boolean | null | undefined | StudentEnrolledCourseMarkDefaultArgs> = $Result.GetResult<Prisma.$StudentEnrolledCourseMarkPayload, S>

  type StudentEnrolledCourseMarkCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<StudentEnrolledCourseMarkFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: StudentEnrolledCourseMarkCountAggregateInputType | true
    }

  export interface StudentEnrolledCourseMarkDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['StudentEnrolledCourseMark'], meta: { name: 'StudentEnrolledCourseMark' } }
    /**
     * Find zero or one StudentEnrolledCourseMark that matches the filter.
     * @param {StudentEnrolledCourseMarkFindUniqueArgs} args - Arguments to find a StudentEnrolledCourseMark
     * @example
     * // Get one StudentEnrolledCourseMark
     * const studentEnrolledCourseMark = await prisma.studentEnrolledCourseMark.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StudentEnrolledCourseMarkFindUniqueArgs>(args: SelectSubset<T, StudentEnrolledCourseMarkFindUniqueArgs<ExtArgs>>): Prisma__StudentEnrolledCourseMarkClient<$Result.GetResult<Prisma.$StudentEnrolledCourseMarkPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one StudentEnrolledCourseMark that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {StudentEnrolledCourseMarkFindUniqueOrThrowArgs} args - Arguments to find a StudentEnrolledCourseMark
     * @example
     * // Get one StudentEnrolledCourseMark
     * const studentEnrolledCourseMark = await prisma.studentEnrolledCourseMark.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StudentEnrolledCourseMarkFindUniqueOrThrowArgs>(args: SelectSubset<T, StudentEnrolledCourseMarkFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StudentEnrolledCourseMarkClient<$Result.GetResult<Prisma.$StudentEnrolledCourseMarkPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StudentEnrolledCourseMark that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentEnrolledCourseMarkFindFirstArgs} args - Arguments to find a StudentEnrolledCourseMark
     * @example
     * // Get one StudentEnrolledCourseMark
     * const studentEnrolledCourseMark = await prisma.studentEnrolledCourseMark.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StudentEnrolledCourseMarkFindFirstArgs>(args?: SelectSubset<T, StudentEnrolledCourseMarkFindFirstArgs<ExtArgs>>): Prisma__StudentEnrolledCourseMarkClient<$Result.GetResult<Prisma.$StudentEnrolledCourseMarkPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StudentEnrolledCourseMark that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentEnrolledCourseMarkFindFirstOrThrowArgs} args - Arguments to find a StudentEnrolledCourseMark
     * @example
     * // Get one StudentEnrolledCourseMark
     * const studentEnrolledCourseMark = await prisma.studentEnrolledCourseMark.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StudentEnrolledCourseMarkFindFirstOrThrowArgs>(args?: SelectSubset<T, StudentEnrolledCourseMarkFindFirstOrThrowArgs<ExtArgs>>): Prisma__StudentEnrolledCourseMarkClient<$Result.GetResult<Prisma.$StudentEnrolledCourseMarkPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more StudentEnrolledCourseMarks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentEnrolledCourseMarkFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StudentEnrolledCourseMarks
     * const studentEnrolledCourseMarks = await prisma.studentEnrolledCourseMark.findMany()
     * 
     * // Get first 10 StudentEnrolledCourseMarks
     * const studentEnrolledCourseMarks = await prisma.studentEnrolledCourseMark.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const studentEnrolledCourseMarkWithIdOnly = await prisma.studentEnrolledCourseMark.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StudentEnrolledCourseMarkFindManyArgs>(args?: SelectSubset<T, StudentEnrolledCourseMarkFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentEnrolledCourseMarkPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a StudentEnrolledCourseMark.
     * @param {StudentEnrolledCourseMarkCreateArgs} args - Arguments to create a StudentEnrolledCourseMark.
     * @example
     * // Create one StudentEnrolledCourseMark
     * const StudentEnrolledCourseMark = await prisma.studentEnrolledCourseMark.create({
     *   data: {
     *     // ... data to create a StudentEnrolledCourseMark
     *   }
     * })
     * 
     */
    create<T extends StudentEnrolledCourseMarkCreateArgs>(args: SelectSubset<T, StudentEnrolledCourseMarkCreateArgs<ExtArgs>>): Prisma__StudentEnrolledCourseMarkClient<$Result.GetResult<Prisma.$StudentEnrolledCourseMarkPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many StudentEnrolledCourseMarks.
     * @param {StudentEnrolledCourseMarkCreateManyArgs} args - Arguments to create many StudentEnrolledCourseMarks.
     * @example
     * // Create many StudentEnrolledCourseMarks
     * const studentEnrolledCourseMark = await prisma.studentEnrolledCourseMark.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StudentEnrolledCourseMarkCreateManyArgs>(args?: SelectSubset<T, StudentEnrolledCourseMarkCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a StudentEnrolledCourseMark.
     * @param {StudentEnrolledCourseMarkDeleteArgs} args - Arguments to delete one StudentEnrolledCourseMark.
     * @example
     * // Delete one StudentEnrolledCourseMark
     * const StudentEnrolledCourseMark = await prisma.studentEnrolledCourseMark.delete({
     *   where: {
     *     // ... filter to delete one StudentEnrolledCourseMark
     *   }
     * })
     * 
     */
    delete<T extends StudentEnrolledCourseMarkDeleteArgs>(args: SelectSubset<T, StudentEnrolledCourseMarkDeleteArgs<ExtArgs>>): Prisma__StudentEnrolledCourseMarkClient<$Result.GetResult<Prisma.$StudentEnrolledCourseMarkPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one StudentEnrolledCourseMark.
     * @param {StudentEnrolledCourseMarkUpdateArgs} args - Arguments to update one StudentEnrolledCourseMark.
     * @example
     * // Update one StudentEnrolledCourseMark
     * const studentEnrolledCourseMark = await prisma.studentEnrolledCourseMark.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StudentEnrolledCourseMarkUpdateArgs>(args: SelectSubset<T, StudentEnrolledCourseMarkUpdateArgs<ExtArgs>>): Prisma__StudentEnrolledCourseMarkClient<$Result.GetResult<Prisma.$StudentEnrolledCourseMarkPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more StudentEnrolledCourseMarks.
     * @param {StudentEnrolledCourseMarkDeleteManyArgs} args - Arguments to filter StudentEnrolledCourseMarks to delete.
     * @example
     * // Delete a few StudentEnrolledCourseMarks
     * const { count } = await prisma.studentEnrolledCourseMark.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StudentEnrolledCourseMarkDeleteManyArgs>(args?: SelectSubset<T, StudentEnrolledCourseMarkDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StudentEnrolledCourseMarks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentEnrolledCourseMarkUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StudentEnrolledCourseMarks
     * const studentEnrolledCourseMark = await prisma.studentEnrolledCourseMark.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StudentEnrolledCourseMarkUpdateManyArgs>(args: SelectSubset<T, StudentEnrolledCourseMarkUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one StudentEnrolledCourseMark.
     * @param {StudentEnrolledCourseMarkUpsertArgs} args - Arguments to update or create a StudentEnrolledCourseMark.
     * @example
     * // Update or create a StudentEnrolledCourseMark
     * const studentEnrolledCourseMark = await prisma.studentEnrolledCourseMark.upsert({
     *   create: {
     *     // ... data to create a StudentEnrolledCourseMark
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StudentEnrolledCourseMark we want to update
     *   }
     * })
     */
    upsert<T extends StudentEnrolledCourseMarkUpsertArgs>(args: SelectSubset<T, StudentEnrolledCourseMarkUpsertArgs<ExtArgs>>): Prisma__StudentEnrolledCourseMarkClient<$Result.GetResult<Prisma.$StudentEnrolledCourseMarkPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of StudentEnrolledCourseMarks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentEnrolledCourseMarkCountArgs} args - Arguments to filter StudentEnrolledCourseMarks to count.
     * @example
     * // Count the number of StudentEnrolledCourseMarks
     * const count = await prisma.studentEnrolledCourseMark.count({
     *   where: {
     *     // ... the filter for the StudentEnrolledCourseMarks we want to count
     *   }
     * })
    **/
    count<T extends StudentEnrolledCourseMarkCountArgs>(
      args?: Subset<T, StudentEnrolledCourseMarkCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StudentEnrolledCourseMarkCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StudentEnrolledCourseMark.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentEnrolledCourseMarkAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StudentEnrolledCourseMarkAggregateArgs>(args: Subset<T, StudentEnrolledCourseMarkAggregateArgs>): Prisma.PrismaPromise<GetStudentEnrolledCourseMarkAggregateType<T>>

    /**
     * Group by StudentEnrolledCourseMark.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentEnrolledCourseMarkGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StudentEnrolledCourseMarkGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StudentEnrolledCourseMarkGroupByArgs['orderBy'] }
        : { orderBy?: StudentEnrolledCourseMarkGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StudentEnrolledCourseMarkGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStudentEnrolledCourseMarkGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the StudentEnrolledCourseMark model
   */
  readonly fields: StudentEnrolledCourseMarkFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for StudentEnrolledCourseMark.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StudentEnrolledCourseMarkClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    student<T extends StudentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StudentDefaultArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    studentEnrolledCourse<T extends StudentEnrolledCourseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StudentEnrolledCourseDefaultArgs<ExtArgs>>): Prisma__StudentEnrolledCourseClient<$Result.GetResult<Prisma.$StudentEnrolledCoursePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    academicSemester<T extends AcademicSemesterDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AcademicSemesterDefaultArgs<ExtArgs>>): Prisma__AcademicSemesterClient<$Result.GetResult<Prisma.$AcademicSemesterPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the StudentEnrolledCourseMark model
   */
  interface StudentEnrolledCourseMarkFieldRefs {
    readonly id: FieldRef<"StudentEnrolledCourseMark", 'String'>
    readonly examType: FieldRef<"StudentEnrolledCourseMark", 'ExamType'>
    readonly createdAt: FieldRef<"StudentEnrolledCourseMark", 'DateTime'>
    readonly updatedAt: FieldRef<"StudentEnrolledCourseMark", 'DateTime'>
    readonly studentId: FieldRef<"StudentEnrolledCourseMark", 'String'>
    readonly studentEnrolledCourseId: FieldRef<"StudentEnrolledCourseMark", 'String'>
    readonly academicSemesterId: FieldRef<"StudentEnrolledCourseMark", 'String'>
    readonly exam1: FieldRef<"StudentEnrolledCourseMark", 'Float'>
    readonly exam2: FieldRef<"StudentEnrolledCourseMark", 'Float'>
    readonly exam3: FieldRef<"StudentEnrolledCourseMark", 'Float'>
    readonly exam4: FieldRef<"StudentEnrolledCourseMark", 'Float'>
    readonly exam5: FieldRef<"StudentEnrolledCourseMark", 'Float'>
    readonly exam6: FieldRef<"StudentEnrolledCourseMark", 'Float'>
    readonly finalExam: FieldRef<"StudentEnrolledCourseMark", 'Float'>
    readonly totalMarks: FieldRef<"StudentEnrolledCourseMark", 'Float'>
    readonly grade: FieldRef<"StudentEnrolledCourseMark", 'Float'>
  }
    

  // Custom InputTypes
  /**
   * StudentEnrolledCourseMark findUnique
   */
  export type StudentEnrolledCourseMarkFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentEnrolledCourseMark
     */
    select?: StudentEnrolledCourseMarkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentEnrolledCourseMark
     */
    omit?: StudentEnrolledCourseMarkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentEnrolledCourseMarkInclude<ExtArgs> | null
    /**
     * Filter, which StudentEnrolledCourseMark to fetch.
     */
    where: StudentEnrolledCourseMarkWhereUniqueInput
  }

  /**
   * StudentEnrolledCourseMark findUniqueOrThrow
   */
  export type StudentEnrolledCourseMarkFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentEnrolledCourseMark
     */
    select?: StudentEnrolledCourseMarkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentEnrolledCourseMark
     */
    omit?: StudentEnrolledCourseMarkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentEnrolledCourseMarkInclude<ExtArgs> | null
    /**
     * Filter, which StudentEnrolledCourseMark to fetch.
     */
    where: StudentEnrolledCourseMarkWhereUniqueInput
  }

  /**
   * StudentEnrolledCourseMark findFirst
   */
  export type StudentEnrolledCourseMarkFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentEnrolledCourseMark
     */
    select?: StudentEnrolledCourseMarkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentEnrolledCourseMark
     */
    omit?: StudentEnrolledCourseMarkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentEnrolledCourseMarkInclude<ExtArgs> | null
    /**
     * Filter, which StudentEnrolledCourseMark to fetch.
     */
    where?: StudentEnrolledCourseMarkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentEnrolledCourseMarks to fetch.
     */
    orderBy?: StudentEnrolledCourseMarkOrderByWithRelationInput | StudentEnrolledCourseMarkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StudentEnrolledCourseMarks.
     */
    cursor?: StudentEnrolledCourseMarkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentEnrolledCourseMarks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentEnrolledCourseMarks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StudentEnrolledCourseMarks.
     */
    distinct?: StudentEnrolledCourseMarkScalarFieldEnum | StudentEnrolledCourseMarkScalarFieldEnum[]
  }

  /**
   * StudentEnrolledCourseMark findFirstOrThrow
   */
  export type StudentEnrolledCourseMarkFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentEnrolledCourseMark
     */
    select?: StudentEnrolledCourseMarkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentEnrolledCourseMark
     */
    omit?: StudentEnrolledCourseMarkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentEnrolledCourseMarkInclude<ExtArgs> | null
    /**
     * Filter, which StudentEnrolledCourseMark to fetch.
     */
    where?: StudentEnrolledCourseMarkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentEnrolledCourseMarks to fetch.
     */
    orderBy?: StudentEnrolledCourseMarkOrderByWithRelationInput | StudentEnrolledCourseMarkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StudentEnrolledCourseMarks.
     */
    cursor?: StudentEnrolledCourseMarkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentEnrolledCourseMarks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentEnrolledCourseMarks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StudentEnrolledCourseMarks.
     */
    distinct?: StudentEnrolledCourseMarkScalarFieldEnum | StudentEnrolledCourseMarkScalarFieldEnum[]
  }

  /**
   * StudentEnrolledCourseMark findMany
   */
  export type StudentEnrolledCourseMarkFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentEnrolledCourseMark
     */
    select?: StudentEnrolledCourseMarkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentEnrolledCourseMark
     */
    omit?: StudentEnrolledCourseMarkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentEnrolledCourseMarkInclude<ExtArgs> | null
    /**
     * Filter, which StudentEnrolledCourseMarks to fetch.
     */
    where?: StudentEnrolledCourseMarkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentEnrolledCourseMarks to fetch.
     */
    orderBy?: StudentEnrolledCourseMarkOrderByWithRelationInput | StudentEnrolledCourseMarkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StudentEnrolledCourseMarks.
     */
    cursor?: StudentEnrolledCourseMarkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentEnrolledCourseMarks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentEnrolledCourseMarks.
     */
    skip?: number
    distinct?: StudentEnrolledCourseMarkScalarFieldEnum | StudentEnrolledCourseMarkScalarFieldEnum[]
  }

  /**
   * StudentEnrolledCourseMark create
   */
  export type StudentEnrolledCourseMarkCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentEnrolledCourseMark
     */
    select?: StudentEnrolledCourseMarkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentEnrolledCourseMark
     */
    omit?: StudentEnrolledCourseMarkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentEnrolledCourseMarkInclude<ExtArgs> | null
    /**
     * The data needed to create a StudentEnrolledCourseMark.
     */
    data: XOR<StudentEnrolledCourseMarkCreateInput, StudentEnrolledCourseMarkUncheckedCreateInput>
  }

  /**
   * StudentEnrolledCourseMark createMany
   */
  export type StudentEnrolledCourseMarkCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many StudentEnrolledCourseMarks.
     */
    data: StudentEnrolledCourseMarkCreateManyInput | StudentEnrolledCourseMarkCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * StudentEnrolledCourseMark update
   */
  export type StudentEnrolledCourseMarkUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentEnrolledCourseMark
     */
    select?: StudentEnrolledCourseMarkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentEnrolledCourseMark
     */
    omit?: StudentEnrolledCourseMarkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentEnrolledCourseMarkInclude<ExtArgs> | null
    /**
     * The data needed to update a StudentEnrolledCourseMark.
     */
    data: XOR<StudentEnrolledCourseMarkUpdateInput, StudentEnrolledCourseMarkUncheckedUpdateInput>
    /**
     * Choose, which StudentEnrolledCourseMark to update.
     */
    where: StudentEnrolledCourseMarkWhereUniqueInput
  }

  /**
   * StudentEnrolledCourseMark updateMany
   */
  export type StudentEnrolledCourseMarkUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update StudentEnrolledCourseMarks.
     */
    data: XOR<StudentEnrolledCourseMarkUpdateManyMutationInput, StudentEnrolledCourseMarkUncheckedUpdateManyInput>
    /**
     * Filter which StudentEnrolledCourseMarks to update
     */
    where?: StudentEnrolledCourseMarkWhereInput
    /**
     * Limit how many StudentEnrolledCourseMarks to update.
     */
    limit?: number
  }

  /**
   * StudentEnrolledCourseMark upsert
   */
  export type StudentEnrolledCourseMarkUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentEnrolledCourseMark
     */
    select?: StudentEnrolledCourseMarkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentEnrolledCourseMark
     */
    omit?: StudentEnrolledCourseMarkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentEnrolledCourseMarkInclude<ExtArgs> | null
    /**
     * The filter to search for the StudentEnrolledCourseMark to update in case it exists.
     */
    where: StudentEnrolledCourseMarkWhereUniqueInput
    /**
     * In case the StudentEnrolledCourseMark found by the `where` argument doesn't exist, create a new StudentEnrolledCourseMark with this data.
     */
    create: XOR<StudentEnrolledCourseMarkCreateInput, StudentEnrolledCourseMarkUncheckedCreateInput>
    /**
     * In case the StudentEnrolledCourseMark was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StudentEnrolledCourseMarkUpdateInput, StudentEnrolledCourseMarkUncheckedUpdateInput>
  }

  /**
   * StudentEnrolledCourseMark delete
   */
  export type StudentEnrolledCourseMarkDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentEnrolledCourseMark
     */
    select?: StudentEnrolledCourseMarkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentEnrolledCourseMark
     */
    omit?: StudentEnrolledCourseMarkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentEnrolledCourseMarkInclude<ExtArgs> | null
    /**
     * Filter which StudentEnrolledCourseMark to delete.
     */
    where: StudentEnrolledCourseMarkWhereUniqueInput
  }

  /**
   * StudentEnrolledCourseMark deleteMany
   */
  export type StudentEnrolledCourseMarkDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StudentEnrolledCourseMarks to delete
     */
    where?: StudentEnrolledCourseMarkWhereInput
    /**
     * Limit how many StudentEnrolledCourseMarks to delete.
     */
    limit?: number
  }

  /**
   * StudentEnrolledCourseMark without action
   */
  export type StudentEnrolledCourseMarkDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentEnrolledCourseMark
     */
    select?: StudentEnrolledCourseMarkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentEnrolledCourseMark
     */
    omit?: StudentEnrolledCourseMarkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentEnrolledCourseMarkInclude<ExtArgs> | null
  }


  /**
   * Model StudentSemesterPayment
   */

  export type AggregateStudentSemesterPayment = {
    _count: StudentSemesterPaymentCountAggregateOutputType | null
    _avg: StudentSemesterPaymentAvgAggregateOutputType | null
    _sum: StudentSemesterPaymentSumAggregateOutputType | null
    _min: StudentSemesterPaymentMinAggregateOutputType | null
    _max: StudentSemesterPaymentMaxAggregateOutputType | null
  }

  export type StudentSemesterPaymentAvgAggregateOutputType = {
    totalPayment: number | null
    baseAmount: number | null
    lateFee: number | null
    paymentMonth: number | null
    paymentYear: number | null
  }

  export type StudentSemesterPaymentSumAggregateOutputType = {
    totalPayment: number | null
    baseAmount: number | null
    lateFee: number | null
    paymentMonth: number | null
    paymentYear: number | null
  }

  export type StudentSemesterPaymentMinAggregateOutputType = {
    id: string | null
    paymentRecipt: string | null
    totalPayment: number | null
    baseAmount: number | null
    lateFee: number | null
    aprovedPayment: boolean | null
    paymentType: $Enums.PAYMENTTYPE | null
    paymentStatus: $Enums.PaymentStatus | null
    paymentMonth: number | null
    paymentYear: number | null
    createdAt: Date | null
    updatedAt: Date | null
    studentId: string | null
    academicSemesterId: string | null
  }

  export type StudentSemesterPaymentMaxAggregateOutputType = {
    id: string | null
    paymentRecipt: string | null
    totalPayment: number | null
    baseAmount: number | null
    lateFee: number | null
    aprovedPayment: boolean | null
    paymentType: $Enums.PAYMENTTYPE | null
    paymentStatus: $Enums.PaymentStatus | null
    paymentMonth: number | null
    paymentYear: number | null
    createdAt: Date | null
    updatedAt: Date | null
    studentId: string | null
    academicSemesterId: string | null
  }

  export type StudentSemesterPaymentCountAggregateOutputType = {
    id: number
    paymentRecipt: number
    totalPayment: number
    baseAmount: number
    lateFee: number
    aprovedPayment: number
    paymentType: number
    paymentStatus: number
    paymentMonth: number
    paymentYear: number
    createdAt: number
    updatedAt: number
    studentId: number
    academicSemesterId: number
    _all: number
  }


  export type StudentSemesterPaymentAvgAggregateInputType = {
    totalPayment?: true
    baseAmount?: true
    lateFee?: true
    paymentMonth?: true
    paymentYear?: true
  }

  export type StudentSemesterPaymentSumAggregateInputType = {
    totalPayment?: true
    baseAmount?: true
    lateFee?: true
    paymentMonth?: true
    paymentYear?: true
  }

  export type StudentSemesterPaymentMinAggregateInputType = {
    id?: true
    paymentRecipt?: true
    totalPayment?: true
    baseAmount?: true
    lateFee?: true
    aprovedPayment?: true
    paymentType?: true
    paymentStatus?: true
    paymentMonth?: true
    paymentYear?: true
    createdAt?: true
    updatedAt?: true
    studentId?: true
    academicSemesterId?: true
  }

  export type StudentSemesterPaymentMaxAggregateInputType = {
    id?: true
    paymentRecipt?: true
    totalPayment?: true
    baseAmount?: true
    lateFee?: true
    aprovedPayment?: true
    paymentType?: true
    paymentStatus?: true
    paymentMonth?: true
    paymentYear?: true
    createdAt?: true
    updatedAt?: true
    studentId?: true
    academicSemesterId?: true
  }

  export type StudentSemesterPaymentCountAggregateInputType = {
    id?: true
    paymentRecipt?: true
    totalPayment?: true
    baseAmount?: true
    lateFee?: true
    aprovedPayment?: true
    paymentType?: true
    paymentStatus?: true
    paymentMonth?: true
    paymentYear?: true
    createdAt?: true
    updatedAt?: true
    studentId?: true
    academicSemesterId?: true
    _all?: true
  }

  export type StudentSemesterPaymentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StudentSemesterPayment to aggregate.
     */
    where?: StudentSemesterPaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentSemesterPayments to fetch.
     */
    orderBy?: StudentSemesterPaymentOrderByWithRelationInput | StudentSemesterPaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StudentSemesterPaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentSemesterPayments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentSemesterPayments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StudentSemesterPayments
    **/
    _count?: true | StudentSemesterPaymentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StudentSemesterPaymentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StudentSemesterPaymentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StudentSemesterPaymentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StudentSemesterPaymentMaxAggregateInputType
  }

  export type GetStudentSemesterPaymentAggregateType<T extends StudentSemesterPaymentAggregateArgs> = {
        [P in keyof T & keyof AggregateStudentSemesterPayment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStudentSemesterPayment[P]>
      : GetScalarType<T[P], AggregateStudentSemesterPayment[P]>
  }




  export type StudentSemesterPaymentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentSemesterPaymentWhereInput
    orderBy?: StudentSemesterPaymentOrderByWithAggregationInput | StudentSemesterPaymentOrderByWithAggregationInput[]
    by: StudentSemesterPaymentScalarFieldEnum[] | StudentSemesterPaymentScalarFieldEnum
    having?: StudentSemesterPaymentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StudentSemesterPaymentCountAggregateInputType | true
    _avg?: StudentSemesterPaymentAvgAggregateInputType
    _sum?: StudentSemesterPaymentSumAggregateInputType
    _min?: StudentSemesterPaymentMinAggregateInputType
    _max?: StudentSemesterPaymentMaxAggregateInputType
  }

  export type StudentSemesterPaymentGroupByOutputType = {
    id: string
    paymentRecipt: string | null
    totalPayment: number
    baseAmount: number
    lateFee: number
    aprovedPayment: boolean
    paymentType: $Enums.PAYMENTTYPE
    paymentStatus: $Enums.PaymentStatus | null
    paymentMonth: number
    paymentYear: number
    createdAt: Date
    updatedAt: Date
    studentId: string
    academicSemesterId: string
    _count: StudentSemesterPaymentCountAggregateOutputType | null
    _avg: StudentSemesterPaymentAvgAggregateOutputType | null
    _sum: StudentSemesterPaymentSumAggregateOutputType | null
    _min: StudentSemesterPaymentMinAggregateOutputType | null
    _max: StudentSemesterPaymentMaxAggregateOutputType | null
  }

  type GetStudentSemesterPaymentGroupByPayload<T extends StudentSemesterPaymentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StudentSemesterPaymentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StudentSemesterPaymentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StudentSemesterPaymentGroupByOutputType[P]>
            : GetScalarType<T[P], StudentSemesterPaymentGroupByOutputType[P]>
        }
      >
    >


  export type StudentSemesterPaymentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    paymentRecipt?: boolean
    totalPayment?: boolean
    baseAmount?: boolean
    lateFee?: boolean
    aprovedPayment?: boolean
    paymentType?: boolean
    paymentStatus?: boolean
    paymentMonth?: boolean
    paymentYear?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    studentId?: boolean
    academicSemesterId?: boolean
    student?: boolean | StudentDefaultArgs<ExtArgs>
    academicSemester?: boolean | AcademicSemesterDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["studentSemesterPayment"]>



  export type StudentSemesterPaymentSelectScalar = {
    id?: boolean
    paymentRecipt?: boolean
    totalPayment?: boolean
    baseAmount?: boolean
    lateFee?: boolean
    aprovedPayment?: boolean
    paymentType?: boolean
    paymentStatus?: boolean
    paymentMonth?: boolean
    paymentYear?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    studentId?: boolean
    academicSemesterId?: boolean
  }

  export type StudentSemesterPaymentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "paymentRecipt" | "totalPayment" | "baseAmount" | "lateFee" | "aprovedPayment" | "paymentType" | "paymentStatus" | "paymentMonth" | "paymentYear" | "createdAt" | "updatedAt" | "studentId" | "academicSemesterId", ExtArgs["result"]["studentSemesterPayment"]>
  export type StudentSemesterPaymentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentDefaultArgs<ExtArgs>
    academicSemester?: boolean | AcademicSemesterDefaultArgs<ExtArgs>
  }

  export type $StudentSemesterPaymentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "StudentSemesterPayment"
    objects: {
      student: Prisma.$StudentPayload<ExtArgs>
      academicSemester: Prisma.$AcademicSemesterPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      paymentRecipt: string | null
      totalPayment: number
      baseAmount: number
      lateFee: number
      aprovedPayment: boolean
      paymentType: $Enums.PAYMENTTYPE
      paymentStatus: $Enums.PaymentStatus | null
      paymentMonth: number
      paymentYear: number
      createdAt: Date
      updatedAt: Date
      studentId: string
      academicSemesterId: string
    }, ExtArgs["result"]["studentSemesterPayment"]>
    composites: {}
  }

  type StudentSemesterPaymentGetPayload<S extends boolean | null | undefined | StudentSemesterPaymentDefaultArgs> = $Result.GetResult<Prisma.$StudentSemesterPaymentPayload, S>

  type StudentSemesterPaymentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<StudentSemesterPaymentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: StudentSemesterPaymentCountAggregateInputType | true
    }

  export interface StudentSemesterPaymentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['StudentSemesterPayment'], meta: { name: 'StudentSemesterPayment' } }
    /**
     * Find zero or one StudentSemesterPayment that matches the filter.
     * @param {StudentSemesterPaymentFindUniqueArgs} args - Arguments to find a StudentSemesterPayment
     * @example
     * // Get one StudentSemesterPayment
     * const studentSemesterPayment = await prisma.studentSemesterPayment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StudentSemesterPaymentFindUniqueArgs>(args: SelectSubset<T, StudentSemesterPaymentFindUniqueArgs<ExtArgs>>): Prisma__StudentSemesterPaymentClient<$Result.GetResult<Prisma.$StudentSemesterPaymentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one StudentSemesterPayment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {StudentSemesterPaymentFindUniqueOrThrowArgs} args - Arguments to find a StudentSemesterPayment
     * @example
     * // Get one StudentSemesterPayment
     * const studentSemesterPayment = await prisma.studentSemesterPayment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StudentSemesterPaymentFindUniqueOrThrowArgs>(args: SelectSubset<T, StudentSemesterPaymentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StudentSemesterPaymentClient<$Result.GetResult<Prisma.$StudentSemesterPaymentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StudentSemesterPayment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentSemesterPaymentFindFirstArgs} args - Arguments to find a StudentSemesterPayment
     * @example
     * // Get one StudentSemesterPayment
     * const studentSemesterPayment = await prisma.studentSemesterPayment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StudentSemesterPaymentFindFirstArgs>(args?: SelectSubset<T, StudentSemesterPaymentFindFirstArgs<ExtArgs>>): Prisma__StudentSemesterPaymentClient<$Result.GetResult<Prisma.$StudentSemesterPaymentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StudentSemesterPayment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentSemesterPaymentFindFirstOrThrowArgs} args - Arguments to find a StudentSemesterPayment
     * @example
     * // Get one StudentSemesterPayment
     * const studentSemesterPayment = await prisma.studentSemesterPayment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StudentSemesterPaymentFindFirstOrThrowArgs>(args?: SelectSubset<T, StudentSemesterPaymentFindFirstOrThrowArgs<ExtArgs>>): Prisma__StudentSemesterPaymentClient<$Result.GetResult<Prisma.$StudentSemesterPaymentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more StudentSemesterPayments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentSemesterPaymentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StudentSemesterPayments
     * const studentSemesterPayments = await prisma.studentSemesterPayment.findMany()
     * 
     * // Get first 10 StudentSemesterPayments
     * const studentSemesterPayments = await prisma.studentSemesterPayment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const studentSemesterPaymentWithIdOnly = await prisma.studentSemesterPayment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StudentSemesterPaymentFindManyArgs>(args?: SelectSubset<T, StudentSemesterPaymentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentSemesterPaymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a StudentSemesterPayment.
     * @param {StudentSemesterPaymentCreateArgs} args - Arguments to create a StudentSemesterPayment.
     * @example
     * // Create one StudentSemesterPayment
     * const StudentSemesterPayment = await prisma.studentSemesterPayment.create({
     *   data: {
     *     // ... data to create a StudentSemesterPayment
     *   }
     * })
     * 
     */
    create<T extends StudentSemesterPaymentCreateArgs>(args: SelectSubset<T, StudentSemesterPaymentCreateArgs<ExtArgs>>): Prisma__StudentSemesterPaymentClient<$Result.GetResult<Prisma.$StudentSemesterPaymentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many StudentSemesterPayments.
     * @param {StudentSemesterPaymentCreateManyArgs} args - Arguments to create many StudentSemesterPayments.
     * @example
     * // Create many StudentSemesterPayments
     * const studentSemesterPayment = await prisma.studentSemesterPayment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StudentSemesterPaymentCreateManyArgs>(args?: SelectSubset<T, StudentSemesterPaymentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a StudentSemesterPayment.
     * @param {StudentSemesterPaymentDeleteArgs} args - Arguments to delete one StudentSemesterPayment.
     * @example
     * // Delete one StudentSemesterPayment
     * const StudentSemesterPayment = await prisma.studentSemesterPayment.delete({
     *   where: {
     *     // ... filter to delete one StudentSemesterPayment
     *   }
     * })
     * 
     */
    delete<T extends StudentSemesterPaymentDeleteArgs>(args: SelectSubset<T, StudentSemesterPaymentDeleteArgs<ExtArgs>>): Prisma__StudentSemesterPaymentClient<$Result.GetResult<Prisma.$StudentSemesterPaymentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one StudentSemesterPayment.
     * @param {StudentSemesterPaymentUpdateArgs} args - Arguments to update one StudentSemesterPayment.
     * @example
     * // Update one StudentSemesterPayment
     * const studentSemesterPayment = await prisma.studentSemesterPayment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StudentSemesterPaymentUpdateArgs>(args: SelectSubset<T, StudentSemesterPaymentUpdateArgs<ExtArgs>>): Prisma__StudentSemesterPaymentClient<$Result.GetResult<Prisma.$StudentSemesterPaymentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more StudentSemesterPayments.
     * @param {StudentSemesterPaymentDeleteManyArgs} args - Arguments to filter StudentSemesterPayments to delete.
     * @example
     * // Delete a few StudentSemesterPayments
     * const { count } = await prisma.studentSemesterPayment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StudentSemesterPaymentDeleteManyArgs>(args?: SelectSubset<T, StudentSemesterPaymentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StudentSemesterPayments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentSemesterPaymentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StudentSemesterPayments
     * const studentSemesterPayment = await prisma.studentSemesterPayment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StudentSemesterPaymentUpdateManyArgs>(args: SelectSubset<T, StudentSemesterPaymentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one StudentSemesterPayment.
     * @param {StudentSemesterPaymentUpsertArgs} args - Arguments to update or create a StudentSemesterPayment.
     * @example
     * // Update or create a StudentSemesterPayment
     * const studentSemesterPayment = await prisma.studentSemesterPayment.upsert({
     *   create: {
     *     // ... data to create a StudentSemesterPayment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StudentSemesterPayment we want to update
     *   }
     * })
     */
    upsert<T extends StudentSemesterPaymentUpsertArgs>(args: SelectSubset<T, StudentSemesterPaymentUpsertArgs<ExtArgs>>): Prisma__StudentSemesterPaymentClient<$Result.GetResult<Prisma.$StudentSemesterPaymentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of StudentSemesterPayments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentSemesterPaymentCountArgs} args - Arguments to filter StudentSemesterPayments to count.
     * @example
     * // Count the number of StudentSemesterPayments
     * const count = await prisma.studentSemesterPayment.count({
     *   where: {
     *     // ... the filter for the StudentSemesterPayments we want to count
     *   }
     * })
    **/
    count<T extends StudentSemesterPaymentCountArgs>(
      args?: Subset<T, StudentSemesterPaymentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StudentSemesterPaymentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StudentSemesterPayment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentSemesterPaymentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StudentSemesterPaymentAggregateArgs>(args: Subset<T, StudentSemesterPaymentAggregateArgs>): Prisma.PrismaPromise<GetStudentSemesterPaymentAggregateType<T>>

    /**
     * Group by StudentSemesterPayment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentSemesterPaymentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StudentSemesterPaymentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StudentSemesterPaymentGroupByArgs['orderBy'] }
        : { orderBy?: StudentSemesterPaymentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StudentSemesterPaymentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStudentSemesterPaymentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the StudentSemesterPayment model
   */
  readonly fields: StudentSemesterPaymentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for StudentSemesterPayment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StudentSemesterPaymentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    student<T extends StudentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StudentDefaultArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    academicSemester<T extends AcademicSemesterDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AcademicSemesterDefaultArgs<ExtArgs>>): Prisma__AcademicSemesterClient<$Result.GetResult<Prisma.$AcademicSemesterPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the StudentSemesterPayment model
   */
  interface StudentSemesterPaymentFieldRefs {
    readonly id: FieldRef<"StudentSemesterPayment", 'String'>
    readonly paymentRecipt: FieldRef<"StudentSemesterPayment", 'String'>
    readonly totalPayment: FieldRef<"StudentSemesterPayment", 'Int'>
    readonly baseAmount: FieldRef<"StudentSemesterPayment", 'Int'>
    readonly lateFee: FieldRef<"StudentSemesterPayment", 'Int'>
    readonly aprovedPayment: FieldRef<"StudentSemesterPayment", 'Boolean'>
    readonly paymentType: FieldRef<"StudentSemesterPayment", 'PAYMENTTYPE'>
    readonly paymentStatus: FieldRef<"StudentSemesterPayment", 'PaymentStatus'>
    readonly paymentMonth: FieldRef<"StudentSemesterPayment", 'Int'>
    readonly paymentYear: FieldRef<"StudentSemesterPayment", 'Int'>
    readonly createdAt: FieldRef<"StudentSemesterPayment", 'DateTime'>
    readonly updatedAt: FieldRef<"StudentSemesterPayment", 'DateTime'>
    readonly studentId: FieldRef<"StudentSemesterPayment", 'String'>
    readonly academicSemesterId: FieldRef<"StudentSemesterPayment", 'String'>
  }
    

  // Custom InputTypes
  /**
   * StudentSemesterPayment findUnique
   */
  export type StudentSemesterPaymentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentSemesterPayment
     */
    select?: StudentSemesterPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentSemesterPayment
     */
    omit?: StudentSemesterPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentSemesterPaymentInclude<ExtArgs> | null
    /**
     * Filter, which StudentSemesterPayment to fetch.
     */
    where: StudentSemesterPaymentWhereUniqueInput
  }

  /**
   * StudentSemesterPayment findUniqueOrThrow
   */
  export type StudentSemesterPaymentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentSemesterPayment
     */
    select?: StudentSemesterPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentSemesterPayment
     */
    omit?: StudentSemesterPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentSemesterPaymentInclude<ExtArgs> | null
    /**
     * Filter, which StudentSemesterPayment to fetch.
     */
    where: StudentSemesterPaymentWhereUniqueInput
  }

  /**
   * StudentSemesterPayment findFirst
   */
  export type StudentSemesterPaymentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentSemesterPayment
     */
    select?: StudentSemesterPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentSemesterPayment
     */
    omit?: StudentSemesterPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentSemesterPaymentInclude<ExtArgs> | null
    /**
     * Filter, which StudentSemesterPayment to fetch.
     */
    where?: StudentSemesterPaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentSemesterPayments to fetch.
     */
    orderBy?: StudentSemesterPaymentOrderByWithRelationInput | StudentSemesterPaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StudentSemesterPayments.
     */
    cursor?: StudentSemesterPaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentSemesterPayments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentSemesterPayments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StudentSemesterPayments.
     */
    distinct?: StudentSemesterPaymentScalarFieldEnum | StudentSemesterPaymentScalarFieldEnum[]
  }

  /**
   * StudentSemesterPayment findFirstOrThrow
   */
  export type StudentSemesterPaymentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentSemesterPayment
     */
    select?: StudentSemesterPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentSemesterPayment
     */
    omit?: StudentSemesterPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentSemesterPaymentInclude<ExtArgs> | null
    /**
     * Filter, which StudentSemesterPayment to fetch.
     */
    where?: StudentSemesterPaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentSemesterPayments to fetch.
     */
    orderBy?: StudentSemesterPaymentOrderByWithRelationInput | StudentSemesterPaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StudentSemesterPayments.
     */
    cursor?: StudentSemesterPaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentSemesterPayments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentSemesterPayments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StudentSemesterPayments.
     */
    distinct?: StudentSemesterPaymentScalarFieldEnum | StudentSemesterPaymentScalarFieldEnum[]
  }

  /**
   * StudentSemesterPayment findMany
   */
  export type StudentSemesterPaymentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentSemesterPayment
     */
    select?: StudentSemesterPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentSemesterPayment
     */
    omit?: StudentSemesterPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentSemesterPaymentInclude<ExtArgs> | null
    /**
     * Filter, which StudentSemesterPayments to fetch.
     */
    where?: StudentSemesterPaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentSemesterPayments to fetch.
     */
    orderBy?: StudentSemesterPaymentOrderByWithRelationInput | StudentSemesterPaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StudentSemesterPayments.
     */
    cursor?: StudentSemesterPaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentSemesterPayments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentSemesterPayments.
     */
    skip?: number
    distinct?: StudentSemesterPaymentScalarFieldEnum | StudentSemesterPaymentScalarFieldEnum[]
  }

  /**
   * StudentSemesterPayment create
   */
  export type StudentSemesterPaymentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentSemesterPayment
     */
    select?: StudentSemesterPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentSemesterPayment
     */
    omit?: StudentSemesterPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentSemesterPaymentInclude<ExtArgs> | null
    /**
     * The data needed to create a StudentSemesterPayment.
     */
    data: XOR<StudentSemesterPaymentCreateInput, StudentSemesterPaymentUncheckedCreateInput>
  }

  /**
   * StudentSemesterPayment createMany
   */
  export type StudentSemesterPaymentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many StudentSemesterPayments.
     */
    data: StudentSemesterPaymentCreateManyInput | StudentSemesterPaymentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * StudentSemesterPayment update
   */
  export type StudentSemesterPaymentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentSemesterPayment
     */
    select?: StudentSemesterPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentSemesterPayment
     */
    omit?: StudentSemesterPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentSemesterPaymentInclude<ExtArgs> | null
    /**
     * The data needed to update a StudentSemesterPayment.
     */
    data: XOR<StudentSemesterPaymentUpdateInput, StudentSemesterPaymentUncheckedUpdateInput>
    /**
     * Choose, which StudentSemesterPayment to update.
     */
    where: StudentSemesterPaymentWhereUniqueInput
  }

  /**
   * StudentSemesterPayment updateMany
   */
  export type StudentSemesterPaymentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update StudentSemesterPayments.
     */
    data: XOR<StudentSemesterPaymentUpdateManyMutationInput, StudentSemesterPaymentUncheckedUpdateManyInput>
    /**
     * Filter which StudentSemesterPayments to update
     */
    where?: StudentSemesterPaymentWhereInput
    /**
     * Limit how many StudentSemesterPayments to update.
     */
    limit?: number
  }

  /**
   * StudentSemesterPayment upsert
   */
  export type StudentSemesterPaymentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentSemesterPayment
     */
    select?: StudentSemesterPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentSemesterPayment
     */
    omit?: StudentSemesterPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentSemesterPaymentInclude<ExtArgs> | null
    /**
     * The filter to search for the StudentSemesterPayment to update in case it exists.
     */
    where: StudentSemesterPaymentWhereUniqueInput
    /**
     * In case the StudentSemesterPayment found by the `where` argument doesn't exist, create a new StudentSemesterPayment with this data.
     */
    create: XOR<StudentSemesterPaymentCreateInput, StudentSemesterPaymentUncheckedCreateInput>
    /**
     * In case the StudentSemesterPayment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StudentSemesterPaymentUpdateInput, StudentSemesterPaymentUncheckedUpdateInput>
  }

  /**
   * StudentSemesterPayment delete
   */
  export type StudentSemesterPaymentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentSemesterPayment
     */
    select?: StudentSemesterPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentSemesterPayment
     */
    omit?: StudentSemesterPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentSemesterPaymentInclude<ExtArgs> | null
    /**
     * Filter which StudentSemesterPayment to delete.
     */
    where: StudentSemesterPaymentWhereUniqueInput
  }

  /**
   * StudentSemesterPayment deleteMany
   */
  export type StudentSemesterPaymentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StudentSemesterPayments to delete
     */
    where?: StudentSemesterPaymentWhereInput
    /**
     * Limit how many StudentSemesterPayments to delete.
     */
    limit?: number
  }

  /**
   * StudentSemesterPayment without action
   */
  export type StudentSemesterPaymentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentSemesterPayment
     */
    select?: StudentSemesterPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentSemesterPayment
     */
    omit?: StudentSemesterPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentSemesterPaymentInclude<ExtArgs> | null
  }


  /**
   * Model StudentAcademicInfo
   */

  export type AggregateStudentAcademicInfo = {
    _count: StudentAcademicInfoCountAggregateOutputType | null
    _avg: StudentAcademicInfoAvgAggregateOutputType | null
    _sum: StudentAcademicInfoSumAggregateOutputType | null
    _min: StudentAcademicInfoMinAggregateOutputType | null
    _max: StudentAcademicInfoMaxAggregateOutputType | null
  }

  export type StudentAcademicInfoAvgAggregateOutputType = {
    totalCompletedCredits: number | null
    cgpa: number | null
  }

  export type StudentAcademicInfoSumAggregateOutputType = {
    totalCompletedCredits: number | null
    cgpa: number | null
  }

  export type StudentAcademicInfoMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    studentId: string | null
    totalCompletedCredits: number | null
    cgpa: number | null
  }

  export type StudentAcademicInfoMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    studentId: string | null
    totalCompletedCredits: number | null
    cgpa: number | null
  }

  export type StudentAcademicInfoCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    studentId: number
    totalCompletedCredits: number
    cgpa: number
    _all: number
  }


  export type StudentAcademicInfoAvgAggregateInputType = {
    totalCompletedCredits?: true
    cgpa?: true
  }

  export type StudentAcademicInfoSumAggregateInputType = {
    totalCompletedCredits?: true
    cgpa?: true
  }

  export type StudentAcademicInfoMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    studentId?: true
    totalCompletedCredits?: true
    cgpa?: true
  }

  export type StudentAcademicInfoMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    studentId?: true
    totalCompletedCredits?: true
    cgpa?: true
  }

  export type StudentAcademicInfoCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    studentId?: true
    totalCompletedCredits?: true
    cgpa?: true
    _all?: true
  }

  export type StudentAcademicInfoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StudentAcademicInfo to aggregate.
     */
    where?: StudentAcademicInfoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentAcademicInfos to fetch.
     */
    orderBy?: StudentAcademicInfoOrderByWithRelationInput | StudentAcademicInfoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StudentAcademicInfoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentAcademicInfos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentAcademicInfos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StudentAcademicInfos
    **/
    _count?: true | StudentAcademicInfoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StudentAcademicInfoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StudentAcademicInfoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StudentAcademicInfoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StudentAcademicInfoMaxAggregateInputType
  }

  export type GetStudentAcademicInfoAggregateType<T extends StudentAcademicInfoAggregateArgs> = {
        [P in keyof T & keyof AggregateStudentAcademicInfo]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStudentAcademicInfo[P]>
      : GetScalarType<T[P], AggregateStudentAcademicInfo[P]>
  }




  export type StudentAcademicInfoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentAcademicInfoWhereInput
    orderBy?: StudentAcademicInfoOrderByWithAggregationInput | StudentAcademicInfoOrderByWithAggregationInput[]
    by: StudentAcademicInfoScalarFieldEnum[] | StudentAcademicInfoScalarFieldEnum
    having?: StudentAcademicInfoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StudentAcademicInfoCountAggregateInputType | true
    _avg?: StudentAcademicInfoAvgAggregateInputType
    _sum?: StudentAcademicInfoSumAggregateInputType
    _min?: StudentAcademicInfoMinAggregateInputType
    _max?: StudentAcademicInfoMaxAggregateInputType
  }

  export type StudentAcademicInfoGroupByOutputType = {
    id: string
    createdAt: Date
    updatedAt: Date
    studentId: string
    totalCompletedCredits: number | null
    cgpa: number | null
    _count: StudentAcademicInfoCountAggregateOutputType | null
    _avg: StudentAcademicInfoAvgAggregateOutputType | null
    _sum: StudentAcademicInfoSumAggregateOutputType | null
    _min: StudentAcademicInfoMinAggregateOutputType | null
    _max: StudentAcademicInfoMaxAggregateOutputType | null
  }

  type GetStudentAcademicInfoGroupByPayload<T extends StudentAcademicInfoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StudentAcademicInfoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StudentAcademicInfoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StudentAcademicInfoGroupByOutputType[P]>
            : GetScalarType<T[P], StudentAcademicInfoGroupByOutputType[P]>
        }
      >
    >


  export type StudentAcademicInfoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    studentId?: boolean
    totalCompletedCredits?: boolean
    cgpa?: boolean
    student?: boolean | StudentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["studentAcademicInfo"]>



  export type StudentAcademicInfoSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    studentId?: boolean
    totalCompletedCredits?: boolean
    cgpa?: boolean
  }

  export type StudentAcademicInfoOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "createdAt" | "updatedAt" | "studentId" | "totalCompletedCredits" | "cgpa", ExtArgs["result"]["studentAcademicInfo"]>
  export type StudentAcademicInfoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentDefaultArgs<ExtArgs>
  }

  export type $StudentAcademicInfoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "StudentAcademicInfo"
    objects: {
      student: Prisma.$StudentPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      createdAt: Date
      updatedAt: Date
      studentId: string
      totalCompletedCredits: number | null
      cgpa: number | null
    }, ExtArgs["result"]["studentAcademicInfo"]>
    composites: {}
  }

  type StudentAcademicInfoGetPayload<S extends boolean | null | undefined | StudentAcademicInfoDefaultArgs> = $Result.GetResult<Prisma.$StudentAcademicInfoPayload, S>

  type StudentAcademicInfoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<StudentAcademicInfoFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: StudentAcademicInfoCountAggregateInputType | true
    }

  export interface StudentAcademicInfoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['StudentAcademicInfo'], meta: { name: 'StudentAcademicInfo' } }
    /**
     * Find zero or one StudentAcademicInfo that matches the filter.
     * @param {StudentAcademicInfoFindUniqueArgs} args - Arguments to find a StudentAcademicInfo
     * @example
     * // Get one StudentAcademicInfo
     * const studentAcademicInfo = await prisma.studentAcademicInfo.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StudentAcademicInfoFindUniqueArgs>(args: SelectSubset<T, StudentAcademicInfoFindUniqueArgs<ExtArgs>>): Prisma__StudentAcademicInfoClient<$Result.GetResult<Prisma.$StudentAcademicInfoPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one StudentAcademicInfo that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {StudentAcademicInfoFindUniqueOrThrowArgs} args - Arguments to find a StudentAcademicInfo
     * @example
     * // Get one StudentAcademicInfo
     * const studentAcademicInfo = await prisma.studentAcademicInfo.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StudentAcademicInfoFindUniqueOrThrowArgs>(args: SelectSubset<T, StudentAcademicInfoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StudentAcademicInfoClient<$Result.GetResult<Prisma.$StudentAcademicInfoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StudentAcademicInfo that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentAcademicInfoFindFirstArgs} args - Arguments to find a StudentAcademicInfo
     * @example
     * // Get one StudentAcademicInfo
     * const studentAcademicInfo = await prisma.studentAcademicInfo.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StudentAcademicInfoFindFirstArgs>(args?: SelectSubset<T, StudentAcademicInfoFindFirstArgs<ExtArgs>>): Prisma__StudentAcademicInfoClient<$Result.GetResult<Prisma.$StudentAcademicInfoPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StudentAcademicInfo that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentAcademicInfoFindFirstOrThrowArgs} args - Arguments to find a StudentAcademicInfo
     * @example
     * // Get one StudentAcademicInfo
     * const studentAcademicInfo = await prisma.studentAcademicInfo.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StudentAcademicInfoFindFirstOrThrowArgs>(args?: SelectSubset<T, StudentAcademicInfoFindFirstOrThrowArgs<ExtArgs>>): Prisma__StudentAcademicInfoClient<$Result.GetResult<Prisma.$StudentAcademicInfoPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more StudentAcademicInfos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentAcademicInfoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StudentAcademicInfos
     * const studentAcademicInfos = await prisma.studentAcademicInfo.findMany()
     * 
     * // Get first 10 StudentAcademicInfos
     * const studentAcademicInfos = await prisma.studentAcademicInfo.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const studentAcademicInfoWithIdOnly = await prisma.studentAcademicInfo.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StudentAcademicInfoFindManyArgs>(args?: SelectSubset<T, StudentAcademicInfoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentAcademicInfoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a StudentAcademicInfo.
     * @param {StudentAcademicInfoCreateArgs} args - Arguments to create a StudentAcademicInfo.
     * @example
     * // Create one StudentAcademicInfo
     * const StudentAcademicInfo = await prisma.studentAcademicInfo.create({
     *   data: {
     *     // ... data to create a StudentAcademicInfo
     *   }
     * })
     * 
     */
    create<T extends StudentAcademicInfoCreateArgs>(args: SelectSubset<T, StudentAcademicInfoCreateArgs<ExtArgs>>): Prisma__StudentAcademicInfoClient<$Result.GetResult<Prisma.$StudentAcademicInfoPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many StudentAcademicInfos.
     * @param {StudentAcademicInfoCreateManyArgs} args - Arguments to create many StudentAcademicInfos.
     * @example
     * // Create many StudentAcademicInfos
     * const studentAcademicInfo = await prisma.studentAcademicInfo.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StudentAcademicInfoCreateManyArgs>(args?: SelectSubset<T, StudentAcademicInfoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a StudentAcademicInfo.
     * @param {StudentAcademicInfoDeleteArgs} args - Arguments to delete one StudentAcademicInfo.
     * @example
     * // Delete one StudentAcademicInfo
     * const StudentAcademicInfo = await prisma.studentAcademicInfo.delete({
     *   where: {
     *     // ... filter to delete one StudentAcademicInfo
     *   }
     * })
     * 
     */
    delete<T extends StudentAcademicInfoDeleteArgs>(args: SelectSubset<T, StudentAcademicInfoDeleteArgs<ExtArgs>>): Prisma__StudentAcademicInfoClient<$Result.GetResult<Prisma.$StudentAcademicInfoPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one StudentAcademicInfo.
     * @param {StudentAcademicInfoUpdateArgs} args - Arguments to update one StudentAcademicInfo.
     * @example
     * // Update one StudentAcademicInfo
     * const studentAcademicInfo = await prisma.studentAcademicInfo.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StudentAcademicInfoUpdateArgs>(args: SelectSubset<T, StudentAcademicInfoUpdateArgs<ExtArgs>>): Prisma__StudentAcademicInfoClient<$Result.GetResult<Prisma.$StudentAcademicInfoPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more StudentAcademicInfos.
     * @param {StudentAcademicInfoDeleteManyArgs} args - Arguments to filter StudentAcademicInfos to delete.
     * @example
     * // Delete a few StudentAcademicInfos
     * const { count } = await prisma.studentAcademicInfo.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StudentAcademicInfoDeleteManyArgs>(args?: SelectSubset<T, StudentAcademicInfoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StudentAcademicInfos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentAcademicInfoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StudentAcademicInfos
     * const studentAcademicInfo = await prisma.studentAcademicInfo.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StudentAcademicInfoUpdateManyArgs>(args: SelectSubset<T, StudentAcademicInfoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one StudentAcademicInfo.
     * @param {StudentAcademicInfoUpsertArgs} args - Arguments to update or create a StudentAcademicInfo.
     * @example
     * // Update or create a StudentAcademicInfo
     * const studentAcademicInfo = await prisma.studentAcademicInfo.upsert({
     *   create: {
     *     // ... data to create a StudentAcademicInfo
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StudentAcademicInfo we want to update
     *   }
     * })
     */
    upsert<T extends StudentAcademicInfoUpsertArgs>(args: SelectSubset<T, StudentAcademicInfoUpsertArgs<ExtArgs>>): Prisma__StudentAcademicInfoClient<$Result.GetResult<Prisma.$StudentAcademicInfoPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of StudentAcademicInfos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentAcademicInfoCountArgs} args - Arguments to filter StudentAcademicInfos to count.
     * @example
     * // Count the number of StudentAcademicInfos
     * const count = await prisma.studentAcademicInfo.count({
     *   where: {
     *     // ... the filter for the StudentAcademicInfos we want to count
     *   }
     * })
    **/
    count<T extends StudentAcademicInfoCountArgs>(
      args?: Subset<T, StudentAcademicInfoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StudentAcademicInfoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StudentAcademicInfo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentAcademicInfoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StudentAcademicInfoAggregateArgs>(args: Subset<T, StudentAcademicInfoAggregateArgs>): Prisma.PrismaPromise<GetStudentAcademicInfoAggregateType<T>>

    /**
     * Group by StudentAcademicInfo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentAcademicInfoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StudentAcademicInfoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StudentAcademicInfoGroupByArgs['orderBy'] }
        : { orderBy?: StudentAcademicInfoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StudentAcademicInfoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStudentAcademicInfoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the StudentAcademicInfo model
   */
  readonly fields: StudentAcademicInfoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for StudentAcademicInfo.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StudentAcademicInfoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    student<T extends StudentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StudentDefaultArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the StudentAcademicInfo model
   */
  interface StudentAcademicInfoFieldRefs {
    readonly id: FieldRef<"StudentAcademicInfo", 'String'>
    readonly createdAt: FieldRef<"StudentAcademicInfo", 'DateTime'>
    readonly updatedAt: FieldRef<"StudentAcademicInfo", 'DateTime'>
    readonly studentId: FieldRef<"StudentAcademicInfo", 'String'>
    readonly totalCompletedCredits: FieldRef<"StudentAcademicInfo", 'Int'>
    readonly cgpa: FieldRef<"StudentAcademicInfo", 'Float'>
  }
    

  // Custom InputTypes
  /**
   * StudentAcademicInfo findUnique
   */
  export type StudentAcademicInfoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentAcademicInfo
     */
    select?: StudentAcademicInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentAcademicInfo
     */
    omit?: StudentAcademicInfoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentAcademicInfoInclude<ExtArgs> | null
    /**
     * Filter, which StudentAcademicInfo to fetch.
     */
    where: StudentAcademicInfoWhereUniqueInput
  }

  /**
   * StudentAcademicInfo findUniqueOrThrow
   */
  export type StudentAcademicInfoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentAcademicInfo
     */
    select?: StudentAcademicInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentAcademicInfo
     */
    omit?: StudentAcademicInfoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentAcademicInfoInclude<ExtArgs> | null
    /**
     * Filter, which StudentAcademicInfo to fetch.
     */
    where: StudentAcademicInfoWhereUniqueInput
  }

  /**
   * StudentAcademicInfo findFirst
   */
  export type StudentAcademicInfoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentAcademicInfo
     */
    select?: StudentAcademicInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentAcademicInfo
     */
    omit?: StudentAcademicInfoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentAcademicInfoInclude<ExtArgs> | null
    /**
     * Filter, which StudentAcademicInfo to fetch.
     */
    where?: StudentAcademicInfoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentAcademicInfos to fetch.
     */
    orderBy?: StudentAcademicInfoOrderByWithRelationInput | StudentAcademicInfoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StudentAcademicInfos.
     */
    cursor?: StudentAcademicInfoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentAcademicInfos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentAcademicInfos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StudentAcademicInfos.
     */
    distinct?: StudentAcademicInfoScalarFieldEnum | StudentAcademicInfoScalarFieldEnum[]
  }

  /**
   * StudentAcademicInfo findFirstOrThrow
   */
  export type StudentAcademicInfoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentAcademicInfo
     */
    select?: StudentAcademicInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentAcademicInfo
     */
    omit?: StudentAcademicInfoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentAcademicInfoInclude<ExtArgs> | null
    /**
     * Filter, which StudentAcademicInfo to fetch.
     */
    where?: StudentAcademicInfoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentAcademicInfos to fetch.
     */
    orderBy?: StudentAcademicInfoOrderByWithRelationInput | StudentAcademicInfoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StudentAcademicInfos.
     */
    cursor?: StudentAcademicInfoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentAcademicInfos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentAcademicInfos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StudentAcademicInfos.
     */
    distinct?: StudentAcademicInfoScalarFieldEnum | StudentAcademicInfoScalarFieldEnum[]
  }

  /**
   * StudentAcademicInfo findMany
   */
  export type StudentAcademicInfoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentAcademicInfo
     */
    select?: StudentAcademicInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentAcademicInfo
     */
    omit?: StudentAcademicInfoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentAcademicInfoInclude<ExtArgs> | null
    /**
     * Filter, which StudentAcademicInfos to fetch.
     */
    where?: StudentAcademicInfoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentAcademicInfos to fetch.
     */
    orderBy?: StudentAcademicInfoOrderByWithRelationInput | StudentAcademicInfoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StudentAcademicInfos.
     */
    cursor?: StudentAcademicInfoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentAcademicInfos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentAcademicInfos.
     */
    skip?: number
    distinct?: StudentAcademicInfoScalarFieldEnum | StudentAcademicInfoScalarFieldEnum[]
  }

  /**
   * StudentAcademicInfo create
   */
  export type StudentAcademicInfoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentAcademicInfo
     */
    select?: StudentAcademicInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentAcademicInfo
     */
    omit?: StudentAcademicInfoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentAcademicInfoInclude<ExtArgs> | null
    /**
     * The data needed to create a StudentAcademicInfo.
     */
    data: XOR<StudentAcademicInfoCreateInput, StudentAcademicInfoUncheckedCreateInput>
  }

  /**
   * StudentAcademicInfo createMany
   */
  export type StudentAcademicInfoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many StudentAcademicInfos.
     */
    data: StudentAcademicInfoCreateManyInput | StudentAcademicInfoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * StudentAcademicInfo update
   */
  export type StudentAcademicInfoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentAcademicInfo
     */
    select?: StudentAcademicInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentAcademicInfo
     */
    omit?: StudentAcademicInfoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentAcademicInfoInclude<ExtArgs> | null
    /**
     * The data needed to update a StudentAcademicInfo.
     */
    data: XOR<StudentAcademicInfoUpdateInput, StudentAcademicInfoUncheckedUpdateInput>
    /**
     * Choose, which StudentAcademicInfo to update.
     */
    where: StudentAcademicInfoWhereUniqueInput
  }

  /**
   * StudentAcademicInfo updateMany
   */
  export type StudentAcademicInfoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update StudentAcademicInfos.
     */
    data: XOR<StudentAcademicInfoUpdateManyMutationInput, StudentAcademicInfoUncheckedUpdateManyInput>
    /**
     * Filter which StudentAcademicInfos to update
     */
    where?: StudentAcademicInfoWhereInput
    /**
     * Limit how many StudentAcademicInfos to update.
     */
    limit?: number
  }

  /**
   * StudentAcademicInfo upsert
   */
  export type StudentAcademicInfoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentAcademicInfo
     */
    select?: StudentAcademicInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentAcademicInfo
     */
    omit?: StudentAcademicInfoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentAcademicInfoInclude<ExtArgs> | null
    /**
     * The filter to search for the StudentAcademicInfo to update in case it exists.
     */
    where: StudentAcademicInfoWhereUniqueInput
    /**
     * In case the StudentAcademicInfo found by the `where` argument doesn't exist, create a new StudentAcademicInfo with this data.
     */
    create: XOR<StudentAcademicInfoCreateInput, StudentAcademicInfoUncheckedCreateInput>
    /**
     * In case the StudentAcademicInfo was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StudentAcademicInfoUpdateInput, StudentAcademicInfoUncheckedUpdateInput>
  }

  /**
   * StudentAcademicInfo delete
   */
  export type StudentAcademicInfoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentAcademicInfo
     */
    select?: StudentAcademicInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentAcademicInfo
     */
    omit?: StudentAcademicInfoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentAcademicInfoInclude<ExtArgs> | null
    /**
     * Filter which StudentAcademicInfo to delete.
     */
    where: StudentAcademicInfoWhereUniqueInput
  }

  /**
   * StudentAcademicInfo deleteMany
   */
  export type StudentAcademicInfoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StudentAcademicInfos to delete
     */
    where?: StudentAcademicInfoWhereInput
    /**
     * Limit how many StudentAcademicInfos to delete.
     */
    limit?: number
  }

  /**
   * StudentAcademicInfo without action
   */
  export type StudentAcademicInfoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentAcademicInfo
     */
    select?: StudentAcademicInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentAcademicInfo
     */
    omit?: StudentAcademicInfoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentAcademicInfoInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UsersScalarFieldEnum: {
    id: 'id',
    name: 'name',
    email: 'email',
    password: 'password',
    avatar: 'avatar',
    role: 'role',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UsersScalarFieldEnum = (typeof UsersScalarFieldEnum)[keyof typeof UsersScalarFieldEnum]


  export const AcademicSemesterScalarFieldEnum: {
    id: 'id',
    title: 'title',
    year: 'year',
    code: 'code',
    startMonth: 'startMonth',
    endMonth: 'endMonth',
    isCurrent: 'isCurrent',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AcademicSemesterScalarFieldEnum = (typeof AcademicSemesterScalarFieldEnum)[keyof typeof AcademicSemesterScalarFieldEnum]


  export const AcademicFacultyScalarFieldEnum: {
    id: 'id',
    title: 'title',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AcademicFacultyScalarFieldEnum = (typeof AcademicFacultyScalarFieldEnum)[keyof typeof AcademicFacultyScalarFieldEnum]


  export const AcademicDepartmentScalarFieldEnum: {
    id: 'id',
    title: 'title',
    academicFacultyId: 'academicFacultyId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    departmentHeadId: 'departmentHeadId'
  };

  export type AcademicDepartmentScalarFieldEnum = (typeof AcademicDepartmentScalarFieldEnum)[keyof typeof AcademicDepartmentScalarFieldEnum]


  export const StudentScalarFieldEnum: {
    id: 'id',
    studentId: 'studentId',
    firstName: 'firstName',
    middleName: 'middleName',
    lastName: 'lastName',
    profileImage: 'profileImage',
    email: 'email',
    contactNo: 'contactNo',
    gender: 'gender',
    isWoker: 'isWoker',
    shift: 'shift',
    password: 'password',
    gradeDeclarationFile: 'gradeDeclarationFile',
    biFile: 'biFile',
    presentAddress: 'presentAddress',
    permanentAddress: 'permanentAddress',
    academicSemesterId: 'academicSemesterId',
    academicFacultyId: 'academicFacultyId',
    academicDepartmentId: 'academicDepartmentId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    admissionRegistrationId: 'admissionRegistrationId'
  };

  export type StudentScalarFieldEnum = (typeof StudentScalarFieldEnum)[keyof typeof StudentScalarFieldEnum]


  export const FacultyScalarFieldEnum: {
    id: 'id',
    facultyId: 'facultyId',
    firstName: 'firstName',
    middleName: 'middleName',
    lastName: 'lastName',
    profileImage: 'profileImage',
    email: 'email',
    contactNo: 'contactNo',
    gender: 'gender',
    designation: 'designation',
    password: 'password',
    academicFacultyId: 'academicFacultyId',
    academicDepartmentId: 'academicDepartmentId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type FacultyScalarFieldEnum = (typeof FacultyScalarFieldEnum)[keyof typeof FacultyScalarFieldEnum]


  export const BuildingScalarFieldEnum: {
    id: 'id',
    title: 'title',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BuildingScalarFieldEnum = (typeof BuildingScalarFieldEnum)[keyof typeof BuildingScalarFieldEnum]


  export const RoomScalarFieldEnum: {
    id: 'id',
    roomNumber: 'roomNumber',
    floor: 'floor',
    buildingId: 'buildingId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type RoomScalarFieldEnum = (typeof RoomScalarFieldEnum)[keyof typeof RoomScalarFieldEnum]


  export const CourseScalarFieldEnum: {
    id: 'id',
    title: 'title',
    code: 'code',
    credits: 'credits',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CourseScalarFieldEnum = (typeof CourseScalarFieldEnum)[keyof typeof CourseScalarFieldEnum]


  export const CourseToPreRequisiteScalarFieldEnum: {
    courseId: 'courseId',
    preRequisiteId: 'preRequisiteId'
  };

  export type CourseToPreRequisiteScalarFieldEnum = (typeof CourseToPreRequisiteScalarFieldEnum)[keyof typeof CourseToPreRequisiteScalarFieldEnum]


  export const CourseFacultyScalarFieldEnum: {
    courseId: 'courseId',
    facultyId: 'facultyId'
  };

  export type CourseFacultyScalarFieldEnum = (typeof CourseFacultyScalarFieldEnum)[keyof typeof CourseFacultyScalarFieldEnum]


  export const SemesterRegistrationScalarFieldEnum: {
    id: 'id',
    startDate: 'startDate',
    endDate: 'endDate',
    status: 'status',
    paymentRecipt: 'paymentRecipt',
    totalPayment: 'totalPayment',
    createdAt: 'createdAt',
    updateAt: 'updateAt',
    academicSemesterId: 'academicSemesterId'
  };

  export type SemesterRegistrationScalarFieldEnum = (typeof SemesterRegistrationScalarFieldEnum)[keyof typeof SemesterRegistrationScalarFieldEnum]


  export const AdmitionExameRegistrationScalarFieldEnum: {
    id: 'id',
    applicantName: 'applicantName',
    paymentRecipt: 'paymentRecipt',
    document: 'document',
    paymentAmoute: 'paymentAmoute',
    aprovePayment: 'aprovePayment',
    exameResults: 'exameResults',
    passed: 'passed',
    fase: 'fase',
    exameDate: 'exameDate',
    createdAt: 'createdAt',
    updateAt: 'updateAt',
    departmentId: 'departmentId'
  };

  export type AdmitionExameRegistrationScalarFieldEnum = (typeof AdmitionExameRegistrationScalarFieldEnum)[keyof typeof AdmitionExameRegistrationScalarFieldEnum]


  export const OfferedCourseScalarFieldEnum: {
    id: 'id',
    academicDepartmentId: 'academicDepartmentId',
    courseId: 'courseId',
    semesterRegistrationId: 'semesterRegistrationId'
  };

  export type OfferedCourseScalarFieldEnum = (typeof OfferedCourseScalarFieldEnum)[keyof typeof OfferedCourseScalarFieldEnum]


  export const OfferedCourseSectionScalarFieldEnum: {
    id: 'id',
    title: 'title',
    maxCapacity: 'maxCapacity',
    currentlyEnrolledStudent: 'currentlyEnrolledStudent',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    semesterRegistrationId: 'semesterRegistrationId',
    offeredCourseId: 'offeredCourseId'
  };

  export type OfferedCourseSectionScalarFieldEnum = (typeof OfferedCourseSectionScalarFieldEnum)[keyof typeof OfferedCourseSectionScalarFieldEnum]


  export const OfferedCourseClassScheduleScalarFieldEnum: {
    id: 'id',
    startTime: 'startTime',
    endTime: 'endTime',
    dayOfWeek: 'dayOfWeek',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    offeredCourseSectionId: 'offeredCourseSectionId',
    semesterRegistrationId: 'semesterRegistrationId',
    roomId: 'roomId',
    facultyId: 'facultyId'
  };

  export type OfferedCourseClassScheduleScalarFieldEnum = (typeof OfferedCourseClassScheduleScalarFieldEnum)[keyof typeof OfferedCourseClassScheduleScalarFieldEnum]


  export const StudentSemesterRegistrationScalarFieldEnum: {
    id: 'id',
    isConfirmed: 'isConfirmed',
    totalCreditsTaken: 'totalCreditsTaken',
    paymentRecipt: 'paymentRecipt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    studentId: 'studentId',
    semesterRegistrationId: 'semesterRegistrationId'
  };

  export type StudentSemesterRegistrationScalarFieldEnum = (typeof StudentSemesterRegistrationScalarFieldEnum)[keyof typeof StudentSemesterRegistrationScalarFieldEnum]


  export const StudentSemesterRegistrationCourseScalarFieldEnum: {
    semesterRegistrationId: 'semesterRegistrationId',
    studentId: 'studentId',
    offeredCourseId: 'offeredCourseId',
    offeredCourseSectionId: 'offeredCourseSectionId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type StudentSemesterRegistrationCourseScalarFieldEnum = (typeof StudentSemesterRegistrationCourseScalarFieldEnum)[keyof typeof StudentSemesterRegistrationCourseScalarFieldEnum]


  export const StudentEnrolledCourseScalarFieldEnum: {
    id: 'id',
    grade: 'grade',
    point: 'point',
    totalMarks: 'totalMarks',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    studentId: 'studentId',
    academicSemesterId: 'academicSemesterId',
    courseId: 'courseId'
  };

  export type StudentEnrolledCourseScalarFieldEnum = (typeof StudentEnrolledCourseScalarFieldEnum)[keyof typeof StudentEnrolledCourseScalarFieldEnum]


  export const StudentEnrolledCourseMarkScalarFieldEnum: {
    id: 'id',
    examType: 'examType',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    studentId: 'studentId',
    studentEnrolledCourseId: 'studentEnrolledCourseId',
    academicSemesterId: 'academicSemesterId',
    exam1: 'exam1',
    exam2: 'exam2',
    exam3: 'exam3',
    exam4: 'exam4',
    exam5: 'exam5',
    exam6: 'exam6',
    finalExam: 'finalExam',
    totalMarks: 'totalMarks',
    grade: 'grade'
  };

  export type StudentEnrolledCourseMarkScalarFieldEnum = (typeof StudentEnrolledCourseMarkScalarFieldEnum)[keyof typeof StudentEnrolledCourseMarkScalarFieldEnum]


  export const StudentSemesterPaymentScalarFieldEnum: {
    id: 'id',
    paymentRecipt: 'paymentRecipt',
    totalPayment: 'totalPayment',
    baseAmount: 'baseAmount',
    lateFee: 'lateFee',
    aprovedPayment: 'aprovedPayment',
    paymentType: 'paymentType',
    paymentStatus: 'paymentStatus',
    paymentMonth: 'paymentMonth',
    paymentYear: 'paymentYear',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    studentId: 'studentId',
    academicSemesterId: 'academicSemesterId'
  };

  export type StudentSemesterPaymentScalarFieldEnum = (typeof StudentSemesterPaymentScalarFieldEnum)[keyof typeof StudentSemesterPaymentScalarFieldEnum]


  export const StudentAcademicInfoScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    studentId: 'studentId',
    totalCompletedCredits: 'totalCompletedCredits',
    cgpa: 'cgpa'
  };

  export type StudentAcademicInfoScalarFieldEnum = (typeof StudentAcademicInfoScalarFieldEnum)[keyof typeof StudentAcademicInfoScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const UsersOrderByRelevanceFieldEnum: {
    id: 'id',
    name: 'name',
    email: 'email',
    password: 'password',
    avatar: 'avatar'
  };

  export type UsersOrderByRelevanceFieldEnum = (typeof UsersOrderByRelevanceFieldEnum)[keyof typeof UsersOrderByRelevanceFieldEnum]


  export const AcademicSemesterOrderByRelevanceFieldEnum: {
    id: 'id',
    title: 'title',
    year: 'year',
    code: 'code',
    startMonth: 'startMonth',
    endMonth: 'endMonth'
  };

  export type AcademicSemesterOrderByRelevanceFieldEnum = (typeof AcademicSemesterOrderByRelevanceFieldEnum)[keyof typeof AcademicSemesterOrderByRelevanceFieldEnum]


  export const AcademicFacultyOrderByRelevanceFieldEnum: {
    id: 'id',
    title: 'title'
  };

  export type AcademicFacultyOrderByRelevanceFieldEnum = (typeof AcademicFacultyOrderByRelevanceFieldEnum)[keyof typeof AcademicFacultyOrderByRelevanceFieldEnum]


  export const AcademicDepartmentOrderByRelevanceFieldEnum: {
    id: 'id',
    title: 'title',
    academicFacultyId: 'academicFacultyId',
    departmentHeadId: 'departmentHeadId'
  };

  export type AcademicDepartmentOrderByRelevanceFieldEnum = (typeof AcademicDepartmentOrderByRelevanceFieldEnum)[keyof typeof AcademicDepartmentOrderByRelevanceFieldEnum]


  export const StudentOrderByRelevanceFieldEnum: {
    id: 'id',
    studentId: 'studentId',
    firstName: 'firstName',
    middleName: 'middleName',
    lastName: 'lastName',
    profileImage: 'profileImage',
    email: 'email',
    contactNo: 'contactNo',
    gender: 'gender',
    password: 'password',
    gradeDeclarationFile: 'gradeDeclarationFile',
    biFile: 'biFile',
    presentAddress: 'presentAddress',
    permanentAddress: 'permanentAddress',
    academicSemesterId: 'academicSemesterId',
    academicFacultyId: 'academicFacultyId',
    academicDepartmentId: 'academicDepartmentId',
    admissionRegistrationId: 'admissionRegistrationId'
  };

  export type StudentOrderByRelevanceFieldEnum = (typeof StudentOrderByRelevanceFieldEnum)[keyof typeof StudentOrderByRelevanceFieldEnum]


  export const FacultyOrderByRelevanceFieldEnum: {
    id: 'id',
    facultyId: 'facultyId',
    firstName: 'firstName',
    middleName: 'middleName',
    lastName: 'lastName',
    profileImage: 'profileImage',
    email: 'email',
    contactNo: 'contactNo',
    gender: 'gender',
    designation: 'designation',
    password: 'password',
    academicFacultyId: 'academicFacultyId',
    academicDepartmentId: 'academicDepartmentId'
  };

  export type FacultyOrderByRelevanceFieldEnum = (typeof FacultyOrderByRelevanceFieldEnum)[keyof typeof FacultyOrderByRelevanceFieldEnum]


  export const BuildingOrderByRelevanceFieldEnum: {
    id: 'id',
    title: 'title'
  };

  export type BuildingOrderByRelevanceFieldEnum = (typeof BuildingOrderByRelevanceFieldEnum)[keyof typeof BuildingOrderByRelevanceFieldEnum]


  export const RoomOrderByRelevanceFieldEnum: {
    id: 'id',
    roomNumber: 'roomNumber',
    floor: 'floor',
    buildingId: 'buildingId'
  };

  export type RoomOrderByRelevanceFieldEnum = (typeof RoomOrderByRelevanceFieldEnum)[keyof typeof RoomOrderByRelevanceFieldEnum]


  export const CourseOrderByRelevanceFieldEnum: {
    id: 'id',
    title: 'title',
    code: 'code'
  };

  export type CourseOrderByRelevanceFieldEnum = (typeof CourseOrderByRelevanceFieldEnum)[keyof typeof CourseOrderByRelevanceFieldEnum]


  export const CourseToPreRequisiteOrderByRelevanceFieldEnum: {
    courseId: 'courseId',
    preRequisiteId: 'preRequisiteId'
  };

  export type CourseToPreRequisiteOrderByRelevanceFieldEnum = (typeof CourseToPreRequisiteOrderByRelevanceFieldEnum)[keyof typeof CourseToPreRequisiteOrderByRelevanceFieldEnum]


  export const CourseFacultyOrderByRelevanceFieldEnum: {
    courseId: 'courseId',
    facultyId: 'facultyId'
  };

  export type CourseFacultyOrderByRelevanceFieldEnum = (typeof CourseFacultyOrderByRelevanceFieldEnum)[keyof typeof CourseFacultyOrderByRelevanceFieldEnum]


  export const SemesterRegistrationOrderByRelevanceFieldEnum: {
    id: 'id',
    paymentRecipt: 'paymentRecipt',
    academicSemesterId: 'academicSemesterId'
  };

  export type SemesterRegistrationOrderByRelevanceFieldEnum = (typeof SemesterRegistrationOrderByRelevanceFieldEnum)[keyof typeof SemesterRegistrationOrderByRelevanceFieldEnum]


  export const AdmitionExameRegistrationOrderByRelevanceFieldEnum: {
    id: 'id',
    applicantName: 'applicantName',
    paymentRecipt: 'paymentRecipt',
    document: 'document',
    departmentId: 'departmentId'
  };

  export type AdmitionExameRegistrationOrderByRelevanceFieldEnum = (typeof AdmitionExameRegistrationOrderByRelevanceFieldEnum)[keyof typeof AdmitionExameRegistrationOrderByRelevanceFieldEnum]


  export const OfferedCourseOrderByRelevanceFieldEnum: {
    id: 'id',
    academicDepartmentId: 'academicDepartmentId',
    courseId: 'courseId',
    semesterRegistrationId: 'semesterRegistrationId'
  };

  export type OfferedCourseOrderByRelevanceFieldEnum = (typeof OfferedCourseOrderByRelevanceFieldEnum)[keyof typeof OfferedCourseOrderByRelevanceFieldEnum]


  export const OfferedCourseSectionOrderByRelevanceFieldEnum: {
    id: 'id',
    title: 'title',
    semesterRegistrationId: 'semesterRegistrationId',
    offeredCourseId: 'offeredCourseId'
  };

  export type OfferedCourseSectionOrderByRelevanceFieldEnum = (typeof OfferedCourseSectionOrderByRelevanceFieldEnum)[keyof typeof OfferedCourseSectionOrderByRelevanceFieldEnum]


  export const OfferedCourseClassScheduleOrderByRelevanceFieldEnum: {
    id: 'id',
    startTime: 'startTime',
    endTime: 'endTime',
    offeredCourseSectionId: 'offeredCourseSectionId',
    semesterRegistrationId: 'semesterRegistrationId',
    roomId: 'roomId',
    facultyId: 'facultyId'
  };

  export type OfferedCourseClassScheduleOrderByRelevanceFieldEnum = (typeof OfferedCourseClassScheduleOrderByRelevanceFieldEnum)[keyof typeof OfferedCourseClassScheduleOrderByRelevanceFieldEnum]


  export const StudentSemesterRegistrationOrderByRelevanceFieldEnum: {
    id: 'id',
    paymentRecipt: 'paymentRecipt',
    studentId: 'studentId',
    semesterRegistrationId: 'semesterRegistrationId'
  };

  export type StudentSemesterRegistrationOrderByRelevanceFieldEnum = (typeof StudentSemesterRegistrationOrderByRelevanceFieldEnum)[keyof typeof StudentSemesterRegistrationOrderByRelevanceFieldEnum]


  export const StudentSemesterRegistrationCourseOrderByRelevanceFieldEnum: {
    semesterRegistrationId: 'semesterRegistrationId',
    studentId: 'studentId',
    offeredCourseId: 'offeredCourseId',
    offeredCourseSectionId: 'offeredCourseSectionId'
  };

  export type StudentSemesterRegistrationCourseOrderByRelevanceFieldEnum = (typeof StudentSemesterRegistrationCourseOrderByRelevanceFieldEnum)[keyof typeof StudentSemesterRegistrationCourseOrderByRelevanceFieldEnum]


  export const StudentEnrolledCourseOrderByRelevanceFieldEnum: {
    id: 'id',
    grade: 'grade',
    studentId: 'studentId',
    academicSemesterId: 'academicSemesterId',
    courseId: 'courseId'
  };

  export type StudentEnrolledCourseOrderByRelevanceFieldEnum = (typeof StudentEnrolledCourseOrderByRelevanceFieldEnum)[keyof typeof StudentEnrolledCourseOrderByRelevanceFieldEnum]


  export const StudentEnrolledCourseMarkOrderByRelevanceFieldEnum: {
    id: 'id',
    studentId: 'studentId',
    studentEnrolledCourseId: 'studentEnrolledCourseId',
    academicSemesterId: 'academicSemesterId'
  };

  export type StudentEnrolledCourseMarkOrderByRelevanceFieldEnum = (typeof StudentEnrolledCourseMarkOrderByRelevanceFieldEnum)[keyof typeof StudentEnrolledCourseMarkOrderByRelevanceFieldEnum]


  export const StudentSemesterPaymentOrderByRelevanceFieldEnum: {
    id: 'id',
    paymentRecipt: 'paymentRecipt',
    studentId: 'studentId',
    academicSemesterId: 'academicSemesterId'
  };

  export type StudentSemesterPaymentOrderByRelevanceFieldEnum = (typeof StudentSemesterPaymentOrderByRelevanceFieldEnum)[keyof typeof StudentSemesterPaymentOrderByRelevanceFieldEnum]


  export const StudentAcademicInfoOrderByRelevanceFieldEnum: {
    id: 'id',
    studentId: 'studentId'
  };

  export type StudentAcademicInfoOrderByRelevanceFieldEnum = (typeof StudentAcademicInfoOrderByRelevanceFieldEnum)[keyof typeof StudentAcademicInfoOrderByRelevanceFieldEnum]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'UserRole'
   */
  export type EnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Shift'
   */
  export type EnumShiftFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Shift'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'SemesterRegistrationStatus'
   */
  export type EnumSemesterRegistrationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SemesterRegistrationStatus'>
    


  /**
   * Reference to a field of type 'WeekDays'
   */
  export type EnumWeekDaysFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'WeekDays'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'StudentEnrolledCourseStatus'
   */
  export type EnumStudentEnrolledCourseStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'StudentEnrolledCourseStatus'>
    


  /**
   * Reference to a field of type 'ExamType'
   */
  export type EnumExamTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ExamType'>
    


  /**
   * Reference to a field of type 'PAYMENTTYPE'
   */
  export type EnumPAYMENTTYPEFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PAYMENTTYPE'>
    


  /**
   * Reference to a field of type 'PaymentStatus'
   */
  export type EnumPaymentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentStatus'>
    
  /**
   * Deep Input Types
   */


  export type UsersWhereInput = {
    AND?: UsersWhereInput | UsersWhereInput[]
    OR?: UsersWhereInput[]
    NOT?: UsersWhereInput | UsersWhereInput[]
    id?: StringFilter<"Users"> | string
    name?: StringFilter<"Users"> | string
    email?: StringFilter<"Users"> | string
    password?: StringFilter<"Users"> | string
    avatar?: StringNullableFilter<"Users"> | string | null
    role?: EnumUserRoleFilter<"Users"> | $Enums.UserRole
    createdAt?: DateTimeFilter<"Users"> | Date | string
    updatedAt?: DateTimeFilter<"Users"> | Date | string
    academicDepartment?: XOR<AcademicDepartmentNullableScalarRelationFilter, AcademicDepartmentWhereInput> | null
    staffDepartments?: AcademicDepartmentListRelationFilter
  }

  export type UsersOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    avatar?: SortOrderInput | SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    academicDepartment?: AcademicDepartmentOrderByWithRelationInput
    staffDepartments?: AcademicDepartmentOrderByRelationAggregateInput
    _relevance?: UsersOrderByRelevanceInput
  }

  export type UsersWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: UsersWhereInput | UsersWhereInput[]
    OR?: UsersWhereInput[]
    NOT?: UsersWhereInput | UsersWhereInput[]
    name?: StringFilter<"Users"> | string
    password?: StringFilter<"Users"> | string
    avatar?: StringNullableFilter<"Users"> | string | null
    role?: EnumUserRoleFilter<"Users"> | $Enums.UserRole
    createdAt?: DateTimeFilter<"Users"> | Date | string
    updatedAt?: DateTimeFilter<"Users"> | Date | string
    academicDepartment?: XOR<AcademicDepartmentNullableScalarRelationFilter, AcademicDepartmentWhereInput> | null
    staffDepartments?: AcademicDepartmentListRelationFilter
  }, "id" | "email">

  export type UsersOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    avatar?: SortOrderInput | SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UsersCountOrderByAggregateInput
    _max?: UsersMaxOrderByAggregateInput
    _min?: UsersMinOrderByAggregateInput
  }

  export type UsersScalarWhereWithAggregatesInput = {
    AND?: UsersScalarWhereWithAggregatesInput | UsersScalarWhereWithAggregatesInput[]
    OR?: UsersScalarWhereWithAggregatesInput[]
    NOT?: UsersScalarWhereWithAggregatesInput | UsersScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Users"> | string
    name?: StringWithAggregatesFilter<"Users"> | string
    email?: StringWithAggregatesFilter<"Users"> | string
    password?: StringWithAggregatesFilter<"Users"> | string
    avatar?: StringNullableWithAggregatesFilter<"Users"> | string | null
    role?: EnumUserRoleWithAggregatesFilter<"Users"> | $Enums.UserRole
    createdAt?: DateTimeWithAggregatesFilter<"Users"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Users"> | Date | string
  }

  export type AcademicSemesterWhereInput = {
    AND?: AcademicSemesterWhereInput | AcademicSemesterWhereInput[]
    OR?: AcademicSemesterWhereInput[]
    NOT?: AcademicSemesterWhereInput | AcademicSemesterWhereInput[]
    id?: StringFilter<"AcademicSemester"> | string
    title?: StringFilter<"AcademicSemester"> | string
    year?: StringFilter<"AcademicSemester"> | string
    code?: StringFilter<"AcademicSemester"> | string
    startMonth?: StringFilter<"AcademicSemester"> | string
    endMonth?: StringFilter<"AcademicSemester"> | string
    isCurrent?: BoolFilter<"AcademicSemester"> | boolean
    createdAt?: DateTimeFilter<"AcademicSemester"> | Date | string
    updatedAt?: DateTimeFilter<"AcademicSemester"> | Date | string
    semesterRegistrations?: SemesterRegistrationListRelationFilter
    students?: XOR<StudentNullableScalarRelationFilter, StudentWhereInput> | null
    studentEnrolledCourses?: StudentEnrolledCourseListRelationFilter
    studentEnrolledCourseMarks?: StudentEnrolledCourseMarkListRelationFilter
    studentSemesterPayments?: StudentSemesterPaymentListRelationFilter
  }

  export type AcademicSemesterOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    year?: SortOrder
    code?: SortOrder
    startMonth?: SortOrder
    endMonth?: SortOrder
    isCurrent?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    semesterRegistrations?: SemesterRegistrationOrderByRelationAggregateInput
    students?: StudentOrderByWithRelationInput
    studentEnrolledCourses?: StudentEnrolledCourseOrderByRelationAggregateInput
    studentEnrolledCourseMarks?: StudentEnrolledCourseMarkOrderByRelationAggregateInput
    studentSemesterPayments?: StudentSemesterPaymentOrderByRelationAggregateInput
    _relevance?: AcademicSemesterOrderByRelevanceInput
  }

  export type AcademicSemesterWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AcademicSemesterWhereInput | AcademicSemesterWhereInput[]
    OR?: AcademicSemesterWhereInput[]
    NOT?: AcademicSemesterWhereInput | AcademicSemesterWhereInput[]
    title?: StringFilter<"AcademicSemester"> | string
    year?: StringFilter<"AcademicSemester"> | string
    code?: StringFilter<"AcademicSemester"> | string
    startMonth?: StringFilter<"AcademicSemester"> | string
    endMonth?: StringFilter<"AcademicSemester"> | string
    isCurrent?: BoolFilter<"AcademicSemester"> | boolean
    createdAt?: DateTimeFilter<"AcademicSemester"> | Date | string
    updatedAt?: DateTimeFilter<"AcademicSemester"> | Date | string
    semesterRegistrations?: SemesterRegistrationListRelationFilter
    students?: XOR<StudentNullableScalarRelationFilter, StudentWhereInput> | null
    studentEnrolledCourses?: StudentEnrolledCourseListRelationFilter
    studentEnrolledCourseMarks?: StudentEnrolledCourseMarkListRelationFilter
    studentSemesterPayments?: StudentSemesterPaymentListRelationFilter
  }, "id">

  export type AcademicSemesterOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    year?: SortOrder
    code?: SortOrder
    startMonth?: SortOrder
    endMonth?: SortOrder
    isCurrent?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AcademicSemesterCountOrderByAggregateInput
    _max?: AcademicSemesterMaxOrderByAggregateInput
    _min?: AcademicSemesterMinOrderByAggregateInput
  }

  export type AcademicSemesterScalarWhereWithAggregatesInput = {
    AND?: AcademicSemesterScalarWhereWithAggregatesInput | AcademicSemesterScalarWhereWithAggregatesInput[]
    OR?: AcademicSemesterScalarWhereWithAggregatesInput[]
    NOT?: AcademicSemesterScalarWhereWithAggregatesInput | AcademicSemesterScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AcademicSemester"> | string
    title?: StringWithAggregatesFilter<"AcademicSemester"> | string
    year?: StringWithAggregatesFilter<"AcademicSemester"> | string
    code?: StringWithAggregatesFilter<"AcademicSemester"> | string
    startMonth?: StringWithAggregatesFilter<"AcademicSemester"> | string
    endMonth?: StringWithAggregatesFilter<"AcademicSemester"> | string
    isCurrent?: BoolWithAggregatesFilter<"AcademicSemester"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"AcademicSemester"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AcademicSemester"> | Date | string
  }

  export type AcademicFacultyWhereInput = {
    AND?: AcademicFacultyWhereInput | AcademicFacultyWhereInput[]
    OR?: AcademicFacultyWhereInput[]
    NOT?: AcademicFacultyWhereInput | AcademicFacultyWhereInput[]
    id?: StringFilter<"AcademicFaculty"> | string
    title?: StringFilter<"AcademicFaculty"> | string
    createdAt?: DateTimeFilter<"AcademicFaculty"> | Date | string
    updatedAt?: DateTimeFilter<"AcademicFaculty"> | Date | string
    academicDepartments?: XOR<AcademicDepartmentNullableScalarRelationFilter, AcademicDepartmentWhereInput> | null
    faculties?: XOR<FacultyNullableScalarRelationFilter, FacultyWhereInput> | null
    students?: XOR<StudentNullableScalarRelationFilter, StudentWhereInput> | null
  }

  export type AcademicFacultyOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    academicDepartments?: AcademicDepartmentOrderByWithRelationInput
    faculties?: FacultyOrderByWithRelationInput
    students?: StudentOrderByWithRelationInput
    _relevance?: AcademicFacultyOrderByRelevanceInput
  }

  export type AcademicFacultyWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AcademicFacultyWhereInput | AcademicFacultyWhereInput[]
    OR?: AcademicFacultyWhereInput[]
    NOT?: AcademicFacultyWhereInput | AcademicFacultyWhereInput[]
    title?: StringFilter<"AcademicFaculty"> | string
    createdAt?: DateTimeFilter<"AcademicFaculty"> | Date | string
    updatedAt?: DateTimeFilter<"AcademicFaculty"> | Date | string
    academicDepartments?: XOR<AcademicDepartmentNullableScalarRelationFilter, AcademicDepartmentWhereInput> | null
    faculties?: XOR<FacultyNullableScalarRelationFilter, FacultyWhereInput> | null
    students?: XOR<StudentNullableScalarRelationFilter, StudentWhereInput> | null
  }, "id">

  export type AcademicFacultyOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AcademicFacultyCountOrderByAggregateInput
    _max?: AcademicFacultyMaxOrderByAggregateInput
    _min?: AcademicFacultyMinOrderByAggregateInput
  }

  export type AcademicFacultyScalarWhereWithAggregatesInput = {
    AND?: AcademicFacultyScalarWhereWithAggregatesInput | AcademicFacultyScalarWhereWithAggregatesInput[]
    OR?: AcademicFacultyScalarWhereWithAggregatesInput[]
    NOT?: AcademicFacultyScalarWhereWithAggregatesInput | AcademicFacultyScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AcademicFaculty"> | string
    title?: StringWithAggregatesFilter<"AcademicFaculty"> | string
    createdAt?: DateTimeWithAggregatesFilter<"AcademicFaculty"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AcademicFaculty"> | Date | string
  }

  export type AcademicDepartmentWhereInput = {
    AND?: AcademicDepartmentWhereInput | AcademicDepartmentWhereInput[]
    OR?: AcademicDepartmentWhereInput[]
    NOT?: AcademicDepartmentWhereInput | AcademicDepartmentWhereInput[]
    id?: StringFilter<"AcademicDepartment"> | string
    title?: StringFilter<"AcademicDepartment"> | string
    academicFacultyId?: StringFilter<"AcademicDepartment"> | string
    createdAt?: DateTimeFilter<"AcademicDepartment"> | Date | string
    updatedAt?: DateTimeFilter<"AcademicDepartment"> | Date | string
    departmentHeadId?: StringNullableFilter<"AcademicDepartment"> | string | null
    academicFaculty?: XOR<AcademicFacultyScalarRelationFilter, AcademicFacultyWhereInput>
    faculties?: XOR<FacultyNullableScalarRelationFilter, FacultyWhereInput> | null
    students?: XOR<StudentNullableScalarRelationFilter, StudentWhereInput> | null
    departmentHead?: XOR<UsersNullableScalarRelationFilter, UsersWhereInput> | null
    staffMembers?: UsersListRelationFilter
    admitionExame?: AdmitionExameRegistrationListRelationFilter
    offeredCourses?: OfferedCourseListRelationFilter
  }

  export type AcademicDepartmentOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    academicFacultyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    departmentHeadId?: SortOrderInput | SortOrder
    academicFaculty?: AcademicFacultyOrderByWithRelationInput
    faculties?: FacultyOrderByWithRelationInput
    students?: StudentOrderByWithRelationInput
    departmentHead?: UsersOrderByWithRelationInput
    staffMembers?: UsersOrderByRelationAggregateInput
    admitionExame?: AdmitionExameRegistrationOrderByRelationAggregateInput
    offeredCourses?: OfferedCourseOrderByRelationAggregateInput
    _relevance?: AcademicDepartmentOrderByRelevanceInput
  }

  export type AcademicDepartmentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    academicFacultyId?: string
    departmentHeadId?: string
    AND?: AcademicDepartmentWhereInput | AcademicDepartmentWhereInput[]
    OR?: AcademicDepartmentWhereInput[]
    NOT?: AcademicDepartmentWhereInput | AcademicDepartmentWhereInput[]
    title?: StringFilter<"AcademicDepartment"> | string
    createdAt?: DateTimeFilter<"AcademicDepartment"> | Date | string
    updatedAt?: DateTimeFilter<"AcademicDepartment"> | Date | string
    academicFaculty?: XOR<AcademicFacultyScalarRelationFilter, AcademicFacultyWhereInput>
    faculties?: XOR<FacultyNullableScalarRelationFilter, FacultyWhereInput> | null
    students?: XOR<StudentNullableScalarRelationFilter, StudentWhereInput> | null
    departmentHead?: XOR<UsersNullableScalarRelationFilter, UsersWhereInput> | null
    staffMembers?: UsersListRelationFilter
    admitionExame?: AdmitionExameRegistrationListRelationFilter
    offeredCourses?: OfferedCourseListRelationFilter
  }, "id" | "academicFacultyId" | "departmentHeadId">

  export type AcademicDepartmentOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    academicFacultyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    departmentHeadId?: SortOrderInput | SortOrder
    _count?: AcademicDepartmentCountOrderByAggregateInput
    _max?: AcademicDepartmentMaxOrderByAggregateInput
    _min?: AcademicDepartmentMinOrderByAggregateInput
  }

  export type AcademicDepartmentScalarWhereWithAggregatesInput = {
    AND?: AcademicDepartmentScalarWhereWithAggregatesInput | AcademicDepartmentScalarWhereWithAggregatesInput[]
    OR?: AcademicDepartmentScalarWhereWithAggregatesInput[]
    NOT?: AcademicDepartmentScalarWhereWithAggregatesInput | AcademicDepartmentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AcademicDepartment"> | string
    title?: StringWithAggregatesFilter<"AcademicDepartment"> | string
    academicFacultyId?: StringWithAggregatesFilter<"AcademicDepartment"> | string
    createdAt?: DateTimeWithAggregatesFilter<"AcademicDepartment"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AcademicDepartment"> | Date | string
    departmentHeadId?: StringNullableWithAggregatesFilter<"AcademicDepartment"> | string | null
  }

  export type StudentWhereInput = {
    AND?: StudentWhereInput | StudentWhereInput[]
    OR?: StudentWhereInput[]
    NOT?: StudentWhereInput | StudentWhereInput[]
    id?: StringFilter<"Student"> | string
    studentId?: StringFilter<"Student"> | string
    firstName?: StringFilter<"Student"> | string
    middleName?: StringNullableFilter<"Student"> | string | null
    lastName?: StringFilter<"Student"> | string
    profileImage?: StringNullableFilter<"Student"> | string | null
    email?: StringNullableFilter<"Student"> | string | null
    contactNo?: StringNullableFilter<"Student"> | string | null
    gender?: StringFilter<"Student"> | string
    isWoker?: BoolFilter<"Student"> | boolean
    shift?: EnumShiftFilter<"Student"> | $Enums.Shift
    password?: StringFilter<"Student"> | string
    gradeDeclarationFile?: StringFilter<"Student"> | string
    biFile?: StringFilter<"Student"> | string
    presentAddress?: StringFilter<"Student"> | string
    permanentAddress?: StringNullableFilter<"Student"> | string | null
    academicSemesterId?: StringFilter<"Student"> | string
    academicFacultyId?: StringFilter<"Student"> | string
    academicDepartmentId?: StringFilter<"Student"> | string
    createdAt?: DateTimeFilter<"Student"> | Date | string
    updatedAt?: DateTimeFilter<"Student"> | Date | string
    admissionRegistrationId?: StringNullableFilter<"Student"> | string | null
    admissionRegistration?: XOR<AdmitionExameRegistrationNullableScalarRelationFilter, AdmitionExameRegistrationWhereInput> | null
    academicDepartment?: XOR<AcademicDepartmentScalarRelationFilter, AcademicDepartmentWhereInput>
    academicFaculty?: XOR<AcademicFacultyScalarRelationFilter, AcademicFacultyWhereInput>
    academicSemester?: XOR<AcademicSemesterScalarRelationFilter, AcademicSemesterWhereInput>
    studentSemesterRegistrations?: StudentSemesterRegistrationListRelationFilter
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseListRelationFilter
    studentEnrolledCourses?: StudentEnrolledCourseListRelationFilter
    studentEnrolledCourseMarks?: StudentEnrolledCourseMarkListRelationFilter
    studentSemesterPayments?: StudentSemesterPaymentListRelationFilter
    studentAcademicInfos?: StudentAcademicInfoListRelationFilter
  }

  export type StudentOrderByWithRelationInput = {
    id?: SortOrder
    studentId?: SortOrder
    firstName?: SortOrder
    middleName?: SortOrderInput | SortOrder
    lastName?: SortOrder
    profileImage?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    contactNo?: SortOrderInput | SortOrder
    gender?: SortOrder
    isWoker?: SortOrder
    shift?: SortOrder
    password?: SortOrder
    gradeDeclarationFile?: SortOrder
    biFile?: SortOrder
    presentAddress?: SortOrder
    permanentAddress?: SortOrderInput | SortOrder
    academicSemesterId?: SortOrder
    academicFacultyId?: SortOrder
    academicDepartmentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    admissionRegistrationId?: SortOrderInput | SortOrder
    admissionRegistration?: AdmitionExameRegistrationOrderByWithRelationInput
    academicDepartment?: AcademicDepartmentOrderByWithRelationInput
    academicFaculty?: AcademicFacultyOrderByWithRelationInput
    academicSemester?: AcademicSemesterOrderByWithRelationInput
    studentSemesterRegistrations?: StudentSemesterRegistrationOrderByRelationAggregateInput
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseOrderByRelationAggregateInput
    studentEnrolledCourses?: StudentEnrolledCourseOrderByRelationAggregateInput
    studentEnrolledCourseMarks?: StudentEnrolledCourseMarkOrderByRelationAggregateInput
    studentSemesterPayments?: StudentSemesterPaymentOrderByRelationAggregateInput
    studentAcademicInfos?: StudentAcademicInfoOrderByRelationAggregateInput
    _relevance?: StudentOrderByRelevanceInput
  }

  export type StudentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    studentId?: string
    academicSemesterId?: string
    academicFacultyId?: string
    academicDepartmentId?: string
    admissionRegistrationId?: string
    AND?: StudentWhereInput | StudentWhereInput[]
    OR?: StudentWhereInput[]
    NOT?: StudentWhereInput | StudentWhereInput[]
    firstName?: StringFilter<"Student"> | string
    middleName?: StringNullableFilter<"Student"> | string | null
    lastName?: StringFilter<"Student"> | string
    profileImage?: StringNullableFilter<"Student"> | string | null
    email?: StringNullableFilter<"Student"> | string | null
    contactNo?: StringNullableFilter<"Student"> | string | null
    gender?: StringFilter<"Student"> | string
    isWoker?: BoolFilter<"Student"> | boolean
    shift?: EnumShiftFilter<"Student"> | $Enums.Shift
    password?: StringFilter<"Student"> | string
    gradeDeclarationFile?: StringFilter<"Student"> | string
    biFile?: StringFilter<"Student"> | string
    presentAddress?: StringFilter<"Student"> | string
    permanentAddress?: StringNullableFilter<"Student"> | string | null
    createdAt?: DateTimeFilter<"Student"> | Date | string
    updatedAt?: DateTimeFilter<"Student"> | Date | string
    admissionRegistration?: XOR<AdmitionExameRegistrationNullableScalarRelationFilter, AdmitionExameRegistrationWhereInput> | null
    academicDepartment?: XOR<AcademicDepartmentScalarRelationFilter, AcademicDepartmentWhereInput>
    academicFaculty?: XOR<AcademicFacultyScalarRelationFilter, AcademicFacultyWhereInput>
    academicSemester?: XOR<AcademicSemesterScalarRelationFilter, AcademicSemesterWhereInput>
    studentSemesterRegistrations?: StudentSemesterRegistrationListRelationFilter
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseListRelationFilter
    studentEnrolledCourses?: StudentEnrolledCourseListRelationFilter
    studentEnrolledCourseMarks?: StudentEnrolledCourseMarkListRelationFilter
    studentSemesterPayments?: StudentSemesterPaymentListRelationFilter
    studentAcademicInfos?: StudentAcademicInfoListRelationFilter
  }, "id" | "studentId" | "academicSemesterId" | "academicFacultyId" | "academicDepartmentId" | "admissionRegistrationId">

  export type StudentOrderByWithAggregationInput = {
    id?: SortOrder
    studentId?: SortOrder
    firstName?: SortOrder
    middleName?: SortOrderInput | SortOrder
    lastName?: SortOrder
    profileImage?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    contactNo?: SortOrderInput | SortOrder
    gender?: SortOrder
    isWoker?: SortOrder
    shift?: SortOrder
    password?: SortOrder
    gradeDeclarationFile?: SortOrder
    biFile?: SortOrder
    presentAddress?: SortOrder
    permanentAddress?: SortOrderInput | SortOrder
    academicSemesterId?: SortOrder
    academicFacultyId?: SortOrder
    academicDepartmentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    admissionRegistrationId?: SortOrderInput | SortOrder
    _count?: StudentCountOrderByAggregateInput
    _max?: StudentMaxOrderByAggregateInput
    _min?: StudentMinOrderByAggregateInput
  }

  export type StudentScalarWhereWithAggregatesInput = {
    AND?: StudentScalarWhereWithAggregatesInput | StudentScalarWhereWithAggregatesInput[]
    OR?: StudentScalarWhereWithAggregatesInput[]
    NOT?: StudentScalarWhereWithAggregatesInput | StudentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Student"> | string
    studentId?: StringWithAggregatesFilter<"Student"> | string
    firstName?: StringWithAggregatesFilter<"Student"> | string
    middleName?: StringNullableWithAggregatesFilter<"Student"> | string | null
    lastName?: StringWithAggregatesFilter<"Student"> | string
    profileImage?: StringNullableWithAggregatesFilter<"Student"> | string | null
    email?: StringNullableWithAggregatesFilter<"Student"> | string | null
    contactNo?: StringNullableWithAggregatesFilter<"Student"> | string | null
    gender?: StringWithAggregatesFilter<"Student"> | string
    isWoker?: BoolWithAggregatesFilter<"Student"> | boolean
    shift?: EnumShiftWithAggregatesFilter<"Student"> | $Enums.Shift
    password?: StringWithAggregatesFilter<"Student"> | string
    gradeDeclarationFile?: StringWithAggregatesFilter<"Student"> | string
    biFile?: StringWithAggregatesFilter<"Student"> | string
    presentAddress?: StringWithAggregatesFilter<"Student"> | string
    permanentAddress?: StringNullableWithAggregatesFilter<"Student"> | string | null
    academicSemesterId?: StringWithAggregatesFilter<"Student"> | string
    academicFacultyId?: StringWithAggregatesFilter<"Student"> | string
    academicDepartmentId?: StringWithAggregatesFilter<"Student"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Student"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Student"> | Date | string
    admissionRegistrationId?: StringNullableWithAggregatesFilter<"Student"> | string | null
  }

  export type FacultyWhereInput = {
    AND?: FacultyWhereInput | FacultyWhereInput[]
    OR?: FacultyWhereInput[]
    NOT?: FacultyWhereInput | FacultyWhereInput[]
    id?: StringFilter<"Faculty"> | string
    facultyId?: StringFilter<"Faculty"> | string
    firstName?: StringFilter<"Faculty"> | string
    middleName?: StringNullableFilter<"Faculty"> | string | null
    lastName?: StringFilter<"Faculty"> | string
    profileImage?: StringNullableFilter<"Faculty"> | string | null
    email?: StringNullableFilter<"Faculty"> | string | null
    contactNo?: StringNullableFilter<"Faculty"> | string | null
    gender?: StringFilter<"Faculty"> | string
    designation?: StringFilter<"Faculty"> | string
    password?: StringFilter<"Faculty"> | string
    academicFacultyId?: StringFilter<"Faculty"> | string
    academicDepartmentId?: StringFilter<"Faculty"> | string
    createdAt?: DateTimeFilter<"Faculty"> | Date | string
    updatedAt?: DateTimeFilter<"Faculty"> | Date | string
    courses?: CourseFacultyListRelationFilter
    academicDepartment?: XOR<AcademicDepartmentScalarRelationFilter, AcademicDepartmentWhereInput>
    academicFaculty?: XOR<AcademicFacultyScalarRelationFilter, AcademicFacultyWhereInput>
    offeredCourseClassSchedules?: OfferedCourseClassScheduleListRelationFilter
  }

  export type FacultyOrderByWithRelationInput = {
    id?: SortOrder
    facultyId?: SortOrder
    firstName?: SortOrder
    middleName?: SortOrderInput | SortOrder
    lastName?: SortOrder
    profileImage?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    contactNo?: SortOrderInput | SortOrder
    gender?: SortOrder
    designation?: SortOrder
    password?: SortOrder
    academicFacultyId?: SortOrder
    academicDepartmentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    courses?: CourseFacultyOrderByRelationAggregateInput
    academicDepartment?: AcademicDepartmentOrderByWithRelationInput
    academicFaculty?: AcademicFacultyOrderByWithRelationInput
    offeredCourseClassSchedules?: OfferedCourseClassScheduleOrderByRelationAggregateInput
    _relevance?: FacultyOrderByRelevanceInput
  }

  export type FacultyWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    facultyId?: string
    academicFacultyId?: string
    academicDepartmentId?: string
    AND?: FacultyWhereInput | FacultyWhereInput[]
    OR?: FacultyWhereInput[]
    NOT?: FacultyWhereInput | FacultyWhereInput[]
    firstName?: StringFilter<"Faculty"> | string
    middleName?: StringNullableFilter<"Faculty"> | string | null
    lastName?: StringFilter<"Faculty"> | string
    profileImage?: StringNullableFilter<"Faculty"> | string | null
    email?: StringNullableFilter<"Faculty"> | string | null
    contactNo?: StringNullableFilter<"Faculty"> | string | null
    gender?: StringFilter<"Faculty"> | string
    designation?: StringFilter<"Faculty"> | string
    password?: StringFilter<"Faculty"> | string
    createdAt?: DateTimeFilter<"Faculty"> | Date | string
    updatedAt?: DateTimeFilter<"Faculty"> | Date | string
    courses?: CourseFacultyListRelationFilter
    academicDepartment?: XOR<AcademicDepartmentScalarRelationFilter, AcademicDepartmentWhereInput>
    academicFaculty?: XOR<AcademicFacultyScalarRelationFilter, AcademicFacultyWhereInput>
    offeredCourseClassSchedules?: OfferedCourseClassScheduleListRelationFilter
  }, "id" | "facultyId" | "academicFacultyId" | "academicDepartmentId">

  export type FacultyOrderByWithAggregationInput = {
    id?: SortOrder
    facultyId?: SortOrder
    firstName?: SortOrder
    middleName?: SortOrderInput | SortOrder
    lastName?: SortOrder
    profileImage?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    contactNo?: SortOrderInput | SortOrder
    gender?: SortOrder
    designation?: SortOrder
    password?: SortOrder
    academicFacultyId?: SortOrder
    academicDepartmentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: FacultyCountOrderByAggregateInput
    _max?: FacultyMaxOrderByAggregateInput
    _min?: FacultyMinOrderByAggregateInput
  }

  export type FacultyScalarWhereWithAggregatesInput = {
    AND?: FacultyScalarWhereWithAggregatesInput | FacultyScalarWhereWithAggregatesInput[]
    OR?: FacultyScalarWhereWithAggregatesInput[]
    NOT?: FacultyScalarWhereWithAggregatesInput | FacultyScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Faculty"> | string
    facultyId?: StringWithAggregatesFilter<"Faculty"> | string
    firstName?: StringWithAggregatesFilter<"Faculty"> | string
    middleName?: StringNullableWithAggregatesFilter<"Faculty"> | string | null
    lastName?: StringWithAggregatesFilter<"Faculty"> | string
    profileImage?: StringNullableWithAggregatesFilter<"Faculty"> | string | null
    email?: StringNullableWithAggregatesFilter<"Faculty"> | string | null
    contactNo?: StringNullableWithAggregatesFilter<"Faculty"> | string | null
    gender?: StringWithAggregatesFilter<"Faculty"> | string
    designation?: StringWithAggregatesFilter<"Faculty"> | string
    password?: StringWithAggregatesFilter<"Faculty"> | string
    academicFacultyId?: StringWithAggregatesFilter<"Faculty"> | string
    academicDepartmentId?: StringWithAggregatesFilter<"Faculty"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Faculty"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Faculty"> | Date | string
  }

  export type BuildingWhereInput = {
    AND?: BuildingWhereInput | BuildingWhereInput[]
    OR?: BuildingWhereInput[]
    NOT?: BuildingWhereInput | BuildingWhereInput[]
    id?: StringFilter<"Building"> | string
    title?: StringFilter<"Building"> | string
    createdAt?: DateTimeFilter<"Building"> | Date | string
    updatedAt?: DateTimeFilter<"Building"> | Date | string
    rooms?: RoomListRelationFilter
  }

  export type BuildingOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    rooms?: RoomOrderByRelationAggregateInput
    _relevance?: BuildingOrderByRelevanceInput
  }

  export type BuildingWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: BuildingWhereInput | BuildingWhereInput[]
    OR?: BuildingWhereInput[]
    NOT?: BuildingWhereInput | BuildingWhereInput[]
    title?: StringFilter<"Building"> | string
    createdAt?: DateTimeFilter<"Building"> | Date | string
    updatedAt?: DateTimeFilter<"Building"> | Date | string
    rooms?: RoomListRelationFilter
  }, "id">

  export type BuildingOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: BuildingCountOrderByAggregateInput
    _max?: BuildingMaxOrderByAggregateInput
    _min?: BuildingMinOrderByAggregateInput
  }

  export type BuildingScalarWhereWithAggregatesInput = {
    AND?: BuildingScalarWhereWithAggregatesInput | BuildingScalarWhereWithAggregatesInput[]
    OR?: BuildingScalarWhereWithAggregatesInput[]
    NOT?: BuildingScalarWhereWithAggregatesInput | BuildingScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Building"> | string
    title?: StringWithAggregatesFilter<"Building"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Building"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Building"> | Date | string
  }

  export type RoomWhereInput = {
    AND?: RoomWhereInput | RoomWhereInput[]
    OR?: RoomWhereInput[]
    NOT?: RoomWhereInput | RoomWhereInput[]
    id?: StringFilter<"Room"> | string
    roomNumber?: StringFilter<"Room"> | string
    floor?: StringFilter<"Room"> | string
    buildingId?: StringFilter<"Room"> | string
    createdAt?: DateTimeFilter<"Room"> | Date | string
    updatedAt?: DateTimeFilter<"Room"> | Date | string
    building?: XOR<BuildingScalarRelationFilter, BuildingWhereInput>
    offeredCourseClassSchedules?: OfferedCourseClassScheduleListRelationFilter
  }

  export type RoomOrderByWithRelationInput = {
    id?: SortOrder
    roomNumber?: SortOrder
    floor?: SortOrder
    buildingId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    building?: BuildingOrderByWithRelationInput
    offeredCourseClassSchedules?: OfferedCourseClassScheduleOrderByRelationAggregateInput
    _relevance?: RoomOrderByRelevanceInput
  }

  export type RoomWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: RoomWhereInput | RoomWhereInput[]
    OR?: RoomWhereInput[]
    NOT?: RoomWhereInput | RoomWhereInput[]
    roomNumber?: StringFilter<"Room"> | string
    floor?: StringFilter<"Room"> | string
    buildingId?: StringFilter<"Room"> | string
    createdAt?: DateTimeFilter<"Room"> | Date | string
    updatedAt?: DateTimeFilter<"Room"> | Date | string
    building?: XOR<BuildingScalarRelationFilter, BuildingWhereInput>
    offeredCourseClassSchedules?: OfferedCourseClassScheduleListRelationFilter
  }, "id">

  export type RoomOrderByWithAggregationInput = {
    id?: SortOrder
    roomNumber?: SortOrder
    floor?: SortOrder
    buildingId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: RoomCountOrderByAggregateInput
    _max?: RoomMaxOrderByAggregateInput
    _min?: RoomMinOrderByAggregateInput
  }

  export type RoomScalarWhereWithAggregatesInput = {
    AND?: RoomScalarWhereWithAggregatesInput | RoomScalarWhereWithAggregatesInput[]
    OR?: RoomScalarWhereWithAggregatesInput[]
    NOT?: RoomScalarWhereWithAggregatesInput | RoomScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Room"> | string
    roomNumber?: StringWithAggregatesFilter<"Room"> | string
    floor?: StringWithAggregatesFilter<"Room"> | string
    buildingId?: StringWithAggregatesFilter<"Room"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Room"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Room"> | Date | string
  }

  export type CourseWhereInput = {
    AND?: CourseWhereInput | CourseWhereInput[]
    OR?: CourseWhereInput[]
    NOT?: CourseWhereInput | CourseWhereInput[]
    id?: StringFilter<"Course"> | string
    title?: StringFilter<"Course"> | string
    code?: StringFilter<"Course"> | string
    credits?: IntFilter<"Course"> | number
    createdAt?: DateTimeFilter<"Course"> | Date | string
    updatedAt?: DateTimeFilter<"Course"> | Date | string
    preRequisite?: CourseToPreRequisiteListRelationFilter
    preRequisiteFor?: CourseToPreRequisiteListRelationFilter
    faculties?: CourseFacultyListRelationFilter
    offeredCourses?: OfferedCourseListRelationFilter
    studentEnrolledCourses?: StudentEnrolledCourseListRelationFilter
  }

  export type CourseOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    code?: SortOrder
    credits?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    preRequisite?: CourseToPreRequisiteOrderByRelationAggregateInput
    preRequisiteFor?: CourseToPreRequisiteOrderByRelationAggregateInput
    faculties?: CourseFacultyOrderByRelationAggregateInput
    offeredCourses?: OfferedCourseOrderByRelationAggregateInput
    studentEnrolledCourses?: StudentEnrolledCourseOrderByRelationAggregateInput
    _relevance?: CourseOrderByRelevanceInput
  }

  export type CourseWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CourseWhereInput | CourseWhereInput[]
    OR?: CourseWhereInput[]
    NOT?: CourseWhereInput | CourseWhereInput[]
    title?: StringFilter<"Course"> | string
    code?: StringFilter<"Course"> | string
    credits?: IntFilter<"Course"> | number
    createdAt?: DateTimeFilter<"Course"> | Date | string
    updatedAt?: DateTimeFilter<"Course"> | Date | string
    preRequisite?: CourseToPreRequisiteListRelationFilter
    preRequisiteFor?: CourseToPreRequisiteListRelationFilter
    faculties?: CourseFacultyListRelationFilter
    offeredCourses?: OfferedCourseListRelationFilter
    studentEnrolledCourses?: StudentEnrolledCourseListRelationFilter
  }, "id">

  export type CourseOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    code?: SortOrder
    credits?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CourseCountOrderByAggregateInput
    _avg?: CourseAvgOrderByAggregateInput
    _max?: CourseMaxOrderByAggregateInput
    _min?: CourseMinOrderByAggregateInput
    _sum?: CourseSumOrderByAggregateInput
  }

  export type CourseScalarWhereWithAggregatesInput = {
    AND?: CourseScalarWhereWithAggregatesInput | CourseScalarWhereWithAggregatesInput[]
    OR?: CourseScalarWhereWithAggregatesInput[]
    NOT?: CourseScalarWhereWithAggregatesInput | CourseScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Course"> | string
    title?: StringWithAggregatesFilter<"Course"> | string
    code?: StringWithAggregatesFilter<"Course"> | string
    credits?: IntWithAggregatesFilter<"Course"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Course"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Course"> | Date | string
  }

  export type CourseToPreRequisiteWhereInput = {
    AND?: CourseToPreRequisiteWhereInput | CourseToPreRequisiteWhereInput[]
    OR?: CourseToPreRequisiteWhereInput[]
    NOT?: CourseToPreRequisiteWhereInput | CourseToPreRequisiteWhereInput[]
    courseId?: StringFilter<"CourseToPreRequisite"> | string
    preRequisiteId?: StringFilter<"CourseToPreRequisite"> | string
    course?: XOR<CourseScalarRelationFilter, CourseWhereInput>
    preRequisite?: XOR<CourseScalarRelationFilter, CourseWhereInput>
  }

  export type CourseToPreRequisiteOrderByWithRelationInput = {
    courseId?: SortOrder
    preRequisiteId?: SortOrder
    course?: CourseOrderByWithRelationInput
    preRequisite?: CourseOrderByWithRelationInput
    _relevance?: CourseToPreRequisiteOrderByRelevanceInput
  }

  export type CourseToPreRequisiteWhereUniqueInput = Prisma.AtLeast<{
    courseId_preRequisiteId?: CourseToPreRequisiteCourseIdPreRequisiteIdCompoundUniqueInput
    AND?: CourseToPreRequisiteWhereInput | CourseToPreRequisiteWhereInput[]
    OR?: CourseToPreRequisiteWhereInput[]
    NOT?: CourseToPreRequisiteWhereInput | CourseToPreRequisiteWhereInput[]
    courseId?: StringFilter<"CourseToPreRequisite"> | string
    preRequisiteId?: StringFilter<"CourseToPreRequisite"> | string
    course?: XOR<CourseScalarRelationFilter, CourseWhereInput>
    preRequisite?: XOR<CourseScalarRelationFilter, CourseWhereInput>
  }, "courseId_preRequisiteId">

  export type CourseToPreRequisiteOrderByWithAggregationInput = {
    courseId?: SortOrder
    preRequisiteId?: SortOrder
    _count?: CourseToPreRequisiteCountOrderByAggregateInput
    _max?: CourseToPreRequisiteMaxOrderByAggregateInput
    _min?: CourseToPreRequisiteMinOrderByAggregateInput
  }

  export type CourseToPreRequisiteScalarWhereWithAggregatesInput = {
    AND?: CourseToPreRequisiteScalarWhereWithAggregatesInput | CourseToPreRequisiteScalarWhereWithAggregatesInput[]
    OR?: CourseToPreRequisiteScalarWhereWithAggregatesInput[]
    NOT?: CourseToPreRequisiteScalarWhereWithAggregatesInput | CourseToPreRequisiteScalarWhereWithAggregatesInput[]
    courseId?: StringWithAggregatesFilter<"CourseToPreRequisite"> | string
    preRequisiteId?: StringWithAggregatesFilter<"CourseToPreRequisite"> | string
  }

  export type CourseFacultyWhereInput = {
    AND?: CourseFacultyWhereInput | CourseFacultyWhereInput[]
    OR?: CourseFacultyWhereInput[]
    NOT?: CourseFacultyWhereInput | CourseFacultyWhereInput[]
    courseId?: StringFilter<"CourseFaculty"> | string
    facultyId?: StringFilter<"CourseFaculty"> | string
    course?: XOR<CourseScalarRelationFilter, CourseWhereInput>
    faculty?: XOR<FacultyScalarRelationFilter, FacultyWhereInput>
  }

  export type CourseFacultyOrderByWithRelationInput = {
    courseId?: SortOrder
    facultyId?: SortOrder
    course?: CourseOrderByWithRelationInput
    faculty?: FacultyOrderByWithRelationInput
    _relevance?: CourseFacultyOrderByRelevanceInput
  }

  export type CourseFacultyWhereUniqueInput = Prisma.AtLeast<{
    courseId_facultyId?: CourseFacultyCourseIdFacultyIdCompoundUniqueInput
    AND?: CourseFacultyWhereInput | CourseFacultyWhereInput[]
    OR?: CourseFacultyWhereInput[]
    NOT?: CourseFacultyWhereInput | CourseFacultyWhereInput[]
    courseId?: StringFilter<"CourseFaculty"> | string
    facultyId?: StringFilter<"CourseFaculty"> | string
    course?: XOR<CourseScalarRelationFilter, CourseWhereInput>
    faculty?: XOR<FacultyScalarRelationFilter, FacultyWhereInput>
  }, "courseId_facultyId">

  export type CourseFacultyOrderByWithAggregationInput = {
    courseId?: SortOrder
    facultyId?: SortOrder
    _count?: CourseFacultyCountOrderByAggregateInput
    _max?: CourseFacultyMaxOrderByAggregateInput
    _min?: CourseFacultyMinOrderByAggregateInput
  }

  export type CourseFacultyScalarWhereWithAggregatesInput = {
    AND?: CourseFacultyScalarWhereWithAggregatesInput | CourseFacultyScalarWhereWithAggregatesInput[]
    OR?: CourseFacultyScalarWhereWithAggregatesInput[]
    NOT?: CourseFacultyScalarWhereWithAggregatesInput | CourseFacultyScalarWhereWithAggregatesInput[]
    courseId?: StringWithAggregatesFilter<"CourseFaculty"> | string
    facultyId?: StringWithAggregatesFilter<"CourseFaculty"> | string
  }

  export type SemesterRegistrationWhereInput = {
    AND?: SemesterRegistrationWhereInput | SemesterRegistrationWhereInput[]
    OR?: SemesterRegistrationWhereInput[]
    NOT?: SemesterRegistrationWhereInput | SemesterRegistrationWhereInput[]
    id?: StringFilter<"SemesterRegistration"> | string
    startDate?: DateTimeFilter<"SemesterRegistration"> | Date | string
    endDate?: DateTimeFilter<"SemesterRegistration"> | Date | string
    status?: EnumSemesterRegistrationStatusNullableFilter<"SemesterRegistration"> | $Enums.SemesterRegistrationStatus | null
    paymentRecipt?: StringFilter<"SemesterRegistration"> | string
    totalPayment?: IntFilter<"SemesterRegistration"> | number
    createdAt?: DateTimeFilter<"SemesterRegistration"> | Date | string
    updateAt?: DateTimeFilter<"SemesterRegistration"> | Date | string
    academicSemesterId?: StringFilter<"SemesterRegistration"> | string
    academicSemester?: XOR<AcademicSemesterScalarRelationFilter, AcademicSemesterWhereInput>
    offeredCourses?: OfferedCourseListRelationFilter
    offeredCourseSections?: OfferedCourseSectionListRelationFilter
    offeredCourseClassSchedules?: OfferedCourseClassScheduleListRelationFilter
    studentSemesterRegistrations?: StudentSemesterRegistrationListRelationFilter
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseListRelationFilter
  }

  export type SemesterRegistrationOrderByWithRelationInput = {
    id?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    status?: SortOrderInput | SortOrder
    paymentRecipt?: SortOrder
    totalPayment?: SortOrder
    createdAt?: SortOrder
    updateAt?: SortOrder
    academicSemesterId?: SortOrder
    academicSemester?: AcademicSemesterOrderByWithRelationInput
    offeredCourses?: OfferedCourseOrderByRelationAggregateInput
    offeredCourseSections?: OfferedCourseSectionOrderByRelationAggregateInput
    offeredCourseClassSchedules?: OfferedCourseClassScheduleOrderByRelationAggregateInput
    studentSemesterRegistrations?: StudentSemesterRegistrationOrderByRelationAggregateInput
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseOrderByRelationAggregateInput
    _relevance?: SemesterRegistrationOrderByRelevanceInput
  }

  export type SemesterRegistrationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SemesterRegistrationWhereInput | SemesterRegistrationWhereInput[]
    OR?: SemesterRegistrationWhereInput[]
    NOT?: SemesterRegistrationWhereInput | SemesterRegistrationWhereInput[]
    startDate?: DateTimeFilter<"SemesterRegistration"> | Date | string
    endDate?: DateTimeFilter<"SemesterRegistration"> | Date | string
    status?: EnumSemesterRegistrationStatusNullableFilter<"SemesterRegistration"> | $Enums.SemesterRegistrationStatus | null
    paymentRecipt?: StringFilter<"SemesterRegistration"> | string
    totalPayment?: IntFilter<"SemesterRegistration"> | number
    createdAt?: DateTimeFilter<"SemesterRegistration"> | Date | string
    updateAt?: DateTimeFilter<"SemesterRegistration"> | Date | string
    academicSemesterId?: StringFilter<"SemesterRegistration"> | string
    academicSemester?: XOR<AcademicSemesterScalarRelationFilter, AcademicSemesterWhereInput>
    offeredCourses?: OfferedCourseListRelationFilter
    offeredCourseSections?: OfferedCourseSectionListRelationFilter
    offeredCourseClassSchedules?: OfferedCourseClassScheduleListRelationFilter
    studentSemesterRegistrations?: StudentSemesterRegistrationListRelationFilter
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseListRelationFilter
  }, "id">

  export type SemesterRegistrationOrderByWithAggregationInput = {
    id?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    status?: SortOrderInput | SortOrder
    paymentRecipt?: SortOrder
    totalPayment?: SortOrder
    createdAt?: SortOrder
    updateAt?: SortOrder
    academicSemesterId?: SortOrder
    _count?: SemesterRegistrationCountOrderByAggregateInput
    _avg?: SemesterRegistrationAvgOrderByAggregateInput
    _max?: SemesterRegistrationMaxOrderByAggregateInput
    _min?: SemesterRegistrationMinOrderByAggregateInput
    _sum?: SemesterRegistrationSumOrderByAggregateInput
  }

  export type SemesterRegistrationScalarWhereWithAggregatesInput = {
    AND?: SemesterRegistrationScalarWhereWithAggregatesInput | SemesterRegistrationScalarWhereWithAggregatesInput[]
    OR?: SemesterRegistrationScalarWhereWithAggregatesInput[]
    NOT?: SemesterRegistrationScalarWhereWithAggregatesInput | SemesterRegistrationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SemesterRegistration"> | string
    startDate?: DateTimeWithAggregatesFilter<"SemesterRegistration"> | Date | string
    endDate?: DateTimeWithAggregatesFilter<"SemesterRegistration"> | Date | string
    status?: EnumSemesterRegistrationStatusNullableWithAggregatesFilter<"SemesterRegistration"> | $Enums.SemesterRegistrationStatus | null
    paymentRecipt?: StringWithAggregatesFilter<"SemesterRegistration"> | string
    totalPayment?: IntWithAggregatesFilter<"SemesterRegistration"> | number
    createdAt?: DateTimeWithAggregatesFilter<"SemesterRegistration"> | Date | string
    updateAt?: DateTimeWithAggregatesFilter<"SemesterRegistration"> | Date | string
    academicSemesterId?: StringWithAggregatesFilter<"SemesterRegistration"> | string
  }

  export type AdmitionExameRegistrationWhereInput = {
    AND?: AdmitionExameRegistrationWhereInput | AdmitionExameRegistrationWhereInput[]
    OR?: AdmitionExameRegistrationWhereInput[]
    NOT?: AdmitionExameRegistrationWhereInput | AdmitionExameRegistrationWhereInput[]
    id?: StringFilter<"AdmitionExameRegistration"> | string
    applicantName?: StringFilter<"AdmitionExameRegistration"> | string
    paymentRecipt?: StringFilter<"AdmitionExameRegistration"> | string
    document?: StringFilter<"AdmitionExameRegistration"> | string
    paymentAmoute?: IntNullableFilter<"AdmitionExameRegistration"> | number | null
    aprovePayment?: BoolNullableFilter<"AdmitionExameRegistration"> | boolean | null
    exameResults?: IntNullableFilter<"AdmitionExameRegistration"> | number | null
    passed?: BoolNullableFilter<"AdmitionExameRegistration"> | boolean | null
    fase?: IntFilter<"AdmitionExameRegistration"> | number
    exameDate?: DateTimeFilter<"AdmitionExameRegistration"> | Date | string
    createdAt?: DateTimeFilter<"AdmitionExameRegistration"> | Date | string
    updateAt?: DateTimeFilter<"AdmitionExameRegistration"> | Date | string
    departmentId?: StringFilter<"AdmitionExameRegistration"> | string
    department?: XOR<AcademicDepartmentScalarRelationFilter, AcademicDepartmentWhereInput>
    Student?: XOR<StudentNullableScalarRelationFilter, StudentWhereInput> | null
  }

  export type AdmitionExameRegistrationOrderByWithRelationInput = {
    id?: SortOrder
    applicantName?: SortOrder
    paymentRecipt?: SortOrder
    document?: SortOrder
    paymentAmoute?: SortOrderInput | SortOrder
    aprovePayment?: SortOrderInput | SortOrder
    exameResults?: SortOrderInput | SortOrder
    passed?: SortOrderInput | SortOrder
    fase?: SortOrder
    exameDate?: SortOrder
    createdAt?: SortOrder
    updateAt?: SortOrder
    departmentId?: SortOrder
    department?: AcademicDepartmentOrderByWithRelationInput
    Student?: StudentOrderByWithRelationInput
    _relevance?: AdmitionExameRegistrationOrderByRelevanceInput
  }

  export type AdmitionExameRegistrationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    applicantName?: string
    AND?: AdmitionExameRegistrationWhereInput | AdmitionExameRegistrationWhereInput[]
    OR?: AdmitionExameRegistrationWhereInput[]
    NOT?: AdmitionExameRegistrationWhereInput | AdmitionExameRegistrationWhereInput[]
    paymentRecipt?: StringFilter<"AdmitionExameRegistration"> | string
    document?: StringFilter<"AdmitionExameRegistration"> | string
    paymentAmoute?: IntNullableFilter<"AdmitionExameRegistration"> | number | null
    aprovePayment?: BoolNullableFilter<"AdmitionExameRegistration"> | boolean | null
    exameResults?: IntNullableFilter<"AdmitionExameRegistration"> | number | null
    passed?: BoolNullableFilter<"AdmitionExameRegistration"> | boolean | null
    fase?: IntFilter<"AdmitionExameRegistration"> | number
    exameDate?: DateTimeFilter<"AdmitionExameRegistration"> | Date | string
    createdAt?: DateTimeFilter<"AdmitionExameRegistration"> | Date | string
    updateAt?: DateTimeFilter<"AdmitionExameRegistration"> | Date | string
    departmentId?: StringFilter<"AdmitionExameRegistration"> | string
    department?: XOR<AcademicDepartmentScalarRelationFilter, AcademicDepartmentWhereInput>
    Student?: XOR<StudentNullableScalarRelationFilter, StudentWhereInput> | null
  }, "id" | "applicantName">

  export type AdmitionExameRegistrationOrderByWithAggregationInput = {
    id?: SortOrder
    applicantName?: SortOrder
    paymentRecipt?: SortOrder
    document?: SortOrder
    paymentAmoute?: SortOrderInput | SortOrder
    aprovePayment?: SortOrderInput | SortOrder
    exameResults?: SortOrderInput | SortOrder
    passed?: SortOrderInput | SortOrder
    fase?: SortOrder
    exameDate?: SortOrder
    createdAt?: SortOrder
    updateAt?: SortOrder
    departmentId?: SortOrder
    _count?: AdmitionExameRegistrationCountOrderByAggregateInput
    _avg?: AdmitionExameRegistrationAvgOrderByAggregateInput
    _max?: AdmitionExameRegistrationMaxOrderByAggregateInput
    _min?: AdmitionExameRegistrationMinOrderByAggregateInput
    _sum?: AdmitionExameRegistrationSumOrderByAggregateInput
  }

  export type AdmitionExameRegistrationScalarWhereWithAggregatesInput = {
    AND?: AdmitionExameRegistrationScalarWhereWithAggregatesInput | AdmitionExameRegistrationScalarWhereWithAggregatesInput[]
    OR?: AdmitionExameRegistrationScalarWhereWithAggregatesInput[]
    NOT?: AdmitionExameRegistrationScalarWhereWithAggregatesInput | AdmitionExameRegistrationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AdmitionExameRegistration"> | string
    applicantName?: StringWithAggregatesFilter<"AdmitionExameRegistration"> | string
    paymentRecipt?: StringWithAggregatesFilter<"AdmitionExameRegistration"> | string
    document?: StringWithAggregatesFilter<"AdmitionExameRegistration"> | string
    paymentAmoute?: IntNullableWithAggregatesFilter<"AdmitionExameRegistration"> | number | null
    aprovePayment?: BoolNullableWithAggregatesFilter<"AdmitionExameRegistration"> | boolean | null
    exameResults?: IntNullableWithAggregatesFilter<"AdmitionExameRegistration"> | number | null
    passed?: BoolNullableWithAggregatesFilter<"AdmitionExameRegistration"> | boolean | null
    fase?: IntWithAggregatesFilter<"AdmitionExameRegistration"> | number
    exameDate?: DateTimeWithAggregatesFilter<"AdmitionExameRegistration"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"AdmitionExameRegistration"> | Date | string
    updateAt?: DateTimeWithAggregatesFilter<"AdmitionExameRegistration"> | Date | string
    departmentId?: StringWithAggregatesFilter<"AdmitionExameRegistration"> | string
  }

  export type OfferedCourseWhereInput = {
    AND?: OfferedCourseWhereInput | OfferedCourseWhereInput[]
    OR?: OfferedCourseWhereInput[]
    NOT?: OfferedCourseWhereInput | OfferedCourseWhereInput[]
    id?: StringFilter<"OfferedCourse"> | string
    academicDepartmentId?: StringFilter<"OfferedCourse"> | string
    courseId?: StringFilter<"OfferedCourse"> | string
    semesterRegistrationId?: StringFilter<"OfferedCourse"> | string
    academicDepartment?: XOR<AcademicDepartmentScalarRelationFilter, AcademicDepartmentWhereInput>
    semesterRegistration?: XOR<SemesterRegistrationScalarRelationFilter, SemesterRegistrationWhereInput>
    course?: XOR<CourseScalarRelationFilter, CourseWhereInput>
    offeredCourseSections?: OfferedCourseSectionListRelationFilter
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseListRelationFilter
  }

  export type OfferedCourseOrderByWithRelationInput = {
    id?: SortOrder
    academicDepartmentId?: SortOrder
    courseId?: SortOrder
    semesterRegistrationId?: SortOrder
    academicDepartment?: AcademicDepartmentOrderByWithRelationInput
    semesterRegistration?: SemesterRegistrationOrderByWithRelationInput
    course?: CourseOrderByWithRelationInput
    offeredCourseSections?: OfferedCourseSectionOrderByRelationAggregateInput
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseOrderByRelationAggregateInput
    _relevance?: OfferedCourseOrderByRelevanceInput
  }

  export type OfferedCourseWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: OfferedCourseWhereInput | OfferedCourseWhereInput[]
    OR?: OfferedCourseWhereInput[]
    NOT?: OfferedCourseWhereInput | OfferedCourseWhereInput[]
    academicDepartmentId?: StringFilter<"OfferedCourse"> | string
    courseId?: StringFilter<"OfferedCourse"> | string
    semesterRegistrationId?: StringFilter<"OfferedCourse"> | string
    academicDepartment?: XOR<AcademicDepartmentScalarRelationFilter, AcademicDepartmentWhereInput>
    semesterRegistration?: XOR<SemesterRegistrationScalarRelationFilter, SemesterRegistrationWhereInput>
    course?: XOR<CourseScalarRelationFilter, CourseWhereInput>
    offeredCourseSections?: OfferedCourseSectionListRelationFilter
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseListRelationFilter
  }, "id">

  export type OfferedCourseOrderByWithAggregationInput = {
    id?: SortOrder
    academicDepartmentId?: SortOrder
    courseId?: SortOrder
    semesterRegistrationId?: SortOrder
    _count?: OfferedCourseCountOrderByAggregateInput
    _max?: OfferedCourseMaxOrderByAggregateInput
    _min?: OfferedCourseMinOrderByAggregateInput
  }

  export type OfferedCourseScalarWhereWithAggregatesInput = {
    AND?: OfferedCourseScalarWhereWithAggregatesInput | OfferedCourseScalarWhereWithAggregatesInput[]
    OR?: OfferedCourseScalarWhereWithAggregatesInput[]
    NOT?: OfferedCourseScalarWhereWithAggregatesInput | OfferedCourseScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"OfferedCourse"> | string
    academicDepartmentId?: StringWithAggregatesFilter<"OfferedCourse"> | string
    courseId?: StringWithAggregatesFilter<"OfferedCourse"> | string
    semesterRegistrationId?: StringWithAggregatesFilter<"OfferedCourse"> | string
  }

  export type OfferedCourseSectionWhereInput = {
    AND?: OfferedCourseSectionWhereInput | OfferedCourseSectionWhereInput[]
    OR?: OfferedCourseSectionWhereInput[]
    NOT?: OfferedCourseSectionWhereInput | OfferedCourseSectionWhereInput[]
    id?: StringFilter<"OfferedCourseSection"> | string
    title?: StringFilter<"OfferedCourseSection"> | string
    maxCapacity?: IntFilter<"OfferedCourseSection"> | number
    currentlyEnrolledStudent?: IntFilter<"OfferedCourseSection"> | number
    createdAt?: DateTimeFilter<"OfferedCourseSection"> | Date | string
    updatedAt?: DateTimeFilter<"OfferedCourseSection"> | Date | string
    semesterRegistrationId?: StringFilter<"OfferedCourseSection"> | string
    offeredCourseId?: StringFilter<"OfferedCourseSection"> | string
    semesterRegistration?: XOR<SemesterRegistrationScalarRelationFilter, SemesterRegistrationWhereInput>
    offeredCourse?: XOR<OfferedCourseScalarRelationFilter, OfferedCourseWhereInput>
    offeredCourseClassSchedules?: OfferedCourseClassScheduleListRelationFilter
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseListRelationFilter
  }

  export type OfferedCourseSectionOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    maxCapacity?: SortOrder
    currentlyEnrolledStudent?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    semesterRegistrationId?: SortOrder
    offeredCourseId?: SortOrder
    semesterRegistration?: SemesterRegistrationOrderByWithRelationInput
    offeredCourse?: OfferedCourseOrderByWithRelationInput
    offeredCourseClassSchedules?: OfferedCourseClassScheduleOrderByRelationAggregateInput
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseOrderByRelationAggregateInput
    _relevance?: OfferedCourseSectionOrderByRelevanceInput
  }

  export type OfferedCourseSectionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: OfferedCourseSectionWhereInput | OfferedCourseSectionWhereInput[]
    OR?: OfferedCourseSectionWhereInput[]
    NOT?: OfferedCourseSectionWhereInput | OfferedCourseSectionWhereInput[]
    title?: StringFilter<"OfferedCourseSection"> | string
    maxCapacity?: IntFilter<"OfferedCourseSection"> | number
    currentlyEnrolledStudent?: IntFilter<"OfferedCourseSection"> | number
    createdAt?: DateTimeFilter<"OfferedCourseSection"> | Date | string
    updatedAt?: DateTimeFilter<"OfferedCourseSection"> | Date | string
    semesterRegistrationId?: StringFilter<"OfferedCourseSection"> | string
    offeredCourseId?: StringFilter<"OfferedCourseSection"> | string
    semesterRegistration?: XOR<SemesterRegistrationScalarRelationFilter, SemesterRegistrationWhereInput>
    offeredCourse?: XOR<OfferedCourseScalarRelationFilter, OfferedCourseWhereInput>
    offeredCourseClassSchedules?: OfferedCourseClassScheduleListRelationFilter
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseListRelationFilter
  }, "id">

  export type OfferedCourseSectionOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    maxCapacity?: SortOrder
    currentlyEnrolledStudent?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    semesterRegistrationId?: SortOrder
    offeredCourseId?: SortOrder
    _count?: OfferedCourseSectionCountOrderByAggregateInput
    _avg?: OfferedCourseSectionAvgOrderByAggregateInput
    _max?: OfferedCourseSectionMaxOrderByAggregateInput
    _min?: OfferedCourseSectionMinOrderByAggregateInput
    _sum?: OfferedCourseSectionSumOrderByAggregateInput
  }

  export type OfferedCourseSectionScalarWhereWithAggregatesInput = {
    AND?: OfferedCourseSectionScalarWhereWithAggregatesInput | OfferedCourseSectionScalarWhereWithAggregatesInput[]
    OR?: OfferedCourseSectionScalarWhereWithAggregatesInput[]
    NOT?: OfferedCourseSectionScalarWhereWithAggregatesInput | OfferedCourseSectionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"OfferedCourseSection"> | string
    title?: StringWithAggregatesFilter<"OfferedCourseSection"> | string
    maxCapacity?: IntWithAggregatesFilter<"OfferedCourseSection"> | number
    currentlyEnrolledStudent?: IntWithAggregatesFilter<"OfferedCourseSection"> | number
    createdAt?: DateTimeWithAggregatesFilter<"OfferedCourseSection"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"OfferedCourseSection"> | Date | string
    semesterRegistrationId?: StringWithAggregatesFilter<"OfferedCourseSection"> | string
    offeredCourseId?: StringWithAggregatesFilter<"OfferedCourseSection"> | string
  }

  export type OfferedCourseClassScheduleWhereInput = {
    AND?: OfferedCourseClassScheduleWhereInput | OfferedCourseClassScheduleWhereInput[]
    OR?: OfferedCourseClassScheduleWhereInput[]
    NOT?: OfferedCourseClassScheduleWhereInput | OfferedCourseClassScheduleWhereInput[]
    id?: StringFilter<"OfferedCourseClassSchedule"> | string
    startTime?: StringFilter<"OfferedCourseClassSchedule"> | string
    endTime?: StringFilter<"OfferedCourseClassSchedule"> | string
    dayOfWeek?: EnumWeekDaysFilter<"OfferedCourseClassSchedule"> | $Enums.WeekDays
    createdAt?: DateTimeFilter<"OfferedCourseClassSchedule"> | Date | string
    updatedAt?: DateTimeFilter<"OfferedCourseClassSchedule"> | Date | string
    offeredCourseSectionId?: StringFilter<"OfferedCourseClassSchedule"> | string
    semesterRegistrationId?: StringFilter<"OfferedCourseClassSchedule"> | string
    roomId?: StringFilter<"OfferedCourseClassSchedule"> | string
    facultyId?: StringFilter<"OfferedCourseClassSchedule"> | string
    offeredCourseSection?: XOR<OfferedCourseSectionScalarRelationFilter, OfferedCourseSectionWhereInput>
    semesterRegistration?: XOR<SemesterRegistrationScalarRelationFilter, SemesterRegistrationWhereInput>
    room?: XOR<RoomScalarRelationFilter, RoomWhereInput>
    faculty?: XOR<FacultyScalarRelationFilter, FacultyWhereInput>
  }

  export type OfferedCourseClassScheduleOrderByWithRelationInput = {
    id?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    dayOfWeek?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    offeredCourseSectionId?: SortOrder
    semesterRegistrationId?: SortOrder
    roomId?: SortOrder
    facultyId?: SortOrder
    offeredCourseSection?: OfferedCourseSectionOrderByWithRelationInput
    semesterRegistration?: SemesterRegistrationOrderByWithRelationInput
    room?: RoomOrderByWithRelationInput
    faculty?: FacultyOrderByWithRelationInput
    _relevance?: OfferedCourseClassScheduleOrderByRelevanceInput
  }

  export type OfferedCourseClassScheduleWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: OfferedCourseClassScheduleWhereInput | OfferedCourseClassScheduleWhereInput[]
    OR?: OfferedCourseClassScheduleWhereInput[]
    NOT?: OfferedCourseClassScheduleWhereInput | OfferedCourseClassScheduleWhereInput[]
    startTime?: StringFilter<"OfferedCourseClassSchedule"> | string
    endTime?: StringFilter<"OfferedCourseClassSchedule"> | string
    dayOfWeek?: EnumWeekDaysFilter<"OfferedCourseClassSchedule"> | $Enums.WeekDays
    createdAt?: DateTimeFilter<"OfferedCourseClassSchedule"> | Date | string
    updatedAt?: DateTimeFilter<"OfferedCourseClassSchedule"> | Date | string
    offeredCourseSectionId?: StringFilter<"OfferedCourseClassSchedule"> | string
    semesterRegistrationId?: StringFilter<"OfferedCourseClassSchedule"> | string
    roomId?: StringFilter<"OfferedCourseClassSchedule"> | string
    facultyId?: StringFilter<"OfferedCourseClassSchedule"> | string
    offeredCourseSection?: XOR<OfferedCourseSectionScalarRelationFilter, OfferedCourseSectionWhereInput>
    semesterRegistration?: XOR<SemesterRegistrationScalarRelationFilter, SemesterRegistrationWhereInput>
    room?: XOR<RoomScalarRelationFilter, RoomWhereInput>
    faculty?: XOR<FacultyScalarRelationFilter, FacultyWhereInput>
  }, "id">

  export type OfferedCourseClassScheduleOrderByWithAggregationInput = {
    id?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    dayOfWeek?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    offeredCourseSectionId?: SortOrder
    semesterRegistrationId?: SortOrder
    roomId?: SortOrder
    facultyId?: SortOrder
    _count?: OfferedCourseClassScheduleCountOrderByAggregateInput
    _max?: OfferedCourseClassScheduleMaxOrderByAggregateInput
    _min?: OfferedCourseClassScheduleMinOrderByAggregateInput
  }

  export type OfferedCourseClassScheduleScalarWhereWithAggregatesInput = {
    AND?: OfferedCourseClassScheduleScalarWhereWithAggregatesInput | OfferedCourseClassScheduleScalarWhereWithAggregatesInput[]
    OR?: OfferedCourseClassScheduleScalarWhereWithAggregatesInput[]
    NOT?: OfferedCourseClassScheduleScalarWhereWithAggregatesInput | OfferedCourseClassScheduleScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"OfferedCourseClassSchedule"> | string
    startTime?: StringWithAggregatesFilter<"OfferedCourseClassSchedule"> | string
    endTime?: StringWithAggregatesFilter<"OfferedCourseClassSchedule"> | string
    dayOfWeek?: EnumWeekDaysWithAggregatesFilter<"OfferedCourseClassSchedule"> | $Enums.WeekDays
    createdAt?: DateTimeWithAggregatesFilter<"OfferedCourseClassSchedule"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"OfferedCourseClassSchedule"> | Date | string
    offeredCourseSectionId?: StringWithAggregatesFilter<"OfferedCourseClassSchedule"> | string
    semesterRegistrationId?: StringWithAggregatesFilter<"OfferedCourseClassSchedule"> | string
    roomId?: StringWithAggregatesFilter<"OfferedCourseClassSchedule"> | string
    facultyId?: StringWithAggregatesFilter<"OfferedCourseClassSchedule"> | string
  }

  export type StudentSemesterRegistrationWhereInput = {
    AND?: StudentSemesterRegistrationWhereInput | StudentSemesterRegistrationWhereInput[]
    OR?: StudentSemesterRegistrationWhereInput[]
    NOT?: StudentSemesterRegistrationWhereInput | StudentSemesterRegistrationWhereInput[]
    id?: StringFilter<"StudentSemesterRegistration"> | string
    isConfirmed?: BoolNullableFilter<"StudentSemesterRegistration"> | boolean | null
    totalCreditsTaken?: IntNullableFilter<"StudentSemesterRegistration"> | number | null
    paymentRecipt?: StringNullableFilter<"StudentSemesterRegistration"> | string | null
    createdAt?: DateTimeFilter<"StudentSemesterRegistration"> | Date | string
    updatedAt?: DateTimeFilter<"StudentSemesterRegistration"> | Date | string
    studentId?: StringFilter<"StudentSemesterRegistration"> | string
    semesterRegistrationId?: StringFilter<"StudentSemesterRegistration"> | string
    student?: XOR<StudentScalarRelationFilter, StudentWhereInput>
    semesterRegistration?: XOR<SemesterRegistrationScalarRelationFilter, SemesterRegistrationWhereInput>
  }

  export type StudentSemesterRegistrationOrderByWithRelationInput = {
    id?: SortOrder
    isConfirmed?: SortOrderInput | SortOrder
    totalCreditsTaken?: SortOrderInput | SortOrder
    paymentRecipt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    studentId?: SortOrder
    semesterRegistrationId?: SortOrder
    student?: StudentOrderByWithRelationInput
    semesterRegistration?: SemesterRegistrationOrderByWithRelationInput
    _relevance?: StudentSemesterRegistrationOrderByRelevanceInput
  }

  export type StudentSemesterRegistrationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: StudentSemesterRegistrationWhereInput | StudentSemesterRegistrationWhereInput[]
    OR?: StudentSemesterRegistrationWhereInput[]
    NOT?: StudentSemesterRegistrationWhereInput | StudentSemesterRegistrationWhereInput[]
    isConfirmed?: BoolNullableFilter<"StudentSemesterRegistration"> | boolean | null
    totalCreditsTaken?: IntNullableFilter<"StudentSemesterRegistration"> | number | null
    paymentRecipt?: StringNullableFilter<"StudentSemesterRegistration"> | string | null
    createdAt?: DateTimeFilter<"StudentSemesterRegistration"> | Date | string
    updatedAt?: DateTimeFilter<"StudentSemesterRegistration"> | Date | string
    studentId?: StringFilter<"StudentSemesterRegistration"> | string
    semesterRegistrationId?: StringFilter<"StudentSemesterRegistration"> | string
    student?: XOR<StudentScalarRelationFilter, StudentWhereInput>
    semesterRegistration?: XOR<SemesterRegistrationScalarRelationFilter, SemesterRegistrationWhereInput>
  }, "id">

  export type StudentSemesterRegistrationOrderByWithAggregationInput = {
    id?: SortOrder
    isConfirmed?: SortOrderInput | SortOrder
    totalCreditsTaken?: SortOrderInput | SortOrder
    paymentRecipt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    studentId?: SortOrder
    semesterRegistrationId?: SortOrder
    _count?: StudentSemesterRegistrationCountOrderByAggregateInput
    _avg?: StudentSemesterRegistrationAvgOrderByAggregateInput
    _max?: StudentSemesterRegistrationMaxOrderByAggregateInput
    _min?: StudentSemesterRegistrationMinOrderByAggregateInput
    _sum?: StudentSemesterRegistrationSumOrderByAggregateInput
  }

  export type StudentSemesterRegistrationScalarWhereWithAggregatesInput = {
    AND?: StudentSemesterRegistrationScalarWhereWithAggregatesInput | StudentSemesterRegistrationScalarWhereWithAggregatesInput[]
    OR?: StudentSemesterRegistrationScalarWhereWithAggregatesInput[]
    NOT?: StudentSemesterRegistrationScalarWhereWithAggregatesInput | StudentSemesterRegistrationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"StudentSemesterRegistration"> | string
    isConfirmed?: BoolNullableWithAggregatesFilter<"StudentSemesterRegistration"> | boolean | null
    totalCreditsTaken?: IntNullableWithAggregatesFilter<"StudentSemesterRegistration"> | number | null
    paymentRecipt?: StringNullableWithAggregatesFilter<"StudentSemesterRegistration"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"StudentSemesterRegistration"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"StudentSemesterRegistration"> | Date | string
    studentId?: StringWithAggregatesFilter<"StudentSemesterRegistration"> | string
    semesterRegistrationId?: StringWithAggregatesFilter<"StudentSemesterRegistration"> | string
  }

  export type StudentSemesterRegistrationCourseWhereInput = {
    AND?: StudentSemesterRegistrationCourseWhereInput | StudentSemesterRegistrationCourseWhereInput[]
    OR?: StudentSemesterRegistrationCourseWhereInput[]
    NOT?: StudentSemesterRegistrationCourseWhereInput | StudentSemesterRegistrationCourseWhereInput[]
    semesterRegistrationId?: StringFilter<"StudentSemesterRegistrationCourse"> | string
    studentId?: StringFilter<"StudentSemesterRegistrationCourse"> | string
    offeredCourseId?: StringFilter<"StudentSemesterRegistrationCourse"> | string
    offeredCourseSectionId?: StringFilter<"StudentSemesterRegistrationCourse"> | string
    createdAt?: DateTimeFilter<"StudentSemesterRegistrationCourse"> | Date | string
    updatedAt?: DateTimeFilter<"StudentSemesterRegistrationCourse"> | Date | string
    semesterRegistration?: XOR<SemesterRegistrationScalarRelationFilter, SemesterRegistrationWhereInput>
    student?: XOR<StudentScalarRelationFilter, StudentWhereInput>
    offeredCourse?: XOR<OfferedCourseScalarRelationFilter, OfferedCourseWhereInput>
    offeredCourseSection?: XOR<OfferedCourseSectionScalarRelationFilter, OfferedCourseSectionWhereInput>
  }

  export type StudentSemesterRegistrationCourseOrderByWithRelationInput = {
    semesterRegistrationId?: SortOrder
    studentId?: SortOrder
    offeredCourseId?: SortOrder
    offeredCourseSectionId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    semesterRegistration?: SemesterRegistrationOrderByWithRelationInput
    student?: StudentOrderByWithRelationInput
    offeredCourse?: OfferedCourseOrderByWithRelationInput
    offeredCourseSection?: OfferedCourseSectionOrderByWithRelationInput
    _relevance?: StudentSemesterRegistrationCourseOrderByRelevanceInput
  }

  export type StudentSemesterRegistrationCourseWhereUniqueInput = Prisma.AtLeast<{
    semesterRegistrationId_studentId_offeredCourseId?: StudentSemesterRegistrationCourseSemesterRegistrationIdStudentIdOfferedCourseIdCompoundUniqueInput
    AND?: StudentSemesterRegistrationCourseWhereInput | StudentSemesterRegistrationCourseWhereInput[]
    OR?: StudentSemesterRegistrationCourseWhereInput[]
    NOT?: StudentSemesterRegistrationCourseWhereInput | StudentSemesterRegistrationCourseWhereInput[]
    semesterRegistrationId?: StringFilter<"StudentSemesterRegistrationCourse"> | string
    studentId?: StringFilter<"StudentSemesterRegistrationCourse"> | string
    offeredCourseId?: StringFilter<"StudentSemesterRegistrationCourse"> | string
    offeredCourseSectionId?: StringFilter<"StudentSemesterRegistrationCourse"> | string
    createdAt?: DateTimeFilter<"StudentSemesterRegistrationCourse"> | Date | string
    updatedAt?: DateTimeFilter<"StudentSemesterRegistrationCourse"> | Date | string
    semesterRegistration?: XOR<SemesterRegistrationScalarRelationFilter, SemesterRegistrationWhereInput>
    student?: XOR<StudentScalarRelationFilter, StudentWhereInput>
    offeredCourse?: XOR<OfferedCourseScalarRelationFilter, OfferedCourseWhereInput>
    offeredCourseSection?: XOR<OfferedCourseSectionScalarRelationFilter, OfferedCourseSectionWhereInput>
  }, "semesterRegistrationId_studentId_offeredCourseId">

  export type StudentSemesterRegistrationCourseOrderByWithAggregationInput = {
    semesterRegistrationId?: SortOrder
    studentId?: SortOrder
    offeredCourseId?: SortOrder
    offeredCourseSectionId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: StudentSemesterRegistrationCourseCountOrderByAggregateInput
    _max?: StudentSemesterRegistrationCourseMaxOrderByAggregateInput
    _min?: StudentSemesterRegistrationCourseMinOrderByAggregateInput
  }

  export type StudentSemesterRegistrationCourseScalarWhereWithAggregatesInput = {
    AND?: StudentSemesterRegistrationCourseScalarWhereWithAggregatesInput | StudentSemesterRegistrationCourseScalarWhereWithAggregatesInput[]
    OR?: StudentSemesterRegistrationCourseScalarWhereWithAggregatesInput[]
    NOT?: StudentSemesterRegistrationCourseScalarWhereWithAggregatesInput | StudentSemesterRegistrationCourseScalarWhereWithAggregatesInput[]
    semesterRegistrationId?: StringWithAggregatesFilter<"StudentSemesterRegistrationCourse"> | string
    studentId?: StringWithAggregatesFilter<"StudentSemesterRegistrationCourse"> | string
    offeredCourseId?: StringWithAggregatesFilter<"StudentSemesterRegistrationCourse"> | string
    offeredCourseSectionId?: StringWithAggregatesFilter<"StudentSemesterRegistrationCourse"> | string
    createdAt?: DateTimeWithAggregatesFilter<"StudentSemesterRegistrationCourse"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"StudentSemesterRegistrationCourse"> | Date | string
  }

  export type StudentEnrolledCourseWhereInput = {
    AND?: StudentEnrolledCourseWhereInput | StudentEnrolledCourseWhereInput[]
    OR?: StudentEnrolledCourseWhereInput[]
    NOT?: StudentEnrolledCourseWhereInput | StudentEnrolledCourseWhereInput[]
    id?: StringFilter<"StudentEnrolledCourse"> | string
    grade?: StringNullableFilter<"StudentEnrolledCourse"> | string | null
    point?: FloatNullableFilter<"StudentEnrolledCourse"> | number | null
    totalMarks?: IntNullableFilter<"StudentEnrolledCourse"> | number | null
    status?: EnumStudentEnrolledCourseStatusNullableFilter<"StudentEnrolledCourse"> | $Enums.StudentEnrolledCourseStatus | null
    createdAt?: DateTimeFilter<"StudentEnrolledCourse"> | Date | string
    updatedAt?: DateTimeFilter<"StudentEnrolledCourse"> | Date | string
    studentId?: StringFilter<"StudentEnrolledCourse"> | string
    academicSemesterId?: StringFilter<"StudentEnrolledCourse"> | string
    courseId?: StringFilter<"StudentEnrolledCourse"> | string
    student?: XOR<StudentScalarRelationFilter, StudentWhereInput>
    academicSemester?: XOR<AcademicSemesterScalarRelationFilter, AcademicSemesterWhereInput>
    course?: XOR<CourseScalarRelationFilter, CourseWhereInput>
    studentEnrolledCourseMarks?: StudentEnrolledCourseMarkListRelationFilter
  }

  export type StudentEnrolledCourseOrderByWithRelationInput = {
    id?: SortOrder
    grade?: SortOrderInput | SortOrder
    point?: SortOrderInput | SortOrder
    totalMarks?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    studentId?: SortOrder
    academicSemesterId?: SortOrder
    courseId?: SortOrder
    student?: StudentOrderByWithRelationInput
    academicSemester?: AcademicSemesterOrderByWithRelationInput
    course?: CourseOrderByWithRelationInput
    studentEnrolledCourseMarks?: StudentEnrolledCourseMarkOrderByRelationAggregateInput
    _relevance?: StudentEnrolledCourseOrderByRelevanceInput
  }

  export type StudentEnrolledCourseWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: StudentEnrolledCourseWhereInput | StudentEnrolledCourseWhereInput[]
    OR?: StudentEnrolledCourseWhereInput[]
    NOT?: StudentEnrolledCourseWhereInput | StudentEnrolledCourseWhereInput[]
    grade?: StringNullableFilter<"StudentEnrolledCourse"> | string | null
    point?: FloatNullableFilter<"StudentEnrolledCourse"> | number | null
    totalMarks?: IntNullableFilter<"StudentEnrolledCourse"> | number | null
    status?: EnumStudentEnrolledCourseStatusNullableFilter<"StudentEnrolledCourse"> | $Enums.StudentEnrolledCourseStatus | null
    createdAt?: DateTimeFilter<"StudentEnrolledCourse"> | Date | string
    updatedAt?: DateTimeFilter<"StudentEnrolledCourse"> | Date | string
    studentId?: StringFilter<"StudentEnrolledCourse"> | string
    academicSemesterId?: StringFilter<"StudentEnrolledCourse"> | string
    courseId?: StringFilter<"StudentEnrolledCourse"> | string
    student?: XOR<StudentScalarRelationFilter, StudentWhereInput>
    academicSemester?: XOR<AcademicSemesterScalarRelationFilter, AcademicSemesterWhereInput>
    course?: XOR<CourseScalarRelationFilter, CourseWhereInput>
    studentEnrolledCourseMarks?: StudentEnrolledCourseMarkListRelationFilter
  }, "id">

  export type StudentEnrolledCourseOrderByWithAggregationInput = {
    id?: SortOrder
    grade?: SortOrderInput | SortOrder
    point?: SortOrderInput | SortOrder
    totalMarks?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    studentId?: SortOrder
    academicSemesterId?: SortOrder
    courseId?: SortOrder
    _count?: StudentEnrolledCourseCountOrderByAggregateInput
    _avg?: StudentEnrolledCourseAvgOrderByAggregateInput
    _max?: StudentEnrolledCourseMaxOrderByAggregateInput
    _min?: StudentEnrolledCourseMinOrderByAggregateInput
    _sum?: StudentEnrolledCourseSumOrderByAggregateInput
  }

  export type StudentEnrolledCourseScalarWhereWithAggregatesInput = {
    AND?: StudentEnrolledCourseScalarWhereWithAggregatesInput | StudentEnrolledCourseScalarWhereWithAggregatesInput[]
    OR?: StudentEnrolledCourseScalarWhereWithAggregatesInput[]
    NOT?: StudentEnrolledCourseScalarWhereWithAggregatesInput | StudentEnrolledCourseScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"StudentEnrolledCourse"> | string
    grade?: StringNullableWithAggregatesFilter<"StudentEnrolledCourse"> | string | null
    point?: FloatNullableWithAggregatesFilter<"StudentEnrolledCourse"> | number | null
    totalMarks?: IntNullableWithAggregatesFilter<"StudentEnrolledCourse"> | number | null
    status?: EnumStudentEnrolledCourseStatusNullableWithAggregatesFilter<"StudentEnrolledCourse"> | $Enums.StudentEnrolledCourseStatus | null
    createdAt?: DateTimeWithAggregatesFilter<"StudentEnrolledCourse"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"StudentEnrolledCourse"> | Date | string
    studentId?: StringWithAggregatesFilter<"StudentEnrolledCourse"> | string
    academicSemesterId?: StringWithAggregatesFilter<"StudentEnrolledCourse"> | string
    courseId?: StringWithAggregatesFilter<"StudentEnrolledCourse"> | string
  }

  export type StudentEnrolledCourseMarkWhereInput = {
    AND?: StudentEnrolledCourseMarkWhereInput | StudentEnrolledCourseMarkWhereInput[]
    OR?: StudentEnrolledCourseMarkWhereInput[]
    NOT?: StudentEnrolledCourseMarkWhereInput | StudentEnrolledCourseMarkWhereInput[]
    id?: StringFilter<"StudentEnrolledCourseMark"> | string
    examType?: EnumExamTypeNullableFilter<"StudentEnrolledCourseMark"> | $Enums.ExamType | null
    createdAt?: DateTimeFilter<"StudentEnrolledCourseMark"> | Date | string
    updatedAt?: DateTimeFilter<"StudentEnrolledCourseMark"> | Date | string
    studentId?: StringFilter<"StudentEnrolledCourseMark"> | string
    studentEnrolledCourseId?: StringFilter<"StudentEnrolledCourseMark"> | string
    academicSemesterId?: StringFilter<"StudentEnrolledCourseMark"> | string
    exam1?: FloatFilter<"StudentEnrolledCourseMark"> | number
    exam2?: FloatFilter<"StudentEnrolledCourseMark"> | number
    exam3?: FloatFilter<"StudentEnrolledCourseMark"> | number
    exam4?: FloatFilter<"StudentEnrolledCourseMark"> | number
    exam5?: FloatFilter<"StudentEnrolledCourseMark"> | number
    exam6?: FloatFilter<"StudentEnrolledCourseMark"> | number
    finalExam?: FloatFilter<"StudentEnrolledCourseMark"> | number
    totalMarks?: FloatFilter<"StudentEnrolledCourseMark"> | number
    grade?: FloatFilter<"StudentEnrolledCourseMark"> | number
    student?: XOR<StudentScalarRelationFilter, StudentWhereInput>
    studentEnrolledCourse?: XOR<StudentEnrolledCourseScalarRelationFilter, StudentEnrolledCourseWhereInput>
    academicSemester?: XOR<AcademicSemesterScalarRelationFilter, AcademicSemesterWhereInput>
  }

  export type StudentEnrolledCourseMarkOrderByWithRelationInput = {
    id?: SortOrder
    examType?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    studentId?: SortOrder
    studentEnrolledCourseId?: SortOrder
    academicSemesterId?: SortOrder
    exam1?: SortOrder
    exam2?: SortOrder
    exam3?: SortOrder
    exam4?: SortOrder
    exam5?: SortOrder
    exam6?: SortOrder
    finalExam?: SortOrder
    totalMarks?: SortOrder
    grade?: SortOrder
    student?: StudentOrderByWithRelationInput
    studentEnrolledCourse?: StudentEnrolledCourseOrderByWithRelationInput
    academicSemester?: AcademicSemesterOrderByWithRelationInput
    _relevance?: StudentEnrolledCourseMarkOrderByRelevanceInput
  }

  export type StudentEnrolledCourseMarkWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: StudentEnrolledCourseMarkWhereInput | StudentEnrolledCourseMarkWhereInput[]
    OR?: StudentEnrolledCourseMarkWhereInput[]
    NOT?: StudentEnrolledCourseMarkWhereInput | StudentEnrolledCourseMarkWhereInput[]
    examType?: EnumExamTypeNullableFilter<"StudentEnrolledCourseMark"> | $Enums.ExamType | null
    createdAt?: DateTimeFilter<"StudentEnrolledCourseMark"> | Date | string
    updatedAt?: DateTimeFilter<"StudentEnrolledCourseMark"> | Date | string
    studentId?: StringFilter<"StudentEnrolledCourseMark"> | string
    studentEnrolledCourseId?: StringFilter<"StudentEnrolledCourseMark"> | string
    academicSemesterId?: StringFilter<"StudentEnrolledCourseMark"> | string
    exam1?: FloatFilter<"StudentEnrolledCourseMark"> | number
    exam2?: FloatFilter<"StudentEnrolledCourseMark"> | number
    exam3?: FloatFilter<"StudentEnrolledCourseMark"> | number
    exam4?: FloatFilter<"StudentEnrolledCourseMark"> | number
    exam5?: FloatFilter<"StudentEnrolledCourseMark"> | number
    exam6?: FloatFilter<"StudentEnrolledCourseMark"> | number
    finalExam?: FloatFilter<"StudentEnrolledCourseMark"> | number
    totalMarks?: FloatFilter<"StudentEnrolledCourseMark"> | number
    grade?: FloatFilter<"StudentEnrolledCourseMark"> | number
    student?: XOR<StudentScalarRelationFilter, StudentWhereInput>
    studentEnrolledCourse?: XOR<StudentEnrolledCourseScalarRelationFilter, StudentEnrolledCourseWhereInput>
    academicSemester?: XOR<AcademicSemesterScalarRelationFilter, AcademicSemesterWhereInput>
  }, "id">

  export type StudentEnrolledCourseMarkOrderByWithAggregationInput = {
    id?: SortOrder
    examType?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    studentId?: SortOrder
    studentEnrolledCourseId?: SortOrder
    academicSemesterId?: SortOrder
    exam1?: SortOrder
    exam2?: SortOrder
    exam3?: SortOrder
    exam4?: SortOrder
    exam5?: SortOrder
    exam6?: SortOrder
    finalExam?: SortOrder
    totalMarks?: SortOrder
    grade?: SortOrder
    _count?: StudentEnrolledCourseMarkCountOrderByAggregateInput
    _avg?: StudentEnrolledCourseMarkAvgOrderByAggregateInput
    _max?: StudentEnrolledCourseMarkMaxOrderByAggregateInput
    _min?: StudentEnrolledCourseMarkMinOrderByAggregateInput
    _sum?: StudentEnrolledCourseMarkSumOrderByAggregateInput
  }

  export type StudentEnrolledCourseMarkScalarWhereWithAggregatesInput = {
    AND?: StudentEnrolledCourseMarkScalarWhereWithAggregatesInput | StudentEnrolledCourseMarkScalarWhereWithAggregatesInput[]
    OR?: StudentEnrolledCourseMarkScalarWhereWithAggregatesInput[]
    NOT?: StudentEnrolledCourseMarkScalarWhereWithAggregatesInput | StudentEnrolledCourseMarkScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"StudentEnrolledCourseMark"> | string
    examType?: EnumExamTypeNullableWithAggregatesFilter<"StudentEnrolledCourseMark"> | $Enums.ExamType | null
    createdAt?: DateTimeWithAggregatesFilter<"StudentEnrolledCourseMark"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"StudentEnrolledCourseMark"> | Date | string
    studentId?: StringWithAggregatesFilter<"StudentEnrolledCourseMark"> | string
    studentEnrolledCourseId?: StringWithAggregatesFilter<"StudentEnrolledCourseMark"> | string
    academicSemesterId?: StringWithAggregatesFilter<"StudentEnrolledCourseMark"> | string
    exam1?: FloatWithAggregatesFilter<"StudentEnrolledCourseMark"> | number
    exam2?: FloatWithAggregatesFilter<"StudentEnrolledCourseMark"> | number
    exam3?: FloatWithAggregatesFilter<"StudentEnrolledCourseMark"> | number
    exam4?: FloatWithAggregatesFilter<"StudentEnrolledCourseMark"> | number
    exam5?: FloatWithAggregatesFilter<"StudentEnrolledCourseMark"> | number
    exam6?: FloatWithAggregatesFilter<"StudentEnrolledCourseMark"> | number
    finalExam?: FloatWithAggregatesFilter<"StudentEnrolledCourseMark"> | number
    totalMarks?: FloatWithAggregatesFilter<"StudentEnrolledCourseMark"> | number
    grade?: FloatWithAggregatesFilter<"StudentEnrolledCourseMark"> | number
  }

  export type StudentSemesterPaymentWhereInput = {
    AND?: StudentSemesterPaymentWhereInput | StudentSemesterPaymentWhereInput[]
    OR?: StudentSemesterPaymentWhereInput[]
    NOT?: StudentSemesterPaymentWhereInput | StudentSemesterPaymentWhereInput[]
    id?: StringFilter<"StudentSemesterPayment"> | string
    paymentRecipt?: StringNullableFilter<"StudentSemesterPayment"> | string | null
    totalPayment?: IntFilter<"StudentSemesterPayment"> | number
    baseAmount?: IntFilter<"StudentSemesterPayment"> | number
    lateFee?: IntFilter<"StudentSemesterPayment"> | number
    aprovedPayment?: BoolFilter<"StudentSemesterPayment"> | boolean
    paymentType?: EnumPAYMENTTYPEFilter<"StudentSemesterPayment"> | $Enums.PAYMENTTYPE
    paymentStatus?: EnumPaymentStatusNullableFilter<"StudentSemesterPayment"> | $Enums.PaymentStatus | null
    paymentMonth?: IntFilter<"StudentSemesterPayment"> | number
    paymentYear?: IntFilter<"StudentSemesterPayment"> | number
    createdAt?: DateTimeFilter<"StudentSemesterPayment"> | Date | string
    updatedAt?: DateTimeFilter<"StudentSemesterPayment"> | Date | string
    studentId?: StringFilter<"StudentSemesterPayment"> | string
    academicSemesterId?: StringFilter<"StudentSemesterPayment"> | string
    student?: XOR<StudentScalarRelationFilter, StudentWhereInput>
    academicSemester?: XOR<AcademicSemesterScalarRelationFilter, AcademicSemesterWhereInput>
  }

  export type StudentSemesterPaymentOrderByWithRelationInput = {
    id?: SortOrder
    paymentRecipt?: SortOrderInput | SortOrder
    totalPayment?: SortOrder
    baseAmount?: SortOrder
    lateFee?: SortOrder
    aprovedPayment?: SortOrder
    paymentType?: SortOrder
    paymentStatus?: SortOrderInput | SortOrder
    paymentMonth?: SortOrder
    paymentYear?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    studentId?: SortOrder
    academicSemesterId?: SortOrder
    student?: StudentOrderByWithRelationInput
    academicSemester?: AcademicSemesterOrderByWithRelationInput
    _relevance?: StudentSemesterPaymentOrderByRelevanceInput
  }

  export type StudentSemesterPaymentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: StudentSemesterPaymentWhereInput | StudentSemesterPaymentWhereInput[]
    OR?: StudentSemesterPaymentWhereInput[]
    NOT?: StudentSemesterPaymentWhereInput | StudentSemesterPaymentWhereInput[]
    paymentRecipt?: StringNullableFilter<"StudentSemesterPayment"> | string | null
    totalPayment?: IntFilter<"StudentSemesterPayment"> | number
    baseAmount?: IntFilter<"StudentSemesterPayment"> | number
    lateFee?: IntFilter<"StudentSemesterPayment"> | number
    aprovedPayment?: BoolFilter<"StudentSemesterPayment"> | boolean
    paymentType?: EnumPAYMENTTYPEFilter<"StudentSemesterPayment"> | $Enums.PAYMENTTYPE
    paymentStatus?: EnumPaymentStatusNullableFilter<"StudentSemesterPayment"> | $Enums.PaymentStatus | null
    paymentMonth?: IntFilter<"StudentSemesterPayment"> | number
    paymentYear?: IntFilter<"StudentSemesterPayment"> | number
    createdAt?: DateTimeFilter<"StudentSemesterPayment"> | Date | string
    updatedAt?: DateTimeFilter<"StudentSemesterPayment"> | Date | string
    studentId?: StringFilter<"StudentSemesterPayment"> | string
    academicSemesterId?: StringFilter<"StudentSemesterPayment"> | string
    student?: XOR<StudentScalarRelationFilter, StudentWhereInput>
    academicSemester?: XOR<AcademicSemesterScalarRelationFilter, AcademicSemesterWhereInput>
  }, "id">

  export type StudentSemesterPaymentOrderByWithAggregationInput = {
    id?: SortOrder
    paymentRecipt?: SortOrderInput | SortOrder
    totalPayment?: SortOrder
    baseAmount?: SortOrder
    lateFee?: SortOrder
    aprovedPayment?: SortOrder
    paymentType?: SortOrder
    paymentStatus?: SortOrderInput | SortOrder
    paymentMonth?: SortOrder
    paymentYear?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    studentId?: SortOrder
    academicSemesterId?: SortOrder
    _count?: StudentSemesterPaymentCountOrderByAggregateInput
    _avg?: StudentSemesterPaymentAvgOrderByAggregateInput
    _max?: StudentSemesterPaymentMaxOrderByAggregateInput
    _min?: StudentSemesterPaymentMinOrderByAggregateInput
    _sum?: StudentSemesterPaymentSumOrderByAggregateInput
  }

  export type StudentSemesterPaymentScalarWhereWithAggregatesInput = {
    AND?: StudentSemesterPaymentScalarWhereWithAggregatesInput | StudentSemesterPaymentScalarWhereWithAggregatesInput[]
    OR?: StudentSemesterPaymentScalarWhereWithAggregatesInput[]
    NOT?: StudentSemesterPaymentScalarWhereWithAggregatesInput | StudentSemesterPaymentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"StudentSemesterPayment"> | string
    paymentRecipt?: StringNullableWithAggregatesFilter<"StudentSemesterPayment"> | string | null
    totalPayment?: IntWithAggregatesFilter<"StudentSemesterPayment"> | number
    baseAmount?: IntWithAggregatesFilter<"StudentSemesterPayment"> | number
    lateFee?: IntWithAggregatesFilter<"StudentSemesterPayment"> | number
    aprovedPayment?: BoolWithAggregatesFilter<"StudentSemesterPayment"> | boolean
    paymentType?: EnumPAYMENTTYPEWithAggregatesFilter<"StudentSemesterPayment"> | $Enums.PAYMENTTYPE
    paymentStatus?: EnumPaymentStatusNullableWithAggregatesFilter<"StudentSemesterPayment"> | $Enums.PaymentStatus | null
    paymentMonth?: IntWithAggregatesFilter<"StudentSemesterPayment"> | number
    paymentYear?: IntWithAggregatesFilter<"StudentSemesterPayment"> | number
    createdAt?: DateTimeWithAggregatesFilter<"StudentSemesterPayment"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"StudentSemesterPayment"> | Date | string
    studentId?: StringWithAggregatesFilter<"StudentSemesterPayment"> | string
    academicSemesterId?: StringWithAggregatesFilter<"StudentSemesterPayment"> | string
  }

  export type StudentAcademicInfoWhereInput = {
    AND?: StudentAcademicInfoWhereInput | StudentAcademicInfoWhereInput[]
    OR?: StudentAcademicInfoWhereInput[]
    NOT?: StudentAcademicInfoWhereInput | StudentAcademicInfoWhereInput[]
    id?: StringFilter<"StudentAcademicInfo"> | string
    createdAt?: DateTimeFilter<"StudentAcademicInfo"> | Date | string
    updatedAt?: DateTimeFilter<"StudentAcademicInfo"> | Date | string
    studentId?: StringFilter<"StudentAcademicInfo"> | string
    totalCompletedCredits?: IntNullableFilter<"StudentAcademicInfo"> | number | null
    cgpa?: FloatNullableFilter<"StudentAcademicInfo"> | number | null
    student?: XOR<StudentScalarRelationFilter, StudentWhereInput>
  }

  export type StudentAcademicInfoOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    studentId?: SortOrder
    totalCompletedCredits?: SortOrderInput | SortOrder
    cgpa?: SortOrderInput | SortOrder
    student?: StudentOrderByWithRelationInput
    _relevance?: StudentAcademicInfoOrderByRelevanceInput
  }

  export type StudentAcademicInfoWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: StudentAcademicInfoWhereInput | StudentAcademicInfoWhereInput[]
    OR?: StudentAcademicInfoWhereInput[]
    NOT?: StudentAcademicInfoWhereInput | StudentAcademicInfoWhereInput[]
    createdAt?: DateTimeFilter<"StudentAcademicInfo"> | Date | string
    updatedAt?: DateTimeFilter<"StudentAcademicInfo"> | Date | string
    studentId?: StringFilter<"StudentAcademicInfo"> | string
    totalCompletedCredits?: IntNullableFilter<"StudentAcademicInfo"> | number | null
    cgpa?: FloatNullableFilter<"StudentAcademicInfo"> | number | null
    student?: XOR<StudentScalarRelationFilter, StudentWhereInput>
  }, "id">

  export type StudentAcademicInfoOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    studentId?: SortOrder
    totalCompletedCredits?: SortOrderInput | SortOrder
    cgpa?: SortOrderInput | SortOrder
    _count?: StudentAcademicInfoCountOrderByAggregateInput
    _avg?: StudentAcademicInfoAvgOrderByAggregateInput
    _max?: StudentAcademicInfoMaxOrderByAggregateInput
    _min?: StudentAcademicInfoMinOrderByAggregateInput
    _sum?: StudentAcademicInfoSumOrderByAggregateInput
  }

  export type StudentAcademicInfoScalarWhereWithAggregatesInput = {
    AND?: StudentAcademicInfoScalarWhereWithAggregatesInput | StudentAcademicInfoScalarWhereWithAggregatesInput[]
    OR?: StudentAcademicInfoScalarWhereWithAggregatesInput[]
    NOT?: StudentAcademicInfoScalarWhereWithAggregatesInput | StudentAcademicInfoScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"StudentAcademicInfo"> | string
    createdAt?: DateTimeWithAggregatesFilter<"StudentAcademicInfo"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"StudentAcademicInfo"> | Date | string
    studentId?: StringWithAggregatesFilter<"StudentAcademicInfo"> | string
    totalCompletedCredits?: IntNullableWithAggregatesFilter<"StudentAcademicInfo"> | number | null
    cgpa?: FloatNullableWithAggregatesFilter<"StudentAcademicInfo"> | number | null
  }

  export type UsersCreateInput = {
    id?: string
    name: string
    email: string
    password: string
    avatar?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    academicDepartment?: AcademicDepartmentCreateNestedOneWithoutDepartmentHeadInput
    staffDepartments?: AcademicDepartmentCreateNestedManyWithoutStaffMembersInput
  }

  export type UsersUncheckedCreateInput = {
    id?: string
    name: string
    email: string
    password: string
    avatar?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    academicDepartment?: AcademicDepartmentUncheckedCreateNestedOneWithoutDepartmentHeadInput
    staffDepartments?: AcademicDepartmentUncheckedCreateNestedManyWithoutStaffMembersInput
  }

  export type UsersUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    academicDepartment?: AcademicDepartmentUpdateOneWithoutDepartmentHeadNestedInput
    staffDepartments?: AcademicDepartmentUpdateManyWithoutStaffMembersNestedInput
  }

  export type UsersUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    academicDepartment?: AcademicDepartmentUncheckedUpdateOneWithoutDepartmentHeadNestedInput
    staffDepartments?: AcademicDepartmentUncheckedUpdateManyWithoutStaffMembersNestedInput
  }

  export type UsersCreateManyInput = {
    id?: string
    name: string
    email: string
    password: string
    avatar?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UsersUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UsersUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AcademicSemesterCreateInput = {
    id?: string
    title: string
    year: string
    code: string
    startMonth: string
    endMonth: string
    isCurrent?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    semesterRegistrations?: SemesterRegistrationCreateNestedManyWithoutAcademicSemesterInput
    students?: StudentCreateNestedOneWithoutAcademicSemesterInput
    studentEnrolledCourses?: StudentEnrolledCourseCreateNestedManyWithoutAcademicSemesterInput
    studentEnrolledCourseMarks?: StudentEnrolledCourseMarkCreateNestedManyWithoutAcademicSemesterInput
    studentSemesterPayments?: StudentSemesterPaymentCreateNestedManyWithoutAcademicSemesterInput
  }

  export type AcademicSemesterUncheckedCreateInput = {
    id?: string
    title: string
    year: string
    code: string
    startMonth: string
    endMonth: string
    isCurrent?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    semesterRegistrations?: SemesterRegistrationUncheckedCreateNestedManyWithoutAcademicSemesterInput
    students?: StudentUncheckedCreateNestedOneWithoutAcademicSemesterInput
    studentEnrolledCourses?: StudentEnrolledCourseUncheckedCreateNestedManyWithoutAcademicSemesterInput
    studentEnrolledCourseMarks?: StudentEnrolledCourseMarkUncheckedCreateNestedManyWithoutAcademicSemesterInput
    studentSemesterPayments?: StudentSemesterPaymentUncheckedCreateNestedManyWithoutAcademicSemesterInput
  }

  export type AcademicSemesterUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    year?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    startMonth?: StringFieldUpdateOperationsInput | string
    endMonth?: StringFieldUpdateOperationsInput | string
    isCurrent?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    semesterRegistrations?: SemesterRegistrationUpdateManyWithoutAcademicSemesterNestedInput
    students?: StudentUpdateOneWithoutAcademicSemesterNestedInput
    studentEnrolledCourses?: StudentEnrolledCourseUpdateManyWithoutAcademicSemesterNestedInput
    studentEnrolledCourseMarks?: StudentEnrolledCourseMarkUpdateManyWithoutAcademicSemesterNestedInput
    studentSemesterPayments?: StudentSemesterPaymentUpdateManyWithoutAcademicSemesterNestedInput
  }

  export type AcademicSemesterUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    year?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    startMonth?: StringFieldUpdateOperationsInput | string
    endMonth?: StringFieldUpdateOperationsInput | string
    isCurrent?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    semesterRegistrations?: SemesterRegistrationUncheckedUpdateManyWithoutAcademicSemesterNestedInput
    students?: StudentUncheckedUpdateOneWithoutAcademicSemesterNestedInput
    studentEnrolledCourses?: StudentEnrolledCourseUncheckedUpdateManyWithoutAcademicSemesterNestedInput
    studentEnrolledCourseMarks?: StudentEnrolledCourseMarkUncheckedUpdateManyWithoutAcademicSemesterNestedInput
    studentSemesterPayments?: StudentSemesterPaymentUncheckedUpdateManyWithoutAcademicSemesterNestedInput
  }

  export type AcademicSemesterCreateManyInput = {
    id?: string
    title: string
    year: string
    code: string
    startMonth: string
    endMonth: string
    isCurrent?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AcademicSemesterUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    year?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    startMonth?: StringFieldUpdateOperationsInput | string
    endMonth?: StringFieldUpdateOperationsInput | string
    isCurrent?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AcademicSemesterUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    year?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    startMonth?: StringFieldUpdateOperationsInput | string
    endMonth?: StringFieldUpdateOperationsInput | string
    isCurrent?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AcademicFacultyCreateInput = {
    id?: string
    title: string
    createdAt?: Date | string
    updatedAt?: Date | string
    academicDepartments?: AcademicDepartmentCreateNestedOneWithoutAcademicFacultyInput
    faculties?: FacultyCreateNestedOneWithoutAcademicFacultyInput
    students?: StudentCreateNestedOneWithoutAcademicFacultyInput
  }

  export type AcademicFacultyUncheckedCreateInput = {
    id?: string
    title: string
    createdAt?: Date | string
    updatedAt?: Date | string
    academicDepartments?: AcademicDepartmentUncheckedCreateNestedOneWithoutAcademicFacultyInput
    faculties?: FacultyUncheckedCreateNestedOneWithoutAcademicFacultyInput
    students?: StudentUncheckedCreateNestedOneWithoutAcademicFacultyInput
  }

  export type AcademicFacultyUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    academicDepartments?: AcademicDepartmentUpdateOneWithoutAcademicFacultyNestedInput
    faculties?: FacultyUpdateOneWithoutAcademicFacultyNestedInput
    students?: StudentUpdateOneWithoutAcademicFacultyNestedInput
  }

  export type AcademicFacultyUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    academicDepartments?: AcademicDepartmentUncheckedUpdateOneWithoutAcademicFacultyNestedInput
    faculties?: FacultyUncheckedUpdateOneWithoutAcademicFacultyNestedInput
    students?: StudentUncheckedUpdateOneWithoutAcademicFacultyNestedInput
  }

  export type AcademicFacultyCreateManyInput = {
    id?: string
    title: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AcademicFacultyUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AcademicFacultyUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AcademicDepartmentCreateInput = {
    id?: string
    title: string
    createdAt?: Date | string
    updatedAt?: Date | string
    academicFaculty: AcademicFacultyCreateNestedOneWithoutAcademicDepartmentsInput
    faculties?: FacultyCreateNestedOneWithoutAcademicDepartmentInput
    students?: StudentCreateNestedOneWithoutAcademicDepartmentInput
    departmentHead?: UsersCreateNestedOneWithoutAcademicDepartmentInput
    staffMembers?: UsersCreateNestedManyWithoutStaffDepartmentsInput
    admitionExame?: AdmitionExameRegistrationCreateNestedManyWithoutDepartmentInput
    offeredCourses?: OfferedCourseCreateNestedManyWithoutAcademicDepartmentInput
  }

  export type AcademicDepartmentUncheckedCreateInput = {
    id?: string
    title: string
    academicFacultyId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    departmentHeadId?: string | null
    faculties?: FacultyUncheckedCreateNestedOneWithoutAcademicDepartmentInput
    students?: StudentUncheckedCreateNestedOneWithoutAcademicDepartmentInput
    staffMembers?: UsersUncheckedCreateNestedManyWithoutStaffDepartmentsInput
    admitionExame?: AdmitionExameRegistrationUncheckedCreateNestedManyWithoutDepartmentInput
    offeredCourses?: OfferedCourseUncheckedCreateNestedManyWithoutAcademicDepartmentInput
  }

  export type AcademicDepartmentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    academicFaculty?: AcademicFacultyUpdateOneRequiredWithoutAcademicDepartmentsNestedInput
    faculties?: FacultyUpdateOneWithoutAcademicDepartmentNestedInput
    students?: StudentUpdateOneWithoutAcademicDepartmentNestedInput
    departmentHead?: UsersUpdateOneWithoutAcademicDepartmentNestedInput
    staffMembers?: UsersUpdateManyWithoutStaffDepartmentsNestedInput
    admitionExame?: AdmitionExameRegistrationUpdateManyWithoutDepartmentNestedInput
    offeredCourses?: OfferedCourseUpdateManyWithoutAcademicDepartmentNestedInput
  }

  export type AcademicDepartmentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    academicFacultyId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    departmentHeadId?: NullableStringFieldUpdateOperationsInput | string | null
    faculties?: FacultyUncheckedUpdateOneWithoutAcademicDepartmentNestedInput
    students?: StudentUncheckedUpdateOneWithoutAcademicDepartmentNestedInput
    staffMembers?: UsersUncheckedUpdateManyWithoutStaffDepartmentsNestedInput
    admitionExame?: AdmitionExameRegistrationUncheckedUpdateManyWithoutDepartmentNestedInput
    offeredCourses?: OfferedCourseUncheckedUpdateManyWithoutAcademicDepartmentNestedInput
  }

  export type AcademicDepartmentCreateManyInput = {
    id?: string
    title: string
    academicFacultyId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    departmentHeadId?: string | null
  }

  export type AcademicDepartmentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AcademicDepartmentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    academicFacultyId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    departmentHeadId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type StudentCreateInput = {
    id?: string
    studentId: string
    firstName: string
    middleName?: string | null
    lastName: string
    profileImage?: string | null
    email?: string | null
    contactNo?: string | null
    gender: string
    isWoker?: boolean
    shift?: $Enums.Shift
    password: string
    gradeDeclarationFile: string
    biFile: string
    presentAddress: string
    permanentAddress?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    admissionRegistration?: AdmitionExameRegistrationCreateNestedOneWithoutStudentInput
    academicDepartment: AcademicDepartmentCreateNestedOneWithoutStudentsInput
    academicFaculty: AcademicFacultyCreateNestedOneWithoutStudentsInput
    academicSemester: AcademicSemesterCreateNestedOneWithoutStudentsInput
    studentSemesterRegistrations?: StudentSemesterRegistrationCreateNestedManyWithoutStudentInput
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseCreateNestedManyWithoutStudentInput
    studentEnrolledCourses?: StudentEnrolledCourseCreateNestedManyWithoutStudentInput
    studentEnrolledCourseMarks?: StudentEnrolledCourseMarkCreateNestedManyWithoutStudentInput
    studentSemesterPayments?: StudentSemesterPaymentCreateNestedManyWithoutStudentInput
    studentAcademicInfos?: StudentAcademicInfoCreateNestedManyWithoutStudentInput
  }

  export type StudentUncheckedCreateInput = {
    id?: string
    studentId: string
    firstName: string
    middleName?: string | null
    lastName: string
    profileImage?: string | null
    email?: string | null
    contactNo?: string | null
    gender: string
    isWoker?: boolean
    shift?: $Enums.Shift
    password: string
    gradeDeclarationFile: string
    biFile: string
    presentAddress: string
    permanentAddress?: string | null
    academicSemesterId: string
    academicFacultyId: string
    academicDepartmentId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    admissionRegistrationId?: string | null
    studentSemesterRegistrations?: StudentSemesterRegistrationUncheckedCreateNestedManyWithoutStudentInput
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseUncheckedCreateNestedManyWithoutStudentInput
    studentEnrolledCourses?: StudentEnrolledCourseUncheckedCreateNestedManyWithoutStudentInput
    studentEnrolledCourseMarks?: StudentEnrolledCourseMarkUncheckedCreateNestedManyWithoutStudentInput
    studentSemesterPayments?: StudentSemesterPaymentUncheckedCreateNestedManyWithoutStudentInput
    studentAcademicInfos?: StudentAcademicInfoUncheckedCreateNestedManyWithoutStudentInput
  }

  export type StudentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    contactNo?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: StringFieldUpdateOperationsInput | string
    isWoker?: BoolFieldUpdateOperationsInput | boolean
    shift?: EnumShiftFieldUpdateOperationsInput | $Enums.Shift
    password?: StringFieldUpdateOperationsInput | string
    gradeDeclarationFile?: StringFieldUpdateOperationsInput | string
    biFile?: StringFieldUpdateOperationsInput | string
    presentAddress?: StringFieldUpdateOperationsInput | string
    permanentAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    admissionRegistration?: AdmitionExameRegistrationUpdateOneWithoutStudentNestedInput
    academicDepartment?: AcademicDepartmentUpdateOneRequiredWithoutStudentsNestedInput
    academicFaculty?: AcademicFacultyUpdateOneRequiredWithoutStudentsNestedInput
    academicSemester?: AcademicSemesterUpdateOneRequiredWithoutStudentsNestedInput
    studentSemesterRegistrations?: StudentSemesterRegistrationUpdateManyWithoutStudentNestedInput
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseUpdateManyWithoutStudentNestedInput
    studentEnrolledCourses?: StudentEnrolledCourseUpdateManyWithoutStudentNestedInput
    studentEnrolledCourseMarks?: StudentEnrolledCourseMarkUpdateManyWithoutStudentNestedInput
    studentSemesterPayments?: StudentSemesterPaymentUpdateManyWithoutStudentNestedInput
    studentAcademicInfos?: StudentAcademicInfoUpdateManyWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    contactNo?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: StringFieldUpdateOperationsInput | string
    isWoker?: BoolFieldUpdateOperationsInput | boolean
    shift?: EnumShiftFieldUpdateOperationsInput | $Enums.Shift
    password?: StringFieldUpdateOperationsInput | string
    gradeDeclarationFile?: StringFieldUpdateOperationsInput | string
    biFile?: StringFieldUpdateOperationsInput | string
    presentAddress?: StringFieldUpdateOperationsInput | string
    permanentAddress?: NullableStringFieldUpdateOperationsInput | string | null
    academicSemesterId?: StringFieldUpdateOperationsInput | string
    academicFacultyId?: StringFieldUpdateOperationsInput | string
    academicDepartmentId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    admissionRegistrationId?: NullableStringFieldUpdateOperationsInput | string | null
    studentSemesterRegistrations?: StudentSemesterRegistrationUncheckedUpdateManyWithoutStudentNestedInput
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseUncheckedUpdateManyWithoutStudentNestedInput
    studentEnrolledCourses?: StudentEnrolledCourseUncheckedUpdateManyWithoutStudentNestedInput
    studentEnrolledCourseMarks?: StudentEnrolledCourseMarkUncheckedUpdateManyWithoutStudentNestedInput
    studentSemesterPayments?: StudentSemesterPaymentUncheckedUpdateManyWithoutStudentNestedInput
    studentAcademicInfos?: StudentAcademicInfoUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type StudentCreateManyInput = {
    id?: string
    studentId: string
    firstName: string
    middleName?: string | null
    lastName: string
    profileImage?: string | null
    email?: string | null
    contactNo?: string | null
    gender: string
    isWoker?: boolean
    shift?: $Enums.Shift
    password: string
    gradeDeclarationFile: string
    biFile: string
    presentAddress: string
    permanentAddress?: string | null
    academicSemesterId: string
    academicFacultyId: string
    academicDepartmentId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    admissionRegistrationId?: string | null
  }

  export type StudentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    contactNo?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: StringFieldUpdateOperationsInput | string
    isWoker?: BoolFieldUpdateOperationsInput | boolean
    shift?: EnumShiftFieldUpdateOperationsInput | $Enums.Shift
    password?: StringFieldUpdateOperationsInput | string
    gradeDeclarationFile?: StringFieldUpdateOperationsInput | string
    biFile?: StringFieldUpdateOperationsInput | string
    presentAddress?: StringFieldUpdateOperationsInput | string
    permanentAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    contactNo?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: StringFieldUpdateOperationsInput | string
    isWoker?: BoolFieldUpdateOperationsInput | boolean
    shift?: EnumShiftFieldUpdateOperationsInput | $Enums.Shift
    password?: StringFieldUpdateOperationsInput | string
    gradeDeclarationFile?: StringFieldUpdateOperationsInput | string
    biFile?: StringFieldUpdateOperationsInput | string
    presentAddress?: StringFieldUpdateOperationsInput | string
    permanentAddress?: NullableStringFieldUpdateOperationsInput | string | null
    academicSemesterId?: StringFieldUpdateOperationsInput | string
    academicFacultyId?: StringFieldUpdateOperationsInput | string
    academicDepartmentId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    admissionRegistrationId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type FacultyCreateInput = {
    id?: string
    facultyId: string
    firstName: string
    middleName?: string | null
    lastName: string
    profileImage?: string | null
    email?: string | null
    contactNo?: string | null
    gender: string
    designation: string
    password: string
    createdAt?: Date | string
    updatedAt?: Date | string
    courses?: CourseFacultyCreateNestedManyWithoutFacultyInput
    academicDepartment: AcademicDepartmentCreateNestedOneWithoutFacultiesInput
    academicFaculty: AcademicFacultyCreateNestedOneWithoutFacultiesInput
    offeredCourseClassSchedules?: OfferedCourseClassScheduleCreateNestedManyWithoutFacultyInput
  }

  export type FacultyUncheckedCreateInput = {
    id?: string
    facultyId: string
    firstName: string
    middleName?: string | null
    lastName: string
    profileImage?: string | null
    email?: string | null
    contactNo?: string | null
    gender: string
    designation: string
    password: string
    academicFacultyId: string
    academicDepartmentId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    courses?: CourseFacultyUncheckedCreateNestedManyWithoutFacultyInput
    offeredCourseClassSchedules?: OfferedCourseClassScheduleUncheckedCreateNestedManyWithoutFacultyInput
  }

  export type FacultyUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    facultyId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    contactNo?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: StringFieldUpdateOperationsInput | string
    designation?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    courses?: CourseFacultyUpdateManyWithoutFacultyNestedInput
    academicDepartment?: AcademicDepartmentUpdateOneRequiredWithoutFacultiesNestedInput
    academicFaculty?: AcademicFacultyUpdateOneRequiredWithoutFacultiesNestedInput
    offeredCourseClassSchedules?: OfferedCourseClassScheduleUpdateManyWithoutFacultyNestedInput
  }

  export type FacultyUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    facultyId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    contactNo?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: StringFieldUpdateOperationsInput | string
    designation?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    academicFacultyId?: StringFieldUpdateOperationsInput | string
    academicDepartmentId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    courses?: CourseFacultyUncheckedUpdateManyWithoutFacultyNestedInput
    offeredCourseClassSchedules?: OfferedCourseClassScheduleUncheckedUpdateManyWithoutFacultyNestedInput
  }

  export type FacultyCreateManyInput = {
    id?: string
    facultyId: string
    firstName: string
    middleName?: string | null
    lastName: string
    profileImage?: string | null
    email?: string | null
    contactNo?: string | null
    gender: string
    designation: string
    password: string
    academicFacultyId: string
    academicDepartmentId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FacultyUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    facultyId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    contactNo?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: StringFieldUpdateOperationsInput | string
    designation?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FacultyUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    facultyId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    contactNo?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: StringFieldUpdateOperationsInput | string
    designation?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    academicFacultyId?: StringFieldUpdateOperationsInput | string
    academicDepartmentId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BuildingCreateInput = {
    id?: string
    title: string
    createdAt?: Date | string
    updatedAt?: Date | string
    rooms?: RoomCreateNestedManyWithoutBuildingInput
  }

  export type BuildingUncheckedCreateInput = {
    id?: string
    title: string
    createdAt?: Date | string
    updatedAt?: Date | string
    rooms?: RoomUncheckedCreateNestedManyWithoutBuildingInput
  }

  export type BuildingUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rooms?: RoomUpdateManyWithoutBuildingNestedInput
  }

  export type BuildingUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rooms?: RoomUncheckedUpdateManyWithoutBuildingNestedInput
  }

  export type BuildingCreateManyInput = {
    id?: string
    title: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BuildingUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BuildingUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoomCreateInput = {
    id?: string
    roomNumber: string
    floor: string
    createdAt?: Date | string
    updatedAt?: Date | string
    building: BuildingCreateNestedOneWithoutRoomsInput
    offeredCourseClassSchedules?: OfferedCourseClassScheduleCreateNestedManyWithoutRoomInput
  }

  export type RoomUncheckedCreateInput = {
    id?: string
    roomNumber: string
    floor: string
    buildingId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    offeredCourseClassSchedules?: OfferedCourseClassScheduleUncheckedCreateNestedManyWithoutRoomInput
  }

  export type RoomUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    roomNumber?: StringFieldUpdateOperationsInput | string
    floor?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    building?: BuildingUpdateOneRequiredWithoutRoomsNestedInput
    offeredCourseClassSchedules?: OfferedCourseClassScheduleUpdateManyWithoutRoomNestedInput
  }

  export type RoomUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    roomNumber?: StringFieldUpdateOperationsInput | string
    floor?: StringFieldUpdateOperationsInput | string
    buildingId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    offeredCourseClassSchedules?: OfferedCourseClassScheduleUncheckedUpdateManyWithoutRoomNestedInput
  }

  export type RoomCreateManyInput = {
    id?: string
    roomNumber: string
    floor: string
    buildingId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RoomUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    roomNumber?: StringFieldUpdateOperationsInput | string
    floor?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoomUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    roomNumber?: StringFieldUpdateOperationsInput | string
    floor?: StringFieldUpdateOperationsInput | string
    buildingId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CourseCreateInput = {
    id?: string
    title: string
    code: string
    credits?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    preRequisite?: CourseToPreRequisiteCreateNestedManyWithoutCourseInput
    preRequisiteFor?: CourseToPreRequisiteCreateNestedManyWithoutPreRequisiteInput
    faculties?: CourseFacultyCreateNestedManyWithoutCourseInput
    offeredCourses?: OfferedCourseCreateNestedManyWithoutCourseInput
    studentEnrolledCourses?: StudentEnrolledCourseCreateNestedManyWithoutCourseInput
  }

  export type CourseUncheckedCreateInput = {
    id?: string
    title: string
    code: string
    credits?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    preRequisite?: CourseToPreRequisiteUncheckedCreateNestedManyWithoutCourseInput
    preRequisiteFor?: CourseToPreRequisiteUncheckedCreateNestedManyWithoutPreRequisiteInput
    faculties?: CourseFacultyUncheckedCreateNestedManyWithoutCourseInput
    offeredCourses?: OfferedCourseUncheckedCreateNestedManyWithoutCourseInput
    studentEnrolledCourses?: StudentEnrolledCourseUncheckedCreateNestedManyWithoutCourseInput
  }

  export type CourseUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    credits?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    preRequisite?: CourseToPreRequisiteUpdateManyWithoutCourseNestedInput
    preRequisiteFor?: CourseToPreRequisiteUpdateManyWithoutPreRequisiteNestedInput
    faculties?: CourseFacultyUpdateManyWithoutCourseNestedInput
    offeredCourses?: OfferedCourseUpdateManyWithoutCourseNestedInput
    studentEnrolledCourses?: StudentEnrolledCourseUpdateManyWithoutCourseNestedInput
  }

  export type CourseUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    credits?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    preRequisite?: CourseToPreRequisiteUncheckedUpdateManyWithoutCourseNestedInput
    preRequisiteFor?: CourseToPreRequisiteUncheckedUpdateManyWithoutPreRequisiteNestedInput
    faculties?: CourseFacultyUncheckedUpdateManyWithoutCourseNestedInput
    offeredCourses?: OfferedCourseUncheckedUpdateManyWithoutCourseNestedInput
    studentEnrolledCourses?: StudentEnrolledCourseUncheckedUpdateManyWithoutCourseNestedInput
  }

  export type CourseCreateManyInput = {
    id?: string
    title: string
    code: string
    credits?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CourseUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    credits?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CourseUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    credits?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CourseToPreRequisiteCreateInput = {
    course: CourseCreateNestedOneWithoutPreRequisiteInput
    preRequisite: CourseCreateNestedOneWithoutPreRequisiteForInput
  }

  export type CourseToPreRequisiteUncheckedCreateInput = {
    courseId: string
    preRequisiteId: string
  }

  export type CourseToPreRequisiteUpdateInput = {
    course?: CourseUpdateOneRequiredWithoutPreRequisiteNestedInput
    preRequisite?: CourseUpdateOneRequiredWithoutPreRequisiteForNestedInput
  }

  export type CourseToPreRequisiteUncheckedUpdateInput = {
    courseId?: StringFieldUpdateOperationsInput | string
    preRequisiteId?: StringFieldUpdateOperationsInput | string
  }

  export type CourseToPreRequisiteCreateManyInput = {
    courseId: string
    preRequisiteId: string
  }

  export type CourseToPreRequisiteUpdateManyMutationInput = {

  }

  export type CourseToPreRequisiteUncheckedUpdateManyInput = {
    courseId?: StringFieldUpdateOperationsInput | string
    preRequisiteId?: StringFieldUpdateOperationsInput | string
  }

  export type CourseFacultyCreateInput = {
    course: CourseCreateNestedOneWithoutFacultiesInput
    faculty: FacultyCreateNestedOneWithoutCoursesInput
  }

  export type CourseFacultyUncheckedCreateInput = {
    courseId: string
    facultyId: string
  }

  export type CourseFacultyUpdateInput = {
    course?: CourseUpdateOneRequiredWithoutFacultiesNestedInput
    faculty?: FacultyUpdateOneRequiredWithoutCoursesNestedInput
  }

  export type CourseFacultyUncheckedUpdateInput = {
    courseId?: StringFieldUpdateOperationsInput | string
    facultyId?: StringFieldUpdateOperationsInput | string
  }

  export type CourseFacultyCreateManyInput = {
    courseId: string
    facultyId: string
  }

  export type CourseFacultyUpdateManyMutationInput = {

  }

  export type CourseFacultyUncheckedUpdateManyInput = {
    courseId?: StringFieldUpdateOperationsInput | string
    facultyId?: StringFieldUpdateOperationsInput | string
  }

  export type SemesterRegistrationCreateInput = {
    id?: string
    startDate: Date | string
    endDate: Date | string
    status?: $Enums.SemesterRegistrationStatus | null
    paymentRecipt: string
    totalPayment?: number
    createdAt?: Date | string
    updateAt?: Date | string
    academicSemester: AcademicSemesterCreateNestedOneWithoutSemesterRegistrationsInput
    offeredCourses?: OfferedCourseCreateNestedManyWithoutSemesterRegistrationInput
    offeredCourseSections?: OfferedCourseSectionCreateNestedManyWithoutSemesterRegistrationInput
    offeredCourseClassSchedules?: OfferedCourseClassScheduleCreateNestedManyWithoutSemesterRegistrationInput
    studentSemesterRegistrations?: StudentSemesterRegistrationCreateNestedManyWithoutSemesterRegistrationInput
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseCreateNestedManyWithoutSemesterRegistrationInput
  }

  export type SemesterRegistrationUncheckedCreateInput = {
    id?: string
    startDate: Date | string
    endDate: Date | string
    status?: $Enums.SemesterRegistrationStatus | null
    paymentRecipt: string
    totalPayment?: number
    createdAt?: Date | string
    updateAt?: Date | string
    academicSemesterId: string
    offeredCourses?: OfferedCourseUncheckedCreateNestedManyWithoutSemesterRegistrationInput
    offeredCourseSections?: OfferedCourseSectionUncheckedCreateNestedManyWithoutSemesterRegistrationInput
    offeredCourseClassSchedules?: OfferedCourseClassScheduleUncheckedCreateNestedManyWithoutSemesterRegistrationInput
    studentSemesterRegistrations?: StudentSemesterRegistrationUncheckedCreateNestedManyWithoutSemesterRegistrationInput
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseUncheckedCreateNestedManyWithoutSemesterRegistrationInput
  }

  export type SemesterRegistrationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: NullableEnumSemesterRegistrationStatusFieldUpdateOperationsInput | $Enums.SemesterRegistrationStatus | null
    paymentRecipt?: StringFieldUpdateOperationsInput | string
    totalPayment?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    academicSemester?: AcademicSemesterUpdateOneRequiredWithoutSemesterRegistrationsNestedInput
    offeredCourses?: OfferedCourseUpdateManyWithoutSemesterRegistrationNestedInput
    offeredCourseSections?: OfferedCourseSectionUpdateManyWithoutSemesterRegistrationNestedInput
    offeredCourseClassSchedules?: OfferedCourseClassScheduleUpdateManyWithoutSemesterRegistrationNestedInput
    studentSemesterRegistrations?: StudentSemesterRegistrationUpdateManyWithoutSemesterRegistrationNestedInput
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseUpdateManyWithoutSemesterRegistrationNestedInput
  }

  export type SemesterRegistrationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: NullableEnumSemesterRegistrationStatusFieldUpdateOperationsInput | $Enums.SemesterRegistrationStatus | null
    paymentRecipt?: StringFieldUpdateOperationsInput | string
    totalPayment?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    academicSemesterId?: StringFieldUpdateOperationsInput | string
    offeredCourses?: OfferedCourseUncheckedUpdateManyWithoutSemesterRegistrationNestedInput
    offeredCourseSections?: OfferedCourseSectionUncheckedUpdateManyWithoutSemesterRegistrationNestedInput
    offeredCourseClassSchedules?: OfferedCourseClassScheduleUncheckedUpdateManyWithoutSemesterRegistrationNestedInput
    studentSemesterRegistrations?: StudentSemesterRegistrationUncheckedUpdateManyWithoutSemesterRegistrationNestedInput
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseUncheckedUpdateManyWithoutSemesterRegistrationNestedInput
  }

  export type SemesterRegistrationCreateManyInput = {
    id?: string
    startDate: Date | string
    endDate: Date | string
    status?: $Enums.SemesterRegistrationStatus | null
    paymentRecipt: string
    totalPayment?: number
    createdAt?: Date | string
    updateAt?: Date | string
    academicSemesterId: string
  }

  export type SemesterRegistrationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: NullableEnumSemesterRegistrationStatusFieldUpdateOperationsInput | $Enums.SemesterRegistrationStatus | null
    paymentRecipt?: StringFieldUpdateOperationsInput | string
    totalPayment?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SemesterRegistrationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: NullableEnumSemesterRegistrationStatusFieldUpdateOperationsInput | $Enums.SemesterRegistrationStatus | null
    paymentRecipt?: StringFieldUpdateOperationsInput | string
    totalPayment?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    academicSemesterId?: StringFieldUpdateOperationsInput | string
  }

  export type AdmitionExameRegistrationCreateInput = {
    id?: string
    applicantName: string
    paymentRecipt: string
    document: string
    paymentAmoute?: number | null
    aprovePayment?: boolean | null
    exameResults?: number | null
    passed?: boolean | null
    fase?: number
    exameDate: Date | string
    createdAt?: Date | string
    updateAt?: Date | string
    department: AcademicDepartmentCreateNestedOneWithoutAdmitionExameInput
    Student?: StudentCreateNestedOneWithoutAdmissionRegistrationInput
  }

  export type AdmitionExameRegistrationUncheckedCreateInput = {
    id?: string
    applicantName: string
    paymentRecipt: string
    document: string
    paymentAmoute?: number | null
    aprovePayment?: boolean | null
    exameResults?: number | null
    passed?: boolean | null
    fase?: number
    exameDate: Date | string
    createdAt?: Date | string
    updateAt?: Date | string
    departmentId: string
    Student?: StudentUncheckedCreateNestedOneWithoutAdmissionRegistrationInput
  }

  export type AdmitionExameRegistrationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    applicantName?: StringFieldUpdateOperationsInput | string
    paymentRecipt?: StringFieldUpdateOperationsInput | string
    document?: StringFieldUpdateOperationsInput | string
    paymentAmoute?: NullableIntFieldUpdateOperationsInput | number | null
    aprovePayment?: NullableBoolFieldUpdateOperationsInput | boolean | null
    exameResults?: NullableIntFieldUpdateOperationsInput | number | null
    passed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    fase?: IntFieldUpdateOperationsInput | number
    exameDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    department?: AcademicDepartmentUpdateOneRequiredWithoutAdmitionExameNestedInput
    Student?: StudentUpdateOneWithoutAdmissionRegistrationNestedInput
  }

  export type AdmitionExameRegistrationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    applicantName?: StringFieldUpdateOperationsInput | string
    paymentRecipt?: StringFieldUpdateOperationsInput | string
    document?: StringFieldUpdateOperationsInput | string
    paymentAmoute?: NullableIntFieldUpdateOperationsInput | number | null
    aprovePayment?: NullableBoolFieldUpdateOperationsInput | boolean | null
    exameResults?: NullableIntFieldUpdateOperationsInput | number | null
    passed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    fase?: IntFieldUpdateOperationsInput | number
    exameDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    departmentId?: StringFieldUpdateOperationsInput | string
    Student?: StudentUncheckedUpdateOneWithoutAdmissionRegistrationNestedInput
  }

  export type AdmitionExameRegistrationCreateManyInput = {
    id?: string
    applicantName: string
    paymentRecipt: string
    document: string
    paymentAmoute?: number | null
    aprovePayment?: boolean | null
    exameResults?: number | null
    passed?: boolean | null
    fase?: number
    exameDate: Date | string
    createdAt?: Date | string
    updateAt?: Date | string
    departmentId: string
  }

  export type AdmitionExameRegistrationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    applicantName?: StringFieldUpdateOperationsInput | string
    paymentRecipt?: StringFieldUpdateOperationsInput | string
    document?: StringFieldUpdateOperationsInput | string
    paymentAmoute?: NullableIntFieldUpdateOperationsInput | number | null
    aprovePayment?: NullableBoolFieldUpdateOperationsInput | boolean | null
    exameResults?: NullableIntFieldUpdateOperationsInput | number | null
    passed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    fase?: IntFieldUpdateOperationsInput | number
    exameDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdmitionExameRegistrationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    applicantName?: StringFieldUpdateOperationsInput | string
    paymentRecipt?: StringFieldUpdateOperationsInput | string
    document?: StringFieldUpdateOperationsInput | string
    paymentAmoute?: NullableIntFieldUpdateOperationsInput | number | null
    aprovePayment?: NullableBoolFieldUpdateOperationsInput | boolean | null
    exameResults?: NullableIntFieldUpdateOperationsInput | number | null
    passed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    fase?: IntFieldUpdateOperationsInput | number
    exameDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    departmentId?: StringFieldUpdateOperationsInput | string
  }

  export type OfferedCourseCreateInput = {
    id?: string
    academicDepartment: AcademicDepartmentCreateNestedOneWithoutOfferedCoursesInput
    semesterRegistration: SemesterRegistrationCreateNestedOneWithoutOfferedCoursesInput
    course: CourseCreateNestedOneWithoutOfferedCoursesInput
    offeredCourseSections?: OfferedCourseSectionCreateNestedManyWithoutOfferedCourseInput
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseCreateNestedManyWithoutOfferedCourseInput
  }

  export type OfferedCourseUncheckedCreateInput = {
    id?: string
    academicDepartmentId: string
    courseId: string
    semesterRegistrationId: string
    offeredCourseSections?: OfferedCourseSectionUncheckedCreateNestedManyWithoutOfferedCourseInput
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseUncheckedCreateNestedManyWithoutOfferedCourseInput
  }

  export type OfferedCourseUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    academicDepartment?: AcademicDepartmentUpdateOneRequiredWithoutOfferedCoursesNestedInput
    semesterRegistration?: SemesterRegistrationUpdateOneRequiredWithoutOfferedCoursesNestedInput
    course?: CourseUpdateOneRequiredWithoutOfferedCoursesNestedInput
    offeredCourseSections?: OfferedCourseSectionUpdateManyWithoutOfferedCourseNestedInput
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseUpdateManyWithoutOfferedCourseNestedInput
  }

  export type OfferedCourseUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    academicDepartmentId?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    semesterRegistrationId?: StringFieldUpdateOperationsInput | string
    offeredCourseSections?: OfferedCourseSectionUncheckedUpdateManyWithoutOfferedCourseNestedInput
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseUncheckedUpdateManyWithoutOfferedCourseNestedInput
  }

  export type OfferedCourseCreateManyInput = {
    id?: string
    academicDepartmentId: string
    courseId: string
    semesterRegistrationId: string
  }

  export type OfferedCourseUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
  }

  export type OfferedCourseUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    academicDepartmentId?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    semesterRegistrationId?: StringFieldUpdateOperationsInput | string
  }

  export type OfferedCourseSectionCreateInput = {
    id?: string
    title: string
    maxCapacity?: number
    currentlyEnrolledStudent?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    semesterRegistration: SemesterRegistrationCreateNestedOneWithoutOfferedCourseSectionsInput
    offeredCourse: OfferedCourseCreateNestedOneWithoutOfferedCourseSectionsInput
    offeredCourseClassSchedules?: OfferedCourseClassScheduleCreateNestedManyWithoutOfferedCourseSectionInput
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseCreateNestedManyWithoutOfferedCourseSectionInput
  }

  export type OfferedCourseSectionUncheckedCreateInput = {
    id?: string
    title: string
    maxCapacity?: number
    currentlyEnrolledStudent?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    semesterRegistrationId: string
    offeredCourseId: string
    offeredCourseClassSchedules?: OfferedCourseClassScheduleUncheckedCreateNestedManyWithoutOfferedCourseSectionInput
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseUncheckedCreateNestedManyWithoutOfferedCourseSectionInput
  }

  export type OfferedCourseSectionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    maxCapacity?: IntFieldUpdateOperationsInput | number
    currentlyEnrolledStudent?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    semesterRegistration?: SemesterRegistrationUpdateOneRequiredWithoutOfferedCourseSectionsNestedInput
    offeredCourse?: OfferedCourseUpdateOneRequiredWithoutOfferedCourseSectionsNestedInput
    offeredCourseClassSchedules?: OfferedCourseClassScheduleUpdateManyWithoutOfferedCourseSectionNestedInput
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseUpdateManyWithoutOfferedCourseSectionNestedInput
  }

  export type OfferedCourseSectionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    maxCapacity?: IntFieldUpdateOperationsInput | number
    currentlyEnrolledStudent?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    semesterRegistrationId?: StringFieldUpdateOperationsInput | string
    offeredCourseId?: StringFieldUpdateOperationsInput | string
    offeredCourseClassSchedules?: OfferedCourseClassScheduleUncheckedUpdateManyWithoutOfferedCourseSectionNestedInput
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseUncheckedUpdateManyWithoutOfferedCourseSectionNestedInput
  }

  export type OfferedCourseSectionCreateManyInput = {
    id?: string
    title: string
    maxCapacity?: number
    currentlyEnrolledStudent?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    semesterRegistrationId: string
    offeredCourseId: string
  }

  export type OfferedCourseSectionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    maxCapacity?: IntFieldUpdateOperationsInput | number
    currentlyEnrolledStudent?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OfferedCourseSectionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    maxCapacity?: IntFieldUpdateOperationsInput | number
    currentlyEnrolledStudent?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    semesterRegistrationId?: StringFieldUpdateOperationsInput | string
    offeredCourseId?: StringFieldUpdateOperationsInput | string
  }

  export type OfferedCourseClassScheduleCreateInput = {
    id?: string
    startTime: string
    endTime: string
    dayOfWeek?: $Enums.WeekDays
    createdAt?: Date | string
    updatedAt?: Date | string
    offeredCourseSection: OfferedCourseSectionCreateNestedOneWithoutOfferedCourseClassSchedulesInput
    semesterRegistration: SemesterRegistrationCreateNestedOneWithoutOfferedCourseClassSchedulesInput
    room: RoomCreateNestedOneWithoutOfferedCourseClassSchedulesInput
    faculty: FacultyCreateNestedOneWithoutOfferedCourseClassSchedulesInput
  }

  export type OfferedCourseClassScheduleUncheckedCreateInput = {
    id?: string
    startTime: string
    endTime: string
    dayOfWeek?: $Enums.WeekDays
    createdAt?: Date | string
    updatedAt?: Date | string
    offeredCourseSectionId: string
    semesterRegistrationId: string
    roomId: string
    facultyId: string
  }

  export type OfferedCourseClassScheduleUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    dayOfWeek?: EnumWeekDaysFieldUpdateOperationsInput | $Enums.WeekDays
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    offeredCourseSection?: OfferedCourseSectionUpdateOneRequiredWithoutOfferedCourseClassSchedulesNestedInput
    semesterRegistration?: SemesterRegistrationUpdateOneRequiredWithoutOfferedCourseClassSchedulesNestedInput
    room?: RoomUpdateOneRequiredWithoutOfferedCourseClassSchedulesNestedInput
    faculty?: FacultyUpdateOneRequiredWithoutOfferedCourseClassSchedulesNestedInput
  }

  export type OfferedCourseClassScheduleUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    dayOfWeek?: EnumWeekDaysFieldUpdateOperationsInput | $Enums.WeekDays
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    offeredCourseSectionId?: StringFieldUpdateOperationsInput | string
    semesterRegistrationId?: StringFieldUpdateOperationsInput | string
    roomId?: StringFieldUpdateOperationsInput | string
    facultyId?: StringFieldUpdateOperationsInput | string
  }

  export type OfferedCourseClassScheduleCreateManyInput = {
    id?: string
    startTime: string
    endTime: string
    dayOfWeek?: $Enums.WeekDays
    createdAt?: Date | string
    updatedAt?: Date | string
    offeredCourseSectionId: string
    semesterRegistrationId: string
    roomId: string
    facultyId: string
  }

  export type OfferedCourseClassScheduleUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    dayOfWeek?: EnumWeekDaysFieldUpdateOperationsInput | $Enums.WeekDays
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OfferedCourseClassScheduleUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    dayOfWeek?: EnumWeekDaysFieldUpdateOperationsInput | $Enums.WeekDays
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    offeredCourseSectionId?: StringFieldUpdateOperationsInput | string
    semesterRegistrationId?: StringFieldUpdateOperationsInput | string
    roomId?: StringFieldUpdateOperationsInput | string
    facultyId?: StringFieldUpdateOperationsInput | string
  }

  export type StudentSemesterRegistrationCreateInput = {
    id?: string
    isConfirmed?: boolean | null
    totalCreditsTaken?: number | null
    paymentRecipt?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    student: StudentCreateNestedOneWithoutStudentSemesterRegistrationsInput
    semesterRegistration: SemesterRegistrationCreateNestedOneWithoutStudentSemesterRegistrationsInput
  }

  export type StudentSemesterRegistrationUncheckedCreateInput = {
    id?: string
    isConfirmed?: boolean | null
    totalCreditsTaken?: number | null
    paymentRecipt?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    studentId: string
    semesterRegistrationId: string
  }

  export type StudentSemesterRegistrationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    isConfirmed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    totalCreditsTaken?: NullableIntFieldUpdateOperationsInput | number | null
    paymentRecipt?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUpdateOneRequiredWithoutStudentSemesterRegistrationsNestedInput
    semesterRegistration?: SemesterRegistrationUpdateOneRequiredWithoutStudentSemesterRegistrationsNestedInput
  }

  export type StudentSemesterRegistrationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    isConfirmed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    totalCreditsTaken?: NullableIntFieldUpdateOperationsInput | number | null
    paymentRecipt?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    studentId?: StringFieldUpdateOperationsInput | string
    semesterRegistrationId?: StringFieldUpdateOperationsInput | string
  }

  export type StudentSemesterRegistrationCreateManyInput = {
    id?: string
    isConfirmed?: boolean | null
    totalCreditsTaken?: number | null
    paymentRecipt?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    studentId: string
    semesterRegistrationId: string
  }

  export type StudentSemesterRegistrationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    isConfirmed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    totalCreditsTaken?: NullableIntFieldUpdateOperationsInput | number | null
    paymentRecipt?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentSemesterRegistrationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    isConfirmed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    totalCreditsTaken?: NullableIntFieldUpdateOperationsInput | number | null
    paymentRecipt?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    studentId?: StringFieldUpdateOperationsInput | string
    semesterRegistrationId?: StringFieldUpdateOperationsInput | string
  }

  export type StudentSemesterRegistrationCourseCreateInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    semesterRegistration: SemesterRegistrationCreateNestedOneWithoutStudentSemesterRegistrationCoursesInput
    student: StudentCreateNestedOneWithoutStudentSemesterRegistrationCoursesInput
    offeredCourse: OfferedCourseCreateNestedOneWithoutStudentSemesterRegistrationCoursesInput
    offeredCourseSection: OfferedCourseSectionCreateNestedOneWithoutStudentSemesterRegistrationCoursesInput
  }

  export type StudentSemesterRegistrationCourseUncheckedCreateInput = {
    semesterRegistrationId: string
    studentId: string
    offeredCourseId: string
    offeredCourseSectionId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StudentSemesterRegistrationCourseUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    semesterRegistration?: SemesterRegistrationUpdateOneRequiredWithoutStudentSemesterRegistrationCoursesNestedInput
    student?: StudentUpdateOneRequiredWithoutStudentSemesterRegistrationCoursesNestedInput
    offeredCourse?: OfferedCourseUpdateOneRequiredWithoutStudentSemesterRegistrationCoursesNestedInput
    offeredCourseSection?: OfferedCourseSectionUpdateOneRequiredWithoutStudentSemesterRegistrationCoursesNestedInput
  }

  export type StudentSemesterRegistrationCourseUncheckedUpdateInput = {
    semesterRegistrationId?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    offeredCourseId?: StringFieldUpdateOperationsInput | string
    offeredCourseSectionId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentSemesterRegistrationCourseCreateManyInput = {
    semesterRegistrationId: string
    studentId: string
    offeredCourseId: string
    offeredCourseSectionId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StudentSemesterRegistrationCourseUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentSemesterRegistrationCourseUncheckedUpdateManyInput = {
    semesterRegistrationId?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    offeredCourseId?: StringFieldUpdateOperationsInput | string
    offeredCourseSectionId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentEnrolledCourseCreateInput = {
    id?: string
    grade?: string | null
    point?: number | null
    totalMarks?: number | null
    status?: $Enums.StudentEnrolledCourseStatus | null
    createdAt?: Date | string
    updatedAt?: Date | string
    student: StudentCreateNestedOneWithoutStudentEnrolledCoursesInput
    academicSemester: AcademicSemesterCreateNestedOneWithoutStudentEnrolledCoursesInput
    course: CourseCreateNestedOneWithoutStudentEnrolledCoursesInput
    studentEnrolledCourseMarks?: StudentEnrolledCourseMarkCreateNestedManyWithoutStudentEnrolledCourseInput
  }

  export type StudentEnrolledCourseUncheckedCreateInput = {
    id?: string
    grade?: string | null
    point?: number | null
    totalMarks?: number | null
    status?: $Enums.StudentEnrolledCourseStatus | null
    createdAt?: Date | string
    updatedAt?: Date | string
    studentId: string
    academicSemesterId: string
    courseId: string
    studentEnrolledCourseMarks?: StudentEnrolledCourseMarkUncheckedCreateNestedManyWithoutStudentEnrolledCourseInput
  }

  export type StudentEnrolledCourseUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    grade?: NullableStringFieldUpdateOperationsInput | string | null
    point?: NullableFloatFieldUpdateOperationsInput | number | null
    totalMarks?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableEnumStudentEnrolledCourseStatusFieldUpdateOperationsInput | $Enums.StudentEnrolledCourseStatus | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUpdateOneRequiredWithoutStudentEnrolledCoursesNestedInput
    academicSemester?: AcademicSemesterUpdateOneRequiredWithoutStudentEnrolledCoursesNestedInput
    course?: CourseUpdateOneRequiredWithoutStudentEnrolledCoursesNestedInput
    studentEnrolledCourseMarks?: StudentEnrolledCourseMarkUpdateManyWithoutStudentEnrolledCourseNestedInput
  }

  export type StudentEnrolledCourseUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    grade?: NullableStringFieldUpdateOperationsInput | string | null
    point?: NullableFloatFieldUpdateOperationsInput | number | null
    totalMarks?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableEnumStudentEnrolledCourseStatusFieldUpdateOperationsInput | $Enums.StudentEnrolledCourseStatus | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    studentId?: StringFieldUpdateOperationsInput | string
    academicSemesterId?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    studentEnrolledCourseMarks?: StudentEnrolledCourseMarkUncheckedUpdateManyWithoutStudentEnrolledCourseNestedInput
  }

  export type StudentEnrolledCourseCreateManyInput = {
    id?: string
    grade?: string | null
    point?: number | null
    totalMarks?: number | null
    status?: $Enums.StudentEnrolledCourseStatus | null
    createdAt?: Date | string
    updatedAt?: Date | string
    studentId: string
    academicSemesterId: string
    courseId: string
  }

  export type StudentEnrolledCourseUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    grade?: NullableStringFieldUpdateOperationsInput | string | null
    point?: NullableFloatFieldUpdateOperationsInput | number | null
    totalMarks?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableEnumStudentEnrolledCourseStatusFieldUpdateOperationsInput | $Enums.StudentEnrolledCourseStatus | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentEnrolledCourseUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    grade?: NullableStringFieldUpdateOperationsInput | string | null
    point?: NullableFloatFieldUpdateOperationsInput | number | null
    totalMarks?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableEnumStudentEnrolledCourseStatusFieldUpdateOperationsInput | $Enums.StudentEnrolledCourseStatus | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    studentId?: StringFieldUpdateOperationsInput | string
    academicSemesterId?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
  }

  export type StudentEnrolledCourseMarkCreateInput = {
    id?: string
    examType?: $Enums.ExamType | null
    createdAt?: Date | string
    updatedAt?: Date | string
    exam1?: number
    exam2?: number
    exam3?: number
    exam4?: number
    exam5?: number
    exam6?: number
    finalExam?: number
    totalMarks?: number
    grade?: number
    student: StudentCreateNestedOneWithoutStudentEnrolledCourseMarksInput
    studentEnrolledCourse: StudentEnrolledCourseCreateNestedOneWithoutStudentEnrolledCourseMarksInput
    academicSemester: AcademicSemesterCreateNestedOneWithoutStudentEnrolledCourseMarksInput
  }

  export type StudentEnrolledCourseMarkUncheckedCreateInput = {
    id?: string
    examType?: $Enums.ExamType | null
    createdAt?: Date | string
    updatedAt?: Date | string
    studentId: string
    studentEnrolledCourseId: string
    academicSemesterId: string
    exam1?: number
    exam2?: number
    exam3?: number
    exam4?: number
    exam5?: number
    exam6?: number
    finalExam?: number
    totalMarks?: number
    grade?: number
  }

  export type StudentEnrolledCourseMarkUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    examType?: NullableEnumExamTypeFieldUpdateOperationsInput | $Enums.ExamType | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    exam1?: FloatFieldUpdateOperationsInput | number
    exam2?: FloatFieldUpdateOperationsInput | number
    exam3?: FloatFieldUpdateOperationsInput | number
    exam4?: FloatFieldUpdateOperationsInput | number
    exam5?: FloatFieldUpdateOperationsInput | number
    exam6?: FloatFieldUpdateOperationsInput | number
    finalExam?: FloatFieldUpdateOperationsInput | number
    totalMarks?: FloatFieldUpdateOperationsInput | number
    grade?: FloatFieldUpdateOperationsInput | number
    student?: StudentUpdateOneRequiredWithoutStudentEnrolledCourseMarksNestedInput
    studentEnrolledCourse?: StudentEnrolledCourseUpdateOneRequiredWithoutStudentEnrolledCourseMarksNestedInput
    academicSemester?: AcademicSemesterUpdateOneRequiredWithoutStudentEnrolledCourseMarksNestedInput
  }

  export type StudentEnrolledCourseMarkUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    examType?: NullableEnumExamTypeFieldUpdateOperationsInput | $Enums.ExamType | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    studentId?: StringFieldUpdateOperationsInput | string
    studentEnrolledCourseId?: StringFieldUpdateOperationsInput | string
    academicSemesterId?: StringFieldUpdateOperationsInput | string
    exam1?: FloatFieldUpdateOperationsInput | number
    exam2?: FloatFieldUpdateOperationsInput | number
    exam3?: FloatFieldUpdateOperationsInput | number
    exam4?: FloatFieldUpdateOperationsInput | number
    exam5?: FloatFieldUpdateOperationsInput | number
    exam6?: FloatFieldUpdateOperationsInput | number
    finalExam?: FloatFieldUpdateOperationsInput | number
    totalMarks?: FloatFieldUpdateOperationsInput | number
    grade?: FloatFieldUpdateOperationsInput | number
  }

  export type StudentEnrolledCourseMarkCreateManyInput = {
    id?: string
    examType?: $Enums.ExamType | null
    createdAt?: Date | string
    updatedAt?: Date | string
    studentId: string
    studentEnrolledCourseId: string
    academicSemesterId: string
    exam1?: number
    exam2?: number
    exam3?: number
    exam4?: number
    exam5?: number
    exam6?: number
    finalExam?: number
    totalMarks?: number
    grade?: number
  }

  export type StudentEnrolledCourseMarkUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    examType?: NullableEnumExamTypeFieldUpdateOperationsInput | $Enums.ExamType | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    exam1?: FloatFieldUpdateOperationsInput | number
    exam2?: FloatFieldUpdateOperationsInput | number
    exam3?: FloatFieldUpdateOperationsInput | number
    exam4?: FloatFieldUpdateOperationsInput | number
    exam5?: FloatFieldUpdateOperationsInput | number
    exam6?: FloatFieldUpdateOperationsInput | number
    finalExam?: FloatFieldUpdateOperationsInput | number
    totalMarks?: FloatFieldUpdateOperationsInput | number
    grade?: FloatFieldUpdateOperationsInput | number
  }

  export type StudentEnrolledCourseMarkUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    examType?: NullableEnumExamTypeFieldUpdateOperationsInput | $Enums.ExamType | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    studentId?: StringFieldUpdateOperationsInput | string
    studentEnrolledCourseId?: StringFieldUpdateOperationsInput | string
    academicSemesterId?: StringFieldUpdateOperationsInput | string
    exam1?: FloatFieldUpdateOperationsInput | number
    exam2?: FloatFieldUpdateOperationsInput | number
    exam3?: FloatFieldUpdateOperationsInput | number
    exam4?: FloatFieldUpdateOperationsInput | number
    exam5?: FloatFieldUpdateOperationsInput | number
    exam6?: FloatFieldUpdateOperationsInput | number
    finalExam?: FloatFieldUpdateOperationsInput | number
    totalMarks?: FloatFieldUpdateOperationsInput | number
    grade?: FloatFieldUpdateOperationsInput | number
  }

  export type StudentSemesterPaymentCreateInput = {
    id?: string
    paymentRecipt?: string | null
    totalPayment?: number
    baseAmount: number
    lateFee?: number
    aprovedPayment?: boolean
    paymentType?: $Enums.PAYMENTTYPE
    paymentStatus?: $Enums.PaymentStatus | null
    paymentMonth: number
    paymentYear: number
    createdAt?: Date | string
    updatedAt?: Date | string
    student: StudentCreateNestedOneWithoutStudentSemesterPaymentsInput
    academicSemester: AcademicSemesterCreateNestedOneWithoutStudentSemesterPaymentsInput
  }

  export type StudentSemesterPaymentUncheckedCreateInput = {
    id?: string
    paymentRecipt?: string | null
    totalPayment?: number
    baseAmount: number
    lateFee?: number
    aprovedPayment?: boolean
    paymentType?: $Enums.PAYMENTTYPE
    paymentStatus?: $Enums.PaymentStatus | null
    paymentMonth: number
    paymentYear: number
    createdAt?: Date | string
    updatedAt?: Date | string
    studentId: string
    academicSemesterId: string
  }

  export type StudentSemesterPaymentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    paymentRecipt?: NullableStringFieldUpdateOperationsInput | string | null
    totalPayment?: IntFieldUpdateOperationsInput | number
    baseAmount?: IntFieldUpdateOperationsInput | number
    lateFee?: IntFieldUpdateOperationsInput | number
    aprovedPayment?: BoolFieldUpdateOperationsInput | boolean
    paymentType?: EnumPAYMENTTYPEFieldUpdateOperationsInput | $Enums.PAYMENTTYPE
    paymentStatus?: NullableEnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus | null
    paymentMonth?: IntFieldUpdateOperationsInput | number
    paymentYear?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUpdateOneRequiredWithoutStudentSemesterPaymentsNestedInput
    academicSemester?: AcademicSemesterUpdateOneRequiredWithoutStudentSemesterPaymentsNestedInput
  }

  export type StudentSemesterPaymentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    paymentRecipt?: NullableStringFieldUpdateOperationsInput | string | null
    totalPayment?: IntFieldUpdateOperationsInput | number
    baseAmount?: IntFieldUpdateOperationsInput | number
    lateFee?: IntFieldUpdateOperationsInput | number
    aprovedPayment?: BoolFieldUpdateOperationsInput | boolean
    paymentType?: EnumPAYMENTTYPEFieldUpdateOperationsInput | $Enums.PAYMENTTYPE
    paymentStatus?: NullableEnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus | null
    paymentMonth?: IntFieldUpdateOperationsInput | number
    paymentYear?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    studentId?: StringFieldUpdateOperationsInput | string
    academicSemesterId?: StringFieldUpdateOperationsInput | string
  }

  export type StudentSemesterPaymentCreateManyInput = {
    id?: string
    paymentRecipt?: string | null
    totalPayment?: number
    baseAmount: number
    lateFee?: number
    aprovedPayment?: boolean
    paymentType?: $Enums.PAYMENTTYPE
    paymentStatus?: $Enums.PaymentStatus | null
    paymentMonth: number
    paymentYear: number
    createdAt?: Date | string
    updatedAt?: Date | string
    studentId: string
    academicSemesterId: string
  }

  export type StudentSemesterPaymentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    paymentRecipt?: NullableStringFieldUpdateOperationsInput | string | null
    totalPayment?: IntFieldUpdateOperationsInput | number
    baseAmount?: IntFieldUpdateOperationsInput | number
    lateFee?: IntFieldUpdateOperationsInput | number
    aprovedPayment?: BoolFieldUpdateOperationsInput | boolean
    paymentType?: EnumPAYMENTTYPEFieldUpdateOperationsInput | $Enums.PAYMENTTYPE
    paymentStatus?: NullableEnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus | null
    paymentMonth?: IntFieldUpdateOperationsInput | number
    paymentYear?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentSemesterPaymentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    paymentRecipt?: NullableStringFieldUpdateOperationsInput | string | null
    totalPayment?: IntFieldUpdateOperationsInput | number
    baseAmount?: IntFieldUpdateOperationsInput | number
    lateFee?: IntFieldUpdateOperationsInput | number
    aprovedPayment?: BoolFieldUpdateOperationsInput | boolean
    paymentType?: EnumPAYMENTTYPEFieldUpdateOperationsInput | $Enums.PAYMENTTYPE
    paymentStatus?: NullableEnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus | null
    paymentMonth?: IntFieldUpdateOperationsInput | number
    paymentYear?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    studentId?: StringFieldUpdateOperationsInput | string
    academicSemesterId?: StringFieldUpdateOperationsInput | string
  }

  export type StudentAcademicInfoCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    totalCompletedCredits?: number | null
    cgpa?: number | null
    student: StudentCreateNestedOneWithoutStudentAcademicInfosInput
  }

  export type StudentAcademicInfoUncheckedCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    studentId: string
    totalCompletedCredits?: number | null
    cgpa?: number | null
  }

  export type StudentAcademicInfoUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    totalCompletedCredits?: NullableIntFieldUpdateOperationsInput | number | null
    cgpa?: NullableFloatFieldUpdateOperationsInput | number | null
    student?: StudentUpdateOneRequiredWithoutStudentAcademicInfosNestedInput
  }

  export type StudentAcademicInfoUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    studentId?: StringFieldUpdateOperationsInput | string
    totalCompletedCredits?: NullableIntFieldUpdateOperationsInput | number | null
    cgpa?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type StudentAcademicInfoCreateManyInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    studentId: string
    totalCompletedCredits?: number | null
    cgpa?: number | null
  }

  export type StudentAcademicInfoUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    totalCompletedCredits?: NullableIntFieldUpdateOperationsInput | number | null
    cgpa?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type StudentAcademicInfoUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    studentId?: StringFieldUpdateOperationsInput | string
    totalCompletedCredits?: NullableIntFieldUpdateOperationsInput | number | null
    cgpa?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type EnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[]
    notIn?: $Enums.UserRole[]
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type AcademicDepartmentNullableScalarRelationFilter = {
    is?: AcademicDepartmentWhereInput | null
    isNot?: AcademicDepartmentWhereInput | null
  }

  export type AcademicDepartmentListRelationFilter = {
    every?: AcademicDepartmentWhereInput
    some?: AcademicDepartmentWhereInput
    none?: AcademicDepartmentWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type AcademicDepartmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UsersOrderByRelevanceInput = {
    fields: UsersOrderByRelevanceFieldEnum | UsersOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type UsersCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    avatar?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UsersMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    avatar?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UsersMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    avatar?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type EnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[]
    notIn?: $Enums.UserRole[]
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type SemesterRegistrationListRelationFilter = {
    every?: SemesterRegistrationWhereInput
    some?: SemesterRegistrationWhereInput
    none?: SemesterRegistrationWhereInput
  }

  export type StudentNullableScalarRelationFilter = {
    is?: StudentWhereInput | null
    isNot?: StudentWhereInput | null
  }

  export type StudentEnrolledCourseListRelationFilter = {
    every?: StudentEnrolledCourseWhereInput
    some?: StudentEnrolledCourseWhereInput
    none?: StudentEnrolledCourseWhereInput
  }

  export type StudentEnrolledCourseMarkListRelationFilter = {
    every?: StudentEnrolledCourseMarkWhereInput
    some?: StudentEnrolledCourseMarkWhereInput
    none?: StudentEnrolledCourseMarkWhereInput
  }

  export type StudentSemesterPaymentListRelationFilter = {
    every?: StudentSemesterPaymentWhereInput
    some?: StudentSemesterPaymentWhereInput
    none?: StudentSemesterPaymentWhereInput
  }

  export type SemesterRegistrationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StudentEnrolledCourseOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StudentEnrolledCourseMarkOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StudentSemesterPaymentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AcademicSemesterOrderByRelevanceInput = {
    fields: AcademicSemesterOrderByRelevanceFieldEnum | AcademicSemesterOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type AcademicSemesterCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    year?: SortOrder
    code?: SortOrder
    startMonth?: SortOrder
    endMonth?: SortOrder
    isCurrent?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AcademicSemesterMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    year?: SortOrder
    code?: SortOrder
    startMonth?: SortOrder
    endMonth?: SortOrder
    isCurrent?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AcademicSemesterMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    year?: SortOrder
    code?: SortOrder
    startMonth?: SortOrder
    endMonth?: SortOrder
    isCurrent?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type FacultyNullableScalarRelationFilter = {
    is?: FacultyWhereInput | null
    isNot?: FacultyWhereInput | null
  }

  export type AcademicFacultyOrderByRelevanceInput = {
    fields: AcademicFacultyOrderByRelevanceFieldEnum | AcademicFacultyOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type AcademicFacultyCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AcademicFacultyMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AcademicFacultyMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AcademicFacultyScalarRelationFilter = {
    is?: AcademicFacultyWhereInput
    isNot?: AcademicFacultyWhereInput
  }

  export type UsersNullableScalarRelationFilter = {
    is?: UsersWhereInput | null
    isNot?: UsersWhereInput | null
  }

  export type UsersListRelationFilter = {
    every?: UsersWhereInput
    some?: UsersWhereInput
    none?: UsersWhereInput
  }

  export type AdmitionExameRegistrationListRelationFilter = {
    every?: AdmitionExameRegistrationWhereInput
    some?: AdmitionExameRegistrationWhereInput
    none?: AdmitionExameRegistrationWhereInput
  }

  export type OfferedCourseListRelationFilter = {
    every?: OfferedCourseWhereInput
    some?: OfferedCourseWhereInput
    none?: OfferedCourseWhereInput
  }

  export type UsersOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AdmitionExameRegistrationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OfferedCourseOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AcademicDepartmentOrderByRelevanceInput = {
    fields: AcademicDepartmentOrderByRelevanceFieldEnum | AcademicDepartmentOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type AcademicDepartmentCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    academicFacultyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    departmentHeadId?: SortOrder
  }

  export type AcademicDepartmentMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    academicFacultyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    departmentHeadId?: SortOrder
  }

  export type AcademicDepartmentMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    academicFacultyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    departmentHeadId?: SortOrder
  }

  export type EnumShiftFilter<$PrismaModel = never> = {
    equals?: $Enums.Shift | EnumShiftFieldRefInput<$PrismaModel>
    in?: $Enums.Shift[]
    notIn?: $Enums.Shift[]
    not?: NestedEnumShiftFilter<$PrismaModel> | $Enums.Shift
  }

  export type AdmitionExameRegistrationNullableScalarRelationFilter = {
    is?: AdmitionExameRegistrationWhereInput | null
    isNot?: AdmitionExameRegistrationWhereInput | null
  }

  export type AcademicDepartmentScalarRelationFilter = {
    is?: AcademicDepartmentWhereInput
    isNot?: AcademicDepartmentWhereInput
  }

  export type AcademicSemesterScalarRelationFilter = {
    is?: AcademicSemesterWhereInput
    isNot?: AcademicSemesterWhereInput
  }

  export type StudentSemesterRegistrationListRelationFilter = {
    every?: StudentSemesterRegistrationWhereInput
    some?: StudentSemesterRegistrationWhereInput
    none?: StudentSemesterRegistrationWhereInput
  }

  export type StudentSemesterRegistrationCourseListRelationFilter = {
    every?: StudentSemesterRegistrationCourseWhereInput
    some?: StudentSemesterRegistrationCourseWhereInput
    none?: StudentSemesterRegistrationCourseWhereInput
  }

  export type StudentAcademicInfoListRelationFilter = {
    every?: StudentAcademicInfoWhereInput
    some?: StudentAcademicInfoWhereInput
    none?: StudentAcademicInfoWhereInput
  }

  export type StudentSemesterRegistrationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StudentSemesterRegistrationCourseOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StudentAcademicInfoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StudentOrderByRelevanceInput = {
    fields: StudentOrderByRelevanceFieldEnum | StudentOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type StudentCountOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    firstName?: SortOrder
    middleName?: SortOrder
    lastName?: SortOrder
    profileImage?: SortOrder
    email?: SortOrder
    contactNo?: SortOrder
    gender?: SortOrder
    isWoker?: SortOrder
    shift?: SortOrder
    password?: SortOrder
    gradeDeclarationFile?: SortOrder
    biFile?: SortOrder
    presentAddress?: SortOrder
    permanentAddress?: SortOrder
    academicSemesterId?: SortOrder
    academicFacultyId?: SortOrder
    academicDepartmentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    admissionRegistrationId?: SortOrder
  }

  export type StudentMaxOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    firstName?: SortOrder
    middleName?: SortOrder
    lastName?: SortOrder
    profileImage?: SortOrder
    email?: SortOrder
    contactNo?: SortOrder
    gender?: SortOrder
    isWoker?: SortOrder
    shift?: SortOrder
    password?: SortOrder
    gradeDeclarationFile?: SortOrder
    biFile?: SortOrder
    presentAddress?: SortOrder
    permanentAddress?: SortOrder
    academicSemesterId?: SortOrder
    academicFacultyId?: SortOrder
    academicDepartmentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    admissionRegistrationId?: SortOrder
  }

  export type StudentMinOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    firstName?: SortOrder
    middleName?: SortOrder
    lastName?: SortOrder
    profileImage?: SortOrder
    email?: SortOrder
    contactNo?: SortOrder
    gender?: SortOrder
    isWoker?: SortOrder
    shift?: SortOrder
    password?: SortOrder
    gradeDeclarationFile?: SortOrder
    biFile?: SortOrder
    presentAddress?: SortOrder
    permanentAddress?: SortOrder
    academicSemesterId?: SortOrder
    academicFacultyId?: SortOrder
    academicDepartmentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    admissionRegistrationId?: SortOrder
  }

  export type EnumShiftWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Shift | EnumShiftFieldRefInput<$PrismaModel>
    in?: $Enums.Shift[]
    notIn?: $Enums.Shift[]
    not?: NestedEnumShiftWithAggregatesFilter<$PrismaModel> | $Enums.Shift
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumShiftFilter<$PrismaModel>
    _max?: NestedEnumShiftFilter<$PrismaModel>
  }

  export type CourseFacultyListRelationFilter = {
    every?: CourseFacultyWhereInput
    some?: CourseFacultyWhereInput
    none?: CourseFacultyWhereInput
  }

  export type OfferedCourseClassScheduleListRelationFilter = {
    every?: OfferedCourseClassScheduleWhereInput
    some?: OfferedCourseClassScheduleWhereInput
    none?: OfferedCourseClassScheduleWhereInput
  }

  export type CourseFacultyOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OfferedCourseClassScheduleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FacultyOrderByRelevanceInput = {
    fields: FacultyOrderByRelevanceFieldEnum | FacultyOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type FacultyCountOrderByAggregateInput = {
    id?: SortOrder
    facultyId?: SortOrder
    firstName?: SortOrder
    middleName?: SortOrder
    lastName?: SortOrder
    profileImage?: SortOrder
    email?: SortOrder
    contactNo?: SortOrder
    gender?: SortOrder
    designation?: SortOrder
    password?: SortOrder
    academicFacultyId?: SortOrder
    academicDepartmentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FacultyMaxOrderByAggregateInput = {
    id?: SortOrder
    facultyId?: SortOrder
    firstName?: SortOrder
    middleName?: SortOrder
    lastName?: SortOrder
    profileImage?: SortOrder
    email?: SortOrder
    contactNo?: SortOrder
    gender?: SortOrder
    designation?: SortOrder
    password?: SortOrder
    academicFacultyId?: SortOrder
    academicDepartmentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FacultyMinOrderByAggregateInput = {
    id?: SortOrder
    facultyId?: SortOrder
    firstName?: SortOrder
    middleName?: SortOrder
    lastName?: SortOrder
    profileImage?: SortOrder
    email?: SortOrder
    contactNo?: SortOrder
    gender?: SortOrder
    designation?: SortOrder
    password?: SortOrder
    academicFacultyId?: SortOrder
    academicDepartmentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RoomListRelationFilter = {
    every?: RoomWhereInput
    some?: RoomWhereInput
    none?: RoomWhereInput
  }

  export type RoomOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BuildingOrderByRelevanceInput = {
    fields: BuildingOrderByRelevanceFieldEnum | BuildingOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type BuildingCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BuildingMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BuildingMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BuildingScalarRelationFilter = {
    is?: BuildingWhereInput
    isNot?: BuildingWhereInput
  }

  export type RoomOrderByRelevanceInput = {
    fields: RoomOrderByRelevanceFieldEnum | RoomOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type RoomCountOrderByAggregateInput = {
    id?: SortOrder
    roomNumber?: SortOrder
    floor?: SortOrder
    buildingId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RoomMaxOrderByAggregateInput = {
    id?: SortOrder
    roomNumber?: SortOrder
    floor?: SortOrder
    buildingId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RoomMinOrderByAggregateInput = {
    id?: SortOrder
    roomNumber?: SortOrder
    floor?: SortOrder
    buildingId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type CourseToPreRequisiteListRelationFilter = {
    every?: CourseToPreRequisiteWhereInput
    some?: CourseToPreRequisiteWhereInput
    none?: CourseToPreRequisiteWhereInput
  }

  export type CourseToPreRequisiteOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CourseOrderByRelevanceInput = {
    fields: CourseOrderByRelevanceFieldEnum | CourseOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type CourseCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    code?: SortOrder
    credits?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CourseAvgOrderByAggregateInput = {
    credits?: SortOrder
  }

  export type CourseMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    code?: SortOrder
    credits?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CourseMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    code?: SortOrder
    credits?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CourseSumOrderByAggregateInput = {
    credits?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type CourseScalarRelationFilter = {
    is?: CourseWhereInput
    isNot?: CourseWhereInput
  }

  export type CourseToPreRequisiteOrderByRelevanceInput = {
    fields: CourseToPreRequisiteOrderByRelevanceFieldEnum | CourseToPreRequisiteOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type CourseToPreRequisiteCourseIdPreRequisiteIdCompoundUniqueInput = {
    courseId: string
    preRequisiteId: string
  }

  export type CourseToPreRequisiteCountOrderByAggregateInput = {
    courseId?: SortOrder
    preRequisiteId?: SortOrder
  }

  export type CourseToPreRequisiteMaxOrderByAggregateInput = {
    courseId?: SortOrder
    preRequisiteId?: SortOrder
  }

  export type CourseToPreRequisiteMinOrderByAggregateInput = {
    courseId?: SortOrder
    preRequisiteId?: SortOrder
  }

  export type FacultyScalarRelationFilter = {
    is?: FacultyWhereInput
    isNot?: FacultyWhereInput
  }

  export type CourseFacultyOrderByRelevanceInput = {
    fields: CourseFacultyOrderByRelevanceFieldEnum | CourseFacultyOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type CourseFacultyCourseIdFacultyIdCompoundUniqueInput = {
    courseId: string
    facultyId: string
  }

  export type CourseFacultyCountOrderByAggregateInput = {
    courseId?: SortOrder
    facultyId?: SortOrder
  }

  export type CourseFacultyMaxOrderByAggregateInput = {
    courseId?: SortOrder
    facultyId?: SortOrder
  }

  export type CourseFacultyMinOrderByAggregateInput = {
    courseId?: SortOrder
    facultyId?: SortOrder
  }

  export type EnumSemesterRegistrationStatusNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.SemesterRegistrationStatus | EnumSemesterRegistrationStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.SemesterRegistrationStatus[] | null
    notIn?: $Enums.SemesterRegistrationStatus[] | null
    not?: NestedEnumSemesterRegistrationStatusNullableFilter<$PrismaModel> | $Enums.SemesterRegistrationStatus | null
  }

  export type OfferedCourseSectionListRelationFilter = {
    every?: OfferedCourseSectionWhereInput
    some?: OfferedCourseSectionWhereInput
    none?: OfferedCourseSectionWhereInput
  }

  export type OfferedCourseSectionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SemesterRegistrationOrderByRelevanceInput = {
    fields: SemesterRegistrationOrderByRelevanceFieldEnum | SemesterRegistrationOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type SemesterRegistrationCountOrderByAggregateInput = {
    id?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    status?: SortOrder
    paymentRecipt?: SortOrder
    totalPayment?: SortOrder
    createdAt?: SortOrder
    updateAt?: SortOrder
    academicSemesterId?: SortOrder
  }

  export type SemesterRegistrationAvgOrderByAggregateInput = {
    totalPayment?: SortOrder
  }

  export type SemesterRegistrationMaxOrderByAggregateInput = {
    id?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    status?: SortOrder
    paymentRecipt?: SortOrder
    totalPayment?: SortOrder
    createdAt?: SortOrder
    updateAt?: SortOrder
    academicSemesterId?: SortOrder
  }

  export type SemesterRegistrationMinOrderByAggregateInput = {
    id?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    status?: SortOrder
    paymentRecipt?: SortOrder
    totalPayment?: SortOrder
    createdAt?: SortOrder
    updateAt?: SortOrder
    academicSemesterId?: SortOrder
  }

  export type SemesterRegistrationSumOrderByAggregateInput = {
    totalPayment?: SortOrder
  }

  export type EnumSemesterRegistrationStatusNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SemesterRegistrationStatus | EnumSemesterRegistrationStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.SemesterRegistrationStatus[] | null
    notIn?: $Enums.SemesterRegistrationStatus[] | null
    not?: NestedEnumSemesterRegistrationStatusNullableWithAggregatesFilter<$PrismaModel> | $Enums.SemesterRegistrationStatus | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumSemesterRegistrationStatusNullableFilter<$PrismaModel>
    _max?: NestedEnumSemesterRegistrationStatusNullableFilter<$PrismaModel>
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type BoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type AdmitionExameRegistrationOrderByRelevanceInput = {
    fields: AdmitionExameRegistrationOrderByRelevanceFieldEnum | AdmitionExameRegistrationOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type AdmitionExameRegistrationCountOrderByAggregateInput = {
    id?: SortOrder
    applicantName?: SortOrder
    paymentRecipt?: SortOrder
    document?: SortOrder
    paymentAmoute?: SortOrder
    aprovePayment?: SortOrder
    exameResults?: SortOrder
    passed?: SortOrder
    fase?: SortOrder
    exameDate?: SortOrder
    createdAt?: SortOrder
    updateAt?: SortOrder
    departmentId?: SortOrder
  }

  export type AdmitionExameRegistrationAvgOrderByAggregateInput = {
    paymentAmoute?: SortOrder
    exameResults?: SortOrder
    fase?: SortOrder
  }

  export type AdmitionExameRegistrationMaxOrderByAggregateInput = {
    id?: SortOrder
    applicantName?: SortOrder
    paymentRecipt?: SortOrder
    document?: SortOrder
    paymentAmoute?: SortOrder
    aprovePayment?: SortOrder
    exameResults?: SortOrder
    passed?: SortOrder
    fase?: SortOrder
    exameDate?: SortOrder
    createdAt?: SortOrder
    updateAt?: SortOrder
    departmentId?: SortOrder
  }

  export type AdmitionExameRegistrationMinOrderByAggregateInput = {
    id?: SortOrder
    applicantName?: SortOrder
    paymentRecipt?: SortOrder
    document?: SortOrder
    paymentAmoute?: SortOrder
    aprovePayment?: SortOrder
    exameResults?: SortOrder
    passed?: SortOrder
    fase?: SortOrder
    exameDate?: SortOrder
    createdAt?: SortOrder
    updateAt?: SortOrder
    departmentId?: SortOrder
  }

  export type AdmitionExameRegistrationSumOrderByAggregateInput = {
    paymentAmoute?: SortOrder
    exameResults?: SortOrder
    fase?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type BoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type SemesterRegistrationScalarRelationFilter = {
    is?: SemesterRegistrationWhereInput
    isNot?: SemesterRegistrationWhereInput
  }

  export type OfferedCourseOrderByRelevanceInput = {
    fields: OfferedCourseOrderByRelevanceFieldEnum | OfferedCourseOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type OfferedCourseCountOrderByAggregateInput = {
    id?: SortOrder
    academicDepartmentId?: SortOrder
    courseId?: SortOrder
    semesterRegistrationId?: SortOrder
  }

  export type OfferedCourseMaxOrderByAggregateInput = {
    id?: SortOrder
    academicDepartmentId?: SortOrder
    courseId?: SortOrder
    semesterRegistrationId?: SortOrder
  }

  export type OfferedCourseMinOrderByAggregateInput = {
    id?: SortOrder
    academicDepartmentId?: SortOrder
    courseId?: SortOrder
    semesterRegistrationId?: SortOrder
  }

  export type OfferedCourseScalarRelationFilter = {
    is?: OfferedCourseWhereInput
    isNot?: OfferedCourseWhereInput
  }

  export type OfferedCourseSectionOrderByRelevanceInput = {
    fields: OfferedCourseSectionOrderByRelevanceFieldEnum | OfferedCourseSectionOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type OfferedCourseSectionCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    maxCapacity?: SortOrder
    currentlyEnrolledStudent?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    semesterRegistrationId?: SortOrder
    offeredCourseId?: SortOrder
  }

  export type OfferedCourseSectionAvgOrderByAggregateInput = {
    maxCapacity?: SortOrder
    currentlyEnrolledStudent?: SortOrder
  }

  export type OfferedCourseSectionMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    maxCapacity?: SortOrder
    currentlyEnrolledStudent?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    semesterRegistrationId?: SortOrder
    offeredCourseId?: SortOrder
  }

  export type OfferedCourseSectionMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    maxCapacity?: SortOrder
    currentlyEnrolledStudent?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    semesterRegistrationId?: SortOrder
    offeredCourseId?: SortOrder
  }

  export type OfferedCourseSectionSumOrderByAggregateInput = {
    maxCapacity?: SortOrder
    currentlyEnrolledStudent?: SortOrder
  }

  export type EnumWeekDaysFilter<$PrismaModel = never> = {
    equals?: $Enums.WeekDays | EnumWeekDaysFieldRefInput<$PrismaModel>
    in?: $Enums.WeekDays[]
    notIn?: $Enums.WeekDays[]
    not?: NestedEnumWeekDaysFilter<$PrismaModel> | $Enums.WeekDays
  }

  export type OfferedCourseSectionScalarRelationFilter = {
    is?: OfferedCourseSectionWhereInput
    isNot?: OfferedCourseSectionWhereInput
  }

  export type RoomScalarRelationFilter = {
    is?: RoomWhereInput
    isNot?: RoomWhereInput
  }

  export type OfferedCourseClassScheduleOrderByRelevanceInput = {
    fields: OfferedCourseClassScheduleOrderByRelevanceFieldEnum | OfferedCourseClassScheduleOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type OfferedCourseClassScheduleCountOrderByAggregateInput = {
    id?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    dayOfWeek?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    offeredCourseSectionId?: SortOrder
    semesterRegistrationId?: SortOrder
    roomId?: SortOrder
    facultyId?: SortOrder
  }

  export type OfferedCourseClassScheduleMaxOrderByAggregateInput = {
    id?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    dayOfWeek?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    offeredCourseSectionId?: SortOrder
    semesterRegistrationId?: SortOrder
    roomId?: SortOrder
    facultyId?: SortOrder
  }

  export type OfferedCourseClassScheduleMinOrderByAggregateInput = {
    id?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    dayOfWeek?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    offeredCourseSectionId?: SortOrder
    semesterRegistrationId?: SortOrder
    roomId?: SortOrder
    facultyId?: SortOrder
  }

  export type EnumWeekDaysWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.WeekDays | EnumWeekDaysFieldRefInput<$PrismaModel>
    in?: $Enums.WeekDays[]
    notIn?: $Enums.WeekDays[]
    not?: NestedEnumWeekDaysWithAggregatesFilter<$PrismaModel> | $Enums.WeekDays
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumWeekDaysFilter<$PrismaModel>
    _max?: NestedEnumWeekDaysFilter<$PrismaModel>
  }

  export type StudentScalarRelationFilter = {
    is?: StudentWhereInput
    isNot?: StudentWhereInput
  }

  export type StudentSemesterRegistrationOrderByRelevanceInput = {
    fields: StudentSemesterRegistrationOrderByRelevanceFieldEnum | StudentSemesterRegistrationOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type StudentSemesterRegistrationCountOrderByAggregateInput = {
    id?: SortOrder
    isConfirmed?: SortOrder
    totalCreditsTaken?: SortOrder
    paymentRecipt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    studentId?: SortOrder
    semesterRegistrationId?: SortOrder
  }

  export type StudentSemesterRegistrationAvgOrderByAggregateInput = {
    totalCreditsTaken?: SortOrder
  }

  export type StudentSemesterRegistrationMaxOrderByAggregateInput = {
    id?: SortOrder
    isConfirmed?: SortOrder
    totalCreditsTaken?: SortOrder
    paymentRecipt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    studentId?: SortOrder
    semesterRegistrationId?: SortOrder
  }

  export type StudentSemesterRegistrationMinOrderByAggregateInput = {
    id?: SortOrder
    isConfirmed?: SortOrder
    totalCreditsTaken?: SortOrder
    paymentRecipt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    studentId?: SortOrder
    semesterRegistrationId?: SortOrder
  }

  export type StudentSemesterRegistrationSumOrderByAggregateInput = {
    totalCreditsTaken?: SortOrder
  }

  export type StudentSemesterRegistrationCourseOrderByRelevanceInput = {
    fields: StudentSemesterRegistrationCourseOrderByRelevanceFieldEnum | StudentSemesterRegistrationCourseOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type StudentSemesterRegistrationCourseSemesterRegistrationIdStudentIdOfferedCourseIdCompoundUniqueInput = {
    semesterRegistrationId: string
    studentId: string
    offeredCourseId: string
  }

  export type StudentSemesterRegistrationCourseCountOrderByAggregateInput = {
    semesterRegistrationId?: SortOrder
    studentId?: SortOrder
    offeredCourseId?: SortOrder
    offeredCourseSectionId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StudentSemesterRegistrationCourseMaxOrderByAggregateInput = {
    semesterRegistrationId?: SortOrder
    studentId?: SortOrder
    offeredCourseId?: SortOrder
    offeredCourseSectionId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StudentSemesterRegistrationCourseMinOrderByAggregateInput = {
    semesterRegistrationId?: SortOrder
    studentId?: SortOrder
    offeredCourseId?: SortOrder
    offeredCourseSectionId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type EnumStudentEnrolledCourseStatusNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.StudentEnrolledCourseStatus | EnumStudentEnrolledCourseStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.StudentEnrolledCourseStatus[] | null
    notIn?: $Enums.StudentEnrolledCourseStatus[] | null
    not?: NestedEnumStudentEnrolledCourseStatusNullableFilter<$PrismaModel> | $Enums.StudentEnrolledCourseStatus | null
  }

  export type StudentEnrolledCourseOrderByRelevanceInput = {
    fields: StudentEnrolledCourseOrderByRelevanceFieldEnum | StudentEnrolledCourseOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type StudentEnrolledCourseCountOrderByAggregateInput = {
    id?: SortOrder
    grade?: SortOrder
    point?: SortOrder
    totalMarks?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    studentId?: SortOrder
    academicSemesterId?: SortOrder
    courseId?: SortOrder
  }

  export type StudentEnrolledCourseAvgOrderByAggregateInput = {
    point?: SortOrder
    totalMarks?: SortOrder
  }

  export type StudentEnrolledCourseMaxOrderByAggregateInput = {
    id?: SortOrder
    grade?: SortOrder
    point?: SortOrder
    totalMarks?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    studentId?: SortOrder
    academicSemesterId?: SortOrder
    courseId?: SortOrder
  }

  export type StudentEnrolledCourseMinOrderByAggregateInput = {
    id?: SortOrder
    grade?: SortOrder
    point?: SortOrder
    totalMarks?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    studentId?: SortOrder
    academicSemesterId?: SortOrder
    courseId?: SortOrder
  }

  export type StudentEnrolledCourseSumOrderByAggregateInput = {
    point?: SortOrder
    totalMarks?: SortOrder
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type EnumStudentEnrolledCourseStatusNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.StudentEnrolledCourseStatus | EnumStudentEnrolledCourseStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.StudentEnrolledCourseStatus[] | null
    notIn?: $Enums.StudentEnrolledCourseStatus[] | null
    not?: NestedEnumStudentEnrolledCourseStatusNullableWithAggregatesFilter<$PrismaModel> | $Enums.StudentEnrolledCourseStatus | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumStudentEnrolledCourseStatusNullableFilter<$PrismaModel>
    _max?: NestedEnumStudentEnrolledCourseStatusNullableFilter<$PrismaModel>
  }

  export type EnumExamTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.ExamType | EnumExamTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.ExamType[] | null
    notIn?: $Enums.ExamType[] | null
    not?: NestedEnumExamTypeNullableFilter<$PrismaModel> | $Enums.ExamType | null
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type StudentEnrolledCourseScalarRelationFilter = {
    is?: StudentEnrolledCourseWhereInput
    isNot?: StudentEnrolledCourseWhereInput
  }

  export type StudentEnrolledCourseMarkOrderByRelevanceInput = {
    fields: StudentEnrolledCourseMarkOrderByRelevanceFieldEnum | StudentEnrolledCourseMarkOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type StudentEnrolledCourseMarkCountOrderByAggregateInput = {
    id?: SortOrder
    examType?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    studentId?: SortOrder
    studentEnrolledCourseId?: SortOrder
    academicSemesterId?: SortOrder
    exam1?: SortOrder
    exam2?: SortOrder
    exam3?: SortOrder
    exam4?: SortOrder
    exam5?: SortOrder
    exam6?: SortOrder
    finalExam?: SortOrder
    totalMarks?: SortOrder
    grade?: SortOrder
  }

  export type StudentEnrolledCourseMarkAvgOrderByAggregateInput = {
    exam1?: SortOrder
    exam2?: SortOrder
    exam3?: SortOrder
    exam4?: SortOrder
    exam5?: SortOrder
    exam6?: SortOrder
    finalExam?: SortOrder
    totalMarks?: SortOrder
    grade?: SortOrder
  }

  export type StudentEnrolledCourseMarkMaxOrderByAggregateInput = {
    id?: SortOrder
    examType?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    studentId?: SortOrder
    studentEnrolledCourseId?: SortOrder
    academicSemesterId?: SortOrder
    exam1?: SortOrder
    exam2?: SortOrder
    exam3?: SortOrder
    exam4?: SortOrder
    exam5?: SortOrder
    exam6?: SortOrder
    finalExam?: SortOrder
    totalMarks?: SortOrder
    grade?: SortOrder
  }

  export type StudentEnrolledCourseMarkMinOrderByAggregateInput = {
    id?: SortOrder
    examType?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    studentId?: SortOrder
    studentEnrolledCourseId?: SortOrder
    academicSemesterId?: SortOrder
    exam1?: SortOrder
    exam2?: SortOrder
    exam3?: SortOrder
    exam4?: SortOrder
    exam5?: SortOrder
    exam6?: SortOrder
    finalExam?: SortOrder
    totalMarks?: SortOrder
    grade?: SortOrder
  }

  export type StudentEnrolledCourseMarkSumOrderByAggregateInput = {
    exam1?: SortOrder
    exam2?: SortOrder
    exam3?: SortOrder
    exam4?: SortOrder
    exam5?: SortOrder
    exam6?: SortOrder
    finalExam?: SortOrder
    totalMarks?: SortOrder
    grade?: SortOrder
  }

  export type EnumExamTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ExamType | EnumExamTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.ExamType[] | null
    notIn?: $Enums.ExamType[] | null
    not?: NestedEnumExamTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.ExamType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumExamTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumExamTypeNullableFilter<$PrismaModel>
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type EnumPAYMENTTYPEFilter<$PrismaModel = never> = {
    equals?: $Enums.PAYMENTTYPE | EnumPAYMENTTYPEFieldRefInput<$PrismaModel>
    in?: $Enums.PAYMENTTYPE[]
    notIn?: $Enums.PAYMENTTYPE[]
    not?: NestedEnumPAYMENTTYPEFilter<$PrismaModel> | $Enums.PAYMENTTYPE
  }

  export type EnumPaymentStatusNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.PaymentStatus[] | null
    notIn?: $Enums.PaymentStatus[] | null
    not?: NestedEnumPaymentStatusNullableFilter<$PrismaModel> | $Enums.PaymentStatus | null
  }

  export type StudentSemesterPaymentOrderByRelevanceInput = {
    fields: StudentSemesterPaymentOrderByRelevanceFieldEnum | StudentSemesterPaymentOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type StudentSemesterPaymentCountOrderByAggregateInput = {
    id?: SortOrder
    paymentRecipt?: SortOrder
    totalPayment?: SortOrder
    baseAmount?: SortOrder
    lateFee?: SortOrder
    aprovedPayment?: SortOrder
    paymentType?: SortOrder
    paymentStatus?: SortOrder
    paymentMonth?: SortOrder
    paymentYear?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    studentId?: SortOrder
    academicSemesterId?: SortOrder
  }

  export type StudentSemesterPaymentAvgOrderByAggregateInput = {
    totalPayment?: SortOrder
    baseAmount?: SortOrder
    lateFee?: SortOrder
    paymentMonth?: SortOrder
    paymentYear?: SortOrder
  }

  export type StudentSemesterPaymentMaxOrderByAggregateInput = {
    id?: SortOrder
    paymentRecipt?: SortOrder
    totalPayment?: SortOrder
    baseAmount?: SortOrder
    lateFee?: SortOrder
    aprovedPayment?: SortOrder
    paymentType?: SortOrder
    paymentStatus?: SortOrder
    paymentMonth?: SortOrder
    paymentYear?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    studentId?: SortOrder
    academicSemesterId?: SortOrder
  }

  export type StudentSemesterPaymentMinOrderByAggregateInput = {
    id?: SortOrder
    paymentRecipt?: SortOrder
    totalPayment?: SortOrder
    baseAmount?: SortOrder
    lateFee?: SortOrder
    aprovedPayment?: SortOrder
    paymentType?: SortOrder
    paymentStatus?: SortOrder
    paymentMonth?: SortOrder
    paymentYear?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    studentId?: SortOrder
    academicSemesterId?: SortOrder
  }

  export type StudentSemesterPaymentSumOrderByAggregateInput = {
    totalPayment?: SortOrder
    baseAmount?: SortOrder
    lateFee?: SortOrder
    paymentMonth?: SortOrder
    paymentYear?: SortOrder
  }

  export type EnumPAYMENTTYPEWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PAYMENTTYPE | EnumPAYMENTTYPEFieldRefInput<$PrismaModel>
    in?: $Enums.PAYMENTTYPE[]
    notIn?: $Enums.PAYMENTTYPE[]
    not?: NestedEnumPAYMENTTYPEWithAggregatesFilter<$PrismaModel> | $Enums.PAYMENTTYPE
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPAYMENTTYPEFilter<$PrismaModel>
    _max?: NestedEnumPAYMENTTYPEFilter<$PrismaModel>
  }

  export type EnumPaymentStatusNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.PaymentStatus[] | null
    notIn?: $Enums.PaymentStatus[] | null
    not?: NestedEnumPaymentStatusNullableWithAggregatesFilter<$PrismaModel> | $Enums.PaymentStatus | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumPaymentStatusNullableFilter<$PrismaModel>
    _max?: NestedEnumPaymentStatusNullableFilter<$PrismaModel>
  }

  export type StudentAcademicInfoOrderByRelevanceInput = {
    fields: StudentAcademicInfoOrderByRelevanceFieldEnum | StudentAcademicInfoOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type StudentAcademicInfoCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    studentId?: SortOrder
    totalCompletedCredits?: SortOrder
    cgpa?: SortOrder
  }

  export type StudentAcademicInfoAvgOrderByAggregateInput = {
    totalCompletedCredits?: SortOrder
    cgpa?: SortOrder
  }

  export type StudentAcademicInfoMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    studentId?: SortOrder
    totalCompletedCredits?: SortOrder
    cgpa?: SortOrder
  }

  export type StudentAcademicInfoMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    studentId?: SortOrder
    totalCompletedCredits?: SortOrder
    cgpa?: SortOrder
  }

  export type StudentAcademicInfoSumOrderByAggregateInput = {
    totalCompletedCredits?: SortOrder
    cgpa?: SortOrder
  }

  export type AcademicDepartmentCreateNestedOneWithoutDepartmentHeadInput = {
    create?: XOR<AcademicDepartmentCreateWithoutDepartmentHeadInput, AcademicDepartmentUncheckedCreateWithoutDepartmentHeadInput>
    connectOrCreate?: AcademicDepartmentCreateOrConnectWithoutDepartmentHeadInput
    connect?: AcademicDepartmentWhereUniqueInput
  }

  export type AcademicDepartmentCreateNestedManyWithoutStaffMembersInput = {
    create?: XOR<AcademicDepartmentCreateWithoutStaffMembersInput, AcademicDepartmentUncheckedCreateWithoutStaffMembersInput> | AcademicDepartmentCreateWithoutStaffMembersInput[] | AcademicDepartmentUncheckedCreateWithoutStaffMembersInput[]
    connectOrCreate?: AcademicDepartmentCreateOrConnectWithoutStaffMembersInput | AcademicDepartmentCreateOrConnectWithoutStaffMembersInput[]
    connect?: AcademicDepartmentWhereUniqueInput | AcademicDepartmentWhereUniqueInput[]
  }

  export type AcademicDepartmentUncheckedCreateNestedOneWithoutDepartmentHeadInput = {
    create?: XOR<AcademicDepartmentCreateWithoutDepartmentHeadInput, AcademicDepartmentUncheckedCreateWithoutDepartmentHeadInput>
    connectOrCreate?: AcademicDepartmentCreateOrConnectWithoutDepartmentHeadInput
    connect?: AcademicDepartmentWhereUniqueInput
  }

  export type AcademicDepartmentUncheckedCreateNestedManyWithoutStaffMembersInput = {
    create?: XOR<AcademicDepartmentCreateWithoutStaffMembersInput, AcademicDepartmentUncheckedCreateWithoutStaffMembersInput> | AcademicDepartmentCreateWithoutStaffMembersInput[] | AcademicDepartmentUncheckedCreateWithoutStaffMembersInput[]
    connectOrCreate?: AcademicDepartmentCreateOrConnectWithoutStaffMembersInput | AcademicDepartmentCreateOrConnectWithoutStaffMembersInput[]
    connect?: AcademicDepartmentWhereUniqueInput | AcademicDepartmentWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type EnumUserRoleFieldUpdateOperationsInput = {
    set?: $Enums.UserRole
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type AcademicDepartmentUpdateOneWithoutDepartmentHeadNestedInput = {
    create?: XOR<AcademicDepartmentCreateWithoutDepartmentHeadInput, AcademicDepartmentUncheckedCreateWithoutDepartmentHeadInput>
    connectOrCreate?: AcademicDepartmentCreateOrConnectWithoutDepartmentHeadInput
    upsert?: AcademicDepartmentUpsertWithoutDepartmentHeadInput
    disconnect?: AcademicDepartmentWhereInput | boolean
    delete?: AcademicDepartmentWhereInput | boolean
    connect?: AcademicDepartmentWhereUniqueInput
    update?: XOR<XOR<AcademicDepartmentUpdateToOneWithWhereWithoutDepartmentHeadInput, AcademicDepartmentUpdateWithoutDepartmentHeadInput>, AcademicDepartmentUncheckedUpdateWithoutDepartmentHeadInput>
  }

  export type AcademicDepartmentUpdateManyWithoutStaffMembersNestedInput = {
    create?: XOR<AcademicDepartmentCreateWithoutStaffMembersInput, AcademicDepartmentUncheckedCreateWithoutStaffMembersInput> | AcademicDepartmentCreateWithoutStaffMembersInput[] | AcademicDepartmentUncheckedCreateWithoutStaffMembersInput[]
    connectOrCreate?: AcademicDepartmentCreateOrConnectWithoutStaffMembersInput | AcademicDepartmentCreateOrConnectWithoutStaffMembersInput[]
    upsert?: AcademicDepartmentUpsertWithWhereUniqueWithoutStaffMembersInput | AcademicDepartmentUpsertWithWhereUniqueWithoutStaffMembersInput[]
    set?: AcademicDepartmentWhereUniqueInput | AcademicDepartmentWhereUniqueInput[]
    disconnect?: AcademicDepartmentWhereUniqueInput | AcademicDepartmentWhereUniqueInput[]
    delete?: AcademicDepartmentWhereUniqueInput | AcademicDepartmentWhereUniqueInput[]
    connect?: AcademicDepartmentWhereUniqueInput | AcademicDepartmentWhereUniqueInput[]
    update?: AcademicDepartmentUpdateWithWhereUniqueWithoutStaffMembersInput | AcademicDepartmentUpdateWithWhereUniqueWithoutStaffMembersInput[]
    updateMany?: AcademicDepartmentUpdateManyWithWhereWithoutStaffMembersInput | AcademicDepartmentUpdateManyWithWhereWithoutStaffMembersInput[]
    deleteMany?: AcademicDepartmentScalarWhereInput | AcademicDepartmentScalarWhereInput[]
  }

  export type AcademicDepartmentUncheckedUpdateOneWithoutDepartmentHeadNestedInput = {
    create?: XOR<AcademicDepartmentCreateWithoutDepartmentHeadInput, AcademicDepartmentUncheckedCreateWithoutDepartmentHeadInput>
    connectOrCreate?: AcademicDepartmentCreateOrConnectWithoutDepartmentHeadInput
    upsert?: AcademicDepartmentUpsertWithoutDepartmentHeadInput
    disconnect?: AcademicDepartmentWhereInput | boolean
    delete?: AcademicDepartmentWhereInput | boolean
    connect?: AcademicDepartmentWhereUniqueInput
    update?: XOR<XOR<AcademicDepartmentUpdateToOneWithWhereWithoutDepartmentHeadInput, AcademicDepartmentUpdateWithoutDepartmentHeadInput>, AcademicDepartmentUncheckedUpdateWithoutDepartmentHeadInput>
  }

  export type AcademicDepartmentUncheckedUpdateManyWithoutStaffMembersNestedInput = {
    create?: XOR<AcademicDepartmentCreateWithoutStaffMembersInput, AcademicDepartmentUncheckedCreateWithoutStaffMembersInput> | AcademicDepartmentCreateWithoutStaffMembersInput[] | AcademicDepartmentUncheckedCreateWithoutStaffMembersInput[]
    connectOrCreate?: AcademicDepartmentCreateOrConnectWithoutStaffMembersInput | AcademicDepartmentCreateOrConnectWithoutStaffMembersInput[]
    upsert?: AcademicDepartmentUpsertWithWhereUniqueWithoutStaffMembersInput | AcademicDepartmentUpsertWithWhereUniqueWithoutStaffMembersInput[]
    set?: AcademicDepartmentWhereUniqueInput | AcademicDepartmentWhereUniqueInput[]
    disconnect?: AcademicDepartmentWhereUniqueInput | AcademicDepartmentWhereUniqueInput[]
    delete?: AcademicDepartmentWhereUniqueInput | AcademicDepartmentWhereUniqueInput[]
    connect?: AcademicDepartmentWhereUniqueInput | AcademicDepartmentWhereUniqueInput[]
    update?: AcademicDepartmentUpdateWithWhereUniqueWithoutStaffMembersInput | AcademicDepartmentUpdateWithWhereUniqueWithoutStaffMembersInput[]
    updateMany?: AcademicDepartmentUpdateManyWithWhereWithoutStaffMembersInput | AcademicDepartmentUpdateManyWithWhereWithoutStaffMembersInput[]
    deleteMany?: AcademicDepartmentScalarWhereInput | AcademicDepartmentScalarWhereInput[]
  }

  export type SemesterRegistrationCreateNestedManyWithoutAcademicSemesterInput = {
    create?: XOR<SemesterRegistrationCreateWithoutAcademicSemesterInput, SemesterRegistrationUncheckedCreateWithoutAcademicSemesterInput> | SemesterRegistrationCreateWithoutAcademicSemesterInput[] | SemesterRegistrationUncheckedCreateWithoutAcademicSemesterInput[]
    connectOrCreate?: SemesterRegistrationCreateOrConnectWithoutAcademicSemesterInput | SemesterRegistrationCreateOrConnectWithoutAcademicSemesterInput[]
    createMany?: SemesterRegistrationCreateManyAcademicSemesterInputEnvelope
    connect?: SemesterRegistrationWhereUniqueInput | SemesterRegistrationWhereUniqueInput[]
  }

  export type StudentCreateNestedOneWithoutAcademicSemesterInput = {
    create?: XOR<StudentCreateWithoutAcademicSemesterInput, StudentUncheckedCreateWithoutAcademicSemesterInput>
    connectOrCreate?: StudentCreateOrConnectWithoutAcademicSemesterInput
    connect?: StudentWhereUniqueInput
  }

  export type StudentEnrolledCourseCreateNestedManyWithoutAcademicSemesterInput = {
    create?: XOR<StudentEnrolledCourseCreateWithoutAcademicSemesterInput, StudentEnrolledCourseUncheckedCreateWithoutAcademicSemesterInput> | StudentEnrolledCourseCreateWithoutAcademicSemesterInput[] | StudentEnrolledCourseUncheckedCreateWithoutAcademicSemesterInput[]
    connectOrCreate?: StudentEnrolledCourseCreateOrConnectWithoutAcademicSemesterInput | StudentEnrolledCourseCreateOrConnectWithoutAcademicSemesterInput[]
    createMany?: StudentEnrolledCourseCreateManyAcademicSemesterInputEnvelope
    connect?: StudentEnrolledCourseWhereUniqueInput | StudentEnrolledCourseWhereUniqueInput[]
  }

  export type StudentEnrolledCourseMarkCreateNestedManyWithoutAcademicSemesterInput = {
    create?: XOR<StudentEnrolledCourseMarkCreateWithoutAcademicSemesterInput, StudentEnrolledCourseMarkUncheckedCreateWithoutAcademicSemesterInput> | StudentEnrolledCourseMarkCreateWithoutAcademicSemesterInput[] | StudentEnrolledCourseMarkUncheckedCreateWithoutAcademicSemesterInput[]
    connectOrCreate?: StudentEnrolledCourseMarkCreateOrConnectWithoutAcademicSemesterInput | StudentEnrolledCourseMarkCreateOrConnectWithoutAcademicSemesterInput[]
    createMany?: StudentEnrolledCourseMarkCreateManyAcademicSemesterInputEnvelope
    connect?: StudentEnrolledCourseMarkWhereUniqueInput | StudentEnrolledCourseMarkWhereUniqueInput[]
  }

  export type StudentSemesterPaymentCreateNestedManyWithoutAcademicSemesterInput = {
    create?: XOR<StudentSemesterPaymentCreateWithoutAcademicSemesterInput, StudentSemesterPaymentUncheckedCreateWithoutAcademicSemesterInput> | StudentSemesterPaymentCreateWithoutAcademicSemesterInput[] | StudentSemesterPaymentUncheckedCreateWithoutAcademicSemesterInput[]
    connectOrCreate?: StudentSemesterPaymentCreateOrConnectWithoutAcademicSemesterInput | StudentSemesterPaymentCreateOrConnectWithoutAcademicSemesterInput[]
    createMany?: StudentSemesterPaymentCreateManyAcademicSemesterInputEnvelope
    connect?: StudentSemesterPaymentWhereUniqueInput | StudentSemesterPaymentWhereUniqueInput[]
  }

  export type SemesterRegistrationUncheckedCreateNestedManyWithoutAcademicSemesterInput = {
    create?: XOR<SemesterRegistrationCreateWithoutAcademicSemesterInput, SemesterRegistrationUncheckedCreateWithoutAcademicSemesterInput> | SemesterRegistrationCreateWithoutAcademicSemesterInput[] | SemesterRegistrationUncheckedCreateWithoutAcademicSemesterInput[]
    connectOrCreate?: SemesterRegistrationCreateOrConnectWithoutAcademicSemesterInput | SemesterRegistrationCreateOrConnectWithoutAcademicSemesterInput[]
    createMany?: SemesterRegistrationCreateManyAcademicSemesterInputEnvelope
    connect?: SemesterRegistrationWhereUniqueInput | SemesterRegistrationWhereUniqueInput[]
  }

  export type StudentUncheckedCreateNestedOneWithoutAcademicSemesterInput = {
    create?: XOR<StudentCreateWithoutAcademicSemesterInput, StudentUncheckedCreateWithoutAcademicSemesterInput>
    connectOrCreate?: StudentCreateOrConnectWithoutAcademicSemesterInput
    connect?: StudentWhereUniqueInput
  }

  export type StudentEnrolledCourseUncheckedCreateNestedManyWithoutAcademicSemesterInput = {
    create?: XOR<StudentEnrolledCourseCreateWithoutAcademicSemesterInput, StudentEnrolledCourseUncheckedCreateWithoutAcademicSemesterInput> | StudentEnrolledCourseCreateWithoutAcademicSemesterInput[] | StudentEnrolledCourseUncheckedCreateWithoutAcademicSemesterInput[]
    connectOrCreate?: StudentEnrolledCourseCreateOrConnectWithoutAcademicSemesterInput | StudentEnrolledCourseCreateOrConnectWithoutAcademicSemesterInput[]
    createMany?: StudentEnrolledCourseCreateManyAcademicSemesterInputEnvelope
    connect?: StudentEnrolledCourseWhereUniqueInput | StudentEnrolledCourseWhereUniqueInput[]
  }

  export type StudentEnrolledCourseMarkUncheckedCreateNestedManyWithoutAcademicSemesterInput = {
    create?: XOR<StudentEnrolledCourseMarkCreateWithoutAcademicSemesterInput, StudentEnrolledCourseMarkUncheckedCreateWithoutAcademicSemesterInput> | StudentEnrolledCourseMarkCreateWithoutAcademicSemesterInput[] | StudentEnrolledCourseMarkUncheckedCreateWithoutAcademicSemesterInput[]
    connectOrCreate?: StudentEnrolledCourseMarkCreateOrConnectWithoutAcademicSemesterInput | StudentEnrolledCourseMarkCreateOrConnectWithoutAcademicSemesterInput[]
    createMany?: StudentEnrolledCourseMarkCreateManyAcademicSemesterInputEnvelope
    connect?: StudentEnrolledCourseMarkWhereUniqueInput | StudentEnrolledCourseMarkWhereUniqueInput[]
  }

  export type StudentSemesterPaymentUncheckedCreateNestedManyWithoutAcademicSemesterInput = {
    create?: XOR<StudentSemesterPaymentCreateWithoutAcademicSemesterInput, StudentSemesterPaymentUncheckedCreateWithoutAcademicSemesterInput> | StudentSemesterPaymentCreateWithoutAcademicSemesterInput[] | StudentSemesterPaymentUncheckedCreateWithoutAcademicSemesterInput[]
    connectOrCreate?: StudentSemesterPaymentCreateOrConnectWithoutAcademicSemesterInput | StudentSemesterPaymentCreateOrConnectWithoutAcademicSemesterInput[]
    createMany?: StudentSemesterPaymentCreateManyAcademicSemesterInputEnvelope
    connect?: StudentSemesterPaymentWhereUniqueInput | StudentSemesterPaymentWhereUniqueInput[]
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type SemesterRegistrationUpdateManyWithoutAcademicSemesterNestedInput = {
    create?: XOR<SemesterRegistrationCreateWithoutAcademicSemesterInput, SemesterRegistrationUncheckedCreateWithoutAcademicSemesterInput> | SemesterRegistrationCreateWithoutAcademicSemesterInput[] | SemesterRegistrationUncheckedCreateWithoutAcademicSemesterInput[]
    connectOrCreate?: SemesterRegistrationCreateOrConnectWithoutAcademicSemesterInput | SemesterRegistrationCreateOrConnectWithoutAcademicSemesterInput[]
    upsert?: SemesterRegistrationUpsertWithWhereUniqueWithoutAcademicSemesterInput | SemesterRegistrationUpsertWithWhereUniqueWithoutAcademicSemesterInput[]
    createMany?: SemesterRegistrationCreateManyAcademicSemesterInputEnvelope
    set?: SemesterRegistrationWhereUniqueInput | SemesterRegistrationWhereUniqueInput[]
    disconnect?: SemesterRegistrationWhereUniqueInput | SemesterRegistrationWhereUniqueInput[]
    delete?: SemesterRegistrationWhereUniqueInput | SemesterRegistrationWhereUniqueInput[]
    connect?: SemesterRegistrationWhereUniqueInput | SemesterRegistrationWhereUniqueInput[]
    update?: SemesterRegistrationUpdateWithWhereUniqueWithoutAcademicSemesterInput | SemesterRegistrationUpdateWithWhereUniqueWithoutAcademicSemesterInput[]
    updateMany?: SemesterRegistrationUpdateManyWithWhereWithoutAcademicSemesterInput | SemesterRegistrationUpdateManyWithWhereWithoutAcademicSemesterInput[]
    deleteMany?: SemesterRegistrationScalarWhereInput | SemesterRegistrationScalarWhereInput[]
  }

  export type StudentUpdateOneWithoutAcademicSemesterNestedInput = {
    create?: XOR<StudentCreateWithoutAcademicSemesterInput, StudentUncheckedCreateWithoutAcademicSemesterInput>
    connectOrCreate?: StudentCreateOrConnectWithoutAcademicSemesterInput
    upsert?: StudentUpsertWithoutAcademicSemesterInput
    disconnect?: StudentWhereInput | boolean
    delete?: StudentWhereInput | boolean
    connect?: StudentWhereUniqueInput
    update?: XOR<XOR<StudentUpdateToOneWithWhereWithoutAcademicSemesterInput, StudentUpdateWithoutAcademicSemesterInput>, StudentUncheckedUpdateWithoutAcademicSemesterInput>
  }

  export type StudentEnrolledCourseUpdateManyWithoutAcademicSemesterNestedInput = {
    create?: XOR<StudentEnrolledCourseCreateWithoutAcademicSemesterInput, StudentEnrolledCourseUncheckedCreateWithoutAcademicSemesterInput> | StudentEnrolledCourseCreateWithoutAcademicSemesterInput[] | StudentEnrolledCourseUncheckedCreateWithoutAcademicSemesterInput[]
    connectOrCreate?: StudentEnrolledCourseCreateOrConnectWithoutAcademicSemesterInput | StudentEnrolledCourseCreateOrConnectWithoutAcademicSemesterInput[]
    upsert?: StudentEnrolledCourseUpsertWithWhereUniqueWithoutAcademicSemesterInput | StudentEnrolledCourseUpsertWithWhereUniqueWithoutAcademicSemesterInput[]
    createMany?: StudentEnrolledCourseCreateManyAcademicSemesterInputEnvelope
    set?: StudentEnrolledCourseWhereUniqueInput | StudentEnrolledCourseWhereUniqueInput[]
    disconnect?: StudentEnrolledCourseWhereUniqueInput | StudentEnrolledCourseWhereUniqueInput[]
    delete?: StudentEnrolledCourseWhereUniqueInput | StudentEnrolledCourseWhereUniqueInput[]
    connect?: StudentEnrolledCourseWhereUniqueInput | StudentEnrolledCourseWhereUniqueInput[]
    update?: StudentEnrolledCourseUpdateWithWhereUniqueWithoutAcademicSemesterInput | StudentEnrolledCourseUpdateWithWhereUniqueWithoutAcademicSemesterInput[]
    updateMany?: StudentEnrolledCourseUpdateManyWithWhereWithoutAcademicSemesterInput | StudentEnrolledCourseUpdateManyWithWhereWithoutAcademicSemesterInput[]
    deleteMany?: StudentEnrolledCourseScalarWhereInput | StudentEnrolledCourseScalarWhereInput[]
  }

  export type StudentEnrolledCourseMarkUpdateManyWithoutAcademicSemesterNestedInput = {
    create?: XOR<StudentEnrolledCourseMarkCreateWithoutAcademicSemesterInput, StudentEnrolledCourseMarkUncheckedCreateWithoutAcademicSemesterInput> | StudentEnrolledCourseMarkCreateWithoutAcademicSemesterInput[] | StudentEnrolledCourseMarkUncheckedCreateWithoutAcademicSemesterInput[]
    connectOrCreate?: StudentEnrolledCourseMarkCreateOrConnectWithoutAcademicSemesterInput | StudentEnrolledCourseMarkCreateOrConnectWithoutAcademicSemesterInput[]
    upsert?: StudentEnrolledCourseMarkUpsertWithWhereUniqueWithoutAcademicSemesterInput | StudentEnrolledCourseMarkUpsertWithWhereUniqueWithoutAcademicSemesterInput[]
    createMany?: StudentEnrolledCourseMarkCreateManyAcademicSemesterInputEnvelope
    set?: StudentEnrolledCourseMarkWhereUniqueInput | StudentEnrolledCourseMarkWhereUniqueInput[]
    disconnect?: StudentEnrolledCourseMarkWhereUniqueInput | StudentEnrolledCourseMarkWhereUniqueInput[]
    delete?: StudentEnrolledCourseMarkWhereUniqueInput | StudentEnrolledCourseMarkWhereUniqueInput[]
    connect?: StudentEnrolledCourseMarkWhereUniqueInput | StudentEnrolledCourseMarkWhereUniqueInput[]
    update?: StudentEnrolledCourseMarkUpdateWithWhereUniqueWithoutAcademicSemesterInput | StudentEnrolledCourseMarkUpdateWithWhereUniqueWithoutAcademicSemesterInput[]
    updateMany?: StudentEnrolledCourseMarkUpdateManyWithWhereWithoutAcademicSemesterInput | StudentEnrolledCourseMarkUpdateManyWithWhereWithoutAcademicSemesterInput[]
    deleteMany?: StudentEnrolledCourseMarkScalarWhereInput | StudentEnrolledCourseMarkScalarWhereInput[]
  }

  export type StudentSemesterPaymentUpdateManyWithoutAcademicSemesterNestedInput = {
    create?: XOR<StudentSemesterPaymentCreateWithoutAcademicSemesterInput, StudentSemesterPaymentUncheckedCreateWithoutAcademicSemesterInput> | StudentSemesterPaymentCreateWithoutAcademicSemesterInput[] | StudentSemesterPaymentUncheckedCreateWithoutAcademicSemesterInput[]
    connectOrCreate?: StudentSemesterPaymentCreateOrConnectWithoutAcademicSemesterInput | StudentSemesterPaymentCreateOrConnectWithoutAcademicSemesterInput[]
    upsert?: StudentSemesterPaymentUpsertWithWhereUniqueWithoutAcademicSemesterInput | StudentSemesterPaymentUpsertWithWhereUniqueWithoutAcademicSemesterInput[]
    createMany?: StudentSemesterPaymentCreateManyAcademicSemesterInputEnvelope
    set?: StudentSemesterPaymentWhereUniqueInput | StudentSemesterPaymentWhereUniqueInput[]
    disconnect?: StudentSemesterPaymentWhereUniqueInput | StudentSemesterPaymentWhereUniqueInput[]
    delete?: StudentSemesterPaymentWhereUniqueInput | StudentSemesterPaymentWhereUniqueInput[]
    connect?: StudentSemesterPaymentWhereUniqueInput | StudentSemesterPaymentWhereUniqueInput[]
    update?: StudentSemesterPaymentUpdateWithWhereUniqueWithoutAcademicSemesterInput | StudentSemesterPaymentUpdateWithWhereUniqueWithoutAcademicSemesterInput[]
    updateMany?: StudentSemesterPaymentUpdateManyWithWhereWithoutAcademicSemesterInput | StudentSemesterPaymentUpdateManyWithWhereWithoutAcademicSemesterInput[]
    deleteMany?: StudentSemesterPaymentScalarWhereInput | StudentSemesterPaymentScalarWhereInput[]
  }

  export type SemesterRegistrationUncheckedUpdateManyWithoutAcademicSemesterNestedInput = {
    create?: XOR<SemesterRegistrationCreateWithoutAcademicSemesterInput, SemesterRegistrationUncheckedCreateWithoutAcademicSemesterInput> | SemesterRegistrationCreateWithoutAcademicSemesterInput[] | SemesterRegistrationUncheckedCreateWithoutAcademicSemesterInput[]
    connectOrCreate?: SemesterRegistrationCreateOrConnectWithoutAcademicSemesterInput | SemesterRegistrationCreateOrConnectWithoutAcademicSemesterInput[]
    upsert?: SemesterRegistrationUpsertWithWhereUniqueWithoutAcademicSemesterInput | SemesterRegistrationUpsertWithWhereUniqueWithoutAcademicSemesterInput[]
    createMany?: SemesterRegistrationCreateManyAcademicSemesterInputEnvelope
    set?: SemesterRegistrationWhereUniqueInput | SemesterRegistrationWhereUniqueInput[]
    disconnect?: SemesterRegistrationWhereUniqueInput | SemesterRegistrationWhereUniqueInput[]
    delete?: SemesterRegistrationWhereUniqueInput | SemesterRegistrationWhereUniqueInput[]
    connect?: SemesterRegistrationWhereUniqueInput | SemesterRegistrationWhereUniqueInput[]
    update?: SemesterRegistrationUpdateWithWhereUniqueWithoutAcademicSemesterInput | SemesterRegistrationUpdateWithWhereUniqueWithoutAcademicSemesterInput[]
    updateMany?: SemesterRegistrationUpdateManyWithWhereWithoutAcademicSemesterInput | SemesterRegistrationUpdateManyWithWhereWithoutAcademicSemesterInput[]
    deleteMany?: SemesterRegistrationScalarWhereInput | SemesterRegistrationScalarWhereInput[]
  }

  export type StudentUncheckedUpdateOneWithoutAcademicSemesterNestedInput = {
    create?: XOR<StudentCreateWithoutAcademicSemesterInput, StudentUncheckedCreateWithoutAcademicSemesterInput>
    connectOrCreate?: StudentCreateOrConnectWithoutAcademicSemesterInput
    upsert?: StudentUpsertWithoutAcademicSemesterInput
    disconnect?: StudentWhereInput | boolean
    delete?: StudentWhereInput | boolean
    connect?: StudentWhereUniqueInput
    update?: XOR<XOR<StudentUpdateToOneWithWhereWithoutAcademicSemesterInput, StudentUpdateWithoutAcademicSemesterInput>, StudentUncheckedUpdateWithoutAcademicSemesterInput>
  }

  export type StudentEnrolledCourseUncheckedUpdateManyWithoutAcademicSemesterNestedInput = {
    create?: XOR<StudentEnrolledCourseCreateWithoutAcademicSemesterInput, StudentEnrolledCourseUncheckedCreateWithoutAcademicSemesterInput> | StudentEnrolledCourseCreateWithoutAcademicSemesterInput[] | StudentEnrolledCourseUncheckedCreateWithoutAcademicSemesterInput[]
    connectOrCreate?: StudentEnrolledCourseCreateOrConnectWithoutAcademicSemesterInput | StudentEnrolledCourseCreateOrConnectWithoutAcademicSemesterInput[]
    upsert?: StudentEnrolledCourseUpsertWithWhereUniqueWithoutAcademicSemesterInput | StudentEnrolledCourseUpsertWithWhereUniqueWithoutAcademicSemesterInput[]
    createMany?: StudentEnrolledCourseCreateManyAcademicSemesterInputEnvelope
    set?: StudentEnrolledCourseWhereUniqueInput | StudentEnrolledCourseWhereUniqueInput[]
    disconnect?: StudentEnrolledCourseWhereUniqueInput | StudentEnrolledCourseWhereUniqueInput[]
    delete?: StudentEnrolledCourseWhereUniqueInput | StudentEnrolledCourseWhereUniqueInput[]
    connect?: StudentEnrolledCourseWhereUniqueInput | StudentEnrolledCourseWhereUniqueInput[]
    update?: StudentEnrolledCourseUpdateWithWhereUniqueWithoutAcademicSemesterInput | StudentEnrolledCourseUpdateWithWhereUniqueWithoutAcademicSemesterInput[]
    updateMany?: StudentEnrolledCourseUpdateManyWithWhereWithoutAcademicSemesterInput | StudentEnrolledCourseUpdateManyWithWhereWithoutAcademicSemesterInput[]
    deleteMany?: StudentEnrolledCourseScalarWhereInput | StudentEnrolledCourseScalarWhereInput[]
  }

  export type StudentEnrolledCourseMarkUncheckedUpdateManyWithoutAcademicSemesterNestedInput = {
    create?: XOR<StudentEnrolledCourseMarkCreateWithoutAcademicSemesterInput, StudentEnrolledCourseMarkUncheckedCreateWithoutAcademicSemesterInput> | StudentEnrolledCourseMarkCreateWithoutAcademicSemesterInput[] | StudentEnrolledCourseMarkUncheckedCreateWithoutAcademicSemesterInput[]
    connectOrCreate?: StudentEnrolledCourseMarkCreateOrConnectWithoutAcademicSemesterInput | StudentEnrolledCourseMarkCreateOrConnectWithoutAcademicSemesterInput[]
    upsert?: StudentEnrolledCourseMarkUpsertWithWhereUniqueWithoutAcademicSemesterInput | StudentEnrolledCourseMarkUpsertWithWhereUniqueWithoutAcademicSemesterInput[]
    createMany?: StudentEnrolledCourseMarkCreateManyAcademicSemesterInputEnvelope
    set?: StudentEnrolledCourseMarkWhereUniqueInput | StudentEnrolledCourseMarkWhereUniqueInput[]
    disconnect?: StudentEnrolledCourseMarkWhereUniqueInput | StudentEnrolledCourseMarkWhereUniqueInput[]
    delete?: StudentEnrolledCourseMarkWhereUniqueInput | StudentEnrolledCourseMarkWhereUniqueInput[]
    connect?: StudentEnrolledCourseMarkWhereUniqueInput | StudentEnrolledCourseMarkWhereUniqueInput[]
    update?: StudentEnrolledCourseMarkUpdateWithWhereUniqueWithoutAcademicSemesterInput | StudentEnrolledCourseMarkUpdateWithWhereUniqueWithoutAcademicSemesterInput[]
    updateMany?: StudentEnrolledCourseMarkUpdateManyWithWhereWithoutAcademicSemesterInput | StudentEnrolledCourseMarkUpdateManyWithWhereWithoutAcademicSemesterInput[]
    deleteMany?: StudentEnrolledCourseMarkScalarWhereInput | StudentEnrolledCourseMarkScalarWhereInput[]
  }

  export type StudentSemesterPaymentUncheckedUpdateManyWithoutAcademicSemesterNestedInput = {
    create?: XOR<StudentSemesterPaymentCreateWithoutAcademicSemesterInput, StudentSemesterPaymentUncheckedCreateWithoutAcademicSemesterInput> | StudentSemesterPaymentCreateWithoutAcademicSemesterInput[] | StudentSemesterPaymentUncheckedCreateWithoutAcademicSemesterInput[]
    connectOrCreate?: StudentSemesterPaymentCreateOrConnectWithoutAcademicSemesterInput | StudentSemesterPaymentCreateOrConnectWithoutAcademicSemesterInput[]
    upsert?: StudentSemesterPaymentUpsertWithWhereUniqueWithoutAcademicSemesterInput | StudentSemesterPaymentUpsertWithWhereUniqueWithoutAcademicSemesterInput[]
    createMany?: StudentSemesterPaymentCreateManyAcademicSemesterInputEnvelope
    set?: StudentSemesterPaymentWhereUniqueInput | StudentSemesterPaymentWhereUniqueInput[]
    disconnect?: StudentSemesterPaymentWhereUniqueInput | StudentSemesterPaymentWhereUniqueInput[]
    delete?: StudentSemesterPaymentWhereUniqueInput | StudentSemesterPaymentWhereUniqueInput[]
    connect?: StudentSemesterPaymentWhereUniqueInput | StudentSemesterPaymentWhereUniqueInput[]
    update?: StudentSemesterPaymentUpdateWithWhereUniqueWithoutAcademicSemesterInput | StudentSemesterPaymentUpdateWithWhereUniqueWithoutAcademicSemesterInput[]
    updateMany?: StudentSemesterPaymentUpdateManyWithWhereWithoutAcademicSemesterInput | StudentSemesterPaymentUpdateManyWithWhereWithoutAcademicSemesterInput[]
    deleteMany?: StudentSemesterPaymentScalarWhereInput | StudentSemesterPaymentScalarWhereInput[]
  }

  export type AcademicDepartmentCreateNestedOneWithoutAcademicFacultyInput = {
    create?: XOR<AcademicDepartmentCreateWithoutAcademicFacultyInput, AcademicDepartmentUncheckedCreateWithoutAcademicFacultyInput>
    connectOrCreate?: AcademicDepartmentCreateOrConnectWithoutAcademicFacultyInput
    connect?: AcademicDepartmentWhereUniqueInput
  }

  export type FacultyCreateNestedOneWithoutAcademicFacultyInput = {
    create?: XOR<FacultyCreateWithoutAcademicFacultyInput, FacultyUncheckedCreateWithoutAcademicFacultyInput>
    connectOrCreate?: FacultyCreateOrConnectWithoutAcademicFacultyInput
    connect?: FacultyWhereUniqueInput
  }

  export type StudentCreateNestedOneWithoutAcademicFacultyInput = {
    create?: XOR<StudentCreateWithoutAcademicFacultyInput, StudentUncheckedCreateWithoutAcademicFacultyInput>
    connectOrCreate?: StudentCreateOrConnectWithoutAcademicFacultyInput
    connect?: StudentWhereUniqueInput
  }

  export type AcademicDepartmentUncheckedCreateNestedOneWithoutAcademicFacultyInput = {
    create?: XOR<AcademicDepartmentCreateWithoutAcademicFacultyInput, AcademicDepartmentUncheckedCreateWithoutAcademicFacultyInput>
    connectOrCreate?: AcademicDepartmentCreateOrConnectWithoutAcademicFacultyInput
    connect?: AcademicDepartmentWhereUniqueInput
  }

  export type FacultyUncheckedCreateNestedOneWithoutAcademicFacultyInput = {
    create?: XOR<FacultyCreateWithoutAcademicFacultyInput, FacultyUncheckedCreateWithoutAcademicFacultyInput>
    connectOrCreate?: FacultyCreateOrConnectWithoutAcademicFacultyInput
    connect?: FacultyWhereUniqueInput
  }

  export type StudentUncheckedCreateNestedOneWithoutAcademicFacultyInput = {
    create?: XOR<StudentCreateWithoutAcademicFacultyInput, StudentUncheckedCreateWithoutAcademicFacultyInput>
    connectOrCreate?: StudentCreateOrConnectWithoutAcademicFacultyInput
    connect?: StudentWhereUniqueInput
  }

  export type AcademicDepartmentUpdateOneWithoutAcademicFacultyNestedInput = {
    create?: XOR<AcademicDepartmentCreateWithoutAcademicFacultyInput, AcademicDepartmentUncheckedCreateWithoutAcademicFacultyInput>
    connectOrCreate?: AcademicDepartmentCreateOrConnectWithoutAcademicFacultyInput
    upsert?: AcademicDepartmentUpsertWithoutAcademicFacultyInput
    disconnect?: AcademicDepartmentWhereInput | boolean
    delete?: AcademicDepartmentWhereInput | boolean
    connect?: AcademicDepartmentWhereUniqueInput
    update?: XOR<XOR<AcademicDepartmentUpdateToOneWithWhereWithoutAcademicFacultyInput, AcademicDepartmentUpdateWithoutAcademicFacultyInput>, AcademicDepartmentUncheckedUpdateWithoutAcademicFacultyInput>
  }

  export type FacultyUpdateOneWithoutAcademicFacultyNestedInput = {
    create?: XOR<FacultyCreateWithoutAcademicFacultyInput, FacultyUncheckedCreateWithoutAcademicFacultyInput>
    connectOrCreate?: FacultyCreateOrConnectWithoutAcademicFacultyInput
    upsert?: FacultyUpsertWithoutAcademicFacultyInput
    disconnect?: FacultyWhereInput | boolean
    delete?: FacultyWhereInput | boolean
    connect?: FacultyWhereUniqueInput
    update?: XOR<XOR<FacultyUpdateToOneWithWhereWithoutAcademicFacultyInput, FacultyUpdateWithoutAcademicFacultyInput>, FacultyUncheckedUpdateWithoutAcademicFacultyInput>
  }

  export type StudentUpdateOneWithoutAcademicFacultyNestedInput = {
    create?: XOR<StudentCreateWithoutAcademicFacultyInput, StudentUncheckedCreateWithoutAcademicFacultyInput>
    connectOrCreate?: StudentCreateOrConnectWithoutAcademicFacultyInput
    upsert?: StudentUpsertWithoutAcademicFacultyInput
    disconnect?: StudentWhereInput | boolean
    delete?: StudentWhereInput | boolean
    connect?: StudentWhereUniqueInput
    update?: XOR<XOR<StudentUpdateToOneWithWhereWithoutAcademicFacultyInput, StudentUpdateWithoutAcademicFacultyInput>, StudentUncheckedUpdateWithoutAcademicFacultyInput>
  }

  export type AcademicDepartmentUncheckedUpdateOneWithoutAcademicFacultyNestedInput = {
    create?: XOR<AcademicDepartmentCreateWithoutAcademicFacultyInput, AcademicDepartmentUncheckedCreateWithoutAcademicFacultyInput>
    connectOrCreate?: AcademicDepartmentCreateOrConnectWithoutAcademicFacultyInput
    upsert?: AcademicDepartmentUpsertWithoutAcademicFacultyInput
    disconnect?: AcademicDepartmentWhereInput | boolean
    delete?: AcademicDepartmentWhereInput | boolean
    connect?: AcademicDepartmentWhereUniqueInput
    update?: XOR<XOR<AcademicDepartmentUpdateToOneWithWhereWithoutAcademicFacultyInput, AcademicDepartmentUpdateWithoutAcademicFacultyInput>, AcademicDepartmentUncheckedUpdateWithoutAcademicFacultyInput>
  }

  export type FacultyUncheckedUpdateOneWithoutAcademicFacultyNestedInput = {
    create?: XOR<FacultyCreateWithoutAcademicFacultyInput, FacultyUncheckedCreateWithoutAcademicFacultyInput>
    connectOrCreate?: FacultyCreateOrConnectWithoutAcademicFacultyInput
    upsert?: FacultyUpsertWithoutAcademicFacultyInput
    disconnect?: FacultyWhereInput | boolean
    delete?: FacultyWhereInput | boolean
    connect?: FacultyWhereUniqueInput
    update?: XOR<XOR<FacultyUpdateToOneWithWhereWithoutAcademicFacultyInput, FacultyUpdateWithoutAcademicFacultyInput>, FacultyUncheckedUpdateWithoutAcademicFacultyInput>
  }

  export type StudentUncheckedUpdateOneWithoutAcademicFacultyNestedInput = {
    create?: XOR<StudentCreateWithoutAcademicFacultyInput, StudentUncheckedCreateWithoutAcademicFacultyInput>
    connectOrCreate?: StudentCreateOrConnectWithoutAcademicFacultyInput
    upsert?: StudentUpsertWithoutAcademicFacultyInput
    disconnect?: StudentWhereInput | boolean
    delete?: StudentWhereInput | boolean
    connect?: StudentWhereUniqueInput
    update?: XOR<XOR<StudentUpdateToOneWithWhereWithoutAcademicFacultyInput, StudentUpdateWithoutAcademicFacultyInput>, StudentUncheckedUpdateWithoutAcademicFacultyInput>
  }

  export type AcademicFacultyCreateNestedOneWithoutAcademicDepartmentsInput = {
    create?: XOR<AcademicFacultyCreateWithoutAcademicDepartmentsInput, AcademicFacultyUncheckedCreateWithoutAcademicDepartmentsInput>
    connectOrCreate?: AcademicFacultyCreateOrConnectWithoutAcademicDepartmentsInput
    connect?: AcademicFacultyWhereUniqueInput
  }

  export type FacultyCreateNestedOneWithoutAcademicDepartmentInput = {
    create?: XOR<FacultyCreateWithoutAcademicDepartmentInput, FacultyUncheckedCreateWithoutAcademicDepartmentInput>
    connectOrCreate?: FacultyCreateOrConnectWithoutAcademicDepartmentInput
    connect?: FacultyWhereUniqueInput
  }

  export type StudentCreateNestedOneWithoutAcademicDepartmentInput = {
    create?: XOR<StudentCreateWithoutAcademicDepartmentInput, StudentUncheckedCreateWithoutAcademicDepartmentInput>
    connectOrCreate?: StudentCreateOrConnectWithoutAcademicDepartmentInput
    connect?: StudentWhereUniqueInput
  }

  export type UsersCreateNestedOneWithoutAcademicDepartmentInput = {
    create?: XOR<UsersCreateWithoutAcademicDepartmentInput, UsersUncheckedCreateWithoutAcademicDepartmentInput>
    connectOrCreate?: UsersCreateOrConnectWithoutAcademicDepartmentInput
    connect?: UsersWhereUniqueInput
  }

  export type UsersCreateNestedManyWithoutStaffDepartmentsInput = {
    create?: XOR<UsersCreateWithoutStaffDepartmentsInput, UsersUncheckedCreateWithoutStaffDepartmentsInput> | UsersCreateWithoutStaffDepartmentsInput[] | UsersUncheckedCreateWithoutStaffDepartmentsInput[]
    connectOrCreate?: UsersCreateOrConnectWithoutStaffDepartmentsInput | UsersCreateOrConnectWithoutStaffDepartmentsInput[]
    connect?: UsersWhereUniqueInput | UsersWhereUniqueInput[]
  }

  export type AdmitionExameRegistrationCreateNestedManyWithoutDepartmentInput = {
    create?: XOR<AdmitionExameRegistrationCreateWithoutDepartmentInput, AdmitionExameRegistrationUncheckedCreateWithoutDepartmentInput> | AdmitionExameRegistrationCreateWithoutDepartmentInput[] | AdmitionExameRegistrationUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: AdmitionExameRegistrationCreateOrConnectWithoutDepartmentInput | AdmitionExameRegistrationCreateOrConnectWithoutDepartmentInput[]
    createMany?: AdmitionExameRegistrationCreateManyDepartmentInputEnvelope
    connect?: AdmitionExameRegistrationWhereUniqueInput | AdmitionExameRegistrationWhereUniqueInput[]
  }

  export type OfferedCourseCreateNestedManyWithoutAcademicDepartmentInput = {
    create?: XOR<OfferedCourseCreateWithoutAcademicDepartmentInput, OfferedCourseUncheckedCreateWithoutAcademicDepartmentInput> | OfferedCourseCreateWithoutAcademicDepartmentInput[] | OfferedCourseUncheckedCreateWithoutAcademicDepartmentInput[]
    connectOrCreate?: OfferedCourseCreateOrConnectWithoutAcademicDepartmentInput | OfferedCourseCreateOrConnectWithoutAcademicDepartmentInput[]
    createMany?: OfferedCourseCreateManyAcademicDepartmentInputEnvelope
    connect?: OfferedCourseWhereUniqueInput | OfferedCourseWhereUniqueInput[]
  }

  export type FacultyUncheckedCreateNestedOneWithoutAcademicDepartmentInput = {
    create?: XOR<FacultyCreateWithoutAcademicDepartmentInput, FacultyUncheckedCreateWithoutAcademicDepartmentInput>
    connectOrCreate?: FacultyCreateOrConnectWithoutAcademicDepartmentInput
    connect?: FacultyWhereUniqueInput
  }

  export type StudentUncheckedCreateNestedOneWithoutAcademicDepartmentInput = {
    create?: XOR<StudentCreateWithoutAcademicDepartmentInput, StudentUncheckedCreateWithoutAcademicDepartmentInput>
    connectOrCreate?: StudentCreateOrConnectWithoutAcademicDepartmentInput
    connect?: StudentWhereUniqueInput
  }

  export type UsersUncheckedCreateNestedManyWithoutStaffDepartmentsInput = {
    create?: XOR<UsersCreateWithoutStaffDepartmentsInput, UsersUncheckedCreateWithoutStaffDepartmentsInput> | UsersCreateWithoutStaffDepartmentsInput[] | UsersUncheckedCreateWithoutStaffDepartmentsInput[]
    connectOrCreate?: UsersCreateOrConnectWithoutStaffDepartmentsInput | UsersCreateOrConnectWithoutStaffDepartmentsInput[]
    connect?: UsersWhereUniqueInput | UsersWhereUniqueInput[]
  }

  export type AdmitionExameRegistrationUncheckedCreateNestedManyWithoutDepartmentInput = {
    create?: XOR<AdmitionExameRegistrationCreateWithoutDepartmentInput, AdmitionExameRegistrationUncheckedCreateWithoutDepartmentInput> | AdmitionExameRegistrationCreateWithoutDepartmentInput[] | AdmitionExameRegistrationUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: AdmitionExameRegistrationCreateOrConnectWithoutDepartmentInput | AdmitionExameRegistrationCreateOrConnectWithoutDepartmentInput[]
    createMany?: AdmitionExameRegistrationCreateManyDepartmentInputEnvelope
    connect?: AdmitionExameRegistrationWhereUniqueInput | AdmitionExameRegistrationWhereUniqueInput[]
  }

  export type OfferedCourseUncheckedCreateNestedManyWithoutAcademicDepartmentInput = {
    create?: XOR<OfferedCourseCreateWithoutAcademicDepartmentInput, OfferedCourseUncheckedCreateWithoutAcademicDepartmentInput> | OfferedCourseCreateWithoutAcademicDepartmentInput[] | OfferedCourseUncheckedCreateWithoutAcademicDepartmentInput[]
    connectOrCreate?: OfferedCourseCreateOrConnectWithoutAcademicDepartmentInput | OfferedCourseCreateOrConnectWithoutAcademicDepartmentInput[]
    createMany?: OfferedCourseCreateManyAcademicDepartmentInputEnvelope
    connect?: OfferedCourseWhereUniqueInput | OfferedCourseWhereUniqueInput[]
  }

  export type AcademicFacultyUpdateOneRequiredWithoutAcademicDepartmentsNestedInput = {
    create?: XOR<AcademicFacultyCreateWithoutAcademicDepartmentsInput, AcademicFacultyUncheckedCreateWithoutAcademicDepartmentsInput>
    connectOrCreate?: AcademicFacultyCreateOrConnectWithoutAcademicDepartmentsInput
    upsert?: AcademicFacultyUpsertWithoutAcademicDepartmentsInput
    connect?: AcademicFacultyWhereUniqueInput
    update?: XOR<XOR<AcademicFacultyUpdateToOneWithWhereWithoutAcademicDepartmentsInput, AcademicFacultyUpdateWithoutAcademicDepartmentsInput>, AcademicFacultyUncheckedUpdateWithoutAcademicDepartmentsInput>
  }

  export type FacultyUpdateOneWithoutAcademicDepartmentNestedInput = {
    create?: XOR<FacultyCreateWithoutAcademicDepartmentInput, FacultyUncheckedCreateWithoutAcademicDepartmentInput>
    connectOrCreate?: FacultyCreateOrConnectWithoutAcademicDepartmentInput
    upsert?: FacultyUpsertWithoutAcademicDepartmentInput
    disconnect?: FacultyWhereInput | boolean
    delete?: FacultyWhereInput | boolean
    connect?: FacultyWhereUniqueInput
    update?: XOR<XOR<FacultyUpdateToOneWithWhereWithoutAcademicDepartmentInput, FacultyUpdateWithoutAcademicDepartmentInput>, FacultyUncheckedUpdateWithoutAcademicDepartmentInput>
  }

  export type StudentUpdateOneWithoutAcademicDepartmentNestedInput = {
    create?: XOR<StudentCreateWithoutAcademicDepartmentInput, StudentUncheckedCreateWithoutAcademicDepartmentInput>
    connectOrCreate?: StudentCreateOrConnectWithoutAcademicDepartmentInput
    upsert?: StudentUpsertWithoutAcademicDepartmentInput
    disconnect?: StudentWhereInput | boolean
    delete?: StudentWhereInput | boolean
    connect?: StudentWhereUniqueInput
    update?: XOR<XOR<StudentUpdateToOneWithWhereWithoutAcademicDepartmentInput, StudentUpdateWithoutAcademicDepartmentInput>, StudentUncheckedUpdateWithoutAcademicDepartmentInput>
  }

  export type UsersUpdateOneWithoutAcademicDepartmentNestedInput = {
    create?: XOR<UsersCreateWithoutAcademicDepartmentInput, UsersUncheckedCreateWithoutAcademicDepartmentInput>
    connectOrCreate?: UsersCreateOrConnectWithoutAcademicDepartmentInput
    upsert?: UsersUpsertWithoutAcademicDepartmentInput
    disconnect?: UsersWhereInput | boolean
    delete?: UsersWhereInput | boolean
    connect?: UsersWhereUniqueInput
    update?: XOR<XOR<UsersUpdateToOneWithWhereWithoutAcademicDepartmentInput, UsersUpdateWithoutAcademicDepartmentInput>, UsersUncheckedUpdateWithoutAcademicDepartmentInput>
  }

  export type UsersUpdateManyWithoutStaffDepartmentsNestedInput = {
    create?: XOR<UsersCreateWithoutStaffDepartmentsInput, UsersUncheckedCreateWithoutStaffDepartmentsInput> | UsersCreateWithoutStaffDepartmentsInput[] | UsersUncheckedCreateWithoutStaffDepartmentsInput[]
    connectOrCreate?: UsersCreateOrConnectWithoutStaffDepartmentsInput | UsersCreateOrConnectWithoutStaffDepartmentsInput[]
    upsert?: UsersUpsertWithWhereUniqueWithoutStaffDepartmentsInput | UsersUpsertWithWhereUniqueWithoutStaffDepartmentsInput[]
    set?: UsersWhereUniqueInput | UsersWhereUniqueInput[]
    disconnect?: UsersWhereUniqueInput | UsersWhereUniqueInput[]
    delete?: UsersWhereUniqueInput | UsersWhereUniqueInput[]
    connect?: UsersWhereUniqueInput | UsersWhereUniqueInput[]
    update?: UsersUpdateWithWhereUniqueWithoutStaffDepartmentsInput | UsersUpdateWithWhereUniqueWithoutStaffDepartmentsInput[]
    updateMany?: UsersUpdateManyWithWhereWithoutStaffDepartmentsInput | UsersUpdateManyWithWhereWithoutStaffDepartmentsInput[]
    deleteMany?: UsersScalarWhereInput | UsersScalarWhereInput[]
  }

  export type AdmitionExameRegistrationUpdateManyWithoutDepartmentNestedInput = {
    create?: XOR<AdmitionExameRegistrationCreateWithoutDepartmentInput, AdmitionExameRegistrationUncheckedCreateWithoutDepartmentInput> | AdmitionExameRegistrationCreateWithoutDepartmentInput[] | AdmitionExameRegistrationUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: AdmitionExameRegistrationCreateOrConnectWithoutDepartmentInput | AdmitionExameRegistrationCreateOrConnectWithoutDepartmentInput[]
    upsert?: AdmitionExameRegistrationUpsertWithWhereUniqueWithoutDepartmentInput | AdmitionExameRegistrationUpsertWithWhereUniqueWithoutDepartmentInput[]
    createMany?: AdmitionExameRegistrationCreateManyDepartmentInputEnvelope
    set?: AdmitionExameRegistrationWhereUniqueInput | AdmitionExameRegistrationWhereUniqueInput[]
    disconnect?: AdmitionExameRegistrationWhereUniqueInput | AdmitionExameRegistrationWhereUniqueInput[]
    delete?: AdmitionExameRegistrationWhereUniqueInput | AdmitionExameRegistrationWhereUniqueInput[]
    connect?: AdmitionExameRegistrationWhereUniqueInput | AdmitionExameRegistrationWhereUniqueInput[]
    update?: AdmitionExameRegistrationUpdateWithWhereUniqueWithoutDepartmentInput | AdmitionExameRegistrationUpdateWithWhereUniqueWithoutDepartmentInput[]
    updateMany?: AdmitionExameRegistrationUpdateManyWithWhereWithoutDepartmentInput | AdmitionExameRegistrationUpdateManyWithWhereWithoutDepartmentInput[]
    deleteMany?: AdmitionExameRegistrationScalarWhereInput | AdmitionExameRegistrationScalarWhereInput[]
  }

  export type OfferedCourseUpdateManyWithoutAcademicDepartmentNestedInput = {
    create?: XOR<OfferedCourseCreateWithoutAcademicDepartmentInput, OfferedCourseUncheckedCreateWithoutAcademicDepartmentInput> | OfferedCourseCreateWithoutAcademicDepartmentInput[] | OfferedCourseUncheckedCreateWithoutAcademicDepartmentInput[]
    connectOrCreate?: OfferedCourseCreateOrConnectWithoutAcademicDepartmentInput | OfferedCourseCreateOrConnectWithoutAcademicDepartmentInput[]
    upsert?: OfferedCourseUpsertWithWhereUniqueWithoutAcademicDepartmentInput | OfferedCourseUpsertWithWhereUniqueWithoutAcademicDepartmentInput[]
    createMany?: OfferedCourseCreateManyAcademicDepartmentInputEnvelope
    set?: OfferedCourseWhereUniqueInput | OfferedCourseWhereUniqueInput[]
    disconnect?: OfferedCourseWhereUniqueInput | OfferedCourseWhereUniqueInput[]
    delete?: OfferedCourseWhereUniqueInput | OfferedCourseWhereUniqueInput[]
    connect?: OfferedCourseWhereUniqueInput | OfferedCourseWhereUniqueInput[]
    update?: OfferedCourseUpdateWithWhereUniqueWithoutAcademicDepartmentInput | OfferedCourseUpdateWithWhereUniqueWithoutAcademicDepartmentInput[]
    updateMany?: OfferedCourseUpdateManyWithWhereWithoutAcademicDepartmentInput | OfferedCourseUpdateManyWithWhereWithoutAcademicDepartmentInput[]
    deleteMany?: OfferedCourseScalarWhereInput | OfferedCourseScalarWhereInput[]
  }

  export type FacultyUncheckedUpdateOneWithoutAcademicDepartmentNestedInput = {
    create?: XOR<FacultyCreateWithoutAcademicDepartmentInput, FacultyUncheckedCreateWithoutAcademicDepartmentInput>
    connectOrCreate?: FacultyCreateOrConnectWithoutAcademicDepartmentInput
    upsert?: FacultyUpsertWithoutAcademicDepartmentInput
    disconnect?: FacultyWhereInput | boolean
    delete?: FacultyWhereInput | boolean
    connect?: FacultyWhereUniqueInput
    update?: XOR<XOR<FacultyUpdateToOneWithWhereWithoutAcademicDepartmentInput, FacultyUpdateWithoutAcademicDepartmentInput>, FacultyUncheckedUpdateWithoutAcademicDepartmentInput>
  }

  export type StudentUncheckedUpdateOneWithoutAcademicDepartmentNestedInput = {
    create?: XOR<StudentCreateWithoutAcademicDepartmentInput, StudentUncheckedCreateWithoutAcademicDepartmentInput>
    connectOrCreate?: StudentCreateOrConnectWithoutAcademicDepartmentInput
    upsert?: StudentUpsertWithoutAcademicDepartmentInput
    disconnect?: StudentWhereInput | boolean
    delete?: StudentWhereInput | boolean
    connect?: StudentWhereUniqueInput
    update?: XOR<XOR<StudentUpdateToOneWithWhereWithoutAcademicDepartmentInput, StudentUpdateWithoutAcademicDepartmentInput>, StudentUncheckedUpdateWithoutAcademicDepartmentInput>
  }

  export type UsersUncheckedUpdateManyWithoutStaffDepartmentsNestedInput = {
    create?: XOR<UsersCreateWithoutStaffDepartmentsInput, UsersUncheckedCreateWithoutStaffDepartmentsInput> | UsersCreateWithoutStaffDepartmentsInput[] | UsersUncheckedCreateWithoutStaffDepartmentsInput[]
    connectOrCreate?: UsersCreateOrConnectWithoutStaffDepartmentsInput | UsersCreateOrConnectWithoutStaffDepartmentsInput[]
    upsert?: UsersUpsertWithWhereUniqueWithoutStaffDepartmentsInput | UsersUpsertWithWhereUniqueWithoutStaffDepartmentsInput[]
    set?: UsersWhereUniqueInput | UsersWhereUniqueInput[]
    disconnect?: UsersWhereUniqueInput | UsersWhereUniqueInput[]
    delete?: UsersWhereUniqueInput | UsersWhereUniqueInput[]
    connect?: UsersWhereUniqueInput | UsersWhereUniqueInput[]
    update?: UsersUpdateWithWhereUniqueWithoutStaffDepartmentsInput | UsersUpdateWithWhereUniqueWithoutStaffDepartmentsInput[]
    updateMany?: UsersUpdateManyWithWhereWithoutStaffDepartmentsInput | UsersUpdateManyWithWhereWithoutStaffDepartmentsInput[]
    deleteMany?: UsersScalarWhereInput | UsersScalarWhereInput[]
  }

  export type AdmitionExameRegistrationUncheckedUpdateManyWithoutDepartmentNestedInput = {
    create?: XOR<AdmitionExameRegistrationCreateWithoutDepartmentInput, AdmitionExameRegistrationUncheckedCreateWithoutDepartmentInput> | AdmitionExameRegistrationCreateWithoutDepartmentInput[] | AdmitionExameRegistrationUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: AdmitionExameRegistrationCreateOrConnectWithoutDepartmentInput | AdmitionExameRegistrationCreateOrConnectWithoutDepartmentInput[]
    upsert?: AdmitionExameRegistrationUpsertWithWhereUniqueWithoutDepartmentInput | AdmitionExameRegistrationUpsertWithWhereUniqueWithoutDepartmentInput[]
    createMany?: AdmitionExameRegistrationCreateManyDepartmentInputEnvelope
    set?: AdmitionExameRegistrationWhereUniqueInput | AdmitionExameRegistrationWhereUniqueInput[]
    disconnect?: AdmitionExameRegistrationWhereUniqueInput | AdmitionExameRegistrationWhereUniqueInput[]
    delete?: AdmitionExameRegistrationWhereUniqueInput | AdmitionExameRegistrationWhereUniqueInput[]
    connect?: AdmitionExameRegistrationWhereUniqueInput | AdmitionExameRegistrationWhereUniqueInput[]
    update?: AdmitionExameRegistrationUpdateWithWhereUniqueWithoutDepartmentInput | AdmitionExameRegistrationUpdateWithWhereUniqueWithoutDepartmentInput[]
    updateMany?: AdmitionExameRegistrationUpdateManyWithWhereWithoutDepartmentInput | AdmitionExameRegistrationUpdateManyWithWhereWithoutDepartmentInput[]
    deleteMany?: AdmitionExameRegistrationScalarWhereInput | AdmitionExameRegistrationScalarWhereInput[]
  }

  export type OfferedCourseUncheckedUpdateManyWithoutAcademicDepartmentNestedInput = {
    create?: XOR<OfferedCourseCreateWithoutAcademicDepartmentInput, OfferedCourseUncheckedCreateWithoutAcademicDepartmentInput> | OfferedCourseCreateWithoutAcademicDepartmentInput[] | OfferedCourseUncheckedCreateWithoutAcademicDepartmentInput[]
    connectOrCreate?: OfferedCourseCreateOrConnectWithoutAcademicDepartmentInput | OfferedCourseCreateOrConnectWithoutAcademicDepartmentInput[]
    upsert?: OfferedCourseUpsertWithWhereUniqueWithoutAcademicDepartmentInput | OfferedCourseUpsertWithWhereUniqueWithoutAcademicDepartmentInput[]
    createMany?: OfferedCourseCreateManyAcademicDepartmentInputEnvelope
    set?: OfferedCourseWhereUniqueInput | OfferedCourseWhereUniqueInput[]
    disconnect?: OfferedCourseWhereUniqueInput | OfferedCourseWhereUniqueInput[]
    delete?: OfferedCourseWhereUniqueInput | OfferedCourseWhereUniqueInput[]
    connect?: OfferedCourseWhereUniqueInput | OfferedCourseWhereUniqueInput[]
    update?: OfferedCourseUpdateWithWhereUniqueWithoutAcademicDepartmentInput | OfferedCourseUpdateWithWhereUniqueWithoutAcademicDepartmentInput[]
    updateMany?: OfferedCourseUpdateManyWithWhereWithoutAcademicDepartmentInput | OfferedCourseUpdateManyWithWhereWithoutAcademicDepartmentInput[]
    deleteMany?: OfferedCourseScalarWhereInput | OfferedCourseScalarWhereInput[]
  }

  export type AdmitionExameRegistrationCreateNestedOneWithoutStudentInput = {
    create?: XOR<AdmitionExameRegistrationCreateWithoutStudentInput, AdmitionExameRegistrationUncheckedCreateWithoutStudentInput>
    connectOrCreate?: AdmitionExameRegistrationCreateOrConnectWithoutStudentInput
    connect?: AdmitionExameRegistrationWhereUniqueInput
  }

  export type AcademicDepartmentCreateNestedOneWithoutStudentsInput = {
    create?: XOR<AcademicDepartmentCreateWithoutStudentsInput, AcademicDepartmentUncheckedCreateWithoutStudentsInput>
    connectOrCreate?: AcademicDepartmentCreateOrConnectWithoutStudentsInput
    connect?: AcademicDepartmentWhereUniqueInput
  }

  export type AcademicFacultyCreateNestedOneWithoutStudentsInput = {
    create?: XOR<AcademicFacultyCreateWithoutStudentsInput, AcademicFacultyUncheckedCreateWithoutStudentsInput>
    connectOrCreate?: AcademicFacultyCreateOrConnectWithoutStudentsInput
    connect?: AcademicFacultyWhereUniqueInput
  }

  export type AcademicSemesterCreateNestedOneWithoutStudentsInput = {
    create?: XOR<AcademicSemesterCreateWithoutStudentsInput, AcademicSemesterUncheckedCreateWithoutStudentsInput>
    connectOrCreate?: AcademicSemesterCreateOrConnectWithoutStudentsInput
    connect?: AcademicSemesterWhereUniqueInput
  }

  export type StudentSemesterRegistrationCreateNestedManyWithoutStudentInput = {
    create?: XOR<StudentSemesterRegistrationCreateWithoutStudentInput, StudentSemesterRegistrationUncheckedCreateWithoutStudentInput> | StudentSemesterRegistrationCreateWithoutStudentInput[] | StudentSemesterRegistrationUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: StudentSemesterRegistrationCreateOrConnectWithoutStudentInput | StudentSemesterRegistrationCreateOrConnectWithoutStudentInput[]
    createMany?: StudentSemesterRegistrationCreateManyStudentInputEnvelope
    connect?: StudentSemesterRegistrationWhereUniqueInput | StudentSemesterRegistrationWhereUniqueInput[]
  }

  export type StudentSemesterRegistrationCourseCreateNestedManyWithoutStudentInput = {
    create?: XOR<StudentSemesterRegistrationCourseCreateWithoutStudentInput, StudentSemesterRegistrationCourseUncheckedCreateWithoutStudentInput> | StudentSemesterRegistrationCourseCreateWithoutStudentInput[] | StudentSemesterRegistrationCourseUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: StudentSemesterRegistrationCourseCreateOrConnectWithoutStudentInput | StudentSemesterRegistrationCourseCreateOrConnectWithoutStudentInput[]
    createMany?: StudentSemesterRegistrationCourseCreateManyStudentInputEnvelope
    connect?: StudentSemesterRegistrationCourseWhereUniqueInput | StudentSemesterRegistrationCourseWhereUniqueInput[]
  }

  export type StudentEnrolledCourseCreateNestedManyWithoutStudentInput = {
    create?: XOR<StudentEnrolledCourseCreateWithoutStudentInput, StudentEnrolledCourseUncheckedCreateWithoutStudentInput> | StudentEnrolledCourseCreateWithoutStudentInput[] | StudentEnrolledCourseUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: StudentEnrolledCourseCreateOrConnectWithoutStudentInput | StudentEnrolledCourseCreateOrConnectWithoutStudentInput[]
    createMany?: StudentEnrolledCourseCreateManyStudentInputEnvelope
    connect?: StudentEnrolledCourseWhereUniqueInput | StudentEnrolledCourseWhereUniqueInput[]
  }

  export type StudentEnrolledCourseMarkCreateNestedManyWithoutStudentInput = {
    create?: XOR<StudentEnrolledCourseMarkCreateWithoutStudentInput, StudentEnrolledCourseMarkUncheckedCreateWithoutStudentInput> | StudentEnrolledCourseMarkCreateWithoutStudentInput[] | StudentEnrolledCourseMarkUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: StudentEnrolledCourseMarkCreateOrConnectWithoutStudentInput | StudentEnrolledCourseMarkCreateOrConnectWithoutStudentInput[]
    createMany?: StudentEnrolledCourseMarkCreateManyStudentInputEnvelope
    connect?: StudentEnrolledCourseMarkWhereUniqueInput | StudentEnrolledCourseMarkWhereUniqueInput[]
  }

  export type StudentSemesterPaymentCreateNestedManyWithoutStudentInput = {
    create?: XOR<StudentSemesterPaymentCreateWithoutStudentInput, StudentSemesterPaymentUncheckedCreateWithoutStudentInput> | StudentSemesterPaymentCreateWithoutStudentInput[] | StudentSemesterPaymentUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: StudentSemesterPaymentCreateOrConnectWithoutStudentInput | StudentSemesterPaymentCreateOrConnectWithoutStudentInput[]
    createMany?: StudentSemesterPaymentCreateManyStudentInputEnvelope
    connect?: StudentSemesterPaymentWhereUniqueInput | StudentSemesterPaymentWhereUniqueInput[]
  }

  export type StudentAcademicInfoCreateNestedManyWithoutStudentInput = {
    create?: XOR<StudentAcademicInfoCreateWithoutStudentInput, StudentAcademicInfoUncheckedCreateWithoutStudentInput> | StudentAcademicInfoCreateWithoutStudentInput[] | StudentAcademicInfoUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: StudentAcademicInfoCreateOrConnectWithoutStudentInput | StudentAcademicInfoCreateOrConnectWithoutStudentInput[]
    createMany?: StudentAcademicInfoCreateManyStudentInputEnvelope
    connect?: StudentAcademicInfoWhereUniqueInput | StudentAcademicInfoWhereUniqueInput[]
  }

  export type StudentSemesterRegistrationUncheckedCreateNestedManyWithoutStudentInput = {
    create?: XOR<StudentSemesterRegistrationCreateWithoutStudentInput, StudentSemesterRegistrationUncheckedCreateWithoutStudentInput> | StudentSemesterRegistrationCreateWithoutStudentInput[] | StudentSemesterRegistrationUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: StudentSemesterRegistrationCreateOrConnectWithoutStudentInput | StudentSemesterRegistrationCreateOrConnectWithoutStudentInput[]
    createMany?: StudentSemesterRegistrationCreateManyStudentInputEnvelope
    connect?: StudentSemesterRegistrationWhereUniqueInput | StudentSemesterRegistrationWhereUniqueInput[]
  }

  export type StudentSemesterRegistrationCourseUncheckedCreateNestedManyWithoutStudentInput = {
    create?: XOR<StudentSemesterRegistrationCourseCreateWithoutStudentInput, StudentSemesterRegistrationCourseUncheckedCreateWithoutStudentInput> | StudentSemesterRegistrationCourseCreateWithoutStudentInput[] | StudentSemesterRegistrationCourseUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: StudentSemesterRegistrationCourseCreateOrConnectWithoutStudentInput | StudentSemesterRegistrationCourseCreateOrConnectWithoutStudentInput[]
    createMany?: StudentSemesterRegistrationCourseCreateManyStudentInputEnvelope
    connect?: StudentSemesterRegistrationCourseWhereUniqueInput | StudentSemesterRegistrationCourseWhereUniqueInput[]
  }

  export type StudentEnrolledCourseUncheckedCreateNestedManyWithoutStudentInput = {
    create?: XOR<StudentEnrolledCourseCreateWithoutStudentInput, StudentEnrolledCourseUncheckedCreateWithoutStudentInput> | StudentEnrolledCourseCreateWithoutStudentInput[] | StudentEnrolledCourseUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: StudentEnrolledCourseCreateOrConnectWithoutStudentInput | StudentEnrolledCourseCreateOrConnectWithoutStudentInput[]
    createMany?: StudentEnrolledCourseCreateManyStudentInputEnvelope
    connect?: StudentEnrolledCourseWhereUniqueInput | StudentEnrolledCourseWhereUniqueInput[]
  }

  export type StudentEnrolledCourseMarkUncheckedCreateNestedManyWithoutStudentInput = {
    create?: XOR<StudentEnrolledCourseMarkCreateWithoutStudentInput, StudentEnrolledCourseMarkUncheckedCreateWithoutStudentInput> | StudentEnrolledCourseMarkCreateWithoutStudentInput[] | StudentEnrolledCourseMarkUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: StudentEnrolledCourseMarkCreateOrConnectWithoutStudentInput | StudentEnrolledCourseMarkCreateOrConnectWithoutStudentInput[]
    createMany?: StudentEnrolledCourseMarkCreateManyStudentInputEnvelope
    connect?: StudentEnrolledCourseMarkWhereUniqueInput | StudentEnrolledCourseMarkWhereUniqueInput[]
  }

  export type StudentSemesterPaymentUncheckedCreateNestedManyWithoutStudentInput = {
    create?: XOR<StudentSemesterPaymentCreateWithoutStudentInput, StudentSemesterPaymentUncheckedCreateWithoutStudentInput> | StudentSemesterPaymentCreateWithoutStudentInput[] | StudentSemesterPaymentUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: StudentSemesterPaymentCreateOrConnectWithoutStudentInput | StudentSemesterPaymentCreateOrConnectWithoutStudentInput[]
    createMany?: StudentSemesterPaymentCreateManyStudentInputEnvelope
    connect?: StudentSemesterPaymentWhereUniqueInput | StudentSemesterPaymentWhereUniqueInput[]
  }

  export type StudentAcademicInfoUncheckedCreateNestedManyWithoutStudentInput = {
    create?: XOR<StudentAcademicInfoCreateWithoutStudentInput, StudentAcademicInfoUncheckedCreateWithoutStudentInput> | StudentAcademicInfoCreateWithoutStudentInput[] | StudentAcademicInfoUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: StudentAcademicInfoCreateOrConnectWithoutStudentInput | StudentAcademicInfoCreateOrConnectWithoutStudentInput[]
    createMany?: StudentAcademicInfoCreateManyStudentInputEnvelope
    connect?: StudentAcademicInfoWhereUniqueInput | StudentAcademicInfoWhereUniqueInput[]
  }

  export type EnumShiftFieldUpdateOperationsInput = {
    set?: $Enums.Shift
  }

  export type AdmitionExameRegistrationUpdateOneWithoutStudentNestedInput = {
    create?: XOR<AdmitionExameRegistrationCreateWithoutStudentInput, AdmitionExameRegistrationUncheckedCreateWithoutStudentInput>
    connectOrCreate?: AdmitionExameRegistrationCreateOrConnectWithoutStudentInput
    upsert?: AdmitionExameRegistrationUpsertWithoutStudentInput
    disconnect?: AdmitionExameRegistrationWhereInput | boolean
    delete?: AdmitionExameRegistrationWhereInput | boolean
    connect?: AdmitionExameRegistrationWhereUniqueInput
    update?: XOR<XOR<AdmitionExameRegistrationUpdateToOneWithWhereWithoutStudentInput, AdmitionExameRegistrationUpdateWithoutStudentInput>, AdmitionExameRegistrationUncheckedUpdateWithoutStudentInput>
  }

  export type AcademicDepartmentUpdateOneRequiredWithoutStudentsNestedInput = {
    create?: XOR<AcademicDepartmentCreateWithoutStudentsInput, AcademicDepartmentUncheckedCreateWithoutStudentsInput>
    connectOrCreate?: AcademicDepartmentCreateOrConnectWithoutStudentsInput
    upsert?: AcademicDepartmentUpsertWithoutStudentsInput
    connect?: AcademicDepartmentWhereUniqueInput
    update?: XOR<XOR<AcademicDepartmentUpdateToOneWithWhereWithoutStudentsInput, AcademicDepartmentUpdateWithoutStudentsInput>, AcademicDepartmentUncheckedUpdateWithoutStudentsInput>
  }

  export type AcademicFacultyUpdateOneRequiredWithoutStudentsNestedInput = {
    create?: XOR<AcademicFacultyCreateWithoutStudentsInput, AcademicFacultyUncheckedCreateWithoutStudentsInput>
    connectOrCreate?: AcademicFacultyCreateOrConnectWithoutStudentsInput
    upsert?: AcademicFacultyUpsertWithoutStudentsInput
    connect?: AcademicFacultyWhereUniqueInput
    update?: XOR<XOR<AcademicFacultyUpdateToOneWithWhereWithoutStudentsInput, AcademicFacultyUpdateWithoutStudentsInput>, AcademicFacultyUncheckedUpdateWithoutStudentsInput>
  }

  export type AcademicSemesterUpdateOneRequiredWithoutStudentsNestedInput = {
    create?: XOR<AcademicSemesterCreateWithoutStudentsInput, AcademicSemesterUncheckedCreateWithoutStudentsInput>
    connectOrCreate?: AcademicSemesterCreateOrConnectWithoutStudentsInput
    upsert?: AcademicSemesterUpsertWithoutStudentsInput
    connect?: AcademicSemesterWhereUniqueInput
    update?: XOR<XOR<AcademicSemesterUpdateToOneWithWhereWithoutStudentsInput, AcademicSemesterUpdateWithoutStudentsInput>, AcademicSemesterUncheckedUpdateWithoutStudentsInput>
  }

  export type StudentSemesterRegistrationUpdateManyWithoutStudentNestedInput = {
    create?: XOR<StudentSemesterRegistrationCreateWithoutStudentInput, StudentSemesterRegistrationUncheckedCreateWithoutStudentInput> | StudentSemesterRegistrationCreateWithoutStudentInput[] | StudentSemesterRegistrationUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: StudentSemesterRegistrationCreateOrConnectWithoutStudentInput | StudentSemesterRegistrationCreateOrConnectWithoutStudentInput[]
    upsert?: StudentSemesterRegistrationUpsertWithWhereUniqueWithoutStudentInput | StudentSemesterRegistrationUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: StudentSemesterRegistrationCreateManyStudentInputEnvelope
    set?: StudentSemesterRegistrationWhereUniqueInput | StudentSemesterRegistrationWhereUniqueInput[]
    disconnect?: StudentSemesterRegistrationWhereUniqueInput | StudentSemesterRegistrationWhereUniqueInput[]
    delete?: StudentSemesterRegistrationWhereUniqueInput | StudentSemesterRegistrationWhereUniqueInput[]
    connect?: StudentSemesterRegistrationWhereUniqueInput | StudentSemesterRegistrationWhereUniqueInput[]
    update?: StudentSemesterRegistrationUpdateWithWhereUniqueWithoutStudentInput | StudentSemesterRegistrationUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: StudentSemesterRegistrationUpdateManyWithWhereWithoutStudentInput | StudentSemesterRegistrationUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: StudentSemesterRegistrationScalarWhereInput | StudentSemesterRegistrationScalarWhereInput[]
  }

  export type StudentSemesterRegistrationCourseUpdateManyWithoutStudentNestedInput = {
    create?: XOR<StudentSemesterRegistrationCourseCreateWithoutStudentInput, StudentSemesterRegistrationCourseUncheckedCreateWithoutStudentInput> | StudentSemesterRegistrationCourseCreateWithoutStudentInput[] | StudentSemesterRegistrationCourseUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: StudentSemesterRegistrationCourseCreateOrConnectWithoutStudentInput | StudentSemesterRegistrationCourseCreateOrConnectWithoutStudentInput[]
    upsert?: StudentSemesterRegistrationCourseUpsertWithWhereUniqueWithoutStudentInput | StudentSemesterRegistrationCourseUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: StudentSemesterRegistrationCourseCreateManyStudentInputEnvelope
    set?: StudentSemesterRegistrationCourseWhereUniqueInput | StudentSemesterRegistrationCourseWhereUniqueInput[]
    disconnect?: StudentSemesterRegistrationCourseWhereUniqueInput | StudentSemesterRegistrationCourseWhereUniqueInput[]
    delete?: StudentSemesterRegistrationCourseWhereUniqueInput | StudentSemesterRegistrationCourseWhereUniqueInput[]
    connect?: StudentSemesterRegistrationCourseWhereUniqueInput | StudentSemesterRegistrationCourseWhereUniqueInput[]
    update?: StudentSemesterRegistrationCourseUpdateWithWhereUniqueWithoutStudentInput | StudentSemesterRegistrationCourseUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: StudentSemesterRegistrationCourseUpdateManyWithWhereWithoutStudentInput | StudentSemesterRegistrationCourseUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: StudentSemesterRegistrationCourseScalarWhereInput | StudentSemesterRegistrationCourseScalarWhereInput[]
  }

  export type StudentEnrolledCourseUpdateManyWithoutStudentNestedInput = {
    create?: XOR<StudentEnrolledCourseCreateWithoutStudentInput, StudentEnrolledCourseUncheckedCreateWithoutStudentInput> | StudentEnrolledCourseCreateWithoutStudentInput[] | StudentEnrolledCourseUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: StudentEnrolledCourseCreateOrConnectWithoutStudentInput | StudentEnrolledCourseCreateOrConnectWithoutStudentInput[]
    upsert?: StudentEnrolledCourseUpsertWithWhereUniqueWithoutStudentInput | StudentEnrolledCourseUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: StudentEnrolledCourseCreateManyStudentInputEnvelope
    set?: StudentEnrolledCourseWhereUniqueInput | StudentEnrolledCourseWhereUniqueInput[]
    disconnect?: StudentEnrolledCourseWhereUniqueInput | StudentEnrolledCourseWhereUniqueInput[]
    delete?: StudentEnrolledCourseWhereUniqueInput | StudentEnrolledCourseWhereUniqueInput[]
    connect?: StudentEnrolledCourseWhereUniqueInput | StudentEnrolledCourseWhereUniqueInput[]
    update?: StudentEnrolledCourseUpdateWithWhereUniqueWithoutStudentInput | StudentEnrolledCourseUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: StudentEnrolledCourseUpdateManyWithWhereWithoutStudentInput | StudentEnrolledCourseUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: StudentEnrolledCourseScalarWhereInput | StudentEnrolledCourseScalarWhereInput[]
  }

  export type StudentEnrolledCourseMarkUpdateManyWithoutStudentNestedInput = {
    create?: XOR<StudentEnrolledCourseMarkCreateWithoutStudentInput, StudentEnrolledCourseMarkUncheckedCreateWithoutStudentInput> | StudentEnrolledCourseMarkCreateWithoutStudentInput[] | StudentEnrolledCourseMarkUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: StudentEnrolledCourseMarkCreateOrConnectWithoutStudentInput | StudentEnrolledCourseMarkCreateOrConnectWithoutStudentInput[]
    upsert?: StudentEnrolledCourseMarkUpsertWithWhereUniqueWithoutStudentInput | StudentEnrolledCourseMarkUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: StudentEnrolledCourseMarkCreateManyStudentInputEnvelope
    set?: StudentEnrolledCourseMarkWhereUniqueInput | StudentEnrolledCourseMarkWhereUniqueInput[]
    disconnect?: StudentEnrolledCourseMarkWhereUniqueInput | StudentEnrolledCourseMarkWhereUniqueInput[]
    delete?: StudentEnrolledCourseMarkWhereUniqueInput | StudentEnrolledCourseMarkWhereUniqueInput[]
    connect?: StudentEnrolledCourseMarkWhereUniqueInput | StudentEnrolledCourseMarkWhereUniqueInput[]
    update?: StudentEnrolledCourseMarkUpdateWithWhereUniqueWithoutStudentInput | StudentEnrolledCourseMarkUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: StudentEnrolledCourseMarkUpdateManyWithWhereWithoutStudentInput | StudentEnrolledCourseMarkUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: StudentEnrolledCourseMarkScalarWhereInput | StudentEnrolledCourseMarkScalarWhereInput[]
  }

  export type StudentSemesterPaymentUpdateManyWithoutStudentNestedInput = {
    create?: XOR<StudentSemesterPaymentCreateWithoutStudentInput, StudentSemesterPaymentUncheckedCreateWithoutStudentInput> | StudentSemesterPaymentCreateWithoutStudentInput[] | StudentSemesterPaymentUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: StudentSemesterPaymentCreateOrConnectWithoutStudentInput | StudentSemesterPaymentCreateOrConnectWithoutStudentInput[]
    upsert?: StudentSemesterPaymentUpsertWithWhereUniqueWithoutStudentInput | StudentSemesterPaymentUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: StudentSemesterPaymentCreateManyStudentInputEnvelope
    set?: StudentSemesterPaymentWhereUniqueInput | StudentSemesterPaymentWhereUniqueInput[]
    disconnect?: StudentSemesterPaymentWhereUniqueInput | StudentSemesterPaymentWhereUniqueInput[]
    delete?: StudentSemesterPaymentWhereUniqueInput | StudentSemesterPaymentWhereUniqueInput[]
    connect?: StudentSemesterPaymentWhereUniqueInput | StudentSemesterPaymentWhereUniqueInput[]
    update?: StudentSemesterPaymentUpdateWithWhereUniqueWithoutStudentInput | StudentSemesterPaymentUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: StudentSemesterPaymentUpdateManyWithWhereWithoutStudentInput | StudentSemesterPaymentUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: StudentSemesterPaymentScalarWhereInput | StudentSemesterPaymentScalarWhereInput[]
  }

  export type StudentAcademicInfoUpdateManyWithoutStudentNestedInput = {
    create?: XOR<StudentAcademicInfoCreateWithoutStudentInput, StudentAcademicInfoUncheckedCreateWithoutStudentInput> | StudentAcademicInfoCreateWithoutStudentInput[] | StudentAcademicInfoUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: StudentAcademicInfoCreateOrConnectWithoutStudentInput | StudentAcademicInfoCreateOrConnectWithoutStudentInput[]
    upsert?: StudentAcademicInfoUpsertWithWhereUniqueWithoutStudentInput | StudentAcademicInfoUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: StudentAcademicInfoCreateManyStudentInputEnvelope
    set?: StudentAcademicInfoWhereUniqueInput | StudentAcademicInfoWhereUniqueInput[]
    disconnect?: StudentAcademicInfoWhereUniqueInput | StudentAcademicInfoWhereUniqueInput[]
    delete?: StudentAcademicInfoWhereUniqueInput | StudentAcademicInfoWhereUniqueInput[]
    connect?: StudentAcademicInfoWhereUniqueInput | StudentAcademicInfoWhereUniqueInput[]
    update?: StudentAcademicInfoUpdateWithWhereUniqueWithoutStudentInput | StudentAcademicInfoUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: StudentAcademicInfoUpdateManyWithWhereWithoutStudentInput | StudentAcademicInfoUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: StudentAcademicInfoScalarWhereInput | StudentAcademicInfoScalarWhereInput[]
  }

  export type StudentSemesterRegistrationUncheckedUpdateManyWithoutStudentNestedInput = {
    create?: XOR<StudentSemesterRegistrationCreateWithoutStudentInput, StudentSemesterRegistrationUncheckedCreateWithoutStudentInput> | StudentSemesterRegistrationCreateWithoutStudentInput[] | StudentSemesterRegistrationUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: StudentSemesterRegistrationCreateOrConnectWithoutStudentInput | StudentSemesterRegistrationCreateOrConnectWithoutStudentInput[]
    upsert?: StudentSemesterRegistrationUpsertWithWhereUniqueWithoutStudentInput | StudentSemesterRegistrationUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: StudentSemesterRegistrationCreateManyStudentInputEnvelope
    set?: StudentSemesterRegistrationWhereUniqueInput | StudentSemesterRegistrationWhereUniqueInput[]
    disconnect?: StudentSemesterRegistrationWhereUniqueInput | StudentSemesterRegistrationWhereUniqueInput[]
    delete?: StudentSemesterRegistrationWhereUniqueInput | StudentSemesterRegistrationWhereUniqueInput[]
    connect?: StudentSemesterRegistrationWhereUniqueInput | StudentSemesterRegistrationWhereUniqueInput[]
    update?: StudentSemesterRegistrationUpdateWithWhereUniqueWithoutStudentInput | StudentSemesterRegistrationUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: StudentSemesterRegistrationUpdateManyWithWhereWithoutStudentInput | StudentSemesterRegistrationUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: StudentSemesterRegistrationScalarWhereInput | StudentSemesterRegistrationScalarWhereInput[]
  }

  export type StudentSemesterRegistrationCourseUncheckedUpdateManyWithoutStudentNestedInput = {
    create?: XOR<StudentSemesterRegistrationCourseCreateWithoutStudentInput, StudentSemesterRegistrationCourseUncheckedCreateWithoutStudentInput> | StudentSemesterRegistrationCourseCreateWithoutStudentInput[] | StudentSemesterRegistrationCourseUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: StudentSemesterRegistrationCourseCreateOrConnectWithoutStudentInput | StudentSemesterRegistrationCourseCreateOrConnectWithoutStudentInput[]
    upsert?: StudentSemesterRegistrationCourseUpsertWithWhereUniqueWithoutStudentInput | StudentSemesterRegistrationCourseUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: StudentSemesterRegistrationCourseCreateManyStudentInputEnvelope
    set?: StudentSemesterRegistrationCourseWhereUniqueInput | StudentSemesterRegistrationCourseWhereUniqueInput[]
    disconnect?: StudentSemesterRegistrationCourseWhereUniqueInput | StudentSemesterRegistrationCourseWhereUniqueInput[]
    delete?: StudentSemesterRegistrationCourseWhereUniqueInput | StudentSemesterRegistrationCourseWhereUniqueInput[]
    connect?: StudentSemesterRegistrationCourseWhereUniqueInput | StudentSemesterRegistrationCourseWhereUniqueInput[]
    update?: StudentSemesterRegistrationCourseUpdateWithWhereUniqueWithoutStudentInput | StudentSemesterRegistrationCourseUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: StudentSemesterRegistrationCourseUpdateManyWithWhereWithoutStudentInput | StudentSemesterRegistrationCourseUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: StudentSemesterRegistrationCourseScalarWhereInput | StudentSemesterRegistrationCourseScalarWhereInput[]
  }

  export type StudentEnrolledCourseUncheckedUpdateManyWithoutStudentNestedInput = {
    create?: XOR<StudentEnrolledCourseCreateWithoutStudentInput, StudentEnrolledCourseUncheckedCreateWithoutStudentInput> | StudentEnrolledCourseCreateWithoutStudentInput[] | StudentEnrolledCourseUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: StudentEnrolledCourseCreateOrConnectWithoutStudentInput | StudentEnrolledCourseCreateOrConnectWithoutStudentInput[]
    upsert?: StudentEnrolledCourseUpsertWithWhereUniqueWithoutStudentInput | StudentEnrolledCourseUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: StudentEnrolledCourseCreateManyStudentInputEnvelope
    set?: StudentEnrolledCourseWhereUniqueInput | StudentEnrolledCourseWhereUniqueInput[]
    disconnect?: StudentEnrolledCourseWhereUniqueInput | StudentEnrolledCourseWhereUniqueInput[]
    delete?: StudentEnrolledCourseWhereUniqueInput | StudentEnrolledCourseWhereUniqueInput[]
    connect?: StudentEnrolledCourseWhereUniqueInput | StudentEnrolledCourseWhereUniqueInput[]
    update?: StudentEnrolledCourseUpdateWithWhereUniqueWithoutStudentInput | StudentEnrolledCourseUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: StudentEnrolledCourseUpdateManyWithWhereWithoutStudentInput | StudentEnrolledCourseUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: StudentEnrolledCourseScalarWhereInput | StudentEnrolledCourseScalarWhereInput[]
  }

  export type StudentEnrolledCourseMarkUncheckedUpdateManyWithoutStudentNestedInput = {
    create?: XOR<StudentEnrolledCourseMarkCreateWithoutStudentInput, StudentEnrolledCourseMarkUncheckedCreateWithoutStudentInput> | StudentEnrolledCourseMarkCreateWithoutStudentInput[] | StudentEnrolledCourseMarkUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: StudentEnrolledCourseMarkCreateOrConnectWithoutStudentInput | StudentEnrolledCourseMarkCreateOrConnectWithoutStudentInput[]
    upsert?: StudentEnrolledCourseMarkUpsertWithWhereUniqueWithoutStudentInput | StudentEnrolledCourseMarkUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: StudentEnrolledCourseMarkCreateManyStudentInputEnvelope
    set?: StudentEnrolledCourseMarkWhereUniqueInput | StudentEnrolledCourseMarkWhereUniqueInput[]
    disconnect?: StudentEnrolledCourseMarkWhereUniqueInput | StudentEnrolledCourseMarkWhereUniqueInput[]
    delete?: StudentEnrolledCourseMarkWhereUniqueInput | StudentEnrolledCourseMarkWhereUniqueInput[]
    connect?: StudentEnrolledCourseMarkWhereUniqueInput | StudentEnrolledCourseMarkWhereUniqueInput[]
    update?: StudentEnrolledCourseMarkUpdateWithWhereUniqueWithoutStudentInput | StudentEnrolledCourseMarkUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: StudentEnrolledCourseMarkUpdateManyWithWhereWithoutStudentInput | StudentEnrolledCourseMarkUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: StudentEnrolledCourseMarkScalarWhereInput | StudentEnrolledCourseMarkScalarWhereInput[]
  }

  export type StudentSemesterPaymentUncheckedUpdateManyWithoutStudentNestedInput = {
    create?: XOR<StudentSemesterPaymentCreateWithoutStudentInput, StudentSemesterPaymentUncheckedCreateWithoutStudentInput> | StudentSemesterPaymentCreateWithoutStudentInput[] | StudentSemesterPaymentUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: StudentSemesterPaymentCreateOrConnectWithoutStudentInput | StudentSemesterPaymentCreateOrConnectWithoutStudentInput[]
    upsert?: StudentSemesterPaymentUpsertWithWhereUniqueWithoutStudentInput | StudentSemesterPaymentUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: StudentSemesterPaymentCreateManyStudentInputEnvelope
    set?: StudentSemesterPaymentWhereUniqueInput | StudentSemesterPaymentWhereUniqueInput[]
    disconnect?: StudentSemesterPaymentWhereUniqueInput | StudentSemesterPaymentWhereUniqueInput[]
    delete?: StudentSemesterPaymentWhereUniqueInput | StudentSemesterPaymentWhereUniqueInput[]
    connect?: StudentSemesterPaymentWhereUniqueInput | StudentSemesterPaymentWhereUniqueInput[]
    update?: StudentSemesterPaymentUpdateWithWhereUniqueWithoutStudentInput | StudentSemesterPaymentUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: StudentSemesterPaymentUpdateManyWithWhereWithoutStudentInput | StudentSemesterPaymentUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: StudentSemesterPaymentScalarWhereInput | StudentSemesterPaymentScalarWhereInput[]
  }

  export type StudentAcademicInfoUncheckedUpdateManyWithoutStudentNestedInput = {
    create?: XOR<StudentAcademicInfoCreateWithoutStudentInput, StudentAcademicInfoUncheckedCreateWithoutStudentInput> | StudentAcademicInfoCreateWithoutStudentInput[] | StudentAcademicInfoUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: StudentAcademicInfoCreateOrConnectWithoutStudentInput | StudentAcademicInfoCreateOrConnectWithoutStudentInput[]
    upsert?: StudentAcademicInfoUpsertWithWhereUniqueWithoutStudentInput | StudentAcademicInfoUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: StudentAcademicInfoCreateManyStudentInputEnvelope
    set?: StudentAcademicInfoWhereUniqueInput | StudentAcademicInfoWhereUniqueInput[]
    disconnect?: StudentAcademicInfoWhereUniqueInput | StudentAcademicInfoWhereUniqueInput[]
    delete?: StudentAcademicInfoWhereUniqueInput | StudentAcademicInfoWhereUniqueInput[]
    connect?: StudentAcademicInfoWhereUniqueInput | StudentAcademicInfoWhereUniqueInput[]
    update?: StudentAcademicInfoUpdateWithWhereUniqueWithoutStudentInput | StudentAcademicInfoUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: StudentAcademicInfoUpdateManyWithWhereWithoutStudentInput | StudentAcademicInfoUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: StudentAcademicInfoScalarWhereInput | StudentAcademicInfoScalarWhereInput[]
  }

  export type CourseFacultyCreateNestedManyWithoutFacultyInput = {
    create?: XOR<CourseFacultyCreateWithoutFacultyInput, CourseFacultyUncheckedCreateWithoutFacultyInput> | CourseFacultyCreateWithoutFacultyInput[] | CourseFacultyUncheckedCreateWithoutFacultyInput[]
    connectOrCreate?: CourseFacultyCreateOrConnectWithoutFacultyInput | CourseFacultyCreateOrConnectWithoutFacultyInput[]
    createMany?: CourseFacultyCreateManyFacultyInputEnvelope
    connect?: CourseFacultyWhereUniqueInput | CourseFacultyWhereUniqueInput[]
  }

  export type AcademicDepartmentCreateNestedOneWithoutFacultiesInput = {
    create?: XOR<AcademicDepartmentCreateWithoutFacultiesInput, AcademicDepartmentUncheckedCreateWithoutFacultiesInput>
    connectOrCreate?: AcademicDepartmentCreateOrConnectWithoutFacultiesInput
    connect?: AcademicDepartmentWhereUniqueInput
  }

  export type AcademicFacultyCreateNestedOneWithoutFacultiesInput = {
    create?: XOR<AcademicFacultyCreateWithoutFacultiesInput, AcademicFacultyUncheckedCreateWithoutFacultiesInput>
    connectOrCreate?: AcademicFacultyCreateOrConnectWithoutFacultiesInput
    connect?: AcademicFacultyWhereUniqueInput
  }

  export type OfferedCourseClassScheduleCreateNestedManyWithoutFacultyInput = {
    create?: XOR<OfferedCourseClassScheduleCreateWithoutFacultyInput, OfferedCourseClassScheduleUncheckedCreateWithoutFacultyInput> | OfferedCourseClassScheduleCreateWithoutFacultyInput[] | OfferedCourseClassScheduleUncheckedCreateWithoutFacultyInput[]
    connectOrCreate?: OfferedCourseClassScheduleCreateOrConnectWithoutFacultyInput | OfferedCourseClassScheduleCreateOrConnectWithoutFacultyInput[]
    createMany?: OfferedCourseClassScheduleCreateManyFacultyInputEnvelope
    connect?: OfferedCourseClassScheduleWhereUniqueInput | OfferedCourseClassScheduleWhereUniqueInput[]
  }

  export type CourseFacultyUncheckedCreateNestedManyWithoutFacultyInput = {
    create?: XOR<CourseFacultyCreateWithoutFacultyInput, CourseFacultyUncheckedCreateWithoutFacultyInput> | CourseFacultyCreateWithoutFacultyInput[] | CourseFacultyUncheckedCreateWithoutFacultyInput[]
    connectOrCreate?: CourseFacultyCreateOrConnectWithoutFacultyInput | CourseFacultyCreateOrConnectWithoutFacultyInput[]
    createMany?: CourseFacultyCreateManyFacultyInputEnvelope
    connect?: CourseFacultyWhereUniqueInput | CourseFacultyWhereUniqueInput[]
  }

  export type OfferedCourseClassScheduleUncheckedCreateNestedManyWithoutFacultyInput = {
    create?: XOR<OfferedCourseClassScheduleCreateWithoutFacultyInput, OfferedCourseClassScheduleUncheckedCreateWithoutFacultyInput> | OfferedCourseClassScheduleCreateWithoutFacultyInput[] | OfferedCourseClassScheduleUncheckedCreateWithoutFacultyInput[]
    connectOrCreate?: OfferedCourseClassScheduleCreateOrConnectWithoutFacultyInput | OfferedCourseClassScheduleCreateOrConnectWithoutFacultyInput[]
    createMany?: OfferedCourseClassScheduleCreateManyFacultyInputEnvelope
    connect?: OfferedCourseClassScheduleWhereUniqueInput | OfferedCourseClassScheduleWhereUniqueInput[]
  }

  export type CourseFacultyUpdateManyWithoutFacultyNestedInput = {
    create?: XOR<CourseFacultyCreateWithoutFacultyInput, CourseFacultyUncheckedCreateWithoutFacultyInput> | CourseFacultyCreateWithoutFacultyInput[] | CourseFacultyUncheckedCreateWithoutFacultyInput[]
    connectOrCreate?: CourseFacultyCreateOrConnectWithoutFacultyInput | CourseFacultyCreateOrConnectWithoutFacultyInput[]
    upsert?: CourseFacultyUpsertWithWhereUniqueWithoutFacultyInput | CourseFacultyUpsertWithWhereUniqueWithoutFacultyInput[]
    createMany?: CourseFacultyCreateManyFacultyInputEnvelope
    set?: CourseFacultyWhereUniqueInput | CourseFacultyWhereUniqueInput[]
    disconnect?: CourseFacultyWhereUniqueInput | CourseFacultyWhereUniqueInput[]
    delete?: CourseFacultyWhereUniqueInput | CourseFacultyWhereUniqueInput[]
    connect?: CourseFacultyWhereUniqueInput | CourseFacultyWhereUniqueInput[]
    update?: CourseFacultyUpdateWithWhereUniqueWithoutFacultyInput | CourseFacultyUpdateWithWhereUniqueWithoutFacultyInput[]
    updateMany?: CourseFacultyUpdateManyWithWhereWithoutFacultyInput | CourseFacultyUpdateManyWithWhereWithoutFacultyInput[]
    deleteMany?: CourseFacultyScalarWhereInput | CourseFacultyScalarWhereInput[]
  }

  export type AcademicDepartmentUpdateOneRequiredWithoutFacultiesNestedInput = {
    create?: XOR<AcademicDepartmentCreateWithoutFacultiesInput, AcademicDepartmentUncheckedCreateWithoutFacultiesInput>
    connectOrCreate?: AcademicDepartmentCreateOrConnectWithoutFacultiesInput
    upsert?: AcademicDepartmentUpsertWithoutFacultiesInput
    connect?: AcademicDepartmentWhereUniqueInput
    update?: XOR<XOR<AcademicDepartmentUpdateToOneWithWhereWithoutFacultiesInput, AcademicDepartmentUpdateWithoutFacultiesInput>, AcademicDepartmentUncheckedUpdateWithoutFacultiesInput>
  }

  export type AcademicFacultyUpdateOneRequiredWithoutFacultiesNestedInput = {
    create?: XOR<AcademicFacultyCreateWithoutFacultiesInput, AcademicFacultyUncheckedCreateWithoutFacultiesInput>
    connectOrCreate?: AcademicFacultyCreateOrConnectWithoutFacultiesInput
    upsert?: AcademicFacultyUpsertWithoutFacultiesInput
    connect?: AcademicFacultyWhereUniqueInput
    update?: XOR<XOR<AcademicFacultyUpdateToOneWithWhereWithoutFacultiesInput, AcademicFacultyUpdateWithoutFacultiesInput>, AcademicFacultyUncheckedUpdateWithoutFacultiesInput>
  }

  export type OfferedCourseClassScheduleUpdateManyWithoutFacultyNestedInput = {
    create?: XOR<OfferedCourseClassScheduleCreateWithoutFacultyInput, OfferedCourseClassScheduleUncheckedCreateWithoutFacultyInput> | OfferedCourseClassScheduleCreateWithoutFacultyInput[] | OfferedCourseClassScheduleUncheckedCreateWithoutFacultyInput[]
    connectOrCreate?: OfferedCourseClassScheduleCreateOrConnectWithoutFacultyInput | OfferedCourseClassScheduleCreateOrConnectWithoutFacultyInput[]
    upsert?: OfferedCourseClassScheduleUpsertWithWhereUniqueWithoutFacultyInput | OfferedCourseClassScheduleUpsertWithWhereUniqueWithoutFacultyInput[]
    createMany?: OfferedCourseClassScheduleCreateManyFacultyInputEnvelope
    set?: OfferedCourseClassScheduleWhereUniqueInput | OfferedCourseClassScheduleWhereUniqueInput[]
    disconnect?: OfferedCourseClassScheduleWhereUniqueInput | OfferedCourseClassScheduleWhereUniqueInput[]
    delete?: OfferedCourseClassScheduleWhereUniqueInput | OfferedCourseClassScheduleWhereUniqueInput[]
    connect?: OfferedCourseClassScheduleWhereUniqueInput | OfferedCourseClassScheduleWhereUniqueInput[]
    update?: OfferedCourseClassScheduleUpdateWithWhereUniqueWithoutFacultyInput | OfferedCourseClassScheduleUpdateWithWhereUniqueWithoutFacultyInput[]
    updateMany?: OfferedCourseClassScheduleUpdateManyWithWhereWithoutFacultyInput | OfferedCourseClassScheduleUpdateManyWithWhereWithoutFacultyInput[]
    deleteMany?: OfferedCourseClassScheduleScalarWhereInput | OfferedCourseClassScheduleScalarWhereInput[]
  }

  export type CourseFacultyUncheckedUpdateManyWithoutFacultyNestedInput = {
    create?: XOR<CourseFacultyCreateWithoutFacultyInput, CourseFacultyUncheckedCreateWithoutFacultyInput> | CourseFacultyCreateWithoutFacultyInput[] | CourseFacultyUncheckedCreateWithoutFacultyInput[]
    connectOrCreate?: CourseFacultyCreateOrConnectWithoutFacultyInput | CourseFacultyCreateOrConnectWithoutFacultyInput[]
    upsert?: CourseFacultyUpsertWithWhereUniqueWithoutFacultyInput | CourseFacultyUpsertWithWhereUniqueWithoutFacultyInput[]
    createMany?: CourseFacultyCreateManyFacultyInputEnvelope
    set?: CourseFacultyWhereUniqueInput | CourseFacultyWhereUniqueInput[]
    disconnect?: CourseFacultyWhereUniqueInput | CourseFacultyWhereUniqueInput[]
    delete?: CourseFacultyWhereUniqueInput | CourseFacultyWhereUniqueInput[]
    connect?: CourseFacultyWhereUniqueInput | CourseFacultyWhereUniqueInput[]
    update?: CourseFacultyUpdateWithWhereUniqueWithoutFacultyInput | CourseFacultyUpdateWithWhereUniqueWithoutFacultyInput[]
    updateMany?: CourseFacultyUpdateManyWithWhereWithoutFacultyInput | CourseFacultyUpdateManyWithWhereWithoutFacultyInput[]
    deleteMany?: CourseFacultyScalarWhereInput | CourseFacultyScalarWhereInput[]
  }

  export type OfferedCourseClassScheduleUncheckedUpdateManyWithoutFacultyNestedInput = {
    create?: XOR<OfferedCourseClassScheduleCreateWithoutFacultyInput, OfferedCourseClassScheduleUncheckedCreateWithoutFacultyInput> | OfferedCourseClassScheduleCreateWithoutFacultyInput[] | OfferedCourseClassScheduleUncheckedCreateWithoutFacultyInput[]
    connectOrCreate?: OfferedCourseClassScheduleCreateOrConnectWithoutFacultyInput | OfferedCourseClassScheduleCreateOrConnectWithoutFacultyInput[]
    upsert?: OfferedCourseClassScheduleUpsertWithWhereUniqueWithoutFacultyInput | OfferedCourseClassScheduleUpsertWithWhereUniqueWithoutFacultyInput[]
    createMany?: OfferedCourseClassScheduleCreateManyFacultyInputEnvelope
    set?: OfferedCourseClassScheduleWhereUniqueInput | OfferedCourseClassScheduleWhereUniqueInput[]
    disconnect?: OfferedCourseClassScheduleWhereUniqueInput | OfferedCourseClassScheduleWhereUniqueInput[]
    delete?: OfferedCourseClassScheduleWhereUniqueInput | OfferedCourseClassScheduleWhereUniqueInput[]
    connect?: OfferedCourseClassScheduleWhereUniqueInput | OfferedCourseClassScheduleWhereUniqueInput[]
    update?: OfferedCourseClassScheduleUpdateWithWhereUniqueWithoutFacultyInput | OfferedCourseClassScheduleUpdateWithWhereUniqueWithoutFacultyInput[]
    updateMany?: OfferedCourseClassScheduleUpdateManyWithWhereWithoutFacultyInput | OfferedCourseClassScheduleUpdateManyWithWhereWithoutFacultyInput[]
    deleteMany?: OfferedCourseClassScheduleScalarWhereInput | OfferedCourseClassScheduleScalarWhereInput[]
  }

  export type RoomCreateNestedManyWithoutBuildingInput = {
    create?: XOR<RoomCreateWithoutBuildingInput, RoomUncheckedCreateWithoutBuildingInput> | RoomCreateWithoutBuildingInput[] | RoomUncheckedCreateWithoutBuildingInput[]
    connectOrCreate?: RoomCreateOrConnectWithoutBuildingInput | RoomCreateOrConnectWithoutBuildingInput[]
    createMany?: RoomCreateManyBuildingInputEnvelope
    connect?: RoomWhereUniqueInput | RoomWhereUniqueInput[]
  }

  export type RoomUncheckedCreateNestedManyWithoutBuildingInput = {
    create?: XOR<RoomCreateWithoutBuildingInput, RoomUncheckedCreateWithoutBuildingInput> | RoomCreateWithoutBuildingInput[] | RoomUncheckedCreateWithoutBuildingInput[]
    connectOrCreate?: RoomCreateOrConnectWithoutBuildingInput | RoomCreateOrConnectWithoutBuildingInput[]
    createMany?: RoomCreateManyBuildingInputEnvelope
    connect?: RoomWhereUniqueInput | RoomWhereUniqueInput[]
  }

  export type RoomUpdateManyWithoutBuildingNestedInput = {
    create?: XOR<RoomCreateWithoutBuildingInput, RoomUncheckedCreateWithoutBuildingInput> | RoomCreateWithoutBuildingInput[] | RoomUncheckedCreateWithoutBuildingInput[]
    connectOrCreate?: RoomCreateOrConnectWithoutBuildingInput | RoomCreateOrConnectWithoutBuildingInput[]
    upsert?: RoomUpsertWithWhereUniqueWithoutBuildingInput | RoomUpsertWithWhereUniqueWithoutBuildingInput[]
    createMany?: RoomCreateManyBuildingInputEnvelope
    set?: RoomWhereUniqueInput | RoomWhereUniqueInput[]
    disconnect?: RoomWhereUniqueInput | RoomWhereUniqueInput[]
    delete?: RoomWhereUniqueInput | RoomWhereUniqueInput[]
    connect?: RoomWhereUniqueInput | RoomWhereUniqueInput[]
    update?: RoomUpdateWithWhereUniqueWithoutBuildingInput | RoomUpdateWithWhereUniqueWithoutBuildingInput[]
    updateMany?: RoomUpdateManyWithWhereWithoutBuildingInput | RoomUpdateManyWithWhereWithoutBuildingInput[]
    deleteMany?: RoomScalarWhereInput | RoomScalarWhereInput[]
  }

  export type RoomUncheckedUpdateManyWithoutBuildingNestedInput = {
    create?: XOR<RoomCreateWithoutBuildingInput, RoomUncheckedCreateWithoutBuildingInput> | RoomCreateWithoutBuildingInput[] | RoomUncheckedCreateWithoutBuildingInput[]
    connectOrCreate?: RoomCreateOrConnectWithoutBuildingInput | RoomCreateOrConnectWithoutBuildingInput[]
    upsert?: RoomUpsertWithWhereUniqueWithoutBuildingInput | RoomUpsertWithWhereUniqueWithoutBuildingInput[]
    createMany?: RoomCreateManyBuildingInputEnvelope
    set?: RoomWhereUniqueInput | RoomWhereUniqueInput[]
    disconnect?: RoomWhereUniqueInput | RoomWhereUniqueInput[]
    delete?: RoomWhereUniqueInput | RoomWhereUniqueInput[]
    connect?: RoomWhereUniqueInput | RoomWhereUniqueInput[]
    update?: RoomUpdateWithWhereUniqueWithoutBuildingInput | RoomUpdateWithWhereUniqueWithoutBuildingInput[]
    updateMany?: RoomUpdateManyWithWhereWithoutBuildingInput | RoomUpdateManyWithWhereWithoutBuildingInput[]
    deleteMany?: RoomScalarWhereInput | RoomScalarWhereInput[]
  }

  export type BuildingCreateNestedOneWithoutRoomsInput = {
    create?: XOR<BuildingCreateWithoutRoomsInput, BuildingUncheckedCreateWithoutRoomsInput>
    connectOrCreate?: BuildingCreateOrConnectWithoutRoomsInput
    connect?: BuildingWhereUniqueInput
  }

  export type OfferedCourseClassScheduleCreateNestedManyWithoutRoomInput = {
    create?: XOR<OfferedCourseClassScheduleCreateWithoutRoomInput, OfferedCourseClassScheduleUncheckedCreateWithoutRoomInput> | OfferedCourseClassScheduleCreateWithoutRoomInput[] | OfferedCourseClassScheduleUncheckedCreateWithoutRoomInput[]
    connectOrCreate?: OfferedCourseClassScheduleCreateOrConnectWithoutRoomInput | OfferedCourseClassScheduleCreateOrConnectWithoutRoomInput[]
    createMany?: OfferedCourseClassScheduleCreateManyRoomInputEnvelope
    connect?: OfferedCourseClassScheduleWhereUniqueInput | OfferedCourseClassScheduleWhereUniqueInput[]
  }

  export type OfferedCourseClassScheduleUncheckedCreateNestedManyWithoutRoomInput = {
    create?: XOR<OfferedCourseClassScheduleCreateWithoutRoomInput, OfferedCourseClassScheduleUncheckedCreateWithoutRoomInput> | OfferedCourseClassScheduleCreateWithoutRoomInput[] | OfferedCourseClassScheduleUncheckedCreateWithoutRoomInput[]
    connectOrCreate?: OfferedCourseClassScheduleCreateOrConnectWithoutRoomInput | OfferedCourseClassScheduleCreateOrConnectWithoutRoomInput[]
    createMany?: OfferedCourseClassScheduleCreateManyRoomInputEnvelope
    connect?: OfferedCourseClassScheduleWhereUniqueInput | OfferedCourseClassScheduleWhereUniqueInput[]
  }

  export type BuildingUpdateOneRequiredWithoutRoomsNestedInput = {
    create?: XOR<BuildingCreateWithoutRoomsInput, BuildingUncheckedCreateWithoutRoomsInput>
    connectOrCreate?: BuildingCreateOrConnectWithoutRoomsInput
    upsert?: BuildingUpsertWithoutRoomsInput
    connect?: BuildingWhereUniqueInput
    update?: XOR<XOR<BuildingUpdateToOneWithWhereWithoutRoomsInput, BuildingUpdateWithoutRoomsInput>, BuildingUncheckedUpdateWithoutRoomsInput>
  }

  export type OfferedCourseClassScheduleUpdateManyWithoutRoomNestedInput = {
    create?: XOR<OfferedCourseClassScheduleCreateWithoutRoomInput, OfferedCourseClassScheduleUncheckedCreateWithoutRoomInput> | OfferedCourseClassScheduleCreateWithoutRoomInput[] | OfferedCourseClassScheduleUncheckedCreateWithoutRoomInput[]
    connectOrCreate?: OfferedCourseClassScheduleCreateOrConnectWithoutRoomInput | OfferedCourseClassScheduleCreateOrConnectWithoutRoomInput[]
    upsert?: OfferedCourseClassScheduleUpsertWithWhereUniqueWithoutRoomInput | OfferedCourseClassScheduleUpsertWithWhereUniqueWithoutRoomInput[]
    createMany?: OfferedCourseClassScheduleCreateManyRoomInputEnvelope
    set?: OfferedCourseClassScheduleWhereUniqueInput | OfferedCourseClassScheduleWhereUniqueInput[]
    disconnect?: OfferedCourseClassScheduleWhereUniqueInput | OfferedCourseClassScheduleWhereUniqueInput[]
    delete?: OfferedCourseClassScheduleWhereUniqueInput | OfferedCourseClassScheduleWhereUniqueInput[]
    connect?: OfferedCourseClassScheduleWhereUniqueInput | OfferedCourseClassScheduleWhereUniqueInput[]
    update?: OfferedCourseClassScheduleUpdateWithWhereUniqueWithoutRoomInput | OfferedCourseClassScheduleUpdateWithWhereUniqueWithoutRoomInput[]
    updateMany?: OfferedCourseClassScheduleUpdateManyWithWhereWithoutRoomInput | OfferedCourseClassScheduleUpdateManyWithWhereWithoutRoomInput[]
    deleteMany?: OfferedCourseClassScheduleScalarWhereInput | OfferedCourseClassScheduleScalarWhereInput[]
  }

  export type OfferedCourseClassScheduleUncheckedUpdateManyWithoutRoomNestedInput = {
    create?: XOR<OfferedCourseClassScheduleCreateWithoutRoomInput, OfferedCourseClassScheduleUncheckedCreateWithoutRoomInput> | OfferedCourseClassScheduleCreateWithoutRoomInput[] | OfferedCourseClassScheduleUncheckedCreateWithoutRoomInput[]
    connectOrCreate?: OfferedCourseClassScheduleCreateOrConnectWithoutRoomInput | OfferedCourseClassScheduleCreateOrConnectWithoutRoomInput[]
    upsert?: OfferedCourseClassScheduleUpsertWithWhereUniqueWithoutRoomInput | OfferedCourseClassScheduleUpsertWithWhereUniqueWithoutRoomInput[]
    createMany?: OfferedCourseClassScheduleCreateManyRoomInputEnvelope
    set?: OfferedCourseClassScheduleWhereUniqueInput | OfferedCourseClassScheduleWhereUniqueInput[]
    disconnect?: OfferedCourseClassScheduleWhereUniqueInput | OfferedCourseClassScheduleWhereUniqueInput[]
    delete?: OfferedCourseClassScheduleWhereUniqueInput | OfferedCourseClassScheduleWhereUniqueInput[]
    connect?: OfferedCourseClassScheduleWhereUniqueInput | OfferedCourseClassScheduleWhereUniqueInput[]
    update?: OfferedCourseClassScheduleUpdateWithWhereUniqueWithoutRoomInput | OfferedCourseClassScheduleUpdateWithWhereUniqueWithoutRoomInput[]
    updateMany?: OfferedCourseClassScheduleUpdateManyWithWhereWithoutRoomInput | OfferedCourseClassScheduleUpdateManyWithWhereWithoutRoomInput[]
    deleteMany?: OfferedCourseClassScheduleScalarWhereInput | OfferedCourseClassScheduleScalarWhereInput[]
  }

  export type CourseToPreRequisiteCreateNestedManyWithoutCourseInput = {
    create?: XOR<CourseToPreRequisiteCreateWithoutCourseInput, CourseToPreRequisiteUncheckedCreateWithoutCourseInput> | CourseToPreRequisiteCreateWithoutCourseInput[] | CourseToPreRequisiteUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: CourseToPreRequisiteCreateOrConnectWithoutCourseInput | CourseToPreRequisiteCreateOrConnectWithoutCourseInput[]
    createMany?: CourseToPreRequisiteCreateManyCourseInputEnvelope
    connect?: CourseToPreRequisiteWhereUniqueInput | CourseToPreRequisiteWhereUniqueInput[]
  }

  export type CourseToPreRequisiteCreateNestedManyWithoutPreRequisiteInput = {
    create?: XOR<CourseToPreRequisiteCreateWithoutPreRequisiteInput, CourseToPreRequisiteUncheckedCreateWithoutPreRequisiteInput> | CourseToPreRequisiteCreateWithoutPreRequisiteInput[] | CourseToPreRequisiteUncheckedCreateWithoutPreRequisiteInput[]
    connectOrCreate?: CourseToPreRequisiteCreateOrConnectWithoutPreRequisiteInput | CourseToPreRequisiteCreateOrConnectWithoutPreRequisiteInput[]
    createMany?: CourseToPreRequisiteCreateManyPreRequisiteInputEnvelope
    connect?: CourseToPreRequisiteWhereUniqueInput | CourseToPreRequisiteWhereUniqueInput[]
  }

  export type CourseFacultyCreateNestedManyWithoutCourseInput = {
    create?: XOR<CourseFacultyCreateWithoutCourseInput, CourseFacultyUncheckedCreateWithoutCourseInput> | CourseFacultyCreateWithoutCourseInput[] | CourseFacultyUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: CourseFacultyCreateOrConnectWithoutCourseInput | CourseFacultyCreateOrConnectWithoutCourseInput[]
    createMany?: CourseFacultyCreateManyCourseInputEnvelope
    connect?: CourseFacultyWhereUniqueInput | CourseFacultyWhereUniqueInput[]
  }

  export type OfferedCourseCreateNestedManyWithoutCourseInput = {
    create?: XOR<OfferedCourseCreateWithoutCourseInput, OfferedCourseUncheckedCreateWithoutCourseInput> | OfferedCourseCreateWithoutCourseInput[] | OfferedCourseUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: OfferedCourseCreateOrConnectWithoutCourseInput | OfferedCourseCreateOrConnectWithoutCourseInput[]
    createMany?: OfferedCourseCreateManyCourseInputEnvelope
    connect?: OfferedCourseWhereUniqueInput | OfferedCourseWhereUniqueInput[]
  }

  export type StudentEnrolledCourseCreateNestedManyWithoutCourseInput = {
    create?: XOR<StudentEnrolledCourseCreateWithoutCourseInput, StudentEnrolledCourseUncheckedCreateWithoutCourseInput> | StudentEnrolledCourseCreateWithoutCourseInput[] | StudentEnrolledCourseUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: StudentEnrolledCourseCreateOrConnectWithoutCourseInput | StudentEnrolledCourseCreateOrConnectWithoutCourseInput[]
    createMany?: StudentEnrolledCourseCreateManyCourseInputEnvelope
    connect?: StudentEnrolledCourseWhereUniqueInput | StudentEnrolledCourseWhereUniqueInput[]
  }

  export type CourseToPreRequisiteUncheckedCreateNestedManyWithoutCourseInput = {
    create?: XOR<CourseToPreRequisiteCreateWithoutCourseInput, CourseToPreRequisiteUncheckedCreateWithoutCourseInput> | CourseToPreRequisiteCreateWithoutCourseInput[] | CourseToPreRequisiteUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: CourseToPreRequisiteCreateOrConnectWithoutCourseInput | CourseToPreRequisiteCreateOrConnectWithoutCourseInput[]
    createMany?: CourseToPreRequisiteCreateManyCourseInputEnvelope
    connect?: CourseToPreRequisiteWhereUniqueInput | CourseToPreRequisiteWhereUniqueInput[]
  }

  export type CourseToPreRequisiteUncheckedCreateNestedManyWithoutPreRequisiteInput = {
    create?: XOR<CourseToPreRequisiteCreateWithoutPreRequisiteInput, CourseToPreRequisiteUncheckedCreateWithoutPreRequisiteInput> | CourseToPreRequisiteCreateWithoutPreRequisiteInput[] | CourseToPreRequisiteUncheckedCreateWithoutPreRequisiteInput[]
    connectOrCreate?: CourseToPreRequisiteCreateOrConnectWithoutPreRequisiteInput | CourseToPreRequisiteCreateOrConnectWithoutPreRequisiteInput[]
    createMany?: CourseToPreRequisiteCreateManyPreRequisiteInputEnvelope
    connect?: CourseToPreRequisiteWhereUniqueInput | CourseToPreRequisiteWhereUniqueInput[]
  }

  export type CourseFacultyUncheckedCreateNestedManyWithoutCourseInput = {
    create?: XOR<CourseFacultyCreateWithoutCourseInput, CourseFacultyUncheckedCreateWithoutCourseInput> | CourseFacultyCreateWithoutCourseInput[] | CourseFacultyUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: CourseFacultyCreateOrConnectWithoutCourseInput | CourseFacultyCreateOrConnectWithoutCourseInput[]
    createMany?: CourseFacultyCreateManyCourseInputEnvelope
    connect?: CourseFacultyWhereUniqueInput | CourseFacultyWhereUniqueInput[]
  }

  export type OfferedCourseUncheckedCreateNestedManyWithoutCourseInput = {
    create?: XOR<OfferedCourseCreateWithoutCourseInput, OfferedCourseUncheckedCreateWithoutCourseInput> | OfferedCourseCreateWithoutCourseInput[] | OfferedCourseUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: OfferedCourseCreateOrConnectWithoutCourseInput | OfferedCourseCreateOrConnectWithoutCourseInput[]
    createMany?: OfferedCourseCreateManyCourseInputEnvelope
    connect?: OfferedCourseWhereUniqueInput | OfferedCourseWhereUniqueInput[]
  }

  export type StudentEnrolledCourseUncheckedCreateNestedManyWithoutCourseInput = {
    create?: XOR<StudentEnrolledCourseCreateWithoutCourseInput, StudentEnrolledCourseUncheckedCreateWithoutCourseInput> | StudentEnrolledCourseCreateWithoutCourseInput[] | StudentEnrolledCourseUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: StudentEnrolledCourseCreateOrConnectWithoutCourseInput | StudentEnrolledCourseCreateOrConnectWithoutCourseInput[]
    createMany?: StudentEnrolledCourseCreateManyCourseInputEnvelope
    connect?: StudentEnrolledCourseWhereUniqueInput | StudentEnrolledCourseWhereUniqueInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type CourseToPreRequisiteUpdateManyWithoutCourseNestedInput = {
    create?: XOR<CourseToPreRequisiteCreateWithoutCourseInput, CourseToPreRequisiteUncheckedCreateWithoutCourseInput> | CourseToPreRequisiteCreateWithoutCourseInput[] | CourseToPreRequisiteUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: CourseToPreRequisiteCreateOrConnectWithoutCourseInput | CourseToPreRequisiteCreateOrConnectWithoutCourseInput[]
    upsert?: CourseToPreRequisiteUpsertWithWhereUniqueWithoutCourseInput | CourseToPreRequisiteUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: CourseToPreRequisiteCreateManyCourseInputEnvelope
    set?: CourseToPreRequisiteWhereUniqueInput | CourseToPreRequisiteWhereUniqueInput[]
    disconnect?: CourseToPreRequisiteWhereUniqueInput | CourseToPreRequisiteWhereUniqueInput[]
    delete?: CourseToPreRequisiteWhereUniqueInput | CourseToPreRequisiteWhereUniqueInput[]
    connect?: CourseToPreRequisiteWhereUniqueInput | CourseToPreRequisiteWhereUniqueInput[]
    update?: CourseToPreRequisiteUpdateWithWhereUniqueWithoutCourseInput | CourseToPreRequisiteUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: CourseToPreRequisiteUpdateManyWithWhereWithoutCourseInput | CourseToPreRequisiteUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: CourseToPreRequisiteScalarWhereInput | CourseToPreRequisiteScalarWhereInput[]
  }

  export type CourseToPreRequisiteUpdateManyWithoutPreRequisiteNestedInput = {
    create?: XOR<CourseToPreRequisiteCreateWithoutPreRequisiteInput, CourseToPreRequisiteUncheckedCreateWithoutPreRequisiteInput> | CourseToPreRequisiteCreateWithoutPreRequisiteInput[] | CourseToPreRequisiteUncheckedCreateWithoutPreRequisiteInput[]
    connectOrCreate?: CourseToPreRequisiteCreateOrConnectWithoutPreRequisiteInput | CourseToPreRequisiteCreateOrConnectWithoutPreRequisiteInput[]
    upsert?: CourseToPreRequisiteUpsertWithWhereUniqueWithoutPreRequisiteInput | CourseToPreRequisiteUpsertWithWhereUniqueWithoutPreRequisiteInput[]
    createMany?: CourseToPreRequisiteCreateManyPreRequisiteInputEnvelope
    set?: CourseToPreRequisiteWhereUniqueInput | CourseToPreRequisiteWhereUniqueInput[]
    disconnect?: CourseToPreRequisiteWhereUniqueInput | CourseToPreRequisiteWhereUniqueInput[]
    delete?: CourseToPreRequisiteWhereUniqueInput | CourseToPreRequisiteWhereUniqueInput[]
    connect?: CourseToPreRequisiteWhereUniqueInput | CourseToPreRequisiteWhereUniqueInput[]
    update?: CourseToPreRequisiteUpdateWithWhereUniqueWithoutPreRequisiteInput | CourseToPreRequisiteUpdateWithWhereUniqueWithoutPreRequisiteInput[]
    updateMany?: CourseToPreRequisiteUpdateManyWithWhereWithoutPreRequisiteInput | CourseToPreRequisiteUpdateManyWithWhereWithoutPreRequisiteInput[]
    deleteMany?: CourseToPreRequisiteScalarWhereInput | CourseToPreRequisiteScalarWhereInput[]
  }

  export type CourseFacultyUpdateManyWithoutCourseNestedInput = {
    create?: XOR<CourseFacultyCreateWithoutCourseInput, CourseFacultyUncheckedCreateWithoutCourseInput> | CourseFacultyCreateWithoutCourseInput[] | CourseFacultyUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: CourseFacultyCreateOrConnectWithoutCourseInput | CourseFacultyCreateOrConnectWithoutCourseInput[]
    upsert?: CourseFacultyUpsertWithWhereUniqueWithoutCourseInput | CourseFacultyUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: CourseFacultyCreateManyCourseInputEnvelope
    set?: CourseFacultyWhereUniqueInput | CourseFacultyWhereUniqueInput[]
    disconnect?: CourseFacultyWhereUniqueInput | CourseFacultyWhereUniqueInput[]
    delete?: CourseFacultyWhereUniqueInput | CourseFacultyWhereUniqueInput[]
    connect?: CourseFacultyWhereUniqueInput | CourseFacultyWhereUniqueInput[]
    update?: CourseFacultyUpdateWithWhereUniqueWithoutCourseInput | CourseFacultyUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: CourseFacultyUpdateManyWithWhereWithoutCourseInput | CourseFacultyUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: CourseFacultyScalarWhereInput | CourseFacultyScalarWhereInput[]
  }

  export type OfferedCourseUpdateManyWithoutCourseNestedInput = {
    create?: XOR<OfferedCourseCreateWithoutCourseInput, OfferedCourseUncheckedCreateWithoutCourseInput> | OfferedCourseCreateWithoutCourseInput[] | OfferedCourseUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: OfferedCourseCreateOrConnectWithoutCourseInput | OfferedCourseCreateOrConnectWithoutCourseInput[]
    upsert?: OfferedCourseUpsertWithWhereUniqueWithoutCourseInput | OfferedCourseUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: OfferedCourseCreateManyCourseInputEnvelope
    set?: OfferedCourseWhereUniqueInput | OfferedCourseWhereUniqueInput[]
    disconnect?: OfferedCourseWhereUniqueInput | OfferedCourseWhereUniqueInput[]
    delete?: OfferedCourseWhereUniqueInput | OfferedCourseWhereUniqueInput[]
    connect?: OfferedCourseWhereUniqueInput | OfferedCourseWhereUniqueInput[]
    update?: OfferedCourseUpdateWithWhereUniqueWithoutCourseInput | OfferedCourseUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: OfferedCourseUpdateManyWithWhereWithoutCourseInput | OfferedCourseUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: OfferedCourseScalarWhereInput | OfferedCourseScalarWhereInput[]
  }

  export type StudentEnrolledCourseUpdateManyWithoutCourseNestedInput = {
    create?: XOR<StudentEnrolledCourseCreateWithoutCourseInput, StudentEnrolledCourseUncheckedCreateWithoutCourseInput> | StudentEnrolledCourseCreateWithoutCourseInput[] | StudentEnrolledCourseUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: StudentEnrolledCourseCreateOrConnectWithoutCourseInput | StudentEnrolledCourseCreateOrConnectWithoutCourseInput[]
    upsert?: StudentEnrolledCourseUpsertWithWhereUniqueWithoutCourseInput | StudentEnrolledCourseUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: StudentEnrolledCourseCreateManyCourseInputEnvelope
    set?: StudentEnrolledCourseWhereUniqueInput | StudentEnrolledCourseWhereUniqueInput[]
    disconnect?: StudentEnrolledCourseWhereUniqueInput | StudentEnrolledCourseWhereUniqueInput[]
    delete?: StudentEnrolledCourseWhereUniqueInput | StudentEnrolledCourseWhereUniqueInput[]
    connect?: StudentEnrolledCourseWhereUniqueInput | StudentEnrolledCourseWhereUniqueInput[]
    update?: StudentEnrolledCourseUpdateWithWhereUniqueWithoutCourseInput | StudentEnrolledCourseUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: StudentEnrolledCourseUpdateManyWithWhereWithoutCourseInput | StudentEnrolledCourseUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: StudentEnrolledCourseScalarWhereInput | StudentEnrolledCourseScalarWhereInput[]
  }

  export type CourseToPreRequisiteUncheckedUpdateManyWithoutCourseNestedInput = {
    create?: XOR<CourseToPreRequisiteCreateWithoutCourseInput, CourseToPreRequisiteUncheckedCreateWithoutCourseInput> | CourseToPreRequisiteCreateWithoutCourseInput[] | CourseToPreRequisiteUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: CourseToPreRequisiteCreateOrConnectWithoutCourseInput | CourseToPreRequisiteCreateOrConnectWithoutCourseInput[]
    upsert?: CourseToPreRequisiteUpsertWithWhereUniqueWithoutCourseInput | CourseToPreRequisiteUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: CourseToPreRequisiteCreateManyCourseInputEnvelope
    set?: CourseToPreRequisiteWhereUniqueInput | CourseToPreRequisiteWhereUniqueInput[]
    disconnect?: CourseToPreRequisiteWhereUniqueInput | CourseToPreRequisiteWhereUniqueInput[]
    delete?: CourseToPreRequisiteWhereUniqueInput | CourseToPreRequisiteWhereUniqueInput[]
    connect?: CourseToPreRequisiteWhereUniqueInput | CourseToPreRequisiteWhereUniqueInput[]
    update?: CourseToPreRequisiteUpdateWithWhereUniqueWithoutCourseInput | CourseToPreRequisiteUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: CourseToPreRequisiteUpdateManyWithWhereWithoutCourseInput | CourseToPreRequisiteUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: CourseToPreRequisiteScalarWhereInput | CourseToPreRequisiteScalarWhereInput[]
  }

  export type CourseToPreRequisiteUncheckedUpdateManyWithoutPreRequisiteNestedInput = {
    create?: XOR<CourseToPreRequisiteCreateWithoutPreRequisiteInput, CourseToPreRequisiteUncheckedCreateWithoutPreRequisiteInput> | CourseToPreRequisiteCreateWithoutPreRequisiteInput[] | CourseToPreRequisiteUncheckedCreateWithoutPreRequisiteInput[]
    connectOrCreate?: CourseToPreRequisiteCreateOrConnectWithoutPreRequisiteInput | CourseToPreRequisiteCreateOrConnectWithoutPreRequisiteInput[]
    upsert?: CourseToPreRequisiteUpsertWithWhereUniqueWithoutPreRequisiteInput | CourseToPreRequisiteUpsertWithWhereUniqueWithoutPreRequisiteInput[]
    createMany?: CourseToPreRequisiteCreateManyPreRequisiteInputEnvelope
    set?: CourseToPreRequisiteWhereUniqueInput | CourseToPreRequisiteWhereUniqueInput[]
    disconnect?: CourseToPreRequisiteWhereUniqueInput | CourseToPreRequisiteWhereUniqueInput[]
    delete?: CourseToPreRequisiteWhereUniqueInput | CourseToPreRequisiteWhereUniqueInput[]
    connect?: CourseToPreRequisiteWhereUniqueInput | CourseToPreRequisiteWhereUniqueInput[]
    update?: CourseToPreRequisiteUpdateWithWhereUniqueWithoutPreRequisiteInput | CourseToPreRequisiteUpdateWithWhereUniqueWithoutPreRequisiteInput[]
    updateMany?: CourseToPreRequisiteUpdateManyWithWhereWithoutPreRequisiteInput | CourseToPreRequisiteUpdateManyWithWhereWithoutPreRequisiteInput[]
    deleteMany?: CourseToPreRequisiteScalarWhereInput | CourseToPreRequisiteScalarWhereInput[]
  }

  export type CourseFacultyUncheckedUpdateManyWithoutCourseNestedInput = {
    create?: XOR<CourseFacultyCreateWithoutCourseInput, CourseFacultyUncheckedCreateWithoutCourseInput> | CourseFacultyCreateWithoutCourseInput[] | CourseFacultyUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: CourseFacultyCreateOrConnectWithoutCourseInput | CourseFacultyCreateOrConnectWithoutCourseInput[]
    upsert?: CourseFacultyUpsertWithWhereUniqueWithoutCourseInput | CourseFacultyUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: CourseFacultyCreateManyCourseInputEnvelope
    set?: CourseFacultyWhereUniqueInput | CourseFacultyWhereUniqueInput[]
    disconnect?: CourseFacultyWhereUniqueInput | CourseFacultyWhereUniqueInput[]
    delete?: CourseFacultyWhereUniqueInput | CourseFacultyWhereUniqueInput[]
    connect?: CourseFacultyWhereUniqueInput | CourseFacultyWhereUniqueInput[]
    update?: CourseFacultyUpdateWithWhereUniqueWithoutCourseInput | CourseFacultyUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: CourseFacultyUpdateManyWithWhereWithoutCourseInput | CourseFacultyUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: CourseFacultyScalarWhereInput | CourseFacultyScalarWhereInput[]
  }

  export type OfferedCourseUncheckedUpdateManyWithoutCourseNestedInput = {
    create?: XOR<OfferedCourseCreateWithoutCourseInput, OfferedCourseUncheckedCreateWithoutCourseInput> | OfferedCourseCreateWithoutCourseInput[] | OfferedCourseUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: OfferedCourseCreateOrConnectWithoutCourseInput | OfferedCourseCreateOrConnectWithoutCourseInput[]
    upsert?: OfferedCourseUpsertWithWhereUniqueWithoutCourseInput | OfferedCourseUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: OfferedCourseCreateManyCourseInputEnvelope
    set?: OfferedCourseWhereUniqueInput | OfferedCourseWhereUniqueInput[]
    disconnect?: OfferedCourseWhereUniqueInput | OfferedCourseWhereUniqueInput[]
    delete?: OfferedCourseWhereUniqueInput | OfferedCourseWhereUniqueInput[]
    connect?: OfferedCourseWhereUniqueInput | OfferedCourseWhereUniqueInput[]
    update?: OfferedCourseUpdateWithWhereUniqueWithoutCourseInput | OfferedCourseUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: OfferedCourseUpdateManyWithWhereWithoutCourseInput | OfferedCourseUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: OfferedCourseScalarWhereInput | OfferedCourseScalarWhereInput[]
  }

  export type StudentEnrolledCourseUncheckedUpdateManyWithoutCourseNestedInput = {
    create?: XOR<StudentEnrolledCourseCreateWithoutCourseInput, StudentEnrolledCourseUncheckedCreateWithoutCourseInput> | StudentEnrolledCourseCreateWithoutCourseInput[] | StudentEnrolledCourseUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: StudentEnrolledCourseCreateOrConnectWithoutCourseInput | StudentEnrolledCourseCreateOrConnectWithoutCourseInput[]
    upsert?: StudentEnrolledCourseUpsertWithWhereUniqueWithoutCourseInput | StudentEnrolledCourseUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: StudentEnrolledCourseCreateManyCourseInputEnvelope
    set?: StudentEnrolledCourseWhereUniqueInput | StudentEnrolledCourseWhereUniqueInput[]
    disconnect?: StudentEnrolledCourseWhereUniqueInput | StudentEnrolledCourseWhereUniqueInput[]
    delete?: StudentEnrolledCourseWhereUniqueInput | StudentEnrolledCourseWhereUniqueInput[]
    connect?: StudentEnrolledCourseWhereUniqueInput | StudentEnrolledCourseWhereUniqueInput[]
    update?: StudentEnrolledCourseUpdateWithWhereUniqueWithoutCourseInput | StudentEnrolledCourseUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: StudentEnrolledCourseUpdateManyWithWhereWithoutCourseInput | StudentEnrolledCourseUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: StudentEnrolledCourseScalarWhereInput | StudentEnrolledCourseScalarWhereInput[]
  }

  export type CourseCreateNestedOneWithoutPreRequisiteInput = {
    create?: XOR<CourseCreateWithoutPreRequisiteInput, CourseUncheckedCreateWithoutPreRequisiteInput>
    connectOrCreate?: CourseCreateOrConnectWithoutPreRequisiteInput
    connect?: CourseWhereUniqueInput
  }

  export type CourseCreateNestedOneWithoutPreRequisiteForInput = {
    create?: XOR<CourseCreateWithoutPreRequisiteForInput, CourseUncheckedCreateWithoutPreRequisiteForInput>
    connectOrCreate?: CourseCreateOrConnectWithoutPreRequisiteForInput
    connect?: CourseWhereUniqueInput
  }

  export type CourseUpdateOneRequiredWithoutPreRequisiteNestedInput = {
    create?: XOR<CourseCreateWithoutPreRequisiteInput, CourseUncheckedCreateWithoutPreRequisiteInput>
    connectOrCreate?: CourseCreateOrConnectWithoutPreRequisiteInput
    upsert?: CourseUpsertWithoutPreRequisiteInput
    connect?: CourseWhereUniqueInput
    update?: XOR<XOR<CourseUpdateToOneWithWhereWithoutPreRequisiteInput, CourseUpdateWithoutPreRequisiteInput>, CourseUncheckedUpdateWithoutPreRequisiteInput>
  }

  export type CourseUpdateOneRequiredWithoutPreRequisiteForNestedInput = {
    create?: XOR<CourseCreateWithoutPreRequisiteForInput, CourseUncheckedCreateWithoutPreRequisiteForInput>
    connectOrCreate?: CourseCreateOrConnectWithoutPreRequisiteForInput
    upsert?: CourseUpsertWithoutPreRequisiteForInput
    connect?: CourseWhereUniqueInput
    update?: XOR<XOR<CourseUpdateToOneWithWhereWithoutPreRequisiteForInput, CourseUpdateWithoutPreRequisiteForInput>, CourseUncheckedUpdateWithoutPreRequisiteForInput>
  }

  export type CourseCreateNestedOneWithoutFacultiesInput = {
    create?: XOR<CourseCreateWithoutFacultiesInput, CourseUncheckedCreateWithoutFacultiesInput>
    connectOrCreate?: CourseCreateOrConnectWithoutFacultiesInput
    connect?: CourseWhereUniqueInput
  }

  export type FacultyCreateNestedOneWithoutCoursesInput = {
    create?: XOR<FacultyCreateWithoutCoursesInput, FacultyUncheckedCreateWithoutCoursesInput>
    connectOrCreate?: FacultyCreateOrConnectWithoutCoursesInput
    connect?: FacultyWhereUniqueInput
  }

  export type CourseUpdateOneRequiredWithoutFacultiesNestedInput = {
    create?: XOR<CourseCreateWithoutFacultiesInput, CourseUncheckedCreateWithoutFacultiesInput>
    connectOrCreate?: CourseCreateOrConnectWithoutFacultiesInput
    upsert?: CourseUpsertWithoutFacultiesInput
    connect?: CourseWhereUniqueInput
    update?: XOR<XOR<CourseUpdateToOneWithWhereWithoutFacultiesInput, CourseUpdateWithoutFacultiesInput>, CourseUncheckedUpdateWithoutFacultiesInput>
  }

  export type FacultyUpdateOneRequiredWithoutCoursesNestedInput = {
    create?: XOR<FacultyCreateWithoutCoursesInput, FacultyUncheckedCreateWithoutCoursesInput>
    connectOrCreate?: FacultyCreateOrConnectWithoutCoursesInput
    upsert?: FacultyUpsertWithoutCoursesInput
    connect?: FacultyWhereUniqueInput
    update?: XOR<XOR<FacultyUpdateToOneWithWhereWithoutCoursesInput, FacultyUpdateWithoutCoursesInput>, FacultyUncheckedUpdateWithoutCoursesInput>
  }

  export type AcademicSemesterCreateNestedOneWithoutSemesterRegistrationsInput = {
    create?: XOR<AcademicSemesterCreateWithoutSemesterRegistrationsInput, AcademicSemesterUncheckedCreateWithoutSemesterRegistrationsInput>
    connectOrCreate?: AcademicSemesterCreateOrConnectWithoutSemesterRegistrationsInput
    connect?: AcademicSemesterWhereUniqueInput
  }

  export type OfferedCourseCreateNestedManyWithoutSemesterRegistrationInput = {
    create?: XOR<OfferedCourseCreateWithoutSemesterRegistrationInput, OfferedCourseUncheckedCreateWithoutSemesterRegistrationInput> | OfferedCourseCreateWithoutSemesterRegistrationInput[] | OfferedCourseUncheckedCreateWithoutSemesterRegistrationInput[]
    connectOrCreate?: OfferedCourseCreateOrConnectWithoutSemesterRegistrationInput | OfferedCourseCreateOrConnectWithoutSemesterRegistrationInput[]
    createMany?: OfferedCourseCreateManySemesterRegistrationInputEnvelope
    connect?: OfferedCourseWhereUniqueInput | OfferedCourseWhereUniqueInput[]
  }

  export type OfferedCourseSectionCreateNestedManyWithoutSemesterRegistrationInput = {
    create?: XOR<OfferedCourseSectionCreateWithoutSemesterRegistrationInput, OfferedCourseSectionUncheckedCreateWithoutSemesterRegistrationInput> | OfferedCourseSectionCreateWithoutSemesterRegistrationInput[] | OfferedCourseSectionUncheckedCreateWithoutSemesterRegistrationInput[]
    connectOrCreate?: OfferedCourseSectionCreateOrConnectWithoutSemesterRegistrationInput | OfferedCourseSectionCreateOrConnectWithoutSemesterRegistrationInput[]
    createMany?: OfferedCourseSectionCreateManySemesterRegistrationInputEnvelope
    connect?: OfferedCourseSectionWhereUniqueInput | OfferedCourseSectionWhereUniqueInput[]
  }

  export type OfferedCourseClassScheduleCreateNestedManyWithoutSemesterRegistrationInput = {
    create?: XOR<OfferedCourseClassScheduleCreateWithoutSemesterRegistrationInput, OfferedCourseClassScheduleUncheckedCreateWithoutSemesterRegistrationInput> | OfferedCourseClassScheduleCreateWithoutSemesterRegistrationInput[] | OfferedCourseClassScheduleUncheckedCreateWithoutSemesterRegistrationInput[]
    connectOrCreate?: OfferedCourseClassScheduleCreateOrConnectWithoutSemesterRegistrationInput | OfferedCourseClassScheduleCreateOrConnectWithoutSemesterRegistrationInput[]
    createMany?: OfferedCourseClassScheduleCreateManySemesterRegistrationInputEnvelope
    connect?: OfferedCourseClassScheduleWhereUniqueInput | OfferedCourseClassScheduleWhereUniqueInput[]
  }

  export type StudentSemesterRegistrationCreateNestedManyWithoutSemesterRegistrationInput = {
    create?: XOR<StudentSemesterRegistrationCreateWithoutSemesterRegistrationInput, StudentSemesterRegistrationUncheckedCreateWithoutSemesterRegistrationInput> | StudentSemesterRegistrationCreateWithoutSemesterRegistrationInput[] | StudentSemesterRegistrationUncheckedCreateWithoutSemesterRegistrationInput[]
    connectOrCreate?: StudentSemesterRegistrationCreateOrConnectWithoutSemesterRegistrationInput | StudentSemesterRegistrationCreateOrConnectWithoutSemesterRegistrationInput[]
    createMany?: StudentSemesterRegistrationCreateManySemesterRegistrationInputEnvelope
    connect?: StudentSemesterRegistrationWhereUniqueInput | StudentSemesterRegistrationWhereUniqueInput[]
  }

  export type StudentSemesterRegistrationCourseCreateNestedManyWithoutSemesterRegistrationInput = {
    create?: XOR<StudentSemesterRegistrationCourseCreateWithoutSemesterRegistrationInput, StudentSemesterRegistrationCourseUncheckedCreateWithoutSemesterRegistrationInput> | StudentSemesterRegistrationCourseCreateWithoutSemesterRegistrationInput[] | StudentSemesterRegistrationCourseUncheckedCreateWithoutSemesterRegistrationInput[]
    connectOrCreate?: StudentSemesterRegistrationCourseCreateOrConnectWithoutSemesterRegistrationInput | StudentSemesterRegistrationCourseCreateOrConnectWithoutSemesterRegistrationInput[]
    createMany?: StudentSemesterRegistrationCourseCreateManySemesterRegistrationInputEnvelope
    connect?: StudentSemesterRegistrationCourseWhereUniqueInput | StudentSemesterRegistrationCourseWhereUniqueInput[]
  }

  export type OfferedCourseUncheckedCreateNestedManyWithoutSemesterRegistrationInput = {
    create?: XOR<OfferedCourseCreateWithoutSemesterRegistrationInput, OfferedCourseUncheckedCreateWithoutSemesterRegistrationInput> | OfferedCourseCreateWithoutSemesterRegistrationInput[] | OfferedCourseUncheckedCreateWithoutSemesterRegistrationInput[]
    connectOrCreate?: OfferedCourseCreateOrConnectWithoutSemesterRegistrationInput | OfferedCourseCreateOrConnectWithoutSemesterRegistrationInput[]
    createMany?: OfferedCourseCreateManySemesterRegistrationInputEnvelope
    connect?: OfferedCourseWhereUniqueInput | OfferedCourseWhereUniqueInput[]
  }

  export type OfferedCourseSectionUncheckedCreateNestedManyWithoutSemesterRegistrationInput = {
    create?: XOR<OfferedCourseSectionCreateWithoutSemesterRegistrationInput, OfferedCourseSectionUncheckedCreateWithoutSemesterRegistrationInput> | OfferedCourseSectionCreateWithoutSemesterRegistrationInput[] | OfferedCourseSectionUncheckedCreateWithoutSemesterRegistrationInput[]
    connectOrCreate?: OfferedCourseSectionCreateOrConnectWithoutSemesterRegistrationInput | OfferedCourseSectionCreateOrConnectWithoutSemesterRegistrationInput[]
    createMany?: OfferedCourseSectionCreateManySemesterRegistrationInputEnvelope
    connect?: OfferedCourseSectionWhereUniqueInput | OfferedCourseSectionWhereUniqueInput[]
  }

  export type OfferedCourseClassScheduleUncheckedCreateNestedManyWithoutSemesterRegistrationInput = {
    create?: XOR<OfferedCourseClassScheduleCreateWithoutSemesterRegistrationInput, OfferedCourseClassScheduleUncheckedCreateWithoutSemesterRegistrationInput> | OfferedCourseClassScheduleCreateWithoutSemesterRegistrationInput[] | OfferedCourseClassScheduleUncheckedCreateWithoutSemesterRegistrationInput[]
    connectOrCreate?: OfferedCourseClassScheduleCreateOrConnectWithoutSemesterRegistrationInput | OfferedCourseClassScheduleCreateOrConnectWithoutSemesterRegistrationInput[]
    createMany?: OfferedCourseClassScheduleCreateManySemesterRegistrationInputEnvelope
    connect?: OfferedCourseClassScheduleWhereUniqueInput | OfferedCourseClassScheduleWhereUniqueInput[]
  }

  export type StudentSemesterRegistrationUncheckedCreateNestedManyWithoutSemesterRegistrationInput = {
    create?: XOR<StudentSemesterRegistrationCreateWithoutSemesterRegistrationInput, StudentSemesterRegistrationUncheckedCreateWithoutSemesterRegistrationInput> | StudentSemesterRegistrationCreateWithoutSemesterRegistrationInput[] | StudentSemesterRegistrationUncheckedCreateWithoutSemesterRegistrationInput[]
    connectOrCreate?: StudentSemesterRegistrationCreateOrConnectWithoutSemesterRegistrationInput | StudentSemesterRegistrationCreateOrConnectWithoutSemesterRegistrationInput[]
    createMany?: StudentSemesterRegistrationCreateManySemesterRegistrationInputEnvelope
    connect?: StudentSemesterRegistrationWhereUniqueInput | StudentSemesterRegistrationWhereUniqueInput[]
  }

  export type StudentSemesterRegistrationCourseUncheckedCreateNestedManyWithoutSemesterRegistrationInput = {
    create?: XOR<StudentSemesterRegistrationCourseCreateWithoutSemesterRegistrationInput, StudentSemesterRegistrationCourseUncheckedCreateWithoutSemesterRegistrationInput> | StudentSemesterRegistrationCourseCreateWithoutSemesterRegistrationInput[] | StudentSemesterRegistrationCourseUncheckedCreateWithoutSemesterRegistrationInput[]
    connectOrCreate?: StudentSemesterRegistrationCourseCreateOrConnectWithoutSemesterRegistrationInput | StudentSemesterRegistrationCourseCreateOrConnectWithoutSemesterRegistrationInput[]
    createMany?: StudentSemesterRegistrationCourseCreateManySemesterRegistrationInputEnvelope
    connect?: StudentSemesterRegistrationCourseWhereUniqueInput | StudentSemesterRegistrationCourseWhereUniqueInput[]
  }

  export type NullableEnumSemesterRegistrationStatusFieldUpdateOperationsInput = {
    set?: $Enums.SemesterRegistrationStatus | null
  }

  export type AcademicSemesterUpdateOneRequiredWithoutSemesterRegistrationsNestedInput = {
    create?: XOR<AcademicSemesterCreateWithoutSemesterRegistrationsInput, AcademicSemesterUncheckedCreateWithoutSemesterRegistrationsInput>
    connectOrCreate?: AcademicSemesterCreateOrConnectWithoutSemesterRegistrationsInput
    upsert?: AcademicSemesterUpsertWithoutSemesterRegistrationsInput
    connect?: AcademicSemesterWhereUniqueInput
    update?: XOR<XOR<AcademicSemesterUpdateToOneWithWhereWithoutSemesterRegistrationsInput, AcademicSemesterUpdateWithoutSemesterRegistrationsInput>, AcademicSemesterUncheckedUpdateWithoutSemesterRegistrationsInput>
  }

  export type OfferedCourseUpdateManyWithoutSemesterRegistrationNestedInput = {
    create?: XOR<OfferedCourseCreateWithoutSemesterRegistrationInput, OfferedCourseUncheckedCreateWithoutSemesterRegistrationInput> | OfferedCourseCreateWithoutSemesterRegistrationInput[] | OfferedCourseUncheckedCreateWithoutSemesterRegistrationInput[]
    connectOrCreate?: OfferedCourseCreateOrConnectWithoutSemesterRegistrationInput | OfferedCourseCreateOrConnectWithoutSemesterRegistrationInput[]
    upsert?: OfferedCourseUpsertWithWhereUniqueWithoutSemesterRegistrationInput | OfferedCourseUpsertWithWhereUniqueWithoutSemesterRegistrationInput[]
    createMany?: OfferedCourseCreateManySemesterRegistrationInputEnvelope
    set?: OfferedCourseWhereUniqueInput | OfferedCourseWhereUniqueInput[]
    disconnect?: OfferedCourseWhereUniqueInput | OfferedCourseWhereUniqueInput[]
    delete?: OfferedCourseWhereUniqueInput | OfferedCourseWhereUniqueInput[]
    connect?: OfferedCourseWhereUniqueInput | OfferedCourseWhereUniqueInput[]
    update?: OfferedCourseUpdateWithWhereUniqueWithoutSemesterRegistrationInput | OfferedCourseUpdateWithWhereUniqueWithoutSemesterRegistrationInput[]
    updateMany?: OfferedCourseUpdateManyWithWhereWithoutSemesterRegistrationInput | OfferedCourseUpdateManyWithWhereWithoutSemesterRegistrationInput[]
    deleteMany?: OfferedCourseScalarWhereInput | OfferedCourseScalarWhereInput[]
  }

  export type OfferedCourseSectionUpdateManyWithoutSemesterRegistrationNestedInput = {
    create?: XOR<OfferedCourseSectionCreateWithoutSemesterRegistrationInput, OfferedCourseSectionUncheckedCreateWithoutSemesterRegistrationInput> | OfferedCourseSectionCreateWithoutSemesterRegistrationInput[] | OfferedCourseSectionUncheckedCreateWithoutSemesterRegistrationInput[]
    connectOrCreate?: OfferedCourseSectionCreateOrConnectWithoutSemesterRegistrationInput | OfferedCourseSectionCreateOrConnectWithoutSemesterRegistrationInput[]
    upsert?: OfferedCourseSectionUpsertWithWhereUniqueWithoutSemesterRegistrationInput | OfferedCourseSectionUpsertWithWhereUniqueWithoutSemesterRegistrationInput[]
    createMany?: OfferedCourseSectionCreateManySemesterRegistrationInputEnvelope
    set?: OfferedCourseSectionWhereUniqueInput | OfferedCourseSectionWhereUniqueInput[]
    disconnect?: OfferedCourseSectionWhereUniqueInput | OfferedCourseSectionWhereUniqueInput[]
    delete?: OfferedCourseSectionWhereUniqueInput | OfferedCourseSectionWhereUniqueInput[]
    connect?: OfferedCourseSectionWhereUniqueInput | OfferedCourseSectionWhereUniqueInput[]
    update?: OfferedCourseSectionUpdateWithWhereUniqueWithoutSemesterRegistrationInput | OfferedCourseSectionUpdateWithWhereUniqueWithoutSemesterRegistrationInput[]
    updateMany?: OfferedCourseSectionUpdateManyWithWhereWithoutSemesterRegistrationInput | OfferedCourseSectionUpdateManyWithWhereWithoutSemesterRegistrationInput[]
    deleteMany?: OfferedCourseSectionScalarWhereInput | OfferedCourseSectionScalarWhereInput[]
  }

  export type OfferedCourseClassScheduleUpdateManyWithoutSemesterRegistrationNestedInput = {
    create?: XOR<OfferedCourseClassScheduleCreateWithoutSemesterRegistrationInput, OfferedCourseClassScheduleUncheckedCreateWithoutSemesterRegistrationInput> | OfferedCourseClassScheduleCreateWithoutSemesterRegistrationInput[] | OfferedCourseClassScheduleUncheckedCreateWithoutSemesterRegistrationInput[]
    connectOrCreate?: OfferedCourseClassScheduleCreateOrConnectWithoutSemesterRegistrationInput | OfferedCourseClassScheduleCreateOrConnectWithoutSemesterRegistrationInput[]
    upsert?: OfferedCourseClassScheduleUpsertWithWhereUniqueWithoutSemesterRegistrationInput | OfferedCourseClassScheduleUpsertWithWhereUniqueWithoutSemesterRegistrationInput[]
    createMany?: OfferedCourseClassScheduleCreateManySemesterRegistrationInputEnvelope
    set?: OfferedCourseClassScheduleWhereUniqueInput | OfferedCourseClassScheduleWhereUniqueInput[]
    disconnect?: OfferedCourseClassScheduleWhereUniqueInput | OfferedCourseClassScheduleWhereUniqueInput[]
    delete?: OfferedCourseClassScheduleWhereUniqueInput | OfferedCourseClassScheduleWhereUniqueInput[]
    connect?: OfferedCourseClassScheduleWhereUniqueInput | OfferedCourseClassScheduleWhereUniqueInput[]
    update?: OfferedCourseClassScheduleUpdateWithWhereUniqueWithoutSemesterRegistrationInput | OfferedCourseClassScheduleUpdateWithWhereUniqueWithoutSemesterRegistrationInput[]
    updateMany?: OfferedCourseClassScheduleUpdateManyWithWhereWithoutSemesterRegistrationInput | OfferedCourseClassScheduleUpdateManyWithWhereWithoutSemesterRegistrationInput[]
    deleteMany?: OfferedCourseClassScheduleScalarWhereInput | OfferedCourseClassScheduleScalarWhereInput[]
  }

  export type StudentSemesterRegistrationUpdateManyWithoutSemesterRegistrationNestedInput = {
    create?: XOR<StudentSemesterRegistrationCreateWithoutSemesterRegistrationInput, StudentSemesterRegistrationUncheckedCreateWithoutSemesterRegistrationInput> | StudentSemesterRegistrationCreateWithoutSemesterRegistrationInput[] | StudentSemesterRegistrationUncheckedCreateWithoutSemesterRegistrationInput[]
    connectOrCreate?: StudentSemesterRegistrationCreateOrConnectWithoutSemesterRegistrationInput | StudentSemesterRegistrationCreateOrConnectWithoutSemesterRegistrationInput[]
    upsert?: StudentSemesterRegistrationUpsertWithWhereUniqueWithoutSemesterRegistrationInput | StudentSemesterRegistrationUpsertWithWhereUniqueWithoutSemesterRegistrationInput[]
    createMany?: StudentSemesterRegistrationCreateManySemesterRegistrationInputEnvelope
    set?: StudentSemesterRegistrationWhereUniqueInput | StudentSemesterRegistrationWhereUniqueInput[]
    disconnect?: StudentSemesterRegistrationWhereUniqueInput | StudentSemesterRegistrationWhereUniqueInput[]
    delete?: StudentSemesterRegistrationWhereUniqueInput | StudentSemesterRegistrationWhereUniqueInput[]
    connect?: StudentSemesterRegistrationWhereUniqueInput | StudentSemesterRegistrationWhereUniqueInput[]
    update?: StudentSemesterRegistrationUpdateWithWhereUniqueWithoutSemesterRegistrationInput | StudentSemesterRegistrationUpdateWithWhereUniqueWithoutSemesterRegistrationInput[]
    updateMany?: StudentSemesterRegistrationUpdateManyWithWhereWithoutSemesterRegistrationInput | StudentSemesterRegistrationUpdateManyWithWhereWithoutSemesterRegistrationInput[]
    deleteMany?: StudentSemesterRegistrationScalarWhereInput | StudentSemesterRegistrationScalarWhereInput[]
  }

  export type StudentSemesterRegistrationCourseUpdateManyWithoutSemesterRegistrationNestedInput = {
    create?: XOR<StudentSemesterRegistrationCourseCreateWithoutSemesterRegistrationInput, StudentSemesterRegistrationCourseUncheckedCreateWithoutSemesterRegistrationInput> | StudentSemesterRegistrationCourseCreateWithoutSemesterRegistrationInput[] | StudentSemesterRegistrationCourseUncheckedCreateWithoutSemesterRegistrationInput[]
    connectOrCreate?: StudentSemesterRegistrationCourseCreateOrConnectWithoutSemesterRegistrationInput | StudentSemesterRegistrationCourseCreateOrConnectWithoutSemesterRegistrationInput[]
    upsert?: StudentSemesterRegistrationCourseUpsertWithWhereUniqueWithoutSemesterRegistrationInput | StudentSemesterRegistrationCourseUpsertWithWhereUniqueWithoutSemesterRegistrationInput[]
    createMany?: StudentSemesterRegistrationCourseCreateManySemesterRegistrationInputEnvelope
    set?: StudentSemesterRegistrationCourseWhereUniqueInput | StudentSemesterRegistrationCourseWhereUniqueInput[]
    disconnect?: StudentSemesterRegistrationCourseWhereUniqueInput | StudentSemesterRegistrationCourseWhereUniqueInput[]
    delete?: StudentSemesterRegistrationCourseWhereUniqueInput | StudentSemesterRegistrationCourseWhereUniqueInput[]
    connect?: StudentSemesterRegistrationCourseWhereUniqueInput | StudentSemesterRegistrationCourseWhereUniqueInput[]
    update?: StudentSemesterRegistrationCourseUpdateWithWhereUniqueWithoutSemesterRegistrationInput | StudentSemesterRegistrationCourseUpdateWithWhereUniqueWithoutSemesterRegistrationInput[]
    updateMany?: StudentSemesterRegistrationCourseUpdateManyWithWhereWithoutSemesterRegistrationInput | StudentSemesterRegistrationCourseUpdateManyWithWhereWithoutSemesterRegistrationInput[]
    deleteMany?: StudentSemesterRegistrationCourseScalarWhereInput | StudentSemesterRegistrationCourseScalarWhereInput[]
  }

  export type OfferedCourseUncheckedUpdateManyWithoutSemesterRegistrationNestedInput = {
    create?: XOR<OfferedCourseCreateWithoutSemesterRegistrationInput, OfferedCourseUncheckedCreateWithoutSemesterRegistrationInput> | OfferedCourseCreateWithoutSemesterRegistrationInput[] | OfferedCourseUncheckedCreateWithoutSemesterRegistrationInput[]
    connectOrCreate?: OfferedCourseCreateOrConnectWithoutSemesterRegistrationInput | OfferedCourseCreateOrConnectWithoutSemesterRegistrationInput[]
    upsert?: OfferedCourseUpsertWithWhereUniqueWithoutSemesterRegistrationInput | OfferedCourseUpsertWithWhereUniqueWithoutSemesterRegistrationInput[]
    createMany?: OfferedCourseCreateManySemesterRegistrationInputEnvelope
    set?: OfferedCourseWhereUniqueInput | OfferedCourseWhereUniqueInput[]
    disconnect?: OfferedCourseWhereUniqueInput | OfferedCourseWhereUniqueInput[]
    delete?: OfferedCourseWhereUniqueInput | OfferedCourseWhereUniqueInput[]
    connect?: OfferedCourseWhereUniqueInput | OfferedCourseWhereUniqueInput[]
    update?: OfferedCourseUpdateWithWhereUniqueWithoutSemesterRegistrationInput | OfferedCourseUpdateWithWhereUniqueWithoutSemesterRegistrationInput[]
    updateMany?: OfferedCourseUpdateManyWithWhereWithoutSemesterRegistrationInput | OfferedCourseUpdateManyWithWhereWithoutSemesterRegistrationInput[]
    deleteMany?: OfferedCourseScalarWhereInput | OfferedCourseScalarWhereInput[]
  }

  export type OfferedCourseSectionUncheckedUpdateManyWithoutSemesterRegistrationNestedInput = {
    create?: XOR<OfferedCourseSectionCreateWithoutSemesterRegistrationInput, OfferedCourseSectionUncheckedCreateWithoutSemesterRegistrationInput> | OfferedCourseSectionCreateWithoutSemesterRegistrationInput[] | OfferedCourseSectionUncheckedCreateWithoutSemesterRegistrationInput[]
    connectOrCreate?: OfferedCourseSectionCreateOrConnectWithoutSemesterRegistrationInput | OfferedCourseSectionCreateOrConnectWithoutSemesterRegistrationInput[]
    upsert?: OfferedCourseSectionUpsertWithWhereUniqueWithoutSemesterRegistrationInput | OfferedCourseSectionUpsertWithWhereUniqueWithoutSemesterRegistrationInput[]
    createMany?: OfferedCourseSectionCreateManySemesterRegistrationInputEnvelope
    set?: OfferedCourseSectionWhereUniqueInput | OfferedCourseSectionWhereUniqueInput[]
    disconnect?: OfferedCourseSectionWhereUniqueInput | OfferedCourseSectionWhereUniqueInput[]
    delete?: OfferedCourseSectionWhereUniqueInput | OfferedCourseSectionWhereUniqueInput[]
    connect?: OfferedCourseSectionWhereUniqueInput | OfferedCourseSectionWhereUniqueInput[]
    update?: OfferedCourseSectionUpdateWithWhereUniqueWithoutSemesterRegistrationInput | OfferedCourseSectionUpdateWithWhereUniqueWithoutSemesterRegistrationInput[]
    updateMany?: OfferedCourseSectionUpdateManyWithWhereWithoutSemesterRegistrationInput | OfferedCourseSectionUpdateManyWithWhereWithoutSemesterRegistrationInput[]
    deleteMany?: OfferedCourseSectionScalarWhereInput | OfferedCourseSectionScalarWhereInput[]
  }

  export type OfferedCourseClassScheduleUncheckedUpdateManyWithoutSemesterRegistrationNestedInput = {
    create?: XOR<OfferedCourseClassScheduleCreateWithoutSemesterRegistrationInput, OfferedCourseClassScheduleUncheckedCreateWithoutSemesterRegistrationInput> | OfferedCourseClassScheduleCreateWithoutSemesterRegistrationInput[] | OfferedCourseClassScheduleUncheckedCreateWithoutSemesterRegistrationInput[]
    connectOrCreate?: OfferedCourseClassScheduleCreateOrConnectWithoutSemesterRegistrationInput | OfferedCourseClassScheduleCreateOrConnectWithoutSemesterRegistrationInput[]
    upsert?: OfferedCourseClassScheduleUpsertWithWhereUniqueWithoutSemesterRegistrationInput | OfferedCourseClassScheduleUpsertWithWhereUniqueWithoutSemesterRegistrationInput[]
    createMany?: OfferedCourseClassScheduleCreateManySemesterRegistrationInputEnvelope
    set?: OfferedCourseClassScheduleWhereUniqueInput | OfferedCourseClassScheduleWhereUniqueInput[]
    disconnect?: OfferedCourseClassScheduleWhereUniqueInput | OfferedCourseClassScheduleWhereUniqueInput[]
    delete?: OfferedCourseClassScheduleWhereUniqueInput | OfferedCourseClassScheduleWhereUniqueInput[]
    connect?: OfferedCourseClassScheduleWhereUniqueInput | OfferedCourseClassScheduleWhereUniqueInput[]
    update?: OfferedCourseClassScheduleUpdateWithWhereUniqueWithoutSemesterRegistrationInput | OfferedCourseClassScheduleUpdateWithWhereUniqueWithoutSemesterRegistrationInput[]
    updateMany?: OfferedCourseClassScheduleUpdateManyWithWhereWithoutSemesterRegistrationInput | OfferedCourseClassScheduleUpdateManyWithWhereWithoutSemesterRegistrationInput[]
    deleteMany?: OfferedCourseClassScheduleScalarWhereInput | OfferedCourseClassScheduleScalarWhereInput[]
  }

  export type StudentSemesterRegistrationUncheckedUpdateManyWithoutSemesterRegistrationNestedInput = {
    create?: XOR<StudentSemesterRegistrationCreateWithoutSemesterRegistrationInput, StudentSemesterRegistrationUncheckedCreateWithoutSemesterRegistrationInput> | StudentSemesterRegistrationCreateWithoutSemesterRegistrationInput[] | StudentSemesterRegistrationUncheckedCreateWithoutSemesterRegistrationInput[]
    connectOrCreate?: StudentSemesterRegistrationCreateOrConnectWithoutSemesterRegistrationInput | StudentSemesterRegistrationCreateOrConnectWithoutSemesterRegistrationInput[]
    upsert?: StudentSemesterRegistrationUpsertWithWhereUniqueWithoutSemesterRegistrationInput | StudentSemesterRegistrationUpsertWithWhereUniqueWithoutSemesterRegistrationInput[]
    createMany?: StudentSemesterRegistrationCreateManySemesterRegistrationInputEnvelope
    set?: StudentSemesterRegistrationWhereUniqueInput | StudentSemesterRegistrationWhereUniqueInput[]
    disconnect?: StudentSemesterRegistrationWhereUniqueInput | StudentSemesterRegistrationWhereUniqueInput[]
    delete?: StudentSemesterRegistrationWhereUniqueInput | StudentSemesterRegistrationWhereUniqueInput[]
    connect?: StudentSemesterRegistrationWhereUniqueInput | StudentSemesterRegistrationWhereUniqueInput[]
    update?: StudentSemesterRegistrationUpdateWithWhereUniqueWithoutSemesterRegistrationInput | StudentSemesterRegistrationUpdateWithWhereUniqueWithoutSemesterRegistrationInput[]
    updateMany?: StudentSemesterRegistrationUpdateManyWithWhereWithoutSemesterRegistrationInput | StudentSemesterRegistrationUpdateManyWithWhereWithoutSemesterRegistrationInput[]
    deleteMany?: StudentSemesterRegistrationScalarWhereInput | StudentSemesterRegistrationScalarWhereInput[]
  }

  export type StudentSemesterRegistrationCourseUncheckedUpdateManyWithoutSemesterRegistrationNestedInput = {
    create?: XOR<StudentSemesterRegistrationCourseCreateWithoutSemesterRegistrationInput, StudentSemesterRegistrationCourseUncheckedCreateWithoutSemesterRegistrationInput> | StudentSemesterRegistrationCourseCreateWithoutSemesterRegistrationInput[] | StudentSemesterRegistrationCourseUncheckedCreateWithoutSemesterRegistrationInput[]
    connectOrCreate?: StudentSemesterRegistrationCourseCreateOrConnectWithoutSemesterRegistrationInput | StudentSemesterRegistrationCourseCreateOrConnectWithoutSemesterRegistrationInput[]
    upsert?: StudentSemesterRegistrationCourseUpsertWithWhereUniqueWithoutSemesterRegistrationInput | StudentSemesterRegistrationCourseUpsertWithWhereUniqueWithoutSemesterRegistrationInput[]
    createMany?: StudentSemesterRegistrationCourseCreateManySemesterRegistrationInputEnvelope
    set?: StudentSemesterRegistrationCourseWhereUniqueInput | StudentSemesterRegistrationCourseWhereUniqueInput[]
    disconnect?: StudentSemesterRegistrationCourseWhereUniqueInput | StudentSemesterRegistrationCourseWhereUniqueInput[]
    delete?: StudentSemesterRegistrationCourseWhereUniqueInput | StudentSemesterRegistrationCourseWhereUniqueInput[]
    connect?: StudentSemesterRegistrationCourseWhereUniqueInput | StudentSemesterRegistrationCourseWhereUniqueInput[]
    update?: StudentSemesterRegistrationCourseUpdateWithWhereUniqueWithoutSemesterRegistrationInput | StudentSemesterRegistrationCourseUpdateWithWhereUniqueWithoutSemesterRegistrationInput[]
    updateMany?: StudentSemesterRegistrationCourseUpdateManyWithWhereWithoutSemesterRegistrationInput | StudentSemesterRegistrationCourseUpdateManyWithWhereWithoutSemesterRegistrationInput[]
    deleteMany?: StudentSemesterRegistrationCourseScalarWhereInput | StudentSemesterRegistrationCourseScalarWhereInput[]
  }

  export type AcademicDepartmentCreateNestedOneWithoutAdmitionExameInput = {
    create?: XOR<AcademicDepartmentCreateWithoutAdmitionExameInput, AcademicDepartmentUncheckedCreateWithoutAdmitionExameInput>
    connectOrCreate?: AcademicDepartmentCreateOrConnectWithoutAdmitionExameInput
    connect?: AcademicDepartmentWhereUniqueInput
  }

  export type StudentCreateNestedOneWithoutAdmissionRegistrationInput = {
    create?: XOR<StudentCreateWithoutAdmissionRegistrationInput, StudentUncheckedCreateWithoutAdmissionRegistrationInput>
    connectOrCreate?: StudentCreateOrConnectWithoutAdmissionRegistrationInput
    connect?: StudentWhereUniqueInput
  }

  export type StudentUncheckedCreateNestedOneWithoutAdmissionRegistrationInput = {
    create?: XOR<StudentCreateWithoutAdmissionRegistrationInput, StudentUncheckedCreateWithoutAdmissionRegistrationInput>
    connectOrCreate?: StudentCreateOrConnectWithoutAdmissionRegistrationInput
    connect?: StudentWhereUniqueInput
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
  }

  export type AcademicDepartmentUpdateOneRequiredWithoutAdmitionExameNestedInput = {
    create?: XOR<AcademicDepartmentCreateWithoutAdmitionExameInput, AcademicDepartmentUncheckedCreateWithoutAdmitionExameInput>
    connectOrCreate?: AcademicDepartmentCreateOrConnectWithoutAdmitionExameInput
    upsert?: AcademicDepartmentUpsertWithoutAdmitionExameInput
    connect?: AcademicDepartmentWhereUniqueInput
    update?: XOR<XOR<AcademicDepartmentUpdateToOneWithWhereWithoutAdmitionExameInput, AcademicDepartmentUpdateWithoutAdmitionExameInput>, AcademicDepartmentUncheckedUpdateWithoutAdmitionExameInput>
  }

  export type StudentUpdateOneWithoutAdmissionRegistrationNestedInput = {
    create?: XOR<StudentCreateWithoutAdmissionRegistrationInput, StudentUncheckedCreateWithoutAdmissionRegistrationInput>
    connectOrCreate?: StudentCreateOrConnectWithoutAdmissionRegistrationInput
    upsert?: StudentUpsertWithoutAdmissionRegistrationInput
    disconnect?: StudentWhereInput | boolean
    delete?: StudentWhereInput | boolean
    connect?: StudentWhereUniqueInput
    update?: XOR<XOR<StudentUpdateToOneWithWhereWithoutAdmissionRegistrationInput, StudentUpdateWithoutAdmissionRegistrationInput>, StudentUncheckedUpdateWithoutAdmissionRegistrationInput>
  }

  export type StudentUncheckedUpdateOneWithoutAdmissionRegistrationNestedInput = {
    create?: XOR<StudentCreateWithoutAdmissionRegistrationInput, StudentUncheckedCreateWithoutAdmissionRegistrationInput>
    connectOrCreate?: StudentCreateOrConnectWithoutAdmissionRegistrationInput
    upsert?: StudentUpsertWithoutAdmissionRegistrationInput
    disconnect?: StudentWhereInput | boolean
    delete?: StudentWhereInput | boolean
    connect?: StudentWhereUniqueInput
    update?: XOR<XOR<StudentUpdateToOneWithWhereWithoutAdmissionRegistrationInput, StudentUpdateWithoutAdmissionRegistrationInput>, StudentUncheckedUpdateWithoutAdmissionRegistrationInput>
  }

  export type AcademicDepartmentCreateNestedOneWithoutOfferedCoursesInput = {
    create?: XOR<AcademicDepartmentCreateWithoutOfferedCoursesInput, AcademicDepartmentUncheckedCreateWithoutOfferedCoursesInput>
    connectOrCreate?: AcademicDepartmentCreateOrConnectWithoutOfferedCoursesInput
    connect?: AcademicDepartmentWhereUniqueInput
  }

  export type SemesterRegistrationCreateNestedOneWithoutOfferedCoursesInput = {
    create?: XOR<SemesterRegistrationCreateWithoutOfferedCoursesInput, SemesterRegistrationUncheckedCreateWithoutOfferedCoursesInput>
    connectOrCreate?: SemesterRegistrationCreateOrConnectWithoutOfferedCoursesInput
    connect?: SemesterRegistrationWhereUniqueInput
  }

  export type CourseCreateNestedOneWithoutOfferedCoursesInput = {
    create?: XOR<CourseCreateWithoutOfferedCoursesInput, CourseUncheckedCreateWithoutOfferedCoursesInput>
    connectOrCreate?: CourseCreateOrConnectWithoutOfferedCoursesInput
    connect?: CourseWhereUniqueInput
  }

  export type OfferedCourseSectionCreateNestedManyWithoutOfferedCourseInput = {
    create?: XOR<OfferedCourseSectionCreateWithoutOfferedCourseInput, OfferedCourseSectionUncheckedCreateWithoutOfferedCourseInput> | OfferedCourseSectionCreateWithoutOfferedCourseInput[] | OfferedCourseSectionUncheckedCreateWithoutOfferedCourseInput[]
    connectOrCreate?: OfferedCourseSectionCreateOrConnectWithoutOfferedCourseInput | OfferedCourseSectionCreateOrConnectWithoutOfferedCourseInput[]
    createMany?: OfferedCourseSectionCreateManyOfferedCourseInputEnvelope
    connect?: OfferedCourseSectionWhereUniqueInput | OfferedCourseSectionWhereUniqueInput[]
  }

  export type StudentSemesterRegistrationCourseCreateNestedManyWithoutOfferedCourseInput = {
    create?: XOR<StudentSemesterRegistrationCourseCreateWithoutOfferedCourseInput, StudentSemesterRegistrationCourseUncheckedCreateWithoutOfferedCourseInput> | StudentSemesterRegistrationCourseCreateWithoutOfferedCourseInput[] | StudentSemesterRegistrationCourseUncheckedCreateWithoutOfferedCourseInput[]
    connectOrCreate?: StudentSemesterRegistrationCourseCreateOrConnectWithoutOfferedCourseInput | StudentSemesterRegistrationCourseCreateOrConnectWithoutOfferedCourseInput[]
    createMany?: StudentSemesterRegistrationCourseCreateManyOfferedCourseInputEnvelope
    connect?: StudentSemesterRegistrationCourseWhereUniqueInput | StudentSemesterRegistrationCourseWhereUniqueInput[]
  }

  export type OfferedCourseSectionUncheckedCreateNestedManyWithoutOfferedCourseInput = {
    create?: XOR<OfferedCourseSectionCreateWithoutOfferedCourseInput, OfferedCourseSectionUncheckedCreateWithoutOfferedCourseInput> | OfferedCourseSectionCreateWithoutOfferedCourseInput[] | OfferedCourseSectionUncheckedCreateWithoutOfferedCourseInput[]
    connectOrCreate?: OfferedCourseSectionCreateOrConnectWithoutOfferedCourseInput | OfferedCourseSectionCreateOrConnectWithoutOfferedCourseInput[]
    createMany?: OfferedCourseSectionCreateManyOfferedCourseInputEnvelope
    connect?: OfferedCourseSectionWhereUniqueInput | OfferedCourseSectionWhereUniqueInput[]
  }

  export type StudentSemesterRegistrationCourseUncheckedCreateNestedManyWithoutOfferedCourseInput = {
    create?: XOR<StudentSemesterRegistrationCourseCreateWithoutOfferedCourseInput, StudentSemesterRegistrationCourseUncheckedCreateWithoutOfferedCourseInput> | StudentSemesterRegistrationCourseCreateWithoutOfferedCourseInput[] | StudentSemesterRegistrationCourseUncheckedCreateWithoutOfferedCourseInput[]
    connectOrCreate?: StudentSemesterRegistrationCourseCreateOrConnectWithoutOfferedCourseInput | StudentSemesterRegistrationCourseCreateOrConnectWithoutOfferedCourseInput[]
    createMany?: StudentSemesterRegistrationCourseCreateManyOfferedCourseInputEnvelope
    connect?: StudentSemesterRegistrationCourseWhereUniqueInput | StudentSemesterRegistrationCourseWhereUniqueInput[]
  }

  export type AcademicDepartmentUpdateOneRequiredWithoutOfferedCoursesNestedInput = {
    create?: XOR<AcademicDepartmentCreateWithoutOfferedCoursesInput, AcademicDepartmentUncheckedCreateWithoutOfferedCoursesInput>
    connectOrCreate?: AcademicDepartmentCreateOrConnectWithoutOfferedCoursesInput
    upsert?: AcademicDepartmentUpsertWithoutOfferedCoursesInput
    connect?: AcademicDepartmentWhereUniqueInput
    update?: XOR<XOR<AcademicDepartmentUpdateToOneWithWhereWithoutOfferedCoursesInput, AcademicDepartmentUpdateWithoutOfferedCoursesInput>, AcademicDepartmentUncheckedUpdateWithoutOfferedCoursesInput>
  }

  export type SemesterRegistrationUpdateOneRequiredWithoutOfferedCoursesNestedInput = {
    create?: XOR<SemesterRegistrationCreateWithoutOfferedCoursesInput, SemesterRegistrationUncheckedCreateWithoutOfferedCoursesInput>
    connectOrCreate?: SemesterRegistrationCreateOrConnectWithoutOfferedCoursesInput
    upsert?: SemesterRegistrationUpsertWithoutOfferedCoursesInput
    connect?: SemesterRegistrationWhereUniqueInput
    update?: XOR<XOR<SemesterRegistrationUpdateToOneWithWhereWithoutOfferedCoursesInput, SemesterRegistrationUpdateWithoutOfferedCoursesInput>, SemesterRegistrationUncheckedUpdateWithoutOfferedCoursesInput>
  }

  export type CourseUpdateOneRequiredWithoutOfferedCoursesNestedInput = {
    create?: XOR<CourseCreateWithoutOfferedCoursesInput, CourseUncheckedCreateWithoutOfferedCoursesInput>
    connectOrCreate?: CourseCreateOrConnectWithoutOfferedCoursesInput
    upsert?: CourseUpsertWithoutOfferedCoursesInput
    connect?: CourseWhereUniqueInput
    update?: XOR<XOR<CourseUpdateToOneWithWhereWithoutOfferedCoursesInput, CourseUpdateWithoutOfferedCoursesInput>, CourseUncheckedUpdateWithoutOfferedCoursesInput>
  }

  export type OfferedCourseSectionUpdateManyWithoutOfferedCourseNestedInput = {
    create?: XOR<OfferedCourseSectionCreateWithoutOfferedCourseInput, OfferedCourseSectionUncheckedCreateWithoutOfferedCourseInput> | OfferedCourseSectionCreateWithoutOfferedCourseInput[] | OfferedCourseSectionUncheckedCreateWithoutOfferedCourseInput[]
    connectOrCreate?: OfferedCourseSectionCreateOrConnectWithoutOfferedCourseInput | OfferedCourseSectionCreateOrConnectWithoutOfferedCourseInput[]
    upsert?: OfferedCourseSectionUpsertWithWhereUniqueWithoutOfferedCourseInput | OfferedCourseSectionUpsertWithWhereUniqueWithoutOfferedCourseInput[]
    createMany?: OfferedCourseSectionCreateManyOfferedCourseInputEnvelope
    set?: OfferedCourseSectionWhereUniqueInput | OfferedCourseSectionWhereUniqueInput[]
    disconnect?: OfferedCourseSectionWhereUniqueInput | OfferedCourseSectionWhereUniqueInput[]
    delete?: OfferedCourseSectionWhereUniqueInput | OfferedCourseSectionWhereUniqueInput[]
    connect?: OfferedCourseSectionWhereUniqueInput | OfferedCourseSectionWhereUniqueInput[]
    update?: OfferedCourseSectionUpdateWithWhereUniqueWithoutOfferedCourseInput | OfferedCourseSectionUpdateWithWhereUniqueWithoutOfferedCourseInput[]
    updateMany?: OfferedCourseSectionUpdateManyWithWhereWithoutOfferedCourseInput | OfferedCourseSectionUpdateManyWithWhereWithoutOfferedCourseInput[]
    deleteMany?: OfferedCourseSectionScalarWhereInput | OfferedCourseSectionScalarWhereInput[]
  }

  export type StudentSemesterRegistrationCourseUpdateManyWithoutOfferedCourseNestedInput = {
    create?: XOR<StudentSemesterRegistrationCourseCreateWithoutOfferedCourseInput, StudentSemesterRegistrationCourseUncheckedCreateWithoutOfferedCourseInput> | StudentSemesterRegistrationCourseCreateWithoutOfferedCourseInput[] | StudentSemesterRegistrationCourseUncheckedCreateWithoutOfferedCourseInput[]
    connectOrCreate?: StudentSemesterRegistrationCourseCreateOrConnectWithoutOfferedCourseInput | StudentSemesterRegistrationCourseCreateOrConnectWithoutOfferedCourseInput[]
    upsert?: StudentSemesterRegistrationCourseUpsertWithWhereUniqueWithoutOfferedCourseInput | StudentSemesterRegistrationCourseUpsertWithWhereUniqueWithoutOfferedCourseInput[]
    createMany?: StudentSemesterRegistrationCourseCreateManyOfferedCourseInputEnvelope
    set?: StudentSemesterRegistrationCourseWhereUniqueInput | StudentSemesterRegistrationCourseWhereUniqueInput[]
    disconnect?: StudentSemesterRegistrationCourseWhereUniqueInput | StudentSemesterRegistrationCourseWhereUniqueInput[]
    delete?: StudentSemesterRegistrationCourseWhereUniqueInput | StudentSemesterRegistrationCourseWhereUniqueInput[]
    connect?: StudentSemesterRegistrationCourseWhereUniqueInput | StudentSemesterRegistrationCourseWhereUniqueInput[]
    update?: StudentSemesterRegistrationCourseUpdateWithWhereUniqueWithoutOfferedCourseInput | StudentSemesterRegistrationCourseUpdateWithWhereUniqueWithoutOfferedCourseInput[]
    updateMany?: StudentSemesterRegistrationCourseUpdateManyWithWhereWithoutOfferedCourseInput | StudentSemesterRegistrationCourseUpdateManyWithWhereWithoutOfferedCourseInput[]
    deleteMany?: StudentSemesterRegistrationCourseScalarWhereInput | StudentSemesterRegistrationCourseScalarWhereInput[]
  }

  export type OfferedCourseSectionUncheckedUpdateManyWithoutOfferedCourseNestedInput = {
    create?: XOR<OfferedCourseSectionCreateWithoutOfferedCourseInput, OfferedCourseSectionUncheckedCreateWithoutOfferedCourseInput> | OfferedCourseSectionCreateWithoutOfferedCourseInput[] | OfferedCourseSectionUncheckedCreateWithoutOfferedCourseInput[]
    connectOrCreate?: OfferedCourseSectionCreateOrConnectWithoutOfferedCourseInput | OfferedCourseSectionCreateOrConnectWithoutOfferedCourseInput[]
    upsert?: OfferedCourseSectionUpsertWithWhereUniqueWithoutOfferedCourseInput | OfferedCourseSectionUpsertWithWhereUniqueWithoutOfferedCourseInput[]
    createMany?: OfferedCourseSectionCreateManyOfferedCourseInputEnvelope
    set?: OfferedCourseSectionWhereUniqueInput | OfferedCourseSectionWhereUniqueInput[]
    disconnect?: OfferedCourseSectionWhereUniqueInput | OfferedCourseSectionWhereUniqueInput[]
    delete?: OfferedCourseSectionWhereUniqueInput | OfferedCourseSectionWhereUniqueInput[]
    connect?: OfferedCourseSectionWhereUniqueInput | OfferedCourseSectionWhereUniqueInput[]
    update?: OfferedCourseSectionUpdateWithWhereUniqueWithoutOfferedCourseInput | OfferedCourseSectionUpdateWithWhereUniqueWithoutOfferedCourseInput[]
    updateMany?: OfferedCourseSectionUpdateManyWithWhereWithoutOfferedCourseInput | OfferedCourseSectionUpdateManyWithWhereWithoutOfferedCourseInput[]
    deleteMany?: OfferedCourseSectionScalarWhereInput | OfferedCourseSectionScalarWhereInput[]
  }

  export type StudentSemesterRegistrationCourseUncheckedUpdateManyWithoutOfferedCourseNestedInput = {
    create?: XOR<StudentSemesterRegistrationCourseCreateWithoutOfferedCourseInput, StudentSemesterRegistrationCourseUncheckedCreateWithoutOfferedCourseInput> | StudentSemesterRegistrationCourseCreateWithoutOfferedCourseInput[] | StudentSemesterRegistrationCourseUncheckedCreateWithoutOfferedCourseInput[]
    connectOrCreate?: StudentSemesterRegistrationCourseCreateOrConnectWithoutOfferedCourseInput | StudentSemesterRegistrationCourseCreateOrConnectWithoutOfferedCourseInput[]
    upsert?: StudentSemesterRegistrationCourseUpsertWithWhereUniqueWithoutOfferedCourseInput | StudentSemesterRegistrationCourseUpsertWithWhereUniqueWithoutOfferedCourseInput[]
    createMany?: StudentSemesterRegistrationCourseCreateManyOfferedCourseInputEnvelope
    set?: StudentSemesterRegistrationCourseWhereUniqueInput | StudentSemesterRegistrationCourseWhereUniqueInput[]
    disconnect?: StudentSemesterRegistrationCourseWhereUniqueInput | StudentSemesterRegistrationCourseWhereUniqueInput[]
    delete?: StudentSemesterRegistrationCourseWhereUniqueInput | StudentSemesterRegistrationCourseWhereUniqueInput[]
    connect?: StudentSemesterRegistrationCourseWhereUniqueInput | StudentSemesterRegistrationCourseWhereUniqueInput[]
    update?: StudentSemesterRegistrationCourseUpdateWithWhereUniqueWithoutOfferedCourseInput | StudentSemesterRegistrationCourseUpdateWithWhereUniqueWithoutOfferedCourseInput[]
    updateMany?: StudentSemesterRegistrationCourseUpdateManyWithWhereWithoutOfferedCourseInput | StudentSemesterRegistrationCourseUpdateManyWithWhereWithoutOfferedCourseInput[]
    deleteMany?: StudentSemesterRegistrationCourseScalarWhereInput | StudentSemesterRegistrationCourseScalarWhereInput[]
  }

  export type SemesterRegistrationCreateNestedOneWithoutOfferedCourseSectionsInput = {
    create?: XOR<SemesterRegistrationCreateWithoutOfferedCourseSectionsInput, SemesterRegistrationUncheckedCreateWithoutOfferedCourseSectionsInput>
    connectOrCreate?: SemesterRegistrationCreateOrConnectWithoutOfferedCourseSectionsInput
    connect?: SemesterRegistrationWhereUniqueInput
  }

  export type OfferedCourseCreateNestedOneWithoutOfferedCourseSectionsInput = {
    create?: XOR<OfferedCourseCreateWithoutOfferedCourseSectionsInput, OfferedCourseUncheckedCreateWithoutOfferedCourseSectionsInput>
    connectOrCreate?: OfferedCourseCreateOrConnectWithoutOfferedCourseSectionsInput
    connect?: OfferedCourseWhereUniqueInput
  }

  export type OfferedCourseClassScheduleCreateNestedManyWithoutOfferedCourseSectionInput = {
    create?: XOR<OfferedCourseClassScheduleCreateWithoutOfferedCourseSectionInput, OfferedCourseClassScheduleUncheckedCreateWithoutOfferedCourseSectionInput> | OfferedCourseClassScheduleCreateWithoutOfferedCourseSectionInput[] | OfferedCourseClassScheduleUncheckedCreateWithoutOfferedCourseSectionInput[]
    connectOrCreate?: OfferedCourseClassScheduleCreateOrConnectWithoutOfferedCourseSectionInput | OfferedCourseClassScheduleCreateOrConnectWithoutOfferedCourseSectionInput[]
    createMany?: OfferedCourseClassScheduleCreateManyOfferedCourseSectionInputEnvelope
    connect?: OfferedCourseClassScheduleWhereUniqueInput | OfferedCourseClassScheduleWhereUniqueInput[]
  }

  export type StudentSemesterRegistrationCourseCreateNestedManyWithoutOfferedCourseSectionInput = {
    create?: XOR<StudentSemesterRegistrationCourseCreateWithoutOfferedCourseSectionInput, StudentSemesterRegistrationCourseUncheckedCreateWithoutOfferedCourseSectionInput> | StudentSemesterRegistrationCourseCreateWithoutOfferedCourseSectionInput[] | StudentSemesterRegistrationCourseUncheckedCreateWithoutOfferedCourseSectionInput[]
    connectOrCreate?: StudentSemesterRegistrationCourseCreateOrConnectWithoutOfferedCourseSectionInput | StudentSemesterRegistrationCourseCreateOrConnectWithoutOfferedCourseSectionInput[]
    createMany?: StudentSemesterRegistrationCourseCreateManyOfferedCourseSectionInputEnvelope
    connect?: StudentSemesterRegistrationCourseWhereUniqueInput | StudentSemesterRegistrationCourseWhereUniqueInput[]
  }

  export type OfferedCourseClassScheduleUncheckedCreateNestedManyWithoutOfferedCourseSectionInput = {
    create?: XOR<OfferedCourseClassScheduleCreateWithoutOfferedCourseSectionInput, OfferedCourseClassScheduleUncheckedCreateWithoutOfferedCourseSectionInput> | OfferedCourseClassScheduleCreateWithoutOfferedCourseSectionInput[] | OfferedCourseClassScheduleUncheckedCreateWithoutOfferedCourseSectionInput[]
    connectOrCreate?: OfferedCourseClassScheduleCreateOrConnectWithoutOfferedCourseSectionInput | OfferedCourseClassScheduleCreateOrConnectWithoutOfferedCourseSectionInput[]
    createMany?: OfferedCourseClassScheduleCreateManyOfferedCourseSectionInputEnvelope
    connect?: OfferedCourseClassScheduleWhereUniqueInput | OfferedCourseClassScheduleWhereUniqueInput[]
  }

  export type StudentSemesterRegistrationCourseUncheckedCreateNestedManyWithoutOfferedCourseSectionInput = {
    create?: XOR<StudentSemesterRegistrationCourseCreateWithoutOfferedCourseSectionInput, StudentSemesterRegistrationCourseUncheckedCreateWithoutOfferedCourseSectionInput> | StudentSemesterRegistrationCourseCreateWithoutOfferedCourseSectionInput[] | StudentSemesterRegistrationCourseUncheckedCreateWithoutOfferedCourseSectionInput[]
    connectOrCreate?: StudentSemesterRegistrationCourseCreateOrConnectWithoutOfferedCourseSectionInput | StudentSemesterRegistrationCourseCreateOrConnectWithoutOfferedCourseSectionInput[]
    createMany?: StudentSemesterRegistrationCourseCreateManyOfferedCourseSectionInputEnvelope
    connect?: StudentSemesterRegistrationCourseWhereUniqueInput | StudentSemesterRegistrationCourseWhereUniqueInput[]
  }

  export type SemesterRegistrationUpdateOneRequiredWithoutOfferedCourseSectionsNestedInput = {
    create?: XOR<SemesterRegistrationCreateWithoutOfferedCourseSectionsInput, SemesterRegistrationUncheckedCreateWithoutOfferedCourseSectionsInput>
    connectOrCreate?: SemesterRegistrationCreateOrConnectWithoutOfferedCourseSectionsInput
    upsert?: SemesterRegistrationUpsertWithoutOfferedCourseSectionsInput
    connect?: SemesterRegistrationWhereUniqueInput
    update?: XOR<XOR<SemesterRegistrationUpdateToOneWithWhereWithoutOfferedCourseSectionsInput, SemesterRegistrationUpdateWithoutOfferedCourseSectionsInput>, SemesterRegistrationUncheckedUpdateWithoutOfferedCourseSectionsInput>
  }

  export type OfferedCourseUpdateOneRequiredWithoutOfferedCourseSectionsNestedInput = {
    create?: XOR<OfferedCourseCreateWithoutOfferedCourseSectionsInput, OfferedCourseUncheckedCreateWithoutOfferedCourseSectionsInput>
    connectOrCreate?: OfferedCourseCreateOrConnectWithoutOfferedCourseSectionsInput
    upsert?: OfferedCourseUpsertWithoutOfferedCourseSectionsInput
    connect?: OfferedCourseWhereUniqueInput
    update?: XOR<XOR<OfferedCourseUpdateToOneWithWhereWithoutOfferedCourseSectionsInput, OfferedCourseUpdateWithoutOfferedCourseSectionsInput>, OfferedCourseUncheckedUpdateWithoutOfferedCourseSectionsInput>
  }

  export type OfferedCourseClassScheduleUpdateManyWithoutOfferedCourseSectionNestedInput = {
    create?: XOR<OfferedCourseClassScheduleCreateWithoutOfferedCourseSectionInput, OfferedCourseClassScheduleUncheckedCreateWithoutOfferedCourseSectionInput> | OfferedCourseClassScheduleCreateWithoutOfferedCourseSectionInput[] | OfferedCourseClassScheduleUncheckedCreateWithoutOfferedCourseSectionInput[]
    connectOrCreate?: OfferedCourseClassScheduleCreateOrConnectWithoutOfferedCourseSectionInput | OfferedCourseClassScheduleCreateOrConnectWithoutOfferedCourseSectionInput[]
    upsert?: OfferedCourseClassScheduleUpsertWithWhereUniqueWithoutOfferedCourseSectionInput | OfferedCourseClassScheduleUpsertWithWhereUniqueWithoutOfferedCourseSectionInput[]
    createMany?: OfferedCourseClassScheduleCreateManyOfferedCourseSectionInputEnvelope
    set?: OfferedCourseClassScheduleWhereUniqueInput | OfferedCourseClassScheduleWhereUniqueInput[]
    disconnect?: OfferedCourseClassScheduleWhereUniqueInput | OfferedCourseClassScheduleWhereUniqueInput[]
    delete?: OfferedCourseClassScheduleWhereUniqueInput | OfferedCourseClassScheduleWhereUniqueInput[]
    connect?: OfferedCourseClassScheduleWhereUniqueInput | OfferedCourseClassScheduleWhereUniqueInput[]
    update?: OfferedCourseClassScheduleUpdateWithWhereUniqueWithoutOfferedCourseSectionInput | OfferedCourseClassScheduleUpdateWithWhereUniqueWithoutOfferedCourseSectionInput[]
    updateMany?: OfferedCourseClassScheduleUpdateManyWithWhereWithoutOfferedCourseSectionInput | OfferedCourseClassScheduleUpdateManyWithWhereWithoutOfferedCourseSectionInput[]
    deleteMany?: OfferedCourseClassScheduleScalarWhereInput | OfferedCourseClassScheduleScalarWhereInput[]
  }

  export type StudentSemesterRegistrationCourseUpdateManyWithoutOfferedCourseSectionNestedInput = {
    create?: XOR<StudentSemesterRegistrationCourseCreateWithoutOfferedCourseSectionInput, StudentSemesterRegistrationCourseUncheckedCreateWithoutOfferedCourseSectionInput> | StudentSemesterRegistrationCourseCreateWithoutOfferedCourseSectionInput[] | StudentSemesterRegistrationCourseUncheckedCreateWithoutOfferedCourseSectionInput[]
    connectOrCreate?: StudentSemesterRegistrationCourseCreateOrConnectWithoutOfferedCourseSectionInput | StudentSemesterRegistrationCourseCreateOrConnectWithoutOfferedCourseSectionInput[]
    upsert?: StudentSemesterRegistrationCourseUpsertWithWhereUniqueWithoutOfferedCourseSectionInput | StudentSemesterRegistrationCourseUpsertWithWhereUniqueWithoutOfferedCourseSectionInput[]
    createMany?: StudentSemesterRegistrationCourseCreateManyOfferedCourseSectionInputEnvelope
    set?: StudentSemesterRegistrationCourseWhereUniqueInput | StudentSemesterRegistrationCourseWhereUniqueInput[]
    disconnect?: StudentSemesterRegistrationCourseWhereUniqueInput | StudentSemesterRegistrationCourseWhereUniqueInput[]
    delete?: StudentSemesterRegistrationCourseWhereUniqueInput | StudentSemesterRegistrationCourseWhereUniqueInput[]
    connect?: StudentSemesterRegistrationCourseWhereUniqueInput | StudentSemesterRegistrationCourseWhereUniqueInput[]
    update?: StudentSemesterRegistrationCourseUpdateWithWhereUniqueWithoutOfferedCourseSectionInput | StudentSemesterRegistrationCourseUpdateWithWhereUniqueWithoutOfferedCourseSectionInput[]
    updateMany?: StudentSemesterRegistrationCourseUpdateManyWithWhereWithoutOfferedCourseSectionInput | StudentSemesterRegistrationCourseUpdateManyWithWhereWithoutOfferedCourseSectionInput[]
    deleteMany?: StudentSemesterRegistrationCourseScalarWhereInput | StudentSemesterRegistrationCourseScalarWhereInput[]
  }

  export type OfferedCourseClassScheduleUncheckedUpdateManyWithoutOfferedCourseSectionNestedInput = {
    create?: XOR<OfferedCourseClassScheduleCreateWithoutOfferedCourseSectionInput, OfferedCourseClassScheduleUncheckedCreateWithoutOfferedCourseSectionInput> | OfferedCourseClassScheduleCreateWithoutOfferedCourseSectionInput[] | OfferedCourseClassScheduleUncheckedCreateWithoutOfferedCourseSectionInput[]
    connectOrCreate?: OfferedCourseClassScheduleCreateOrConnectWithoutOfferedCourseSectionInput | OfferedCourseClassScheduleCreateOrConnectWithoutOfferedCourseSectionInput[]
    upsert?: OfferedCourseClassScheduleUpsertWithWhereUniqueWithoutOfferedCourseSectionInput | OfferedCourseClassScheduleUpsertWithWhereUniqueWithoutOfferedCourseSectionInput[]
    createMany?: OfferedCourseClassScheduleCreateManyOfferedCourseSectionInputEnvelope
    set?: OfferedCourseClassScheduleWhereUniqueInput | OfferedCourseClassScheduleWhereUniqueInput[]
    disconnect?: OfferedCourseClassScheduleWhereUniqueInput | OfferedCourseClassScheduleWhereUniqueInput[]
    delete?: OfferedCourseClassScheduleWhereUniqueInput | OfferedCourseClassScheduleWhereUniqueInput[]
    connect?: OfferedCourseClassScheduleWhereUniqueInput | OfferedCourseClassScheduleWhereUniqueInput[]
    update?: OfferedCourseClassScheduleUpdateWithWhereUniqueWithoutOfferedCourseSectionInput | OfferedCourseClassScheduleUpdateWithWhereUniqueWithoutOfferedCourseSectionInput[]
    updateMany?: OfferedCourseClassScheduleUpdateManyWithWhereWithoutOfferedCourseSectionInput | OfferedCourseClassScheduleUpdateManyWithWhereWithoutOfferedCourseSectionInput[]
    deleteMany?: OfferedCourseClassScheduleScalarWhereInput | OfferedCourseClassScheduleScalarWhereInput[]
  }

  export type StudentSemesterRegistrationCourseUncheckedUpdateManyWithoutOfferedCourseSectionNestedInput = {
    create?: XOR<StudentSemesterRegistrationCourseCreateWithoutOfferedCourseSectionInput, StudentSemesterRegistrationCourseUncheckedCreateWithoutOfferedCourseSectionInput> | StudentSemesterRegistrationCourseCreateWithoutOfferedCourseSectionInput[] | StudentSemesterRegistrationCourseUncheckedCreateWithoutOfferedCourseSectionInput[]
    connectOrCreate?: StudentSemesterRegistrationCourseCreateOrConnectWithoutOfferedCourseSectionInput | StudentSemesterRegistrationCourseCreateOrConnectWithoutOfferedCourseSectionInput[]
    upsert?: StudentSemesterRegistrationCourseUpsertWithWhereUniqueWithoutOfferedCourseSectionInput | StudentSemesterRegistrationCourseUpsertWithWhereUniqueWithoutOfferedCourseSectionInput[]
    createMany?: StudentSemesterRegistrationCourseCreateManyOfferedCourseSectionInputEnvelope
    set?: StudentSemesterRegistrationCourseWhereUniqueInput | StudentSemesterRegistrationCourseWhereUniqueInput[]
    disconnect?: StudentSemesterRegistrationCourseWhereUniqueInput | StudentSemesterRegistrationCourseWhereUniqueInput[]
    delete?: StudentSemesterRegistrationCourseWhereUniqueInput | StudentSemesterRegistrationCourseWhereUniqueInput[]
    connect?: StudentSemesterRegistrationCourseWhereUniqueInput | StudentSemesterRegistrationCourseWhereUniqueInput[]
    update?: StudentSemesterRegistrationCourseUpdateWithWhereUniqueWithoutOfferedCourseSectionInput | StudentSemesterRegistrationCourseUpdateWithWhereUniqueWithoutOfferedCourseSectionInput[]
    updateMany?: StudentSemesterRegistrationCourseUpdateManyWithWhereWithoutOfferedCourseSectionInput | StudentSemesterRegistrationCourseUpdateManyWithWhereWithoutOfferedCourseSectionInput[]
    deleteMany?: StudentSemesterRegistrationCourseScalarWhereInput | StudentSemesterRegistrationCourseScalarWhereInput[]
  }

  export type OfferedCourseSectionCreateNestedOneWithoutOfferedCourseClassSchedulesInput = {
    create?: XOR<OfferedCourseSectionCreateWithoutOfferedCourseClassSchedulesInput, OfferedCourseSectionUncheckedCreateWithoutOfferedCourseClassSchedulesInput>
    connectOrCreate?: OfferedCourseSectionCreateOrConnectWithoutOfferedCourseClassSchedulesInput
    connect?: OfferedCourseSectionWhereUniqueInput
  }

  export type SemesterRegistrationCreateNestedOneWithoutOfferedCourseClassSchedulesInput = {
    create?: XOR<SemesterRegistrationCreateWithoutOfferedCourseClassSchedulesInput, SemesterRegistrationUncheckedCreateWithoutOfferedCourseClassSchedulesInput>
    connectOrCreate?: SemesterRegistrationCreateOrConnectWithoutOfferedCourseClassSchedulesInput
    connect?: SemesterRegistrationWhereUniqueInput
  }

  export type RoomCreateNestedOneWithoutOfferedCourseClassSchedulesInput = {
    create?: XOR<RoomCreateWithoutOfferedCourseClassSchedulesInput, RoomUncheckedCreateWithoutOfferedCourseClassSchedulesInput>
    connectOrCreate?: RoomCreateOrConnectWithoutOfferedCourseClassSchedulesInput
    connect?: RoomWhereUniqueInput
  }

  export type FacultyCreateNestedOneWithoutOfferedCourseClassSchedulesInput = {
    create?: XOR<FacultyCreateWithoutOfferedCourseClassSchedulesInput, FacultyUncheckedCreateWithoutOfferedCourseClassSchedulesInput>
    connectOrCreate?: FacultyCreateOrConnectWithoutOfferedCourseClassSchedulesInput
    connect?: FacultyWhereUniqueInput
  }

  export type EnumWeekDaysFieldUpdateOperationsInput = {
    set?: $Enums.WeekDays
  }

  export type OfferedCourseSectionUpdateOneRequiredWithoutOfferedCourseClassSchedulesNestedInput = {
    create?: XOR<OfferedCourseSectionCreateWithoutOfferedCourseClassSchedulesInput, OfferedCourseSectionUncheckedCreateWithoutOfferedCourseClassSchedulesInput>
    connectOrCreate?: OfferedCourseSectionCreateOrConnectWithoutOfferedCourseClassSchedulesInput
    upsert?: OfferedCourseSectionUpsertWithoutOfferedCourseClassSchedulesInput
    connect?: OfferedCourseSectionWhereUniqueInput
    update?: XOR<XOR<OfferedCourseSectionUpdateToOneWithWhereWithoutOfferedCourseClassSchedulesInput, OfferedCourseSectionUpdateWithoutOfferedCourseClassSchedulesInput>, OfferedCourseSectionUncheckedUpdateWithoutOfferedCourseClassSchedulesInput>
  }

  export type SemesterRegistrationUpdateOneRequiredWithoutOfferedCourseClassSchedulesNestedInput = {
    create?: XOR<SemesterRegistrationCreateWithoutOfferedCourseClassSchedulesInput, SemesterRegistrationUncheckedCreateWithoutOfferedCourseClassSchedulesInput>
    connectOrCreate?: SemesterRegistrationCreateOrConnectWithoutOfferedCourseClassSchedulesInput
    upsert?: SemesterRegistrationUpsertWithoutOfferedCourseClassSchedulesInput
    connect?: SemesterRegistrationWhereUniqueInput
    update?: XOR<XOR<SemesterRegistrationUpdateToOneWithWhereWithoutOfferedCourseClassSchedulesInput, SemesterRegistrationUpdateWithoutOfferedCourseClassSchedulesInput>, SemesterRegistrationUncheckedUpdateWithoutOfferedCourseClassSchedulesInput>
  }

  export type RoomUpdateOneRequiredWithoutOfferedCourseClassSchedulesNestedInput = {
    create?: XOR<RoomCreateWithoutOfferedCourseClassSchedulesInput, RoomUncheckedCreateWithoutOfferedCourseClassSchedulesInput>
    connectOrCreate?: RoomCreateOrConnectWithoutOfferedCourseClassSchedulesInput
    upsert?: RoomUpsertWithoutOfferedCourseClassSchedulesInput
    connect?: RoomWhereUniqueInput
    update?: XOR<XOR<RoomUpdateToOneWithWhereWithoutOfferedCourseClassSchedulesInput, RoomUpdateWithoutOfferedCourseClassSchedulesInput>, RoomUncheckedUpdateWithoutOfferedCourseClassSchedulesInput>
  }

  export type FacultyUpdateOneRequiredWithoutOfferedCourseClassSchedulesNestedInput = {
    create?: XOR<FacultyCreateWithoutOfferedCourseClassSchedulesInput, FacultyUncheckedCreateWithoutOfferedCourseClassSchedulesInput>
    connectOrCreate?: FacultyCreateOrConnectWithoutOfferedCourseClassSchedulesInput
    upsert?: FacultyUpsertWithoutOfferedCourseClassSchedulesInput
    connect?: FacultyWhereUniqueInput
    update?: XOR<XOR<FacultyUpdateToOneWithWhereWithoutOfferedCourseClassSchedulesInput, FacultyUpdateWithoutOfferedCourseClassSchedulesInput>, FacultyUncheckedUpdateWithoutOfferedCourseClassSchedulesInput>
  }

  export type StudentCreateNestedOneWithoutStudentSemesterRegistrationsInput = {
    create?: XOR<StudentCreateWithoutStudentSemesterRegistrationsInput, StudentUncheckedCreateWithoutStudentSemesterRegistrationsInput>
    connectOrCreate?: StudentCreateOrConnectWithoutStudentSemesterRegistrationsInput
    connect?: StudentWhereUniqueInput
  }

  export type SemesterRegistrationCreateNestedOneWithoutStudentSemesterRegistrationsInput = {
    create?: XOR<SemesterRegistrationCreateWithoutStudentSemesterRegistrationsInput, SemesterRegistrationUncheckedCreateWithoutStudentSemesterRegistrationsInput>
    connectOrCreate?: SemesterRegistrationCreateOrConnectWithoutStudentSemesterRegistrationsInput
    connect?: SemesterRegistrationWhereUniqueInput
  }

  export type StudentUpdateOneRequiredWithoutStudentSemesterRegistrationsNestedInput = {
    create?: XOR<StudentCreateWithoutStudentSemesterRegistrationsInput, StudentUncheckedCreateWithoutStudentSemesterRegistrationsInput>
    connectOrCreate?: StudentCreateOrConnectWithoutStudentSemesterRegistrationsInput
    upsert?: StudentUpsertWithoutStudentSemesterRegistrationsInput
    connect?: StudentWhereUniqueInput
    update?: XOR<XOR<StudentUpdateToOneWithWhereWithoutStudentSemesterRegistrationsInput, StudentUpdateWithoutStudentSemesterRegistrationsInput>, StudentUncheckedUpdateWithoutStudentSemesterRegistrationsInput>
  }

  export type SemesterRegistrationUpdateOneRequiredWithoutStudentSemesterRegistrationsNestedInput = {
    create?: XOR<SemesterRegistrationCreateWithoutStudentSemesterRegistrationsInput, SemesterRegistrationUncheckedCreateWithoutStudentSemesterRegistrationsInput>
    connectOrCreate?: SemesterRegistrationCreateOrConnectWithoutStudentSemesterRegistrationsInput
    upsert?: SemesterRegistrationUpsertWithoutStudentSemesterRegistrationsInput
    connect?: SemesterRegistrationWhereUniqueInput
    update?: XOR<XOR<SemesterRegistrationUpdateToOneWithWhereWithoutStudentSemesterRegistrationsInput, SemesterRegistrationUpdateWithoutStudentSemesterRegistrationsInput>, SemesterRegistrationUncheckedUpdateWithoutStudentSemesterRegistrationsInput>
  }

  export type SemesterRegistrationCreateNestedOneWithoutStudentSemesterRegistrationCoursesInput = {
    create?: XOR<SemesterRegistrationCreateWithoutStudentSemesterRegistrationCoursesInput, SemesterRegistrationUncheckedCreateWithoutStudentSemesterRegistrationCoursesInput>
    connectOrCreate?: SemesterRegistrationCreateOrConnectWithoutStudentSemesterRegistrationCoursesInput
    connect?: SemesterRegistrationWhereUniqueInput
  }

  export type StudentCreateNestedOneWithoutStudentSemesterRegistrationCoursesInput = {
    create?: XOR<StudentCreateWithoutStudentSemesterRegistrationCoursesInput, StudentUncheckedCreateWithoutStudentSemesterRegistrationCoursesInput>
    connectOrCreate?: StudentCreateOrConnectWithoutStudentSemesterRegistrationCoursesInput
    connect?: StudentWhereUniqueInput
  }

  export type OfferedCourseCreateNestedOneWithoutStudentSemesterRegistrationCoursesInput = {
    create?: XOR<OfferedCourseCreateWithoutStudentSemesterRegistrationCoursesInput, OfferedCourseUncheckedCreateWithoutStudentSemesterRegistrationCoursesInput>
    connectOrCreate?: OfferedCourseCreateOrConnectWithoutStudentSemesterRegistrationCoursesInput
    connect?: OfferedCourseWhereUniqueInput
  }

  export type OfferedCourseSectionCreateNestedOneWithoutStudentSemesterRegistrationCoursesInput = {
    create?: XOR<OfferedCourseSectionCreateWithoutStudentSemesterRegistrationCoursesInput, OfferedCourseSectionUncheckedCreateWithoutStudentSemesterRegistrationCoursesInput>
    connectOrCreate?: OfferedCourseSectionCreateOrConnectWithoutStudentSemesterRegistrationCoursesInput
    connect?: OfferedCourseSectionWhereUniqueInput
  }

  export type SemesterRegistrationUpdateOneRequiredWithoutStudentSemesterRegistrationCoursesNestedInput = {
    create?: XOR<SemesterRegistrationCreateWithoutStudentSemesterRegistrationCoursesInput, SemesterRegistrationUncheckedCreateWithoutStudentSemesterRegistrationCoursesInput>
    connectOrCreate?: SemesterRegistrationCreateOrConnectWithoutStudentSemesterRegistrationCoursesInput
    upsert?: SemesterRegistrationUpsertWithoutStudentSemesterRegistrationCoursesInput
    connect?: SemesterRegistrationWhereUniqueInput
    update?: XOR<XOR<SemesterRegistrationUpdateToOneWithWhereWithoutStudentSemesterRegistrationCoursesInput, SemesterRegistrationUpdateWithoutStudentSemesterRegistrationCoursesInput>, SemesterRegistrationUncheckedUpdateWithoutStudentSemesterRegistrationCoursesInput>
  }

  export type StudentUpdateOneRequiredWithoutStudentSemesterRegistrationCoursesNestedInput = {
    create?: XOR<StudentCreateWithoutStudentSemesterRegistrationCoursesInput, StudentUncheckedCreateWithoutStudentSemesterRegistrationCoursesInput>
    connectOrCreate?: StudentCreateOrConnectWithoutStudentSemesterRegistrationCoursesInput
    upsert?: StudentUpsertWithoutStudentSemesterRegistrationCoursesInput
    connect?: StudentWhereUniqueInput
    update?: XOR<XOR<StudentUpdateToOneWithWhereWithoutStudentSemesterRegistrationCoursesInput, StudentUpdateWithoutStudentSemesterRegistrationCoursesInput>, StudentUncheckedUpdateWithoutStudentSemesterRegistrationCoursesInput>
  }

  export type OfferedCourseUpdateOneRequiredWithoutStudentSemesterRegistrationCoursesNestedInput = {
    create?: XOR<OfferedCourseCreateWithoutStudentSemesterRegistrationCoursesInput, OfferedCourseUncheckedCreateWithoutStudentSemesterRegistrationCoursesInput>
    connectOrCreate?: OfferedCourseCreateOrConnectWithoutStudentSemesterRegistrationCoursesInput
    upsert?: OfferedCourseUpsertWithoutStudentSemesterRegistrationCoursesInput
    connect?: OfferedCourseWhereUniqueInput
    update?: XOR<XOR<OfferedCourseUpdateToOneWithWhereWithoutStudentSemesterRegistrationCoursesInput, OfferedCourseUpdateWithoutStudentSemesterRegistrationCoursesInput>, OfferedCourseUncheckedUpdateWithoutStudentSemesterRegistrationCoursesInput>
  }

  export type OfferedCourseSectionUpdateOneRequiredWithoutStudentSemesterRegistrationCoursesNestedInput = {
    create?: XOR<OfferedCourseSectionCreateWithoutStudentSemesterRegistrationCoursesInput, OfferedCourseSectionUncheckedCreateWithoutStudentSemesterRegistrationCoursesInput>
    connectOrCreate?: OfferedCourseSectionCreateOrConnectWithoutStudentSemesterRegistrationCoursesInput
    upsert?: OfferedCourseSectionUpsertWithoutStudentSemesterRegistrationCoursesInput
    connect?: OfferedCourseSectionWhereUniqueInput
    update?: XOR<XOR<OfferedCourseSectionUpdateToOneWithWhereWithoutStudentSemesterRegistrationCoursesInput, OfferedCourseSectionUpdateWithoutStudentSemesterRegistrationCoursesInput>, OfferedCourseSectionUncheckedUpdateWithoutStudentSemesterRegistrationCoursesInput>
  }

  export type StudentCreateNestedOneWithoutStudentEnrolledCoursesInput = {
    create?: XOR<StudentCreateWithoutStudentEnrolledCoursesInput, StudentUncheckedCreateWithoutStudentEnrolledCoursesInput>
    connectOrCreate?: StudentCreateOrConnectWithoutStudentEnrolledCoursesInput
    connect?: StudentWhereUniqueInput
  }

  export type AcademicSemesterCreateNestedOneWithoutStudentEnrolledCoursesInput = {
    create?: XOR<AcademicSemesterCreateWithoutStudentEnrolledCoursesInput, AcademicSemesterUncheckedCreateWithoutStudentEnrolledCoursesInput>
    connectOrCreate?: AcademicSemesterCreateOrConnectWithoutStudentEnrolledCoursesInput
    connect?: AcademicSemesterWhereUniqueInput
  }

  export type CourseCreateNestedOneWithoutStudentEnrolledCoursesInput = {
    create?: XOR<CourseCreateWithoutStudentEnrolledCoursesInput, CourseUncheckedCreateWithoutStudentEnrolledCoursesInput>
    connectOrCreate?: CourseCreateOrConnectWithoutStudentEnrolledCoursesInput
    connect?: CourseWhereUniqueInput
  }

  export type StudentEnrolledCourseMarkCreateNestedManyWithoutStudentEnrolledCourseInput = {
    create?: XOR<StudentEnrolledCourseMarkCreateWithoutStudentEnrolledCourseInput, StudentEnrolledCourseMarkUncheckedCreateWithoutStudentEnrolledCourseInput> | StudentEnrolledCourseMarkCreateWithoutStudentEnrolledCourseInput[] | StudentEnrolledCourseMarkUncheckedCreateWithoutStudentEnrolledCourseInput[]
    connectOrCreate?: StudentEnrolledCourseMarkCreateOrConnectWithoutStudentEnrolledCourseInput | StudentEnrolledCourseMarkCreateOrConnectWithoutStudentEnrolledCourseInput[]
    createMany?: StudentEnrolledCourseMarkCreateManyStudentEnrolledCourseInputEnvelope
    connect?: StudentEnrolledCourseMarkWhereUniqueInput | StudentEnrolledCourseMarkWhereUniqueInput[]
  }

  export type StudentEnrolledCourseMarkUncheckedCreateNestedManyWithoutStudentEnrolledCourseInput = {
    create?: XOR<StudentEnrolledCourseMarkCreateWithoutStudentEnrolledCourseInput, StudentEnrolledCourseMarkUncheckedCreateWithoutStudentEnrolledCourseInput> | StudentEnrolledCourseMarkCreateWithoutStudentEnrolledCourseInput[] | StudentEnrolledCourseMarkUncheckedCreateWithoutStudentEnrolledCourseInput[]
    connectOrCreate?: StudentEnrolledCourseMarkCreateOrConnectWithoutStudentEnrolledCourseInput | StudentEnrolledCourseMarkCreateOrConnectWithoutStudentEnrolledCourseInput[]
    createMany?: StudentEnrolledCourseMarkCreateManyStudentEnrolledCourseInputEnvelope
    connect?: StudentEnrolledCourseMarkWhereUniqueInput | StudentEnrolledCourseMarkWhereUniqueInput[]
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableEnumStudentEnrolledCourseStatusFieldUpdateOperationsInput = {
    set?: $Enums.StudentEnrolledCourseStatus | null
  }

  export type StudentUpdateOneRequiredWithoutStudentEnrolledCoursesNestedInput = {
    create?: XOR<StudentCreateWithoutStudentEnrolledCoursesInput, StudentUncheckedCreateWithoutStudentEnrolledCoursesInput>
    connectOrCreate?: StudentCreateOrConnectWithoutStudentEnrolledCoursesInput
    upsert?: StudentUpsertWithoutStudentEnrolledCoursesInput
    connect?: StudentWhereUniqueInput
    update?: XOR<XOR<StudentUpdateToOneWithWhereWithoutStudentEnrolledCoursesInput, StudentUpdateWithoutStudentEnrolledCoursesInput>, StudentUncheckedUpdateWithoutStudentEnrolledCoursesInput>
  }

  export type AcademicSemesterUpdateOneRequiredWithoutStudentEnrolledCoursesNestedInput = {
    create?: XOR<AcademicSemesterCreateWithoutStudentEnrolledCoursesInput, AcademicSemesterUncheckedCreateWithoutStudentEnrolledCoursesInput>
    connectOrCreate?: AcademicSemesterCreateOrConnectWithoutStudentEnrolledCoursesInput
    upsert?: AcademicSemesterUpsertWithoutStudentEnrolledCoursesInput
    connect?: AcademicSemesterWhereUniqueInput
    update?: XOR<XOR<AcademicSemesterUpdateToOneWithWhereWithoutStudentEnrolledCoursesInput, AcademicSemesterUpdateWithoutStudentEnrolledCoursesInput>, AcademicSemesterUncheckedUpdateWithoutStudentEnrolledCoursesInput>
  }

  export type CourseUpdateOneRequiredWithoutStudentEnrolledCoursesNestedInput = {
    create?: XOR<CourseCreateWithoutStudentEnrolledCoursesInput, CourseUncheckedCreateWithoutStudentEnrolledCoursesInput>
    connectOrCreate?: CourseCreateOrConnectWithoutStudentEnrolledCoursesInput
    upsert?: CourseUpsertWithoutStudentEnrolledCoursesInput
    connect?: CourseWhereUniqueInput
    update?: XOR<XOR<CourseUpdateToOneWithWhereWithoutStudentEnrolledCoursesInput, CourseUpdateWithoutStudentEnrolledCoursesInput>, CourseUncheckedUpdateWithoutStudentEnrolledCoursesInput>
  }

  export type StudentEnrolledCourseMarkUpdateManyWithoutStudentEnrolledCourseNestedInput = {
    create?: XOR<StudentEnrolledCourseMarkCreateWithoutStudentEnrolledCourseInput, StudentEnrolledCourseMarkUncheckedCreateWithoutStudentEnrolledCourseInput> | StudentEnrolledCourseMarkCreateWithoutStudentEnrolledCourseInput[] | StudentEnrolledCourseMarkUncheckedCreateWithoutStudentEnrolledCourseInput[]
    connectOrCreate?: StudentEnrolledCourseMarkCreateOrConnectWithoutStudentEnrolledCourseInput | StudentEnrolledCourseMarkCreateOrConnectWithoutStudentEnrolledCourseInput[]
    upsert?: StudentEnrolledCourseMarkUpsertWithWhereUniqueWithoutStudentEnrolledCourseInput | StudentEnrolledCourseMarkUpsertWithWhereUniqueWithoutStudentEnrolledCourseInput[]
    createMany?: StudentEnrolledCourseMarkCreateManyStudentEnrolledCourseInputEnvelope
    set?: StudentEnrolledCourseMarkWhereUniqueInput | StudentEnrolledCourseMarkWhereUniqueInput[]
    disconnect?: StudentEnrolledCourseMarkWhereUniqueInput | StudentEnrolledCourseMarkWhereUniqueInput[]
    delete?: StudentEnrolledCourseMarkWhereUniqueInput | StudentEnrolledCourseMarkWhereUniqueInput[]
    connect?: StudentEnrolledCourseMarkWhereUniqueInput | StudentEnrolledCourseMarkWhereUniqueInput[]
    update?: StudentEnrolledCourseMarkUpdateWithWhereUniqueWithoutStudentEnrolledCourseInput | StudentEnrolledCourseMarkUpdateWithWhereUniqueWithoutStudentEnrolledCourseInput[]
    updateMany?: StudentEnrolledCourseMarkUpdateManyWithWhereWithoutStudentEnrolledCourseInput | StudentEnrolledCourseMarkUpdateManyWithWhereWithoutStudentEnrolledCourseInput[]
    deleteMany?: StudentEnrolledCourseMarkScalarWhereInput | StudentEnrolledCourseMarkScalarWhereInput[]
  }

  export type StudentEnrolledCourseMarkUncheckedUpdateManyWithoutStudentEnrolledCourseNestedInput = {
    create?: XOR<StudentEnrolledCourseMarkCreateWithoutStudentEnrolledCourseInput, StudentEnrolledCourseMarkUncheckedCreateWithoutStudentEnrolledCourseInput> | StudentEnrolledCourseMarkCreateWithoutStudentEnrolledCourseInput[] | StudentEnrolledCourseMarkUncheckedCreateWithoutStudentEnrolledCourseInput[]
    connectOrCreate?: StudentEnrolledCourseMarkCreateOrConnectWithoutStudentEnrolledCourseInput | StudentEnrolledCourseMarkCreateOrConnectWithoutStudentEnrolledCourseInput[]
    upsert?: StudentEnrolledCourseMarkUpsertWithWhereUniqueWithoutStudentEnrolledCourseInput | StudentEnrolledCourseMarkUpsertWithWhereUniqueWithoutStudentEnrolledCourseInput[]
    createMany?: StudentEnrolledCourseMarkCreateManyStudentEnrolledCourseInputEnvelope
    set?: StudentEnrolledCourseMarkWhereUniqueInput | StudentEnrolledCourseMarkWhereUniqueInput[]
    disconnect?: StudentEnrolledCourseMarkWhereUniqueInput | StudentEnrolledCourseMarkWhereUniqueInput[]
    delete?: StudentEnrolledCourseMarkWhereUniqueInput | StudentEnrolledCourseMarkWhereUniqueInput[]
    connect?: StudentEnrolledCourseMarkWhereUniqueInput | StudentEnrolledCourseMarkWhereUniqueInput[]
    update?: StudentEnrolledCourseMarkUpdateWithWhereUniqueWithoutStudentEnrolledCourseInput | StudentEnrolledCourseMarkUpdateWithWhereUniqueWithoutStudentEnrolledCourseInput[]
    updateMany?: StudentEnrolledCourseMarkUpdateManyWithWhereWithoutStudentEnrolledCourseInput | StudentEnrolledCourseMarkUpdateManyWithWhereWithoutStudentEnrolledCourseInput[]
    deleteMany?: StudentEnrolledCourseMarkScalarWhereInput | StudentEnrolledCourseMarkScalarWhereInput[]
  }

  export type StudentCreateNestedOneWithoutStudentEnrolledCourseMarksInput = {
    create?: XOR<StudentCreateWithoutStudentEnrolledCourseMarksInput, StudentUncheckedCreateWithoutStudentEnrolledCourseMarksInput>
    connectOrCreate?: StudentCreateOrConnectWithoutStudentEnrolledCourseMarksInput
    connect?: StudentWhereUniqueInput
  }

  export type StudentEnrolledCourseCreateNestedOneWithoutStudentEnrolledCourseMarksInput = {
    create?: XOR<StudentEnrolledCourseCreateWithoutStudentEnrolledCourseMarksInput, StudentEnrolledCourseUncheckedCreateWithoutStudentEnrolledCourseMarksInput>
    connectOrCreate?: StudentEnrolledCourseCreateOrConnectWithoutStudentEnrolledCourseMarksInput
    connect?: StudentEnrolledCourseWhereUniqueInput
  }

  export type AcademicSemesterCreateNestedOneWithoutStudentEnrolledCourseMarksInput = {
    create?: XOR<AcademicSemesterCreateWithoutStudentEnrolledCourseMarksInput, AcademicSemesterUncheckedCreateWithoutStudentEnrolledCourseMarksInput>
    connectOrCreate?: AcademicSemesterCreateOrConnectWithoutStudentEnrolledCourseMarksInput
    connect?: AcademicSemesterWhereUniqueInput
  }

  export type NullableEnumExamTypeFieldUpdateOperationsInput = {
    set?: $Enums.ExamType | null
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type StudentUpdateOneRequiredWithoutStudentEnrolledCourseMarksNestedInput = {
    create?: XOR<StudentCreateWithoutStudentEnrolledCourseMarksInput, StudentUncheckedCreateWithoutStudentEnrolledCourseMarksInput>
    connectOrCreate?: StudentCreateOrConnectWithoutStudentEnrolledCourseMarksInput
    upsert?: StudentUpsertWithoutStudentEnrolledCourseMarksInput
    connect?: StudentWhereUniqueInput
    update?: XOR<XOR<StudentUpdateToOneWithWhereWithoutStudentEnrolledCourseMarksInput, StudentUpdateWithoutStudentEnrolledCourseMarksInput>, StudentUncheckedUpdateWithoutStudentEnrolledCourseMarksInput>
  }

  export type StudentEnrolledCourseUpdateOneRequiredWithoutStudentEnrolledCourseMarksNestedInput = {
    create?: XOR<StudentEnrolledCourseCreateWithoutStudentEnrolledCourseMarksInput, StudentEnrolledCourseUncheckedCreateWithoutStudentEnrolledCourseMarksInput>
    connectOrCreate?: StudentEnrolledCourseCreateOrConnectWithoutStudentEnrolledCourseMarksInput
    upsert?: StudentEnrolledCourseUpsertWithoutStudentEnrolledCourseMarksInput
    connect?: StudentEnrolledCourseWhereUniqueInput
    update?: XOR<XOR<StudentEnrolledCourseUpdateToOneWithWhereWithoutStudentEnrolledCourseMarksInput, StudentEnrolledCourseUpdateWithoutStudentEnrolledCourseMarksInput>, StudentEnrolledCourseUncheckedUpdateWithoutStudentEnrolledCourseMarksInput>
  }

  export type AcademicSemesterUpdateOneRequiredWithoutStudentEnrolledCourseMarksNestedInput = {
    create?: XOR<AcademicSemesterCreateWithoutStudentEnrolledCourseMarksInput, AcademicSemesterUncheckedCreateWithoutStudentEnrolledCourseMarksInput>
    connectOrCreate?: AcademicSemesterCreateOrConnectWithoutStudentEnrolledCourseMarksInput
    upsert?: AcademicSemesterUpsertWithoutStudentEnrolledCourseMarksInput
    connect?: AcademicSemesterWhereUniqueInput
    update?: XOR<XOR<AcademicSemesterUpdateToOneWithWhereWithoutStudentEnrolledCourseMarksInput, AcademicSemesterUpdateWithoutStudentEnrolledCourseMarksInput>, AcademicSemesterUncheckedUpdateWithoutStudentEnrolledCourseMarksInput>
  }

  export type StudentCreateNestedOneWithoutStudentSemesterPaymentsInput = {
    create?: XOR<StudentCreateWithoutStudentSemesterPaymentsInput, StudentUncheckedCreateWithoutStudentSemesterPaymentsInput>
    connectOrCreate?: StudentCreateOrConnectWithoutStudentSemesterPaymentsInput
    connect?: StudentWhereUniqueInput
  }

  export type AcademicSemesterCreateNestedOneWithoutStudentSemesterPaymentsInput = {
    create?: XOR<AcademicSemesterCreateWithoutStudentSemesterPaymentsInput, AcademicSemesterUncheckedCreateWithoutStudentSemesterPaymentsInput>
    connectOrCreate?: AcademicSemesterCreateOrConnectWithoutStudentSemesterPaymentsInput
    connect?: AcademicSemesterWhereUniqueInput
  }

  export type EnumPAYMENTTYPEFieldUpdateOperationsInput = {
    set?: $Enums.PAYMENTTYPE
  }

  export type NullableEnumPaymentStatusFieldUpdateOperationsInput = {
    set?: $Enums.PaymentStatus | null
  }

  export type StudentUpdateOneRequiredWithoutStudentSemesterPaymentsNestedInput = {
    create?: XOR<StudentCreateWithoutStudentSemesterPaymentsInput, StudentUncheckedCreateWithoutStudentSemesterPaymentsInput>
    connectOrCreate?: StudentCreateOrConnectWithoutStudentSemesterPaymentsInput
    upsert?: StudentUpsertWithoutStudentSemesterPaymentsInput
    connect?: StudentWhereUniqueInput
    update?: XOR<XOR<StudentUpdateToOneWithWhereWithoutStudentSemesterPaymentsInput, StudentUpdateWithoutStudentSemesterPaymentsInput>, StudentUncheckedUpdateWithoutStudentSemesterPaymentsInput>
  }

  export type AcademicSemesterUpdateOneRequiredWithoutStudentSemesterPaymentsNestedInput = {
    create?: XOR<AcademicSemesterCreateWithoutStudentSemesterPaymentsInput, AcademicSemesterUncheckedCreateWithoutStudentSemesterPaymentsInput>
    connectOrCreate?: AcademicSemesterCreateOrConnectWithoutStudentSemesterPaymentsInput
    upsert?: AcademicSemesterUpsertWithoutStudentSemesterPaymentsInput
    connect?: AcademicSemesterWhereUniqueInput
    update?: XOR<XOR<AcademicSemesterUpdateToOneWithWhereWithoutStudentSemesterPaymentsInput, AcademicSemesterUpdateWithoutStudentSemesterPaymentsInput>, AcademicSemesterUncheckedUpdateWithoutStudentSemesterPaymentsInput>
  }

  export type StudentCreateNestedOneWithoutStudentAcademicInfosInput = {
    create?: XOR<StudentCreateWithoutStudentAcademicInfosInput, StudentUncheckedCreateWithoutStudentAcademicInfosInput>
    connectOrCreate?: StudentCreateOrConnectWithoutStudentAcademicInfosInput
    connect?: StudentWhereUniqueInput
  }

  export type StudentUpdateOneRequiredWithoutStudentAcademicInfosNestedInput = {
    create?: XOR<StudentCreateWithoutStudentAcademicInfosInput, StudentUncheckedCreateWithoutStudentAcademicInfosInput>
    connectOrCreate?: StudentCreateOrConnectWithoutStudentAcademicInfosInput
    upsert?: StudentUpsertWithoutStudentAcademicInfosInput
    connect?: StudentWhereUniqueInput
    update?: XOR<XOR<StudentUpdateToOneWithWhereWithoutStudentAcademicInfosInput, StudentUpdateWithoutStudentAcademicInfosInput>, StudentUncheckedUpdateWithoutStudentAcademicInfosInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedEnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[]
    notIn?: $Enums.UserRole[]
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[]
    notIn?: $Enums.UserRole[]
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedEnumShiftFilter<$PrismaModel = never> = {
    equals?: $Enums.Shift | EnumShiftFieldRefInput<$PrismaModel>
    in?: $Enums.Shift[]
    notIn?: $Enums.Shift[]
    not?: NestedEnumShiftFilter<$PrismaModel> | $Enums.Shift
  }

  export type NestedEnumShiftWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Shift | EnumShiftFieldRefInput<$PrismaModel>
    in?: $Enums.Shift[]
    notIn?: $Enums.Shift[]
    not?: NestedEnumShiftWithAggregatesFilter<$PrismaModel> | $Enums.Shift
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumShiftFilter<$PrismaModel>
    _max?: NestedEnumShiftFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedEnumSemesterRegistrationStatusNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.SemesterRegistrationStatus | EnumSemesterRegistrationStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.SemesterRegistrationStatus[] | null
    notIn?: $Enums.SemesterRegistrationStatus[] | null
    not?: NestedEnumSemesterRegistrationStatusNullableFilter<$PrismaModel> | $Enums.SemesterRegistrationStatus | null
  }

  export type NestedEnumSemesterRegistrationStatusNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SemesterRegistrationStatus | EnumSemesterRegistrationStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.SemesterRegistrationStatus[] | null
    notIn?: $Enums.SemesterRegistrationStatus[] | null
    not?: NestedEnumSemesterRegistrationStatusNullableWithAggregatesFilter<$PrismaModel> | $Enums.SemesterRegistrationStatus | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumSemesterRegistrationStatusNullableFilter<$PrismaModel>
    _max?: NestedEnumSemesterRegistrationStatusNullableFilter<$PrismaModel>
  }

  export type NestedBoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type NestedEnumWeekDaysFilter<$PrismaModel = never> = {
    equals?: $Enums.WeekDays | EnumWeekDaysFieldRefInput<$PrismaModel>
    in?: $Enums.WeekDays[]
    notIn?: $Enums.WeekDays[]
    not?: NestedEnumWeekDaysFilter<$PrismaModel> | $Enums.WeekDays
  }

  export type NestedEnumWeekDaysWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.WeekDays | EnumWeekDaysFieldRefInput<$PrismaModel>
    in?: $Enums.WeekDays[]
    notIn?: $Enums.WeekDays[]
    not?: NestedEnumWeekDaysWithAggregatesFilter<$PrismaModel> | $Enums.WeekDays
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumWeekDaysFilter<$PrismaModel>
    _max?: NestedEnumWeekDaysFilter<$PrismaModel>
  }

  export type NestedEnumStudentEnrolledCourseStatusNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.StudentEnrolledCourseStatus | EnumStudentEnrolledCourseStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.StudentEnrolledCourseStatus[] | null
    notIn?: $Enums.StudentEnrolledCourseStatus[] | null
    not?: NestedEnumStudentEnrolledCourseStatusNullableFilter<$PrismaModel> | $Enums.StudentEnrolledCourseStatus | null
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedEnumStudentEnrolledCourseStatusNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.StudentEnrolledCourseStatus | EnumStudentEnrolledCourseStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.StudentEnrolledCourseStatus[] | null
    notIn?: $Enums.StudentEnrolledCourseStatus[] | null
    not?: NestedEnumStudentEnrolledCourseStatusNullableWithAggregatesFilter<$PrismaModel> | $Enums.StudentEnrolledCourseStatus | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumStudentEnrolledCourseStatusNullableFilter<$PrismaModel>
    _max?: NestedEnumStudentEnrolledCourseStatusNullableFilter<$PrismaModel>
  }

  export type NestedEnumExamTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.ExamType | EnumExamTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.ExamType[] | null
    notIn?: $Enums.ExamType[] | null
    not?: NestedEnumExamTypeNullableFilter<$PrismaModel> | $Enums.ExamType | null
  }

  export type NestedEnumExamTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ExamType | EnumExamTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.ExamType[] | null
    notIn?: $Enums.ExamType[] | null
    not?: NestedEnumExamTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.ExamType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumExamTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumExamTypeNullableFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedEnumPAYMENTTYPEFilter<$PrismaModel = never> = {
    equals?: $Enums.PAYMENTTYPE | EnumPAYMENTTYPEFieldRefInput<$PrismaModel>
    in?: $Enums.PAYMENTTYPE[]
    notIn?: $Enums.PAYMENTTYPE[]
    not?: NestedEnumPAYMENTTYPEFilter<$PrismaModel> | $Enums.PAYMENTTYPE
  }

  export type NestedEnumPaymentStatusNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.PaymentStatus[] | null
    notIn?: $Enums.PaymentStatus[] | null
    not?: NestedEnumPaymentStatusNullableFilter<$PrismaModel> | $Enums.PaymentStatus | null
  }

  export type NestedEnumPAYMENTTYPEWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PAYMENTTYPE | EnumPAYMENTTYPEFieldRefInput<$PrismaModel>
    in?: $Enums.PAYMENTTYPE[]
    notIn?: $Enums.PAYMENTTYPE[]
    not?: NestedEnumPAYMENTTYPEWithAggregatesFilter<$PrismaModel> | $Enums.PAYMENTTYPE
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPAYMENTTYPEFilter<$PrismaModel>
    _max?: NestedEnumPAYMENTTYPEFilter<$PrismaModel>
  }

  export type NestedEnumPaymentStatusNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.PaymentStatus[] | null
    notIn?: $Enums.PaymentStatus[] | null
    not?: NestedEnumPaymentStatusNullableWithAggregatesFilter<$PrismaModel> | $Enums.PaymentStatus | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumPaymentStatusNullableFilter<$PrismaModel>
    _max?: NestedEnumPaymentStatusNullableFilter<$PrismaModel>
  }

  export type AcademicDepartmentCreateWithoutDepartmentHeadInput = {
    id?: string
    title: string
    createdAt?: Date | string
    updatedAt?: Date | string
    academicFaculty: AcademicFacultyCreateNestedOneWithoutAcademicDepartmentsInput
    faculties?: FacultyCreateNestedOneWithoutAcademicDepartmentInput
    students?: StudentCreateNestedOneWithoutAcademicDepartmentInput
    staffMembers?: UsersCreateNestedManyWithoutStaffDepartmentsInput
    admitionExame?: AdmitionExameRegistrationCreateNestedManyWithoutDepartmentInput
    offeredCourses?: OfferedCourseCreateNestedManyWithoutAcademicDepartmentInput
  }

  export type AcademicDepartmentUncheckedCreateWithoutDepartmentHeadInput = {
    id?: string
    title: string
    academicFacultyId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    faculties?: FacultyUncheckedCreateNestedOneWithoutAcademicDepartmentInput
    students?: StudentUncheckedCreateNestedOneWithoutAcademicDepartmentInput
    staffMembers?: UsersUncheckedCreateNestedManyWithoutStaffDepartmentsInput
    admitionExame?: AdmitionExameRegistrationUncheckedCreateNestedManyWithoutDepartmentInput
    offeredCourses?: OfferedCourseUncheckedCreateNestedManyWithoutAcademicDepartmentInput
  }

  export type AcademicDepartmentCreateOrConnectWithoutDepartmentHeadInput = {
    where: AcademicDepartmentWhereUniqueInput
    create: XOR<AcademicDepartmentCreateWithoutDepartmentHeadInput, AcademicDepartmentUncheckedCreateWithoutDepartmentHeadInput>
  }

  export type AcademicDepartmentCreateWithoutStaffMembersInput = {
    id?: string
    title: string
    createdAt?: Date | string
    updatedAt?: Date | string
    academicFaculty: AcademicFacultyCreateNestedOneWithoutAcademicDepartmentsInput
    faculties?: FacultyCreateNestedOneWithoutAcademicDepartmentInput
    students?: StudentCreateNestedOneWithoutAcademicDepartmentInput
    departmentHead?: UsersCreateNestedOneWithoutAcademicDepartmentInput
    admitionExame?: AdmitionExameRegistrationCreateNestedManyWithoutDepartmentInput
    offeredCourses?: OfferedCourseCreateNestedManyWithoutAcademicDepartmentInput
  }

  export type AcademicDepartmentUncheckedCreateWithoutStaffMembersInput = {
    id?: string
    title: string
    academicFacultyId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    departmentHeadId?: string | null
    faculties?: FacultyUncheckedCreateNestedOneWithoutAcademicDepartmentInput
    students?: StudentUncheckedCreateNestedOneWithoutAcademicDepartmentInput
    admitionExame?: AdmitionExameRegistrationUncheckedCreateNestedManyWithoutDepartmentInput
    offeredCourses?: OfferedCourseUncheckedCreateNestedManyWithoutAcademicDepartmentInput
  }

  export type AcademicDepartmentCreateOrConnectWithoutStaffMembersInput = {
    where: AcademicDepartmentWhereUniqueInput
    create: XOR<AcademicDepartmentCreateWithoutStaffMembersInput, AcademicDepartmentUncheckedCreateWithoutStaffMembersInput>
  }

  export type AcademicDepartmentUpsertWithoutDepartmentHeadInput = {
    update: XOR<AcademicDepartmentUpdateWithoutDepartmentHeadInput, AcademicDepartmentUncheckedUpdateWithoutDepartmentHeadInput>
    create: XOR<AcademicDepartmentCreateWithoutDepartmentHeadInput, AcademicDepartmentUncheckedCreateWithoutDepartmentHeadInput>
    where?: AcademicDepartmentWhereInput
  }

  export type AcademicDepartmentUpdateToOneWithWhereWithoutDepartmentHeadInput = {
    where?: AcademicDepartmentWhereInput
    data: XOR<AcademicDepartmentUpdateWithoutDepartmentHeadInput, AcademicDepartmentUncheckedUpdateWithoutDepartmentHeadInput>
  }

  export type AcademicDepartmentUpdateWithoutDepartmentHeadInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    academicFaculty?: AcademicFacultyUpdateOneRequiredWithoutAcademicDepartmentsNestedInput
    faculties?: FacultyUpdateOneWithoutAcademicDepartmentNestedInput
    students?: StudentUpdateOneWithoutAcademicDepartmentNestedInput
    staffMembers?: UsersUpdateManyWithoutStaffDepartmentsNestedInput
    admitionExame?: AdmitionExameRegistrationUpdateManyWithoutDepartmentNestedInput
    offeredCourses?: OfferedCourseUpdateManyWithoutAcademicDepartmentNestedInput
  }

  export type AcademicDepartmentUncheckedUpdateWithoutDepartmentHeadInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    academicFacultyId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    faculties?: FacultyUncheckedUpdateOneWithoutAcademicDepartmentNestedInput
    students?: StudentUncheckedUpdateOneWithoutAcademicDepartmentNestedInput
    staffMembers?: UsersUncheckedUpdateManyWithoutStaffDepartmentsNestedInput
    admitionExame?: AdmitionExameRegistrationUncheckedUpdateManyWithoutDepartmentNestedInput
    offeredCourses?: OfferedCourseUncheckedUpdateManyWithoutAcademicDepartmentNestedInput
  }

  export type AcademicDepartmentUpsertWithWhereUniqueWithoutStaffMembersInput = {
    where: AcademicDepartmentWhereUniqueInput
    update: XOR<AcademicDepartmentUpdateWithoutStaffMembersInput, AcademicDepartmentUncheckedUpdateWithoutStaffMembersInput>
    create: XOR<AcademicDepartmentCreateWithoutStaffMembersInput, AcademicDepartmentUncheckedCreateWithoutStaffMembersInput>
  }

  export type AcademicDepartmentUpdateWithWhereUniqueWithoutStaffMembersInput = {
    where: AcademicDepartmentWhereUniqueInput
    data: XOR<AcademicDepartmentUpdateWithoutStaffMembersInput, AcademicDepartmentUncheckedUpdateWithoutStaffMembersInput>
  }

  export type AcademicDepartmentUpdateManyWithWhereWithoutStaffMembersInput = {
    where: AcademicDepartmentScalarWhereInput
    data: XOR<AcademicDepartmentUpdateManyMutationInput, AcademicDepartmentUncheckedUpdateManyWithoutStaffMembersInput>
  }

  export type AcademicDepartmentScalarWhereInput = {
    AND?: AcademicDepartmentScalarWhereInput | AcademicDepartmentScalarWhereInput[]
    OR?: AcademicDepartmentScalarWhereInput[]
    NOT?: AcademicDepartmentScalarWhereInput | AcademicDepartmentScalarWhereInput[]
    id?: StringFilter<"AcademicDepartment"> | string
    title?: StringFilter<"AcademicDepartment"> | string
    academicFacultyId?: StringFilter<"AcademicDepartment"> | string
    createdAt?: DateTimeFilter<"AcademicDepartment"> | Date | string
    updatedAt?: DateTimeFilter<"AcademicDepartment"> | Date | string
    departmentHeadId?: StringNullableFilter<"AcademicDepartment"> | string | null
  }

  export type SemesterRegistrationCreateWithoutAcademicSemesterInput = {
    id?: string
    startDate: Date | string
    endDate: Date | string
    status?: $Enums.SemesterRegistrationStatus | null
    paymentRecipt: string
    totalPayment?: number
    createdAt?: Date | string
    updateAt?: Date | string
    offeredCourses?: OfferedCourseCreateNestedManyWithoutSemesterRegistrationInput
    offeredCourseSections?: OfferedCourseSectionCreateNestedManyWithoutSemesterRegistrationInput
    offeredCourseClassSchedules?: OfferedCourseClassScheduleCreateNestedManyWithoutSemesterRegistrationInput
    studentSemesterRegistrations?: StudentSemesterRegistrationCreateNestedManyWithoutSemesterRegistrationInput
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseCreateNestedManyWithoutSemesterRegistrationInput
  }

  export type SemesterRegistrationUncheckedCreateWithoutAcademicSemesterInput = {
    id?: string
    startDate: Date | string
    endDate: Date | string
    status?: $Enums.SemesterRegistrationStatus | null
    paymentRecipt: string
    totalPayment?: number
    createdAt?: Date | string
    updateAt?: Date | string
    offeredCourses?: OfferedCourseUncheckedCreateNestedManyWithoutSemesterRegistrationInput
    offeredCourseSections?: OfferedCourseSectionUncheckedCreateNestedManyWithoutSemesterRegistrationInput
    offeredCourseClassSchedules?: OfferedCourseClassScheduleUncheckedCreateNestedManyWithoutSemesterRegistrationInput
    studentSemesterRegistrations?: StudentSemesterRegistrationUncheckedCreateNestedManyWithoutSemesterRegistrationInput
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseUncheckedCreateNestedManyWithoutSemesterRegistrationInput
  }

  export type SemesterRegistrationCreateOrConnectWithoutAcademicSemesterInput = {
    where: SemesterRegistrationWhereUniqueInput
    create: XOR<SemesterRegistrationCreateWithoutAcademicSemesterInput, SemesterRegistrationUncheckedCreateWithoutAcademicSemesterInput>
  }

  export type SemesterRegistrationCreateManyAcademicSemesterInputEnvelope = {
    data: SemesterRegistrationCreateManyAcademicSemesterInput | SemesterRegistrationCreateManyAcademicSemesterInput[]
    skipDuplicates?: boolean
  }

  export type StudentCreateWithoutAcademicSemesterInput = {
    id?: string
    studentId: string
    firstName: string
    middleName?: string | null
    lastName: string
    profileImage?: string | null
    email?: string | null
    contactNo?: string | null
    gender: string
    isWoker?: boolean
    shift?: $Enums.Shift
    password: string
    gradeDeclarationFile: string
    biFile: string
    presentAddress: string
    permanentAddress?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    admissionRegistration?: AdmitionExameRegistrationCreateNestedOneWithoutStudentInput
    academicDepartment: AcademicDepartmentCreateNestedOneWithoutStudentsInput
    academicFaculty: AcademicFacultyCreateNestedOneWithoutStudentsInput
    studentSemesterRegistrations?: StudentSemesterRegistrationCreateNestedManyWithoutStudentInput
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseCreateNestedManyWithoutStudentInput
    studentEnrolledCourses?: StudentEnrolledCourseCreateNestedManyWithoutStudentInput
    studentEnrolledCourseMarks?: StudentEnrolledCourseMarkCreateNestedManyWithoutStudentInput
    studentSemesterPayments?: StudentSemesterPaymentCreateNestedManyWithoutStudentInput
    studentAcademicInfos?: StudentAcademicInfoCreateNestedManyWithoutStudentInput
  }

  export type StudentUncheckedCreateWithoutAcademicSemesterInput = {
    id?: string
    studentId: string
    firstName: string
    middleName?: string | null
    lastName: string
    profileImage?: string | null
    email?: string | null
    contactNo?: string | null
    gender: string
    isWoker?: boolean
    shift?: $Enums.Shift
    password: string
    gradeDeclarationFile: string
    biFile: string
    presentAddress: string
    permanentAddress?: string | null
    academicFacultyId: string
    academicDepartmentId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    admissionRegistrationId?: string | null
    studentSemesterRegistrations?: StudentSemesterRegistrationUncheckedCreateNestedManyWithoutStudentInput
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseUncheckedCreateNestedManyWithoutStudentInput
    studentEnrolledCourses?: StudentEnrolledCourseUncheckedCreateNestedManyWithoutStudentInput
    studentEnrolledCourseMarks?: StudentEnrolledCourseMarkUncheckedCreateNestedManyWithoutStudentInput
    studentSemesterPayments?: StudentSemesterPaymentUncheckedCreateNestedManyWithoutStudentInput
    studentAcademicInfos?: StudentAcademicInfoUncheckedCreateNestedManyWithoutStudentInput
  }

  export type StudentCreateOrConnectWithoutAcademicSemesterInput = {
    where: StudentWhereUniqueInput
    create: XOR<StudentCreateWithoutAcademicSemesterInput, StudentUncheckedCreateWithoutAcademicSemesterInput>
  }

  export type StudentEnrolledCourseCreateWithoutAcademicSemesterInput = {
    id?: string
    grade?: string | null
    point?: number | null
    totalMarks?: number | null
    status?: $Enums.StudentEnrolledCourseStatus | null
    createdAt?: Date | string
    updatedAt?: Date | string
    student: StudentCreateNestedOneWithoutStudentEnrolledCoursesInput
    course: CourseCreateNestedOneWithoutStudentEnrolledCoursesInput
    studentEnrolledCourseMarks?: StudentEnrolledCourseMarkCreateNestedManyWithoutStudentEnrolledCourseInput
  }

  export type StudentEnrolledCourseUncheckedCreateWithoutAcademicSemesterInput = {
    id?: string
    grade?: string | null
    point?: number | null
    totalMarks?: number | null
    status?: $Enums.StudentEnrolledCourseStatus | null
    createdAt?: Date | string
    updatedAt?: Date | string
    studentId: string
    courseId: string
    studentEnrolledCourseMarks?: StudentEnrolledCourseMarkUncheckedCreateNestedManyWithoutStudentEnrolledCourseInput
  }

  export type StudentEnrolledCourseCreateOrConnectWithoutAcademicSemesterInput = {
    where: StudentEnrolledCourseWhereUniqueInput
    create: XOR<StudentEnrolledCourseCreateWithoutAcademicSemesterInput, StudentEnrolledCourseUncheckedCreateWithoutAcademicSemesterInput>
  }

  export type StudentEnrolledCourseCreateManyAcademicSemesterInputEnvelope = {
    data: StudentEnrolledCourseCreateManyAcademicSemesterInput | StudentEnrolledCourseCreateManyAcademicSemesterInput[]
    skipDuplicates?: boolean
  }

  export type StudentEnrolledCourseMarkCreateWithoutAcademicSemesterInput = {
    id?: string
    examType?: $Enums.ExamType | null
    createdAt?: Date | string
    updatedAt?: Date | string
    exam1?: number
    exam2?: number
    exam3?: number
    exam4?: number
    exam5?: number
    exam6?: number
    finalExam?: number
    totalMarks?: number
    grade?: number
    student: StudentCreateNestedOneWithoutStudentEnrolledCourseMarksInput
    studentEnrolledCourse: StudentEnrolledCourseCreateNestedOneWithoutStudentEnrolledCourseMarksInput
  }

  export type StudentEnrolledCourseMarkUncheckedCreateWithoutAcademicSemesterInput = {
    id?: string
    examType?: $Enums.ExamType | null
    createdAt?: Date | string
    updatedAt?: Date | string
    studentId: string
    studentEnrolledCourseId: string
    exam1?: number
    exam2?: number
    exam3?: number
    exam4?: number
    exam5?: number
    exam6?: number
    finalExam?: number
    totalMarks?: number
    grade?: number
  }

  export type StudentEnrolledCourseMarkCreateOrConnectWithoutAcademicSemesterInput = {
    where: StudentEnrolledCourseMarkWhereUniqueInput
    create: XOR<StudentEnrolledCourseMarkCreateWithoutAcademicSemesterInput, StudentEnrolledCourseMarkUncheckedCreateWithoutAcademicSemesterInput>
  }

  export type StudentEnrolledCourseMarkCreateManyAcademicSemesterInputEnvelope = {
    data: StudentEnrolledCourseMarkCreateManyAcademicSemesterInput | StudentEnrolledCourseMarkCreateManyAcademicSemesterInput[]
    skipDuplicates?: boolean
  }

  export type StudentSemesterPaymentCreateWithoutAcademicSemesterInput = {
    id?: string
    paymentRecipt?: string | null
    totalPayment?: number
    baseAmount: number
    lateFee?: number
    aprovedPayment?: boolean
    paymentType?: $Enums.PAYMENTTYPE
    paymentStatus?: $Enums.PaymentStatus | null
    paymentMonth: number
    paymentYear: number
    createdAt?: Date | string
    updatedAt?: Date | string
    student: StudentCreateNestedOneWithoutStudentSemesterPaymentsInput
  }

  export type StudentSemesterPaymentUncheckedCreateWithoutAcademicSemesterInput = {
    id?: string
    paymentRecipt?: string | null
    totalPayment?: number
    baseAmount: number
    lateFee?: number
    aprovedPayment?: boolean
    paymentType?: $Enums.PAYMENTTYPE
    paymentStatus?: $Enums.PaymentStatus | null
    paymentMonth: number
    paymentYear: number
    createdAt?: Date | string
    updatedAt?: Date | string
    studentId: string
  }

  export type StudentSemesterPaymentCreateOrConnectWithoutAcademicSemesterInput = {
    where: StudentSemesterPaymentWhereUniqueInput
    create: XOR<StudentSemesterPaymentCreateWithoutAcademicSemesterInput, StudentSemesterPaymentUncheckedCreateWithoutAcademicSemesterInput>
  }

  export type StudentSemesterPaymentCreateManyAcademicSemesterInputEnvelope = {
    data: StudentSemesterPaymentCreateManyAcademicSemesterInput | StudentSemesterPaymentCreateManyAcademicSemesterInput[]
    skipDuplicates?: boolean
  }

  export type SemesterRegistrationUpsertWithWhereUniqueWithoutAcademicSemesterInput = {
    where: SemesterRegistrationWhereUniqueInput
    update: XOR<SemesterRegistrationUpdateWithoutAcademicSemesterInput, SemesterRegistrationUncheckedUpdateWithoutAcademicSemesterInput>
    create: XOR<SemesterRegistrationCreateWithoutAcademicSemesterInput, SemesterRegistrationUncheckedCreateWithoutAcademicSemesterInput>
  }

  export type SemesterRegistrationUpdateWithWhereUniqueWithoutAcademicSemesterInput = {
    where: SemesterRegistrationWhereUniqueInput
    data: XOR<SemesterRegistrationUpdateWithoutAcademicSemesterInput, SemesterRegistrationUncheckedUpdateWithoutAcademicSemesterInput>
  }

  export type SemesterRegistrationUpdateManyWithWhereWithoutAcademicSemesterInput = {
    where: SemesterRegistrationScalarWhereInput
    data: XOR<SemesterRegistrationUpdateManyMutationInput, SemesterRegistrationUncheckedUpdateManyWithoutAcademicSemesterInput>
  }

  export type SemesterRegistrationScalarWhereInput = {
    AND?: SemesterRegistrationScalarWhereInput | SemesterRegistrationScalarWhereInput[]
    OR?: SemesterRegistrationScalarWhereInput[]
    NOT?: SemesterRegistrationScalarWhereInput | SemesterRegistrationScalarWhereInput[]
    id?: StringFilter<"SemesterRegistration"> | string
    startDate?: DateTimeFilter<"SemesterRegistration"> | Date | string
    endDate?: DateTimeFilter<"SemesterRegistration"> | Date | string
    status?: EnumSemesterRegistrationStatusNullableFilter<"SemesterRegistration"> | $Enums.SemesterRegistrationStatus | null
    paymentRecipt?: StringFilter<"SemesterRegistration"> | string
    totalPayment?: IntFilter<"SemesterRegistration"> | number
    createdAt?: DateTimeFilter<"SemesterRegistration"> | Date | string
    updateAt?: DateTimeFilter<"SemesterRegistration"> | Date | string
    academicSemesterId?: StringFilter<"SemesterRegistration"> | string
  }

  export type StudentUpsertWithoutAcademicSemesterInput = {
    update: XOR<StudentUpdateWithoutAcademicSemesterInput, StudentUncheckedUpdateWithoutAcademicSemesterInput>
    create: XOR<StudentCreateWithoutAcademicSemesterInput, StudentUncheckedCreateWithoutAcademicSemesterInput>
    where?: StudentWhereInput
  }

  export type StudentUpdateToOneWithWhereWithoutAcademicSemesterInput = {
    where?: StudentWhereInput
    data: XOR<StudentUpdateWithoutAcademicSemesterInput, StudentUncheckedUpdateWithoutAcademicSemesterInput>
  }

  export type StudentUpdateWithoutAcademicSemesterInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    contactNo?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: StringFieldUpdateOperationsInput | string
    isWoker?: BoolFieldUpdateOperationsInput | boolean
    shift?: EnumShiftFieldUpdateOperationsInput | $Enums.Shift
    password?: StringFieldUpdateOperationsInput | string
    gradeDeclarationFile?: StringFieldUpdateOperationsInput | string
    biFile?: StringFieldUpdateOperationsInput | string
    presentAddress?: StringFieldUpdateOperationsInput | string
    permanentAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    admissionRegistration?: AdmitionExameRegistrationUpdateOneWithoutStudentNestedInput
    academicDepartment?: AcademicDepartmentUpdateOneRequiredWithoutStudentsNestedInput
    academicFaculty?: AcademicFacultyUpdateOneRequiredWithoutStudentsNestedInput
    studentSemesterRegistrations?: StudentSemesterRegistrationUpdateManyWithoutStudentNestedInput
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseUpdateManyWithoutStudentNestedInput
    studentEnrolledCourses?: StudentEnrolledCourseUpdateManyWithoutStudentNestedInput
    studentEnrolledCourseMarks?: StudentEnrolledCourseMarkUpdateManyWithoutStudentNestedInput
    studentSemesterPayments?: StudentSemesterPaymentUpdateManyWithoutStudentNestedInput
    studentAcademicInfos?: StudentAcademicInfoUpdateManyWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateWithoutAcademicSemesterInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    contactNo?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: StringFieldUpdateOperationsInput | string
    isWoker?: BoolFieldUpdateOperationsInput | boolean
    shift?: EnumShiftFieldUpdateOperationsInput | $Enums.Shift
    password?: StringFieldUpdateOperationsInput | string
    gradeDeclarationFile?: StringFieldUpdateOperationsInput | string
    biFile?: StringFieldUpdateOperationsInput | string
    presentAddress?: StringFieldUpdateOperationsInput | string
    permanentAddress?: NullableStringFieldUpdateOperationsInput | string | null
    academicFacultyId?: StringFieldUpdateOperationsInput | string
    academicDepartmentId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    admissionRegistrationId?: NullableStringFieldUpdateOperationsInput | string | null
    studentSemesterRegistrations?: StudentSemesterRegistrationUncheckedUpdateManyWithoutStudentNestedInput
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseUncheckedUpdateManyWithoutStudentNestedInput
    studentEnrolledCourses?: StudentEnrolledCourseUncheckedUpdateManyWithoutStudentNestedInput
    studentEnrolledCourseMarks?: StudentEnrolledCourseMarkUncheckedUpdateManyWithoutStudentNestedInput
    studentSemesterPayments?: StudentSemesterPaymentUncheckedUpdateManyWithoutStudentNestedInput
    studentAcademicInfos?: StudentAcademicInfoUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type StudentEnrolledCourseUpsertWithWhereUniqueWithoutAcademicSemesterInput = {
    where: StudentEnrolledCourseWhereUniqueInput
    update: XOR<StudentEnrolledCourseUpdateWithoutAcademicSemesterInput, StudentEnrolledCourseUncheckedUpdateWithoutAcademicSemesterInput>
    create: XOR<StudentEnrolledCourseCreateWithoutAcademicSemesterInput, StudentEnrolledCourseUncheckedCreateWithoutAcademicSemesterInput>
  }

  export type StudentEnrolledCourseUpdateWithWhereUniqueWithoutAcademicSemesterInput = {
    where: StudentEnrolledCourseWhereUniqueInput
    data: XOR<StudentEnrolledCourseUpdateWithoutAcademicSemesterInput, StudentEnrolledCourseUncheckedUpdateWithoutAcademicSemesterInput>
  }

  export type StudentEnrolledCourseUpdateManyWithWhereWithoutAcademicSemesterInput = {
    where: StudentEnrolledCourseScalarWhereInput
    data: XOR<StudentEnrolledCourseUpdateManyMutationInput, StudentEnrolledCourseUncheckedUpdateManyWithoutAcademicSemesterInput>
  }

  export type StudentEnrolledCourseScalarWhereInput = {
    AND?: StudentEnrolledCourseScalarWhereInput | StudentEnrolledCourseScalarWhereInput[]
    OR?: StudentEnrolledCourseScalarWhereInput[]
    NOT?: StudentEnrolledCourseScalarWhereInput | StudentEnrolledCourseScalarWhereInput[]
    id?: StringFilter<"StudentEnrolledCourse"> | string
    grade?: StringNullableFilter<"StudentEnrolledCourse"> | string | null
    point?: FloatNullableFilter<"StudentEnrolledCourse"> | number | null
    totalMarks?: IntNullableFilter<"StudentEnrolledCourse"> | number | null
    status?: EnumStudentEnrolledCourseStatusNullableFilter<"StudentEnrolledCourse"> | $Enums.StudentEnrolledCourseStatus | null
    createdAt?: DateTimeFilter<"StudentEnrolledCourse"> | Date | string
    updatedAt?: DateTimeFilter<"StudentEnrolledCourse"> | Date | string
    studentId?: StringFilter<"StudentEnrolledCourse"> | string
    academicSemesterId?: StringFilter<"StudentEnrolledCourse"> | string
    courseId?: StringFilter<"StudentEnrolledCourse"> | string
  }

  export type StudentEnrolledCourseMarkUpsertWithWhereUniqueWithoutAcademicSemesterInput = {
    where: StudentEnrolledCourseMarkWhereUniqueInput
    update: XOR<StudentEnrolledCourseMarkUpdateWithoutAcademicSemesterInput, StudentEnrolledCourseMarkUncheckedUpdateWithoutAcademicSemesterInput>
    create: XOR<StudentEnrolledCourseMarkCreateWithoutAcademicSemesterInput, StudentEnrolledCourseMarkUncheckedCreateWithoutAcademicSemesterInput>
  }

  export type StudentEnrolledCourseMarkUpdateWithWhereUniqueWithoutAcademicSemesterInput = {
    where: StudentEnrolledCourseMarkWhereUniqueInput
    data: XOR<StudentEnrolledCourseMarkUpdateWithoutAcademicSemesterInput, StudentEnrolledCourseMarkUncheckedUpdateWithoutAcademicSemesterInput>
  }

  export type StudentEnrolledCourseMarkUpdateManyWithWhereWithoutAcademicSemesterInput = {
    where: StudentEnrolledCourseMarkScalarWhereInput
    data: XOR<StudentEnrolledCourseMarkUpdateManyMutationInput, StudentEnrolledCourseMarkUncheckedUpdateManyWithoutAcademicSemesterInput>
  }

  export type StudentEnrolledCourseMarkScalarWhereInput = {
    AND?: StudentEnrolledCourseMarkScalarWhereInput | StudentEnrolledCourseMarkScalarWhereInput[]
    OR?: StudentEnrolledCourseMarkScalarWhereInput[]
    NOT?: StudentEnrolledCourseMarkScalarWhereInput | StudentEnrolledCourseMarkScalarWhereInput[]
    id?: StringFilter<"StudentEnrolledCourseMark"> | string
    examType?: EnumExamTypeNullableFilter<"StudentEnrolledCourseMark"> | $Enums.ExamType | null
    createdAt?: DateTimeFilter<"StudentEnrolledCourseMark"> | Date | string
    updatedAt?: DateTimeFilter<"StudentEnrolledCourseMark"> | Date | string
    studentId?: StringFilter<"StudentEnrolledCourseMark"> | string
    studentEnrolledCourseId?: StringFilter<"StudentEnrolledCourseMark"> | string
    academicSemesterId?: StringFilter<"StudentEnrolledCourseMark"> | string
    exam1?: FloatFilter<"StudentEnrolledCourseMark"> | number
    exam2?: FloatFilter<"StudentEnrolledCourseMark"> | number
    exam3?: FloatFilter<"StudentEnrolledCourseMark"> | number
    exam4?: FloatFilter<"StudentEnrolledCourseMark"> | number
    exam5?: FloatFilter<"StudentEnrolledCourseMark"> | number
    exam6?: FloatFilter<"StudentEnrolledCourseMark"> | number
    finalExam?: FloatFilter<"StudentEnrolledCourseMark"> | number
    totalMarks?: FloatFilter<"StudentEnrolledCourseMark"> | number
    grade?: FloatFilter<"StudentEnrolledCourseMark"> | number
  }

  export type StudentSemesterPaymentUpsertWithWhereUniqueWithoutAcademicSemesterInput = {
    where: StudentSemesterPaymentWhereUniqueInput
    update: XOR<StudentSemesterPaymentUpdateWithoutAcademicSemesterInput, StudentSemesterPaymentUncheckedUpdateWithoutAcademicSemesterInput>
    create: XOR<StudentSemesterPaymentCreateWithoutAcademicSemesterInput, StudentSemesterPaymentUncheckedCreateWithoutAcademicSemesterInput>
  }

  export type StudentSemesterPaymentUpdateWithWhereUniqueWithoutAcademicSemesterInput = {
    where: StudentSemesterPaymentWhereUniqueInput
    data: XOR<StudentSemesterPaymentUpdateWithoutAcademicSemesterInput, StudentSemesterPaymentUncheckedUpdateWithoutAcademicSemesterInput>
  }

  export type StudentSemesterPaymentUpdateManyWithWhereWithoutAcademicSemesterInput = {
    where: StudentSemesterPaymentScalarWhereInput
    data: XOR<StudentSemesterPaymentUpdateManyMutationInput, StudentSemesterPaymentUncheckedUpdateManyWithoutAcademicSemesterInput>
  }

  export type StudentSemesterPaymentScalarWhereInput = {
    AND?: StudentSemesterPaymentScalarWhereInput | StudentSemesterPaymentScalarWhereInput[]
    OR?: StudentSemesterPaymentScalarWhereInput[]
    NOT?: StudentSemesterPaymentScalarWhereInput | StudentSemesterPaymentScalarWhereInput[]
    id?: StringFilter<"StudentSemesterPayment"> | string
    paymentRecipt?: StringNullableFilter<"StudentSemesterPayment"> | string | null
    totalPayment?: IntFilter<"StudentSemesterPayment"> | number
    baseAmount?: IntFilter<"StudentSemesterPayment"> | number
    lateFee?: IntFilter<"StudentSemesterPayment"> | number
    aprovedPayment?: BoolFilter<"StudentSemesterPayment"> | boolean
    paymentType?: EnumPAYMENTTYPEFilter<"StudentSemesterPayment"> | $Enums.PAYMENTTYPE
    paymentStatus?: EnumPaymentStatusNullableFilter<"StudentSemesterPayment"> | $Enums.PaymentStatus | null
    paymentMonth?: IntFilter<"StudentSemesterPayment"> | number
    paymentYear?: IntFilter<"StudentSemesterPayment"> | number
    createdAt?: DateTimeFilter<"StudentSemesterPayment"> | Date | string
    updatedAt?: DateTimeFilter<"StudentSemesterPayment"> | Date | string
    studentId?: StringFilter<"StudentSemesterPayment"> | string
    academicSemesterId?: StringFilter<"StudentSemesterPayment"> | string
  }

  export type AcademicDepartmentCreateWithoutAcademicFacultyInput = {
    id?: string
    title: string
    createdAt?: Date | string
    updatedAt?: Date | string
    faculties?: FacultyCreateNestedOneWithoutAcademicDepartmentInput
    students?: StudentCreateNestedOneWithoutAcademicDepartmentInput
    departmentHead?: UsersCreateNestedOneWithoutAcademicDepartmentInput
    staffMembers?: UsersCreateNestedManyWithoutStaffDepartmentsInput
    admitionExame?: AdmitionExameRegistrationCreateNestedManyWithoutDepartmentInput
    offeredCourses?: OfferedCourseCreateNestedManyWithoutAcademicDepartmentInput
  }

  export type AcademicDepartmentUncheckedCreateWithoutAcademicFacultyInput = {
    id?: string
    title: string
    createdAt?: Date | string
    updatedAt?: Date | string
    departmentHeadId?: string | null
    faculties?: FacultyUncheckedCreateNestedOneWithoutAcademicDepartmentInput
    students?: StudentUncheckedCreateNestedOneWithoutAcademicDepartmentInput
    staffMembers?: UsersUncheckedCreateNestedManyWithoutStaffDepartmentsInput
    admitionExame?: AdmitionExameRegistrationUncheckedCreateNestedManyWithoutDepartmentInput
    offeredCourses?: OfferedCourseUncheckedCreateNestedManyWithoutAcademicDepartmentInput
  }

  export type AcademicDepartmentCreateOrConnectWithoutAcademicFacultyInput = {
    where: AcademicDepartmentWhereUniqueInput
    create: XOR<AcademicDepartmentCreateWithoutAcademicFacultyInput, AcademicDepartmentUncheckedCreateWithoutAcademicFacultyInput>
  }

  export type FacultyCreateWithoutAcademicFacultyInput = {
    id?: string
    facultyId: string
    firstName: string
    middleName?: string | null
    lastName: string
    profileImage?: string | null
    email?: string | null
    contactNo?: string | null
    gender: string
    designation: string
    password: string
    createdAt?: Date | string
    updatedAt?: Date | string
    courses?: CourseFacultyCreateNestedManyWithoutFacultyInput
    academicDepartment: AcademicDepartmentCreateNestedOneWithoutFacultiesInput
    offeredCourseClassSchedules?: OfferedCourseClassScheduleCreateNestedManyWithoutFacultyInput
  }

  export type FacultyUncheckedCreateWithoutAcademicFacultyInput = {
    id?: string
    facultyId: string
    firstName: string
    middleName?: string | null
    lastName: string
    profileImage?: string | null
    email?: string | null
    contactNo?: string | null
    gender: string
    designation: string
    password: string
    academicDepartmentId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    courses?: CourseFacultyUncheckedCreateNestedManyWithoutFacultyInput
    offeredCourseClassSchedules?: OfferedCourseClassScheduleUncheckedCreateNestedManyWithoutFacultyInput
  }

  export type FacultyCreateOrConnectWithoutAcademicFacultyInput = {
    where: FacultyWhereUniqueInput
    create: XOR<FacultyCreateWithoutAcademicFacultyInput, FacultyUncheckedCreateWithoutAcademicFacultyInput>
  }

  export type StudentCreateWithoutAcademicFacultyInput = {
    id?: string
    studentId: string
    firstName: string
    middleName?: string | null
    lastName: string
    profileImage?: string | null
    email?: string | null
    contactNo?: string | null
    gender: string
    isWoker?: boolean
    shift?: $Enums.Shift
    password: string
    gradeDeclarationFile: string
    biFile: string
    presentAddress: string
    permanentAddress?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    admissionRegistration?: AdmitionExameRegistrationCreateNestedOneWithoutStudentInput
    academicDepartment: AcademicDepartmentCreateNestedOneWithoutStudentsInput
    academicSemester: AcademicSemesterCreateNestedOneWithoutStudentsInput
    studentSemesterRegistrations?: StudentSemesterRegistrationCreateNestedManyWithoutStudentInput
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseCreateNestedManyWithoutStudentInput
    studentEnrolledCourses?: StudentEnrolledCourseCreateNestedManyWithoutStudentInput
    studentEnrolledCourseMarks?: StudentEnrolledCourseMarkCreateNestedManyWithoutStudentInput
    studentSemesterPayments?: StudentSemesterPaymentCreateNestedManyWithoutStudentInput
    studentAcademicInfos?: StudentAcademicInfoCreateNestedManyWithoutStudentInput
  }

  export type StudentUncheckedCreateWithoutAcademicFacultyInput = {
    id?: string
    studentId: string
    firstName: string
    middleName?: string | null
    lastName: string
    profileImage?: string | null
    email?: string | null
    contactNo?: string | null
    gender: string
    isWoker?: boolean
    shift?: $Enums.Shift
    password: string
    gradeDeclarationFile: string
    biFile: string
    presentAddress: string
    permanentAddress?: string | null
    academicSemesterId: string
    academicDepartmentId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    admissionRegistrationId?: string | null
    studentSemesterRegistrations?: StudentSemesterRegistrationUncheckedCreateNestedManyWithoutStudentInput
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseUncheckedCreateNestedManyWithoutStudentInput
    studentEnrolledCourses?: StudentEnrolledCourseUncheckedCreateNestedManyWithoutStudentInput
    studentEnrolledCourseMarks?: StudentEnrolledCourseMarkUncheckedCreateNestedManyWithoutStudentInput
    studentSemesterPayments?: StudentSemesterPaymentUncheckedCreateNestedManyWithoutStudentInput
    studentAcademicInfos?: StudentAcademicInfoUncheckedCreateNestedManyWithoutStudentInput
  }

  export type StudentCreateOrConnectWithoutAcademicFacultyInput = {
    where: StudentWhereUniqueInput
    create: XOR<StudentCreateWithoutAcademicFacultyInput, StudentUncheckedCreateWithoutAcademicFacultyInput>
  }

  export type AcademicDepartmentUpsertWithoutAcademicFacultyInput = {
    update: XOR<AcademicDepartmentUpdateWithoutAcademicFacultyInput, AcademicDepartmentUncheckedUpdateWithoutAcademicFacultyInput>
    create: XOR<AcademicDepartmentCreateWithoutAcademicFacultyInput, AcademicDepartmentUncheckedCreateWithoutAcademicFacultyInput>
    where?: AcademicDepartmentWhereInput
  }

  export type AcademicDepartmentUpdateToOneWithWhereWithoutAcademicFacultyInput = {
    where?: AcademicDepartmentWhereInput
    data: XOR<AcademicDepartmentUpdateWithoutAcademicFacultyInput, AcademicDepartmentUncheckedUpdateWithoutAcademicFacultyInput>
  }

  export type AcademicDepartmentUpdateWithoutAcademicFacultyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    faculties?: FacultyUpdateOneWithoutAcademicDepartmentNestedInput
    students?: StudentUpdateOneWithoutAcademicDepartmentNestedInput
    departmentHead?: UsersUpdateOneWithoutAcademicDepartmentNestedInput
    staffMembers?: UsersUpdateManyWithoutStaffDepartmentsNestedInput
    admitionExame?: AdmitionExameRegistrationUpdateManyWithoutDepartmentNestedInput
    offeredCourses?: OfferedCourseUpdateManyWithoutAcademicDepartmentNestedInput
  }

  export type AcademicDepartmentUncheckedUpdateWithoutAcademicFacultyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    departmentHeadId?: NullableStringFieldUpdateOperationsInput | string | null
    faculties?: FacultyUncheckedUpdateOneWithoutAcademicDepartmentNestedInput
    students?: StudentUncheckedUpdateOneWithoutAcademicDepartmentNestedInput
    staffMembers?: UsersUncheckedUpdateManyWithoutStaffDepartmentsNestedInput
    admitionExame?: AdmitionExameRegistrationUncheckedUpdateManyWithoutDepartmentNestedInput
    offeredCourses?: OfferedCourseUncheckedUpdateManyWithoutAcademicDepartmentNestedInput
  }

  export type FacultyUpsertWithoutAcademicFacultyInput = {
    update: XOR<FacultyUpdateWithoutAcademicFacultyInput, FacultyUncheckedUpdateWithoutAcademicFacultyInput>
    create: XOR<FacultyCreateWithoutAcademicFacultyInput, FacultyUncheckedCreateWithoutAcademicFacultyInput>
    where?: FacultyWhereInput
  }

  export type FacultyUpdateToOneWithWhereWithoutAcademicFacultyInput = {
    where?: FacultyWhereInput
    data: XOR<FacultyUpdateWithoutAcademicFacultyInput, FacultyUncheckedUpdateWithoutAcademicFacultyInput>
  }

  export type FacultyUpdateWithoutAcademicFacultyInput = {
    id?: StringFieldUpdateOperationsInput | string
    facultyId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    contactNo?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: StringFieldUpdateOperationsInput | string
    designation?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    courses?: CourseFacultyUpdateManyWithoutFacultyNestedInput
    academicDepartment?: AcademicDepartmentUpdateOneRequiredWithoutFacultiesNestedInput
    offeredCourseClassSchedules?: OfferedCourseClassScheduleUpdateManyWithoutFacultyNestedInput
  }

  export type FacultyUncheckedUpdateWithoutAcademicFacultyInput = {
    id?: StringFieldUpdateOperationsInput | string
    facultyId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    contactNo?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: StringFieldUpdateOperationsInput | string
    designation?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    academicDepartmentId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    courses?: CourseFacultyUncheckedUpdateManyWithoutFacultyNestedInput
    offeredCourseClassSchedules?: OfferedCourseClassScheduleUncheckedUpdateManyWithoutFacultyNestedInput
  }

  export type StudentUpsertWithoutAcademicFacultyInput = {
    update: XOR<StudentUpdateWithoutAcademicFacultyInput, StudentUncheckedUpdateWithoutAcademicFacultyInput>
    create: XOR<StudentCreateWithoutAcademicFacultyInput, StudentUncheckedCreateWithoutAcademicFacultyInput>
    where?: StudentWhereInput
  }

  export type StudentUpdateToOneWithWhereWithoutAcademicFacultyInput = {
    where?: StudentWhereInput
    data: XOR<StudentUpdateWithoutAcademicFacultyInput, StudentUncheckedUpdateWithoutAcademicFacultyInput>
  }

  export type StudentUpdateWithoutAcademicFacultyInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    contactNo?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: StringFieldUpdateOperationsInput | string
    isWoker?: BoolFieldUpdateOperationsInput | boolean
    shift?: EnumShiftFieldUpdateOperationsInput | $Enums.Shift
    password?: StringFieldUpdateOperationsInput | string
    gradeDeclarationFile?: StringFieldUpdateOperationsInput | string
    biFile?: StringFieldUpdateOperationsInput | string
    presentAddress?: StringFieldUpdateOperationsInput | string
    permanentAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    admissionRegistration?: AdmitionExameRegistrationUpdateOneWithoutStudentNestedInput
    academicDepartment?: AcademicDepartmentUpdateOneRequiredWithoutStudentsNestedInput
    academicSemester?: AcademicSemesterUpdateOneRequiredWithoutStudentsNestedInput
    studentSemesterRegistrations?: StudentSemesterRegistrationUpdateManyWithoutStudentNestedInput
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseUpdateManyWithoutStudentNestedInput
    studentEnrolledCourses?: StudentEnrolledCourseUpdateManyWithoutStudentNestedInput
    studentEnrolledCourseMarks?: StudentEnrolledCourseMarkUpdateManyWithoutStudentNestedInput
    studentSemesterPayments?: StudentSemesterPaymentUpdateManyWithoutStudentNestedInput
    studentAcademicInfos?: StudentAcademicInfoUpdateManyWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateWithoutAcademicFacultyInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    contactNo?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: StringFieldUpdateOperationsInput | string
    isWoker?: BoolFieldUpdateOperationsInput | boolean
    shift?: EnumShiftFieldUpdateOperationsInput | $Enums.Shift
    password?: StringFieldUpdateOperationsInput | string
    gradeDeclarationFile?: StringFieldUpdateOperationsInput | string
    biFile?: StringFieldUpdateOperationsInput | string
    presentAddress?: StringFieldUpdateOperationsInput | string
    permanentAddress?: NullableStringFieldUpdateOperationsInput | string | null
    academicSemesterId?: StringFieldUpdateOperationsInput | string
    academicDepartmentId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    admissionRegistrationId?: NullableStringFieldUpdateOperationsInput | string | null
    studentSemesterRegistrations?: StudentSemesterRegistrationUncheckedUpdateManyWithoutStudentNestedInput
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseUncheckedUpdateManyWithoutStudentNestedInput
    studentEnrolledCourses?: StudentEnrolledCourseUncheckedUpdateManyWithoutStudentNestedInput
    studentEnrolledCourseMarks?: StudentEnrolledCourseMarkUncheckedUpdateManyWithoutStudentNestedInput
    studentSemesterPayments?: StudentSemesterPaymentUncheckedUpdateManyWithoutStudentNestedInput
    studentAcademicInfos?: StudentAcademicInfoUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type AcademicFacultyCreateWithoutAcademicDepartmentsInput = {
    id?: string
    title: string
    createdAt?: Date | string
    updatedAt?: Date | string
    faculties?: FacultyCreateNestedOneWithoutAcademicFacultyInput
    students?: StudentCreateNestedOneWithoutAcademicFacultyInput
  }

  export type AcademicFacultyUncheckedCreateWithoutAcademicDepartmentsInput = {
    id?: string
    title: string
    createdAt?: Date | string
    updatedAt?: Date | string
    faculties?: FacultyUncheckedCreateNestedOneWithoutAcademicFacultyInput
    students?: StudentUncheckedCreateNestedOneWithoutAcademicFacultyInput
  }

  export type AcademicFacultyCreateOrConnectWithoutAcademicDepartmentsInput = {
    where: AcademicFacultyWhereUniqueInput
    create: XOR<AcademicFacultyCreateWithoutAcademicDepartmentsInput, AcademicFacultyUncheckedCreateWithoutAcademicDepartmentsInput>
  }

  export type FacultyCreateWithoutAcademicDepartmentInput = {
    id?: string
    facultyId: string
    firstName: string
    middleName?: string | null
    lastName: string
    profileImage?: string | null
    email?: string | null
    contactNo?: string | null
    gender: string
    designation: string
    password: string
    createdAt?: Date | string
    updatedAt?: Date | string
    courses?: CourseFacultyCreateNestedManyWithoutFacultyInput
    academicFaculty: AcademicFacultyCreateNestedOneWithoutFacultiesInput
    offeredCourseClassSchedules?: OfferedCourseClassScheduleCreateNestedManyWithoutFacultyInput
  }

  export type FacultyUncheckedCreateWithoutAcademicDepartmentInput = {
    id?: string
    facultyId: string
    firstName: string
    middleName?: string | null
    lastName: string
    profileImage?: string | null
    email?: string | null
    contactNo?: string | null
    gender: string
    designation: string
    password: string
    academicFacultyId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    courses?: CourseFacultyUncheckedCreateNestedManyWithoutFacultyInput
    offeredCourseClassSchedules?: OfferedCourseClassScheduleUncheckedCreateNestedManyWithoutFacultyInput
  }

  export type FacultyCreateOrConnectWithoutAcademicDepartmentInput = {
    where: FacultyWhereUniqueInput
    create: XOR<FacultyCreateWithoutAcademicDepartmentInput, FacultyUncheckedCreateWithoutAcademicDepartmentInput>
  }

  export type StudentCreateWithoutAcademicDepartmentInput = {
    id?: string
    studentId: string
    firstName: string
    middleName?: string | null
    lastName: string
    profileImage?: string | null
    email?: string | null
    contactNo?: string | null
    gender: string
    isWoker?: boolean
    shift?: $Enums.Shift
    password: string
    gradeDeclarationFile: string
    biFile: string
    presentAddress: string
    permanentAddress?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    admissionRegistration?: AdmitionExameRegistrationCreateNestedOneWithoutStudentInput
    academicFaculty: AcademicFacultyCreateNestedOneWithoutStudentsInput
    academicSemester: AcademicSemesterCreateNestedOneWithoutStudentsInput
    studentSemesterRegistrations?: StudentSemesterRegistrationCreateNestedManyWithoutStudentInput
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseCreateNestedManyWithoutStudentInput
    studentEnrolledCourses?: StudentEnrolledCourseCreateNestedManyWithoutStudentInput
    studentEnrolledCourseMarks?: StudentEnrolledCourseMarkCreateNestedManyWithoutStudentInput
    studentSemesterPayments?: StudentSemesterPaymentCreateNestedManyWithoutStudentInput
    studentAcademicInfos?: StudentAcademicInfoCreateNestedManyWithoutStudentInput
  }

  export type StudentUncheckedCreateWithoutAcademicDepartmentInput = {
    id?: string
    studentId: string
    firstName: string
    middleName?: string | null
    lastName: string
    profileImage?: string | null
    email?: string | null
    contactNo?: string | null
    gender: string
    isWoker?: boolean
    shift?: $Enums.Shift
    password: string
    gradeDeclarationFile: string
    biFile: string
    presentAddress: string
    permanentAddress?: string | null
    academicSemesterId: string
    academicFacultyId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    admissionRegistrationId?: string | null
    studentSemesterRegistrations?: StudentSemesterRegistrationUncheckedCreateNestedManyWithoutStudentInput
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseUncheckedCreateNestedManyWithoutStudentInput
    studentEnrolledCourses?: StudentEnrolledCourseUncheckedCreateNestedManyWithoutStudentInput
    studentEnrolledCourseMarks?: StudentEnrolledCourseMarkUncheckedCreateNestedManyWithoutStudentInput
    studentSemesterPayments?: StudentSemesterPaymentUncheckedCreateNestedManyWithoutStudentInput
    studentAcademicInfos?: StudentAcademicInfoUncheckedCreateNestedManyWithoutStudentInput
  }

  export type StudentCreateOrConnectWithoutAcademicDepartmentInput = {
    where: StudentWhereUniqueInput
    create: XOR<StudentCreateWithoutAcademicDepartmentInput, StudentUncheckedCreateWithoutAcademicDepartmentInput>
  }

  export type UsersCreateWithoutAcademicDepartmentInput = {
    id?: string
    name: string
    email: string
    password: string
    avatar?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    staffDepartments?: AcademicDepartmentCreateNestedManyWithoutStaffMembersInput
  }

  export type UsersUncheckedCreateWithoutAcademicDepartmentInput = {
    id?: string
    name: string
    email: string
    password: string
    avatar?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    staffDepartments?: AcademicDepartmentUncheckedCreateNestedManyWithoutStaffMembersInput
  }

  export type UsersCreateOrConnectWithoutAcademicDepartmentInput = {
    where: UsersWhereUniqueInput
    create: XOR<UsersCreateWithoutAcademicDepartmentInput, UsersUncheckedCreateWithoutAcademicDepartmentInput>
  }

  export type UsersCreateWithoutStaffDepartmentsInput = {
    id?: string
    name: string
    email: string
    password: string
    avatar?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    academicDepartment?: AcademicDepartmentCreateNestedOneWithoutDepartmentHeadInput
  }

  export type UsersUncheckedCreateWithoutStaffDepartmentsInput = {
    id?: string
    name: string
    email: string
    password: string
    avatar?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    academicDepartment?: AcademicDepartmentUncheckedCreateNestedOneWithoutDepartmentHeadInput
  }

  export type UsersCreateOrConnectWithoutStaffDepartmentsInput = {
    where: UsersWhereUniqueInput
    create: XOR<UsersCreateWithoutStaffDepartmentsInput, UsersUncheckedCreateWithoutStaffDepartmentsInput>
  }

  export type AdmitionExameRegistrationCreateWithoutDepartmentInput = {
    id?: string
    applicantName: string
    paymentRecipt: string
    document: string
    paymentAmoute?: number | null
    aprovePayment?: boolean | null
    exameResults?: number | null
    passed?: boolean | null
    fase?: number
    exameDate: Date | string
    createdAt?: Date | string
    updateAt?: Date | string
    Student?: StudentCreateNestedOneWithoutAdmissionRegistrationInput
  }

  export type AdmitionExameRegistrationUncheckedCreateWithoutDepartmentInput = {
    id?: string
    applicantName: string
    paymentRecipt: string
    document: string
    paymentAmoute?: number | null
    aprovePayment?: boolean | null
    exameResults?: number | null
    passed?: boolean | null
    fase?: number
    exameDate: Date | string
    createdAt?: Date | string
    updateAt?: Date | string
    Student?: StudentUncheckedCreateNestedOneWithoutAdmissionRegistrationInput
  }

  export type AdmitionExameRegistrationCreateOrConnectWithoutDepartmentInput = {
    where: AdmitionExameRegistrationWhereUniqueInput
    create: XOR<AdmitionExameRegistrationCreateWithoutDepartmentInput, AdmitionExameRegistrationUncheckedCreateWithoutDepartmentInput>
  }

  export type AdmitionExameRegistrationCreateManyDepartmentInputEnvelope = {
    data: AdmitionExameRegistrationCreateManyDepartmentInput | AdmitionExameRegistrationCreateManyDepartmentInput[]
    skipDuplicates?: boolean
  }

  export type OfferedCourseCreateWithoutAcademicDepartmentInput = {
    id?: string
    semesterRegistration: SemesterRegistrationCreateNestedOneWithoutOfferedCoursesInput
    course: CourseCreateNestedOneWithoutOfferedCoursesInput
    offeredCourseSections?: OfferedCourseSectionCreateNestedManyWithoutOfferedCourseInput
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseCreateNestedManyWithoutOfferedCourseInput
  }

  export type OfferedCourseUncheckedCreateWithoutAcademicDepartmentInput = {
    id?: string
    courseId: string
    semesterRegistrationId: string
    offeredCourseSections?: OfferedCourseSectionUncheckedCreateNestedManyWithoutOfferedCourseInput
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseUncheckedCreateNestedManyWithoutOfferedCourseInput
  }

  export type OfferedCourseCreateOrConnectWithoutAcademicDepartmentInput = {
    where: OfferedCourseWhereUniqueInput
    create: XOR<OfferedCourseCreateWithoutAcademicDepartmentInput, OfferedCourseUncheckedCreateWithoutAcademicDepartmentInput>
  }

  export type OfferedCourseCreateManyAcademicDepartmentInputEnvelope = {
    data: OfferedCourseCreateManyAcademicDepartmentInput | OfferedCourseCreateManyAcademicDepartmentInput[]
    skipDuplicates?: boolean
  }

  export type AcademicFacultyUpsertWithoutAcademicDepartmentsInput = {
    update: XOR<AcademicFacultyUpdateWithoutAcademicDepartmentsInput, AcademicFacultyUncheckedUpdateWithoutAcademicDepartmentsInput>
    create: XOR<AcademicFacultyCreateWithoutAcademicDepartmentsInput, AcademicFacultyUncheckedCreateWithoutAcademicDepartmentsInput>
    where?: AcademicFacultyWhereInput
  }

  export type AcademicFacultyUpdateToOneWithWhereWithoutAcademicDepartmentsInput = {
    where?: AcademicFacultyWhereInput
    data: XOR<AcademicFacultyUpdateWithoutAcademicDepartmentsInput, AcademicFacultyUncheckedUpdateWithoutAcademicDepartmentsInput>
  }

  export type AcademicFacultyUpdateWithoutAcademicDepartmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    faculties?: FacultyUpdateOneWithoutAcademicFacultyNestedInput
    students?: StudentUpdateOneWithoutAcademicFacultyNestedInput
  }

  export type AcademicFacultyUncheckedUpdateWithoutAcademicDepartmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    faculties?: FacultyUncheckedUpdateOneWithoutAcademicFacultyNestedInput
    students?: StudentUncheckedUpdateOneWithoutAcademicFacultyNestedInput
  }

  export type FacultyUpsertWithoutAcademicDepartmentInput = {
    update: XOR<FacultyUpdateWithoutAcademicDepartmentInput, FacultyUncheckedUpdateWithoutAcademicDepartmentInput>
    create: XOR<FacultyCreateWithoutAcademicDepartmentInput, FacultyUncheckedCreateWithoutAcademicDepartmentInput>
    where?: FacultyWhereInput
  }

  export type FacultyUpdateToOneWithWhereWithoutAcademicDepartmentInput = {
    where?: FacultyWhereInput
    data: XOR<FacultyUpdateWithoutAcademicDepartmentInput, FacultyUncheckedUpdateWithoutAcademicDepartmentInput>
  }

  export type FacultyUpdateWithoutAcademicDepartmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    facultyId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    contactNo?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: StringFieldUpdateOperationsInput | string
    designation?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    courses?: CourseFacultyUpdateManyWithoutFacultyNestedInput
    academicFaculty?: AcademicFacultyUpdateOneRequiredWithoutFacultiesNestedInput
    offeredCourseClassSchedules?: OfferedCourseClassScheduleUpdateManyWithoutFacultyNestedInput
  }

  export type FacultyUncheckedUpdateWithoutAcademicDepartmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    facultyId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    contactNo?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: StringFieldUpdateOperationsInput | string
    designation?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    academicFacultyId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    courses?: CourseFacultyUncheckedUpdateManyWithoutFacultyNestedInput
    offeredCourseClassSchedules?: OfferedCourseClassScheduleUncheckedUpdateManyWithoutFacultyNestedInput
  }

  export type StudentUpsertWithoutAcademicDepartmentInput = {
    update: XOR<StudentUpdateWithoutAcademicDepartmentInput, StudentUncheckedUpdateWithoutAcademicDepartmentInput>
    create: XOR<StudentCreateWithoutAcademicDepartmentInput, StudentUncheckedCreateWithoutAcademicDepartmentInput>
    where?: StudentWhereInput
  }

  export type StudentUpdateToOneWithWhereWithoutAcademicDepartmentInput = {
    where?: StudentWhereInput
    data: XOR<StudentUpdateWithoutAcademicDepartmentInput, StudentUncheckedUpdateWithoutAcademicDepartmentInput>
  }

  export type StudentUpdateWithoutAcademicDepartmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    contactNo?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: StringFieldUpdateOperationsInput | string
    isWoker?: BoolFieldUpdateOperationsInput | boolean
    shift?: EnumShiftFieldUpdateOperationsInput | $Enums.Shift
    password?: StringFieldUpdateOperationsInput | string
    gradeDeclarationFile?: StringFieldUpdateOperationsInput | string
    biFile?: StringFieldUpdateOperationsInput | string
    presentAddress?: StringFieldUpdateOperationsInput | string
    permanentAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    admissionRegistration?: AdmitionExameRegistrationUpdateOneWithoutStudentNestedInput
    academicFaculty?: AcademicFacultyUpdateOneRequiredWithoutStudentsNestedInput
    academicSemester?: AcademicSemesterUpdateOneRequiredWithoutStudentsNestedInput
    studentSemesterRegistrations?: StudentSemesterRegistrationUpdateManyWithoutStudentNestedInput
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseUpdateManyWithoutStudentNestedInput
    studentEnrolledCourses?: StudentEnrolledCourseUpdateManyWithoutStudentNestedInput
    studentEnrolledCourseMarks?: StudentEnrolledCourseMarkUpdateManyWithoutStudentNestedInput
    studentSemesterPayments?: StudentSemesterPaymentUpdateManyWithoutStudentNestedInput
    studentAcademicInfos?: StudentAcademicInfoUpdateManyWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateWithoutAcademicDepartmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    contactNo?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: StringFieldUpdateOperationsInput | string
    isWoker?: BoolFieldUpdateOperationsInput | boolean
    shift?: EnumShiftFieldUpdateOperationsInput | $Enums.Shift
    password?: StringFieldUpdateOperationsInput | string
    gradeDeclarationFile?: StringFieldUpdateOperationsInput | string
    biFile?: StringFieldUpdateOperationsInput | string
    presentAddress?: StringFieldUpdateOperationsInput | string
    permanentAddress?: NullableStringFieldUpdateOperationsInput | string | null
    academicSemesterId?: StringFieldUpdateOperationsInput | string
    academicFacultyId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    admissionRegistrationId?: NullableStringFieldUpdateOperationsInput | string | null
    studentSemesterRegistrations?: StudentSemesterRegistrationUncheckedUpdateManyWithoutStudentNestedInput
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseUncheckedUpdateManyWithoutStudentNestedInput
    studentEnrolledCourses?: StudentEnrolledCourseUncheckedUpdateManyWithoutStudentNestedInput
    studentEnrolledCourseMarks?: StudentEnrolledCourseMarkUncheckedUpdateManyWithoutStudentNestedInput
    studentSemesterPayments?: StudentSemesterPaymentUncheckedUpdateManyWithoutStudentNestedInput
    studentAcademicInfos?: StudentAcademicInfoUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type UsersUpsertWithoutAcademicDepartmentInput = {
    update: XOR<UsersUpdateWithoutAcademicDepartmentInput, UsersUncheckedUpdateWithoutAcademicDepartmentInput>
    create: XOR<UsersCreateWithoutAcademicDepartmentInput, UsersUncheckedCreateWithoutAcademicDepartmentInput>
    where?: UsersWhereInput
  }

  export type UsersUpdateToOneWithWhereWithoutAcademicDepartmentInput = {
    where?: UsersWhereInput
    data: XOR<UsersUpdateWithoutAcademicDepartmentInput, UsersUncheckedUpdateWithoutAcademicDepartmentInput>
  }

  export type UsersUpdateWithoutAcademicDepartmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    staffDepartments?: AcademicDepartmentUpdateManyWithoutStaffMembersNestedInput
  }

  export type UsersUncheckedUpdateWithoutAcademicDepartmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    staffDepartments?: AcademicDepartmentUncheckedUpdateManyWithoutStaffMembersNestedInput
  }

  export type UsersUpsertWithWhereUniqueWithoutStaffDepartmentsInput = {
    where: UsersWhereUniqueInput
    update: XOR<UsersUpdateWithoutStaffDepartmentsInput, UsersUncheckedUpdateWithoutStaffDepartmentsInput>
    create: XOR<UsersCreateWithoutStaffDepartmentsInput, UsersUncheckedCreateWithoutStaffDepartmentsInput>
  }

  export type UsersUpdateWithWhereUniqueWithoutStaffDepartmentsInput = {
    where: UsersWhereUniqueInput
    data: XOR<UsersUpdateWithoutStaffDepartmentsInput, UsersUncheckedUpdateWithoutStaffDepartmentsInput>
  }

  export type UsersUpdateManyWithWhereWithoutStaffDepartmentsInput = {
    where: UsersScalarWhereInput
    data: XOR<UsersUpdateManyMutationInput, UsersUncheckedUpdateManyWithoutStaffDepartmentsInput>
  }

  export type UsersScalarWhereInput = {
    AND?: UsersScalarWhereInput | UsersScalarWhereInput[]
    OR?: UsersScalarWhereInput[]
    NOT?: UsersScalarWhereInput | UsersScalarWhereInput[]
    id?: StringFilter<"Users"> | string
    name?: StringFilter<"Users"> | string
    email?: StringFilter<"Users"> | string
    password?: StringFilter<"Users"> | string
    avatar?: StringNullableFilter<"Users"> | string | null
    role?: EnumUserRoleFilter<"Users"> | $Enums.UserRole
    createdAt?: DateTimeFilter<"Users"> | Date | string
    updatedAt?: DateTimeFilter<"Users"> | Date | string
  }

  export type AdmitionExameRegistrationUpsertWithWhereUniqueWithoutDepartmentInput = {
    where: AdmitionExameRegistrationWhereUniqueInput
    update: XOR<AdmitionExameRegistrationUpdateWithoutDepartmentInput, AdmitionExameRegistrationUncheckedUpdateWithoutDepartmentInput>
    create: XOR<AdmitionExameRegistrationCreateWithoutDepartmentInput, AdmitionExameRegistrationUncheckedCreateWithoutDepartmentInput>
  }

  export type AdmitionExameRegistrationUpdateWithWhereUniqueWithoutDepartmentInput = {
    where: AdmitionExameRegistrationWhereUniqueInput
    data: XOR<AdmitionExameRegistrationUpdateWithoutDepartmentInput, AdmitionExameRegistrationUncheckedUpdateWithoutDepartmentInput>
  }

  export type AdmitionExameRegistrationUpdateManyWithWhereWithoutDepartmentInput = {
    where: AdmitionExameRegistrationScalarWhereInput
    data: XOR<AdmitionExameRegistrationUpdateManyMutationInput, AdmitionExameRegistrationUncheckedUpdateManyWithoutDepartmentInput>
  }

  export type AdmitionExameRegistrationScalarWhereInput = {
    AND?: AdmitionExameRegistrationScalarWhereInput | AdmitionExameRegistrationScalarWhereInput[]
    OR?: AdmitionExameRegistrationScalarWhereInput[]
    NOT?: AdmitionExameRegistrationScalarWhereInput | AdmitionExameRegistrationScalarWhereInput[]
    id?: StringFilter<"AdmitionExameRegistration"> | string
    applicantName?: StringFilter<"AdmitionExameRegistration"> | string
    paymentRecipt?: StringFilter<"AdmitionExameRegistration"> | string
    document?: StringFilter<"AdmitionExameRegistration"> | string
    paymentAmoute?: IntNullableFilter<"AdmitionExameRegistration"> | number | null
    aprovePayment?: BoolNullableFilter<"AdmitionExameRegistration"> | boolean | null
    exameResults?: IntNullableFilter<"AdmitionExameRegistration"> | number | null
    passed?: BoolNullableFilter<"AdmitionExameRegistration"> | boolean | null
    fase?: IntFilter<"AdmitionExameRegistration"> | number
    exameDate?: DateTimeFilter<"AdmitionExameRegistration"> | Date | string
    createdAt?: DateTimeFilter<"AdmitionExameRegistration"> | Date | string
    updateAt?: DateTimeFilter<"AdmitionExameRegistration"> | Date | string
    departmentId?: StringFilter<"AdmitionExameRegistration"> | string
  }

  export type OfferedCourseUpsertWithWhereUniqueWithoutAcademicDepartmentInput = {
    where: OfferedCourseWhereUniqueInput
    update: XOR<OfferedCourseUpdateWithoutAcademicDepartmentInput, OfferedCourseUncheckedUpdateWithoutAcademicDepartmentInput>
    create: XOR<OfferedCourseCreateWithoutAcademicDepartmentInput, OfferedCourseUncheckedCreateWithoutAcademicDepartmentInput>
  }

  export type OfferedCourseUpdateWithWhereUniqueWithoutAcademicDepartmentInput = {
    where: OfferedCourseWhereUniqueInput
    data: XOR<OfferedCourseUpdateWithoutAcademicDepartmentInput, OfferedCourseUncheckedUpdateWithoutAcademicDepartmentInput>
  }

  export type OfferedCourseUpdateManyWithWhereWithoutAcademicDepartmentInput = {
    where: OfferedCourseScalarWhereInput
    data: XOR<OfferedCourseUpdateManyMutationInput, OfferedCourseUncheckedUpdateManyWithoutAcademicDepartmentInput>
  }

  export type OfferedCourseScalarWhereInput = {
    AND?: OfferedCourseScalarWhereInput | OfferedCourseScalarWhereInput[]
    OR?: OfferedCourseScalarWhereInput[]
    NOT?: OfferedCourseScalarWhereInput | OfferedCourseScalarWhereInput[]
    id?: StringFilter<"OfferedCourse"> | string
    academicDepartmentId?: StringFilter<"OfferedCourse"> | string
    courseId?: StringFilter<"OfferedCourse"> | string
    semesterRegistrationId?: StringFilter<"OfferedCourse"> | string
  }

  export type AdmitionExameRegistrationCreateWithoutStudentInput = {
    id?: string
    applicantName: string
    paymentRecipt: string
    document: string
    paymentAmoute?: number | null
    aprovePayment?: boolean | null
    exameResults?: number | null
    passed?: boolean | null
    fase?: number
    exameDate: Date | string
    createdAt?: Date | string
    updateAt?: Date | string
    department: AcademicDepartmentCreateNestedOneWithoutAdmitionExameInput
  }

  export type AdmitionExameRegistrationUncheckedCreateWithoutStudentInput = {
    id?: string
    applicantName: string
    paymentRecipt: string
    document: string
    paymentAmoute?: number | null
    aprovePayment?: boolean | null
    exameResults?: number | null
    passed?: boolean | null
    fase?: number
    exameDate: Date | string
    createdAt?: Date | string
    updateAt?: Date | string
    departmentId: string
  }

  export type AdmitionExameRegistrationCreateOrConnectWithoutStudentInput = {
    where: AdmitionExameRegistrationWhereUniqueInput
    create: XOR<AdmitionExameRegistrationCreateWithoutStudentInput, AdmitionExameRegistrationUncheckedCreateWithoutStudentInput>
  }

  export type AcademicDepartmentCreateWithoutStudentsInput = {
    id?: string
    title: string
    createdAt?: Date | string
    updatedAt?: Date | string
    academicFaculty: AcademicFacultyCreateNestedOneWithoutAcademicDepartmentsInput
    faculties?: FacultyCreateNestedOneWithoutAcademicDepartmentInput
    departmentHead?: UsersCreateNestedOneWithoutAcademicDepartmentInput
    staffMembers?: UsersCreateNestedManyWithoutStaffDepartmentsInput
    admitionExame?: AdmitionExameRegistrationCreateNestedManyWithoutDepartmentInput
    offeredCourses?: OfferedCourseCreateNestedManyWithoutAcademicDepartmentInput
  }

  export type AcademicDepartmentUncheckedCreateWithoutStudentsInput = {
    id?: string
    title: string
    academicFacultyId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    departmentHeadId?: string | null
    faculties?: FacultyUncheckedCreateNestedOneWithoutAcademicDepartmentInput
    staffMembers?: UsersUncheckedCreateNestedManyWithoutStaffDepartmentsInput
    admitionExame?: AdmitionExameRegistrationUncheckedCreateNestedManyWithoutDepartmentInput
    offeredCourses?: OfferedCourseUncheckedCreateNestedManyWithoutAcademicDepartmentInput
  }

  export type AcademicDepartmentCreateOrConnectWithoutStudentsInput = {
    where: AcademicDepartmentWhereUniqueInput
    create: XOR<AcademicDepartmentCreateWithoutStudentsInput, AcademicDepartmentUncheckedCreateWithoutStudentsInput>
  }

  export type AcademicFacultyCreateWithoutStudentsInput = {
    id?: string
    title: string
    createdAt?: Date | string
    updatedAt?: Date | string
    academicDepartments?: AcademicDepartmentCreateNestedOneWithoutAcademicFacultyInput
    faculties?: FacultyCreateNestedOneWithoutAcademicFacultyInput
  }

  export type AcademicFacultyUncheckedCreateWithoutStudentsInput = {
    id?: string
    title: string
    createdAt?: Date | string
    updatedAt?: Date | string
    academicDepartments?: AcademicDepartmentUncheckedCreateNestedOneWithoutAcademicFacultyInput
    faculties?: FacultyUncheckedCreateNestedOneWithoutAcademicFacultyInput
  }

  export type AcademicFacultyCreateOrConnectWithoutStudentsInput = {
    where: AcademicFacultyWhereUniqueInput
    create: XOR<AcademicFacultyCreateWithoutStudentsInput, AcademicFacultyUncheckedCreateWithoutStudentsInput>
  }

  export type AcademicSemesterCreateWithoutStudentsInput = {
    id?: string
    title: string
    year: string
    code: string
    startMonth: string
    endMonth: string
    isCurrent?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    semesterRegistrations?: SemesterRegistrationCreateNestedManyWithoutAcademicSemesterInput
    studentEnrolledCourses?: StudentEnrolledCourseCreateNestedManyWithoutAcademicSemesterInput
    studentEnrolledCourseMarks?: StudentEnrolledCourseMarkCreateNestedManyWithoutAcademicSemesterInput
    studentSemesterPayments?: StudentSemesterPaymentCreateNestedManyWithoutAcademicSemesterInput
  }

  export type AcademicSemesterUncheckedCreateWithoutStudentsInput = {
    id?: string
    title: string
    year: string
    code: string
    startMonth: string
    endMonth: string
    isCurrent?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    semesterRegistrations?: SemesterRegistrationUncheckedCreateNestedManyWithoutAcademicSemesterInput
    studentEnrolledCourses?: StudentEnrolledCourseUncheckedCreateNestedManyWithoutAcademicSemesterInput
    studentEnrolledCourseMarks?: StudentEnrolledCourseMarkUncheckedCreateNestedManyWithoutAcademicSemesterInput
    studentSemesterPayments?: StudentSemesterPaymentUncheckedCreateNestedManyWithoutAcademicSemesterInput
  }

  export type AcademicSemesterCreateOrConnectWithoutStudentsInput = {
    where: AcademicSemesterWhereUniqueInput
    create: XOR<AcademicSemesterCreateWithoutStudentsInput, AcademicSemesterUncheckedCreateWithoutStudentsInput>
  }

  export type StudentSemesterRegistrationCreateWithoutStudentInput = {
    id?: string
    isConfirmed?: boolean | null
    totalCreditsTaken?: number | null
    paymentRecipt?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    semesterRegistration: SemesterRegistrationCreateNestedOneWithoutStudentSemesterRegistrationsInput
  }

  export type StudentSemesterRegistrationUncheckedCreateWithoutStudentInput = {
    id?: string
    isConfirmed?: boolean | null
    totalCreditsTaken?: number | null
    paymentRecipt?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    semesterRegistrationId: string
  }

  export type StudentSemesterRegistrationCreateOrConnectWithoutStudentInput = {
    where: StudentSemesterRegistrationWhereUniqueInput
    create: XOR<StudentSemesterRegistrationCreateWithoutStudentInput, StudentSemesterRegistrationUncheckedCreateWithoutStudentInput>
  }

  export type StudentSemesterRegistrationCreateManyStudentInputEnvelope = {
    data: StudentSemesterRegistrationCreateManyStudentInput | StudentSemesterRegistrationCreateManyStudentInput[]
    skipDuplicates?: boolean
  }

  export type StudentSemesterRegistrationCourseCreateWithoutStudentInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    semesterRegistration: SemesterRegistrationCreateNestedOneWithoutStudentSemesterRegistrationCoursesInput
    offeredCourse: OfferedCourseCreateNestedOneWithoutStudentSemesterRegistrationCoursesInput
    offeredCourseSection: OfferedCourseSectionCreateNestedOneWithoutStudentSemesterRegistrationCoursesInput
  }

  export type StudentSemesterRegistrationCourseUncheckedCreateWithoutStudentInput = {
    semesterRegistrationId: string
    offeredCourseId: string
    offeredCourseSectionId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StudentSemesterRegistrationCourseCreateOrConnectWithoutStudentInput = {
    where: StudentSemesterRegistrationCourseWhereUniqueInput
    create: XOR<StudentSemesterRegistrationCourseCreateWithoutStudentInput, StudentSemesterRegistrationCourseUncheckedCreateWithoutStudentInput>
  }

  export type StudentSemesterRegistrationCourseCreateManyStudentInputEnvelope = {
    data: StudentSemesterRegistrationCourseCreateManyStudentInput | StudentSemesterRegistrationCourseCreateManyStudentInput[]
    skipDuplicates?: boolean
  }

  export type StudentEnrolledCourseCreateWithoutStudentInput = {
    id?: string
    grade?: string | null
    point?: number | null
    totalMarks?: number | null
    status?: $Enums.StudentEnrolledCourseStatus | null
    createdAt?: Date | string
    updatedAt?: Date | string
    academicSemester: AcademicSemesterCreateNestedOneWithoutStudentEnrolledCoursesInput
    course: CourseCreateNestedOneWithoutStudentEnrolledCoursesInput
    studentEnrolledCourseMarks?: StudentEnrolledCourseMarkCreateNestedManyWithoutStudentEnrolledCourseInput
  }

  export type StudentEnrolledCourseUncheckedCreateWithoutStudentInput = {
    id?: string
    grade?: string | null
    point?: number | null
    totalMarks?: number | null
    status?: $Enums.StudentEnrolledCourseStatus | null
    createdAt?: Date | string
    updatedAt?: Date | string
    academicSemesterId: string
    courseId: string
    studentEnrolledCourseMarks?: StudentEnrolledCourseMarkUncheckedCreateNestedManyWithoutStudentEnrolledCourseInput
  }

  export type StudentEnrolledCourseCreateOrConnectWithoutStudentInput = {
    where: StudentEnrolledCourseWhereUniqueInput
    create: XOR<StudentEnrolledCourseCreateWithoutStudentInput, StudentEnrolledCourseUncheckedCreateWithoutStudentInput>
  }

  export type StudentEnrolledCourseCreateManyStudentInputEnvelope = {
    data: StudentEnrolledCourseCreateManyStudentInput | StudentEnrolledCourseCreateManyStudentInput[]
    skipDuplicates?: boolean
  }

  export type StudentEnrolledCourseMarkCreateWithoutStudentInput = {
    id?: string
    examType?: $Enums.ExamType | null
    createdAt?: Date | string
    updatedAt?: Date | string
    exam1?: number
    exam2?: number
    exam3?: number
    exam4?: number
    exam5?: number
    exam6?: number
    finalExam?: number
    totalMarks?: number
    grade?: number
    studentEnrolledCourse: StudentEnrolledCourseCreateNestedOneWithoutStudentEnrolledCourseMarksInput
    academicSemester: AcademicSemesterCreateNestedOneWithoutStudentEnrolledCourseMarksInput
  }

  export type StudentEnrolledCourseMarkUncheckedCreateWithoutStudentInput = {
    id?: string
    examType?: $Enums.ExamType | null
    createdAt?: Date | string
    updatedAt?: Date | string
    studentEnrolledCourseId: string
    academicSemesterId: string
    exam1?: number
    exam2?: number
    exam3?: number
    exam4?: number
    exam5?: number
    exam6?: number
    finalExam?: number
    totalMarks?: number
    grade?: number
  }

  export type StudentEnrolledCourseMarkCreateOrConnectWithoutStudentInput = {
    where: StudentEnrolledCourseMarkWhereUniqueInput
    create: XOR<StudentEnrolledCourseMarkCreateWithoutStudentInput, StudentEnrolledCourseMarkUncheckedCreateWithoutStudentInput>
  }

  export type StudentEnrolledCourseMarkCreateManyStudentInputEnvelope = {
    data: StudentEnrolledCourseMarkCreateManyStudentInput | StudentEnrolledCourseMarkCreateManyStudentInput[]
    skipDuplicates?: boolean
  }

  export type StudentSemesterPaymentCreateWithoutStudentInput = {
    id?: string
    paymentRecipt?: string | null
    totalPayment?: number
    baseAmount: number
    lateFee?: number
    aprovedPayment?: boolean
    paymentType?: $Enums.PAYMENTTYPE
    paymentStatus?: $Enums.PaymentStatus | null
    paymentMonth: number
    paymentYear: number
    createdAt?: Date | string
    updatedAt?: Date | string
    academicSemester: AcademicSemesterCreateNestedOneWithoutStudentSemesterPaymentsInput
  }

  export type StudentSemesterPaymentUncheckedCreateWithoutStudentInput = {
    id?: string
    paymentRecipt?: string | null
    totalPayment?: number
    baseAmount: number
    lateFee?: number
    aprovedPayment?: boolean
    paymentType?: $Enums.PAYMENTTYPE
    paymentStatus?: $Enums.PaymentStatus | null
    paymentMonth: number
    paymentYear: number
    createdAt?: Date | string
    updatedAt?: Date | string
    academicSemesterId: string
  }

  export type StudentSemesterPaymentCreateOrConnectWithoutStudentInput = {
    where: StudentSemesterPaymentWhereUniqueInput
    create: XOR<StudentSemesterPaymentCreateWithoutStudentInput, StudentSemesterPaymentUncheckedCreateWithoutStudentInput>
  }

  export type StudentSemesterPaymentCreateManyStudentInputEnvelope = {
    data: StudentSemesterPaymentCreateManyStudentInput | StudentSemesterPaymentCreateManyStudentInput[]
    skipDuplicates?: boolean
  }

  export type StudentAcademicInfoCreateWithoutStudentInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    totalCompletedCredits?: number | null
    cgpa?: number | null
  }

  export type StudentAcademicInfoUncheckedCreateWithoutStudentInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    totalCompletedCredits?: number | null
    cgpa?: number | null
  }

  export type StudentAcademicInfoCreateOrConnectWithoutStudentInput = {
    where: StudentAcademicInfoWhereUniqueInput
    create: XOR<StudentAcademicInfoCreateWithoutStudentInput, StudentAcademicInfoUncheckedCreateWithoutStudentInput>
  }

  export type StudentAcademicInfoCreateManyStudentInputEnvelope = {
    data: StudentAcademicInfoCreateManyStudentInput | StudentAcademicInfoCreateManyStudentInput[]
    skipDuplicates?: boolean
  }

  export type AdmitionExameRegistrationUpsertWithoutStudentInput = {
    update: XOR<AdmitionExameRegistrationUpdateWithoutStudentInput, AdmitionExameRegistrationUncheckedUpdateWithoutStudentInput>
    create: XOR<AdmitionExameRegistrationCreateWithoutStudentInput, AdmitionExameRegistrationUncheckedCreateWithoutStudentInput>
    where?: AdmitionExameRegistrationWhereInput
  }

  export type AdmitionExameRegistrationUpdateToOneWithWhereWithoutStudentInput = {
    where?: AdmitionExameRegistrationWhereInput
    data: XOR<AdmitionExameRegistrationUpdateWithoutStudentInput, AdmitionExameRegistrationUncheckedUpdateWithoutStudentInput>
  }

  export type AdmitionExameRegistrationUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    applicantName?: StringFieldUpdateOperationsInput | string
    paymentRecipt?: StringFieldUpdateOperationsInput | string
    document?: StringFieldUpdateOperationsInput | string
    paymentAmoute?: NullableIntFieldUpdateOperationsInput | number | null
    aprovePayment?: NullableBoolFieldUpdateOperationsInput | boolean | null
    exameResults?: NullableIntFieldUpdateOperationsInput | number | null
    passed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    fase?: IntFieldUpdateOperationsInput | number
    exameDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    department?: AcademicDepartmentUpdateOneRequiredWithoutAdmitionExameNestedInput
  }

  export type AdmitionExameRegistrationUncheckedUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    applicantName?: StringFieldUpdateOperationsInput | string
    paymentRecipt?: StringFieldUpdateOperationsInput | string
    document?: StringFieldUpdateOperationsInput | string
    paymentAmoute?: NullableIntFieldUpdateOperationsInput | number | null
    aprovePayment?: NullableBoolFieldUpdateOperationsInput | boolean | null
    exameResults?: NullableIntFieldUpdateOperationsInput | number | null
    passed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    fase?: IntFieldUpdateOperationsInput | number
    exameDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    departmentId?: StringFieldUpdateOperationsInput | string
  }

  export type AcademicDepartmentUpsertWithoutStudentsInput = {
    update: XOR<AcademicDepartmentUpdateWithoutStudentsInput, AcademicDepartmentUncheckedUpdateWithoutStudentsInput>
    create: XOR<AcademicDepartmentCreateWithoutStudentsInput, AcademicDepartmentUncheckedCreateWithoutStudentsInput>
    where?: AcademicDepartmentWhereInput
  }

  export type AcademicDepartmentUpdateToOneWithWhereWithoutStudentsInput = {
    where?: AcademicDepartmentWhereInput
    data: XOR<AcademicDepartmentUpdateWithoutStudentsInput, AcademicDepartmentUncheckedUpdateWithoutStudentsInput>
  }

  export type AcademicDepartmentUpdateWithoutStudentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    academicFaculty?: AcademicFacultyUpdateOneRequiredWithoutAcademicDepartmentsNestedInput
    faculties?: FacultyUpdateOneWithoutAcademicDepartmentNestedInput
    departmentHead?: UsersUpdateOneWithoutAcademicDepartmentNestedInput
    staffMembers?: UsersUpdateManyWithoutStaffDepartmentsNestedInput
    admitionExame?: AdmitionExameRegistrationUpdateManyWithoutDepartmentNestedInput
    offeredCourses?: OfferedCourseUpdateManyWithoutAcademicDepartmentNestedInput
  }

  export type AcademicDepartmentUncheckedUpdateWithoutStudentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    academicFacultyId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    departmentHeadId?: NullableStringFieldUpdateOperationsInput | string | null
    faculties?: FacultyUncheckedUpdateOneWithoutAcademicDepartmentNestedInput
    staffMembers?: UsersUncheckedUpdateManyWithoutStaffDepartmentsNestedInput
    admitionExame?: AdmitionExameRegistrationUncheckedUpdateManyWithoutDepartmentNestedInput
    offeredCourses?: OfferedCourseUncheckedUpdateManyWithoutAcademicDepartmentNestedInput
  }

  export type AcademicFacultyUpsertWithoutStudentsInput = {
    update: XOR<AcademicFacultyUpdateWithoutStudentsInput, AcademicFacultyUncheckedUpdateWithoutStudentsInput>
    create: XOR<AcademicFacultyCreateWithoutStudentsInput, AcademicFacultyUncheckedCreateWithoutStudentsInput>
    where?: AcademicFacultyWhereInput
  }

  export type AcademicFacultyUpdateToOneWithWhereWithoutStudentsInput = {
    where?: AcademicFacultyWhereInput
    data: XOR<AcademicFacultyUpdateWithoutStudentsInput, AcademicFacultyUncheckedUpdateWithoutStudentsInput>
  }

  export type AcademicFacultyUpdateWithoutStudentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    academicDepartments?: AcademicDepartmentUpdateOneWithoutAcademicFacultyNestedInput
    faculties?: FacultyUpdateOneWithoutAcademicFacultyNestedInput
  }

  export type AcademicFacultyUncheckedUpdateWithoutStudentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    academicDepartments?: AcademicDepartmentUncheckedUpdateOneWithoutAcademicFacultyNestedInput
    faculties?: FacultyUncheckedUpdateOneWithoutAcademicFacultyNestedInput
  }

  export type AcademicSemesterUpsertWithoutStudentsInput = {
    update: XOR<AcademicSemesterUpdateWithoutStudentsInput, AcademicSemesterUncheckedUpdateWithoutStudentsInput>
    create: XOR<AcademicSemesterCreateWithoutStudentsInput, AcademicSemesterUncheckedCreateWithoutStudentsInput>
    where?: AcademicSemesterWhereInput
  }

  export type AcademicSemesterUpdateToOneWithWhereWithoutStudentsInput = {
    where?: AcademicSemesterWhereInput
    data: XOR<AcademicSemesterUpdateWithoutStudentsInput, AcademicSemesterUncheckedUpdateWithoutStudentsInput>
  }

  export type AcademicSemesterUpdateWithoutStudentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    year?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    startMonth?: StringFieldUpdateOperationsInput | string
    endMonth?: StringFieldUpdateOperationsInput | string
    isCurrent?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    semesterRegistrations?: SemesterRegistrationUpdateManyWithoutAcademicSemesterNestedInput
    studentEnrolledCourses?: StudentEnrolledCourseUpdateManyWithoutAcademicSemesterNestedInput
    studentEnrolledCourseMarks?: StudentEnrolledCourseMarkUpdateManyWithoutAcademicSemesterNestedInput
    studentSemesterPayments?: StudentSemesterPaymentUpdateManyWithoutAcademicSemesterNestedInput
  }

  export type AcademicSemesterUncheckedUpdateWithoutStudentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    year?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    startMonth?: StringFieldUpdateOperationsInput | string
    endMonth?: StringFieldUpdateOperationsInput | string
    isCurrent?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    semesterRegistrations?: SemesterRegistrationUncheckedUpdateManyWithoutAcademicSemesterNestedInput
    studentEnrolledCourses?: StudentEnrolledCourseUncheckedUpdateManyWithoutAcademicSemesterNestedInput
    studentEnrolledCourseMarks?: StudentEnrolledCourseMarkUncheckedUpdateManyWithoutAcademicSemesterNestedInput
    studentSemesterPayments?: StudentSemesterPaymentUncheckedUpdateManyWithoutAcademicSemesterNestedInput
  }

  export type StudentSemesterRegistrationUpsertWithWhereUniqueWithoutStudentInput = {
    where: StudentSemesterRegistrationWhereUniqueInput
    update: XOR<StudentSemesterRegistrationUpdateWithoutStudentInput, StudentSemesterRegistrationUncheckedUpdateWithoutStudentInput>
    create: XOR<StudentSemesterRegistrationCreateWithoutStudentInput, StudentSemesterRegistrationUncheckedCreateWithoutStudentInput>
  }

  export type StudentSemesterRegistrationUpdateWithWhereUniqueWithoutStudentInput = {
    where: StudentSemesterRegistrationWhereUniqueInput
    data: XOR<StudentSemesterRegistrationUpdateWithoutStudentInput, StudentSemesterRegistrationUncheckedUpdateWithoutStudentInput>
  }

  export type StudentSemesterRegistrationUpdateManyWithWhereWithoutStudentInput = {
    where: StudentSemesterRegistrationScalarWhereInput
    data: XOR<StudentSemesterRegistrationUpdateManyMutationInput, StudentSemesterRegistrationUncheckedUpdateManyWithoutStudentInput>
  }

  export type StudentSemesterRegistrationScalarWhereInput = {
    AND?: StudentSemesterRegistrationScalarWhereInput | StudentSemesterRegistrationScalarWhereInput[]
    OR?: StudentSemesterRegistrationScalarWhereInput[]
    NOT?: StudentSemesterRegistrationScalarWhereInput | StudentSemesterRegistrationScalarWhereInput[]
    id?: StringFilter<"StudentSemesterRegistration"> | string
    isConfirmed?: BoolNullableFilter<"StudentSemesterRegistration"> | boolean | null
    totalCreditsTaken?: IntNullableFilter<"StudentSemesterRegistration"> | number | null
    paymentRecipt?: StringNullableFilter<"StudentSemesterRegistration"> | string | null
    createdAt?: DateTimeFilter<"StudentSemesterRegistration"> | Date | string
    updatedAt?: DateTimeFilter<"StudentSemesterRegistration"> | Date | string
    studentId?: StringFilter<"StudentSemesterRegistration"> | string
    semesterRegistrationId?: StringFilter<"StudentSemesterRegistration"> | string
  }

  export type StudentSemesterRegistrationCourseUpsertWithWhereUniqueWithoutStudentInput = {
    where: StudentSemesterRegistrationCourseWhereUniqueInput
    update: XOR<StudentSemesterRegistrationCourseUpdateWithoutStudentInput, StudentSemesterRegistrationCourseUncheckedUpdateWithoutStudentInput>
    create: XOR<StudentSemesterRegistrationCourseCreateWithoutStudentInput, StudentSemesterRegistrationCourseUncheckedCreateWithoutStudentInput>
  }

  export type StudentSemesterRegistrationCourseUpdateWithWhereUniqueWithoutStudentInput = {
    where: StudentSemesterRegistrationCourseWhereUniqueInput
    data: XOR<StudentSemesterRegistrationCourseUpdateWithoutStudentInput, StudentSemesterRegistrationCourseUncheckedUpdateWithoutStudentInput>
  }

  export type StudentSemesterRegistrationCourseUpdateManyWithWhereWithoutStudentInput = {
    where: StudentSemesterRegistrationCourseScalarWhereInput
    data: XOR<StudentSemesterRegistrationCourseUpdateManyMutationInput, StudentSemesterRegistrationCourseUncheckedUpdateManyWithoutStudentInput>
  }

  export type StudentSemesterRegistrationCourseScalarWhereInput = {
    AND?: StudentSemesterRegistrationCourseScalarWhereInput | StudentSemesterRegistrationCourseScalarWhereInput[]
    OR?: StudentSemesterRegistrationCourseScalarWhereInput[]
    NOT?: StudentSemesterRegistrationCourseScalarWhereInput | StudentSemesterRegistrationCourseScalarWhereInput[]
    semesterRegistrationId?: StringFilter<"StudentSemesterRegistrationCourse"> | string
    studentId?: StringFilter<"StudentSemesterRegistrationCourse"> | string
    offeredCourseId?: StringFilter<"StudentSemesterRegistrationCourse"> | string
    offeredCourseSectionId?: StringFilter<"StudentSemesterRegistrationCourse"> | string
    createdAt?: DateTimeFilter<"StudentSemesterRegistrationCourse"> | Date | string
    updatedAt?: DateTimeFilter<"StudentSemesterRegistrationCourse"> | Date | string
  }

  export type StudentEnrolledCourseUpsertWithWhereUniqueWithoutStudentInput = {
    where: StudentEnrolledCourseWhereUniqueInput
    update: XOR<StudentEnrolledCourseUpdateWithoutStudentInput, StudentEnrolledCourseUncheckedUpdateWithoutStudentInput>
    create: XOR<StudentEnrolledCourseCreateWithoutStudentInput, StudentEnrolledCourseUncheckedCreateWithoutStudentInput>
  }

  export type StudentEnrolledCourseUpdateWithWhereUniqueWithoutStudentInput = {
    where: StudentEnrolledCourseWhereUniqueInput
    data: XOR<StudentEnrolledCourseUpdateWithoutStudentInput, StudentEnrolledCourseUncheckedUpdateWithoutStudentInput>
  }

  export type StudentEnrolledCourseUpdateManyWithWhereWithoutStudentInput = {
    where: StudentEnrolledCourseScalarWhereInput
    data: XOR<StudentEnrolledCourseUpdateManyMutationInput, StudentEnrolledCourseUncheckedUpdateManyWithoutStudentInput>
  }

  export type StudentEnrolledCourseMarkUpsertWithWhereUniqueWithoutStudentInput = {
    where: StudentEnrolledCourseMarkWhereUniqueInput
    update: XOR<StudentEnrolledCourseMarkUpdateWithoutStudentInput, StudentEnrolledCourseMarkUncheckedUpdateWithoutStudentInput>
    create: XOR<StudentEnrolledCourseMarkCreateWithoutStudentInput, StudentEnrolledCourseMarkUncheckedCreateWithoutStudentInput>
  }

  export type StudentEnrolledCourseMarkUpdateWithWhereUniqueWithoutStudentInput = {
    where: StudentEnrolledCourseMarkWhereUniqueInput
    data: XOR<StudentEnrolledCourseMarkUpdateWithoutStudentInput, StudentEnrolledCourseMarkUncheckedUpdateWithoutStudentInput>
  }

  export type StudentEnrolledCourseMarkUpdateManyWithWhereWithoutStudentInput = {
    where: StudentEnrolledCourseMarkScalarWhereInput
    data: XOR<StudentEnrolledCourseMarkUpdateManyMutationInput, StudentEnrolledCourseMarkUncheckedUpdateManyWithoutStudentInput>
  }

  export type StudentSemesterPaymentUpsertWithWhereUniqueWithoutStudentInput = {
    where: StudentSemesterPaymentWhereUniqueInput
    update: XOR<StudentSemesterPaymentUpdateWithoutStudentInput, StudentSemesterPaymentUncheckedUpdateWithoutStudentInput>
    create: XOR<StudentSemesterPaymentCreateWithoutStudentInput, StudentSemesterPaymentUncheckedCreateWithoutStudentInput>
  }

  export type StudentSemesterPaymentUpdateWithWhereUniqueWithoutStudentInput = {
    where: StudentSemesterPaymentWhereUniqueInput
    data: XOR<StudentSemesterPaymentUpdateWithoutStudentInput, StudentSemesterPaymentUncheckedUpdateWithoutStudentInput>
  }

  export type StudentSemesterPaymentUpdateManyWithWhereWithoutStudentInput = {
    where: StudentSemesterPaymentScalarWhereInput
    data: XOR<StudentSemesterPaymentUpdateManyMutationInput, StudentSemesterPaymentUncheckedUpdateManyWithoutStudentInput>
  }

  export type StudentAcademicInfoUpsertWithWhereUniqueWithoutStudentInput = {
    where: StudentAcademicInfoWhereUniqueInput
    update: XOR<StudentAcademicInfoUpdateWithoutStudentInput, StudentAcademicInfoUncheckedUpdateWithoutStudentInput>
    create: XOR<StudentAcademicInfoCreateWithoutStudentInput, StudentAcademicInfoUncheckedCreateWithoutStudentInput>
  }

  export type StudentAcademicInfoUpdateWithWhereUniqueWithoutStudentInput = {
    where: StudentAcademicInfoWhereUniqueInput
    data: XOR<StudentAcademicInfoUpdateWithoutStudentInput, StudentAcademicInfoUncheckedUpdateWithoutStudentInput>
  }

  export type StudentAcademicInfoUpdateManyWithWhereWithoutStudentInput = {
    where: StudentAcademicInfoScalarWhereInput
    data: XOR<StudentAcademicInfoUpdateManyMutationInput, StudentAcademicInfoUncheckedUpdateManyWithoutStudentInput>
  }

  export type StudentAcademicInfoScalarWhereInput = {
    AND?: StudentAcademicInfoScalarWhereInput | StudentAcademicInfoScalarWhereInput[]
    OR?: StudentAcademicInfoScalarWhereInput[]
    NOT?: StudentAcademicInfoScalarWhereInput | StudentAcademicInfoScalarWhereInput[]
    id?: StringFilter<"StudentAcademicInfo"> | string
    createdAt?: DateTimeFilter<"StudentAcademicInfo"> | Date | string
    updatedAt?: DateTimeFilter<"StudentAcademicInfo"> | Date | string
    studentId?: StringFilter<"StudentAcademicInfo"> | string
    totalCompletedCredits?: IntNullableFilter<"StudentAcademicInfo"> | number | null
    cgpa?: FloatNullableFilter<"StudentAcademicInfo"> | number | null
  }

  export type CourseFacultyCreateWithoutFacultyInput = {
    course: CourseCreateNestedOneWithoutFacultiesInput
  }

  export type CourseFacultyUncheckedCreateWithoutFacultyInput = {
    courseId: string
  }

  export type CourseFacultyCreateOrConnectWithoutFacultyInput = {
    where: CourseFacultyWhereUniqueInput
    create: XOR<CourseFacultyCreateWithoutFacultyInput, CourseFacultyUncheckedCreateWithoutFacultyInput>
  }

  export type CourseFacultyCreateManyFacultyInputEnvelope = {
    data: CourseFacultyCreateManyFacultyInput | CourseFacultyCreateManyFacultyInput[]
    skipDuplicates?: boolean
  }

  export type AcademicDepartmentCreateWithoutFacultiesInput = {
    id?: string
    title: string
    createdAt?: Date | string
    updatedAt?: Date | string
    academicFaculty: AcademicFacultyCreateNestedOneWithoutAcademicDepartmentsInput
    students?: StudentCreateNestedOneWithoutAcademicDepartmentInput
    departmentHead?: UsersCreateNestedOneWithoutAcademicDepartmentInput
    staffMembers?: UsersCreateNestedManyWithoutStaffDepartmentsInput
    admitionExame?: AdmitionExameRegistrationCreateNestedManyWithoutDepartmentInput
    offeredCourses?: OfferedCourseCreateNestedManyWithoutAcademicDepartmentInput
  }

  export type AcademicDepartmentUncheckedCreateWithoutFacultiesInput = {
    id?: string
    title: string
    academicFacultyId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    departmentHeadId?: string | null
    students?: StudentUncheckedCreateNestedOneWithoutAcademicDepartmentInput
    staffMembers?: UsersUncheckedCreateNestedManyWithoutStaffDepartmentsInput
    admitionExame?: AdmitionExameRegistrationUncheckedCreateNestedManyWithoutDepartmentInput
    offeredCourses?: OfferedCourseUncheckedCreateNestedManyWithoutAcademicDepartmentInput
  }

  export type AcademicDepartmentCreateOrConnectWithoutFacultiesInput = {
    where: AcademicDepartmentWhereUniqueInput
    create: XOR<AcademicDepartmentCreateWithoutFacultiesInput, AcademicDepartmentUncheckedCreateWithoutFacultiesInput>
  }

  export type AcademicFacultyCreateWithoutFacultiesInput = {
    id?: string
    title: string
    createdAt?: Date | string
    updatedAt?: Date | string
    academicDepartments?: AcademicDepartmentCreateNestedOneWithoutAcademicFacultyInput
    students?: StudentCreateNestedOneWithoutAcademicFacultyInput
  }

  export type AcademicFacultyUncheckedCreateWithoutFacultiesInput = {
    id?: string
    title: string
    createdAt?: Date | string
    updatedAt?: Date | string
    academicDepartments?: AcademicDepartmentUncheckedCreateNestedOneWithoutAcademicFacultyInput
    students?: StudentUncheckedCreateNestedOneWithoutAcademicFacultyInput
  }

  export type AcademicFacultyCreateOrConnectWithoutFacultiesInput = {
    where: AcademicFacultyWhereUniqueInput
    create: XOR<AcademicFacultyCreateWithoutFacultiesInput, AcademicFacultyUncheckedCreateWithoutFacultiesInput>
  }

  export type OfferedCourseClassScheduleCreateWithoutFacultyInput = {
    id?: string
    startTime: string
    endTime: string
    dayOfWeek?: $Enums.WeekDays
    createdAt?: Date | string
    updatedAt?: Date | string
    offeredCourseSection: OfferedCourseSectionCreateNestedOneWithoutOfferedCourseClassSchedulesInput
    semesterRegistration: SemesterRegistrationCreateNestedOneWithoutOfferedCourseClassSchedulesInput
    room: RoomCreateNestedOneWithoutOfferedCourseClassSchedulesInput
  }

  export type OfferedCourseClassScheduleUncheckedCreateWithoutFacultyInput = {
    id?: string
    startTime: string
    endTime: string
    dayOfWeek?: $Enums.WeekDays
    createdAt?: Date | string
    updatedAt?: Date | string
    offeredCourseSectionId: string
    semesterRegistrationId: string
    roomId: string
  }

  export type OfferedCourseClassScheduleCreateOrConnectWithoutFacultyInput = {
    where: OfferedCourseClassScheduleWhereUniqueInput
    create: XOR<OfferedCourseClassScheduleCreateWithoutFacultyInput, OfferedCourseClassScheduleUncheckedCreateWithoutFacultyInput>
  }

  export type OfferedCourseClassScheduleCreateManyFacultyInputEnvelope = {
    data: OfferedCourseClassScheduleCreateManyFacultyInput | OfferedCourseClassScheduleCreateManyFacultyInput[]
    skipDuplicates?: boolean
  }

  export type CourseFacultyUpsertWithWhereUniqueWithoutFacultyInput = {
    where: CourseFacultyWhereUniqueInput
    update: XOR<CourseFacultyUpdateWithoutFacultyInput, CourseFacultyUncheckedUpdateWithoutFacultyInput>
    create: XOR<CourseFacultyCreateWithoutFacultyInput, CourseFacultyUncheckedCreateWithoutFacultyInput>
  }

  export type CourseFacultyUpdateWithWhereUniqueWithoutFacultyInput = {
    where: CourseFacultyWhereUniqueInput
    data: XOR<CourseFacultyUpdateWithoutFacultyInput, CourseFacultyUncheckedUpdateWithoutFacultyInput>
  }

  export type CourseFacultyUpdateManyWithWhereWithoutFacultyInput = {
    where: CourseFacultyScalarWhereInput
    data: XOR<CourseFacultyUpdateManyMutationInput, CourseFacultyUncheckedUpdateManyWithoutFacultyInput>
  }

  export type CourseFacultyScalarWhereInput = {
    AND?: CourseFacultyScalarWhereInput | CourseFacultyScalarWhereInput[]
    OR?: CourseFacultyScalarWhereInput[]
    NOT?: CourseFacultyScalarWhereInput | CourseFacultyScalarWhereInput[]
    courseId?: StringFilter<"CourseFaculty"> | string
    facultyId?: StringFilter<"CourseFaculty"> | string
  }

  export type AcademicDepartmentUpsertWithoutFacultiesInput = {
    update: XOR<AcademicDepartmentUpdateWithoutFacultiesInput, AcademicDepartmentUncheckedUpdateWithoutFacultiesInput>
    create: XOR<AcademicDepartmentCreateWithoutFacultiesInput, AcademicDepartmentUncheckedCreateWithoutFacultiesInput>
    where?: AcademicDepartmentWhereInput
  }

  export type AcademicDepartmentUpdateToOneWithWhereWithoutFacultiesInput = {
    where?: AcademicDepartmentWhereInput
    data: XOR<AcademicDepartmentUpdateWithoutFacultiesInput, AcademicDepartmentUncheckedUpdateWithoutFacultiesInput>
  }

  export type AcademicDepartmentUpdateWithoutFacultiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    academicFaculty?: AcademicFacultyUpdateOneRequiredWithoutAcademicDepartmentsNestedInput
    students?: StudentUpdateOneWithoutAcademicDepartmentNestedInput
    departmentHead?: UsersUpdateOneWithoutAcademicDepartmentNestedInput
    staffMembers?: UsersUpdateManyWithoutStaffDepartmentsNestedInput
    admitionExame?: AdmitionExameRegistrationUpdateManyWithoutDepartmentNestedInput
    offeredCourses?: OfferedCourseUpdateManyWithoutAcademicDepartmentNestedInput
  }

  export type AcademicDepartmentUncheckedUpdateWithoutFacultiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    academicFacultyId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    departmentHeadId?: NullableStringFieldUpdateOperationsInput | string | null
    students?: StudentUncheckedUpdateOneWithoutAcademicDepartmentNestedInput
    staffMembers?: UsersUncheckedUpdateManyWithoutStaffDepartmentsNestedInput
    admitionExame?: AdmitionExameRegistrationUncheckedUpdateManyWithoutDepartmentNestedInput
    offeredCourses?: OfferedCourseUncheckedUpdateManyWithoutAcademicDepartmentNestedInput
  }

  export type AcademicFacultyUpsertWithoutFacultiesInput = {
    update: XOR<AcademicFacultyUpdateWithoutFacultiesInput, AcademicFacultyUncheckedUpdateWithoutFacultiesInput>
    create: XOR<AcademicFacultyCreateWithoutFacultiesInput, AcademicFacultyUncheckedCreateWithoutFacultiesInput>
    where?: AcademicFacultyWhereInput
  }

  export type AcademicFacultyUpdateToOneWithWhereWithoutFacultiesInput = {
    where?: AcademicFacultyWhereInput
    data: XOR<AcademicFacultyUpdateWithoutFacultiesInput, AcademicFacultyUncheckedUpdateWithoutFacultiesInput>
  }

  export type AcademicFacultyUpdateWithoutFacultiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    academicDepartments?: AcademicDepartmentUpdateOneWithoutAcademicFacultyNestedInput
    students?: StudentUpdateOneWithoutAcademicFacultyNestedInput
  }

  export type AcademicFacultyUncheckedUpdateWithoutFacultiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    academicDepartments?: AcademicDepartmentUncheckedUpdateOneWithoutAcademicFacultyNestedInput
    students?: StudentUncheckedUpdateOneWithoutAcademicFacultyNestedInput
  }

  export type OfferedCourseClassScheduleUpsertWithWhereUniqueWithoutFacultyInput = {
    where: OfferedCourseClassScheduleWhereUniqueInput
    update: XOR<OfferedCourseClassScheduleUpdateWithoutFacultyInput, OfferedCourseClassScheduleUncheckedUpdateWithoutFacultyInput>
    create: XOR<OfferedCourseClassScheduleCreateWithoutFacultyInput, OfferedCourseClassScheduleUncheckedCreateWithoutFacultyInput>
  }

  export type OfferedCourseClassScheduleUpdateWithWhereUniqueWithoutFacultyInput = {
    where: OfferedCourseClassScheduleWhereUniqueInput
    data: XOR<OfferedCourseClassScheduleUpdateWithoutFacultyInput, OfferedCourseClassScheduleUncheckedUpdateWithoutFacultyInput>
  }

  export type OfferedCourseClassScheduleUpdateManyWithWhereWithoutFacultyInput = {
    where: OfferedCourseClassScheduleScalarWhereInput
    data: XOR<OfferedCourseClassScheduleUpdateManyMutationInput, OfferedCourseClassScheduleUncheckedUpdateManyWithoutFacultyInput>
  }

  export type OfferedCourseClassScheduleScalarWhereInput = {
    AND?: OfferedCourseClassScheduleScalarWhereInput | OfferedCourseClassScheduleScalarWhereInput[]
    OR?: OfferedCourseClassScheduleScalarWhereInput[]
    NOT?: OfferedCourseClassScheduleScalarWhereInput | OfferedCourseClassScheduleScalarWhereInput[]
    id?: StringFilter<"OfferedCourseClassSchedule"> | string
    startTime?: StringFilter<"OfferedCourseClassSchedule"> | string
    endTime?: StringFilter<"OfferedCourseClassSchedule"> | string
    dayOfWeek?: EnumWeekDaysFilter<"OfferedCourseClassSchedule"> | $Enums.WeekDays
    createdAt?: DateTimeFilter<"OfferedCourseClassSchedule"> | Date | string
    updatedAt?: DateTimeFilter<"OfferedCourseClassSchedule"> | Date | string
    offeredCourseSectionId?: StringFilter<"OfferedCourseClassSchedule"> | string
    semesterRegistrationId?: StringFilter<"OfferedCourseClassSchedule"> | string
    roomId?: StringFilter<"OfferedCourseClassSchedule"> | string
    facultyId?: StringFilter<"OfferedCourseClassSchedule"> | string
  }

  export type RoomCreateWithoutBuildingInput = {
    id?: string
    roomNumber: string
    floor: string
    createdAt?: Date | string
    updatedAt?: Date | string
    offeredCourseClassSchedules?: OfferedCourseClassScheduleCreateNestedManyWithoutRoomInput
  }

  export type RoomUncheckedCreateWithoutBuildingInput = {
    id?: string
    roomNumber: string
    floor: string
    createdAt?: Date | string
    updatedAt?: Date | string
    offeredCourseClassSchedules?: OfferedCourseClassScheduleUncheckedCreateNestedManyWithoutRoomInput
  }

  export type RoomCreateOrConnectWithoutBuildingInput = {
    where: RoomWhereUniqueInput
    create: XOR<RoomCreateWithoutBuildingInput, RoomUncheckedCreateWithoutBuildingInput>
  }

  export type RoomCreateManyBuildingInputEnvelope = {
    data: RoomCreateManyBuildingInput | RoomCreateManyBuildingInput[]
    skipDuplicates?: boolean
  }

  export type RoomUpsertWithWhereUniqueWithoutBuildingInput = {
    where: RoomWhereUniqueInput
    update: XOR<RoomUpdateWithoutBuildingInput, RoomUncheckedUpdateWithoutBuildingInput>
    create: XOR<RoomCreateWithoutBuildingInput, RoomUncheckedCreateWithoutBuildingInput>
  }

  export type RoomUpdateWithWhereUniqueWithoutBuildingInput = {
    where: RoomWhereUniqueInput
    data: XOR<RoomUpdateWithoutBuildingInput, RoomUncheckedUpdateWithoutBuildingInput>
  }

  export type RoomUpdateManyWithWhereWithoutBuildingInput = {
    where: RoomScalarWhereInput
    data: XOR<RoomUpdateManyMutationInput, RoomUncheckedUpdateManyWithoutBuildingInput>
  }

  export type RoomScalarWhereInput = {
    AND?: RoomScalarWhereInput | RoomScalarWhereInput[]
    OR?: RoomScalarWhereInput[]
    NOT?: RoomScalarWhereInput | RoomScalarWhereInput[]
    id?: StringFilter<"Room"> | string
    roomNumber?: StringFilter<"Room"> | string
    floor?: StringFilter<"Room"> | string
    buildingId?: StringFilter<"Room"> | string
    createdAt?: DateTimeFilter<"Room"> | Date | string
    updatedAt?: DateTimeFilter<"Room"> | Date | string
  }

  export type BuildingCreateWithoutRoomsInput = {
    id?: string
    title: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BuildingUncheckedCreateWithoutRoomsInput = {
    id?: string
    title: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BuildingCreateOrConnectWithoutRoomsInput = {
    where: BuildingWhereUniqueInput
    create: XOR<BuildingCreateWithoutRoomsInput, BuildingUncheckedCreateWithoutRoomsInput>
  }

  export type OfferedCourseClassScheduleCreateWithoutRoomInput = {
    id?: string
    startTime: string
    endTime: string
    dayOfWeek?: $Enums.WeekDays
    createdAt?: Date | string
    updatedAt?: Date | string
    offeredCourseSection: OfferedCourseSectionCreateNestedOneWithoutOfferedCourseClassSchedulesInput
    semesterRegistration: SemesterRegistrationCreateNestedOneWithoutOfferedCourseClassSchedulesInput
    faculty: FacultyCreateNestedOneWithoutOfferedCourseClassSchedulesInput
  }

  export type OfferedCourseClassScheduleUncheckedCreateWithoutRoomInput = {
    id?: string
    startTime: string
    endTime: string
    dayOfWeek?: $Enums.WeekDays
    createdAt?: Date | string
    updatedAt?: Date | string
    offeredCourseSectionId: string
    semesterRegistrationId: string
    facultyId: string
  }

  export type OfferedCourseClassScheduleCreateOrConnectWithoutRoomInput = {
    where: OfferedCourseClassScheduleWhereUniqueInput
    create: XOR<OfferedCourseClassScheduleCreateWithoutRoomInput, OfferedCourseClassScheduleUncheckedCreateWithoutRoomInput>
  }

  export type OfferedCourseClassScheduleCreateManyRoomInputEnvelope = {
    data: OfferedCourseClassScheduleCreateManyRoomInput | OfferedCourseClassScheduleCreateManyRoomInput[]
    skipDuplicates?: boolean
  }

  export type BuildingUpsertWithoutRoomsInput = {
    update: XOR<BuildingUpdateWithoutRoomsInput, BuildingUncheckedUpdateWithoutRoomsInput>
    create: XOR<BuildingCreateWithoutRoomsInput, BuildingUncheckedCreateWithoutRoomsInput>
    where?: BuildingWhereInput
  }

  export type BuildingUpdateToOneWithWhereWithoutRoomsInput = {
    where?: BuildingWhereInput
    data: XOR<BuildingUpdateWithoutRoomsInput, BuildingUncheckedUpdateWithoutRoomsInput>
  }

  export type BuildingUpdateWithoutRoomsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BuildingUncheckedUpdateWithoutRoomsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OfferedCourseClassScheduleUpsertWithWhereUniqueWithoutRoomInput = {
    where: OfferedCourseClassScheduleWhereUniqueInput
    update: XOR<OfferedCourseClassScheduleUpdateWithoutRoomInput, OfferedCourseClassScheduleUncheckedUpdateWithoutRoomInput>
    create: XOR<OfferedCourseClassScheduleCreateWithoutRoomInput, OfferedCourseClassScheduleUncheckedCreateWithoutRoomInput>
  }

  export type OfferedCourseClassScheduleUpdateWithWhereUniqueWithoutRoomInput = {
    where: OfferedCourseClassScheduleWhereUniqueInput
    data: XOR<OfferedCourseClassScheduleUpdateWithoutRoomInput, OfferedCourseClassScheduleUncheckedUpdateWithoutRoomInput>
  }

  export type OfferedCourseClassScheduleUpdateManyWithWhereWithoutRoomInput = {
    where: OfferedCourseClassScheduleScalarWhereInput
    data: XOR<OfferedCourseClassScheduleUpdateManyMutationInput, OfferedCourseClassScheduleUncheckedUpdateManyWithoutRoomInput>
  }

  export type CourseToPreRequisiteCreateWithoutCourseInput = {
    preRequisite: CourseCreateNestedOneWithoutPreRequisiteForInput
  }

  export type CourseToPreRequisiteUncheckedCreateWithoutCourseInput = {
    preRequisiteId: string
  }

  export type CourseToPreRequisiteCreateOrConnectWithoutCourseInput = {
    where: CourseToPreRequisiteWhereUniqueInput
    create: XOR<CourseToPreRequisiteCreateWithoutCourseInput, CourseToPreRequisiteUncheckedCreateWithoutCourseInput>
  }

  export type CourseToPreRequisiteCreateManyCourseInputEnvelope = {
    data: CourseToPreRequisiteCreateManyCourseInput | CourseToPreRequisiteCreateManyCourseInput[]
    skipDuplicates?: boolean
  }

  export type CourseToPreRequisiteCreateWithoutPreRequisiteInput = {
    course: CourseCreateNestedOneWithoutPreRequisiteInput
  }

  export type CourseToPreRequisiteUncheckedCreateWithoutPreRequisiteInput = {
    courseId: string
  }

  export type CourseToPreRequisiteCreateOrConnectWithoutPreRequisiteInput = {
    where: CourseToPreRequisiteWhereUniqueInput
    create: XOR<CourseToPreRequisiteCreateWithoutPreRequisiteInput, CourseToPreRequisiteUncheckedCreateWithoutPreRequisiteInput>
  }

  export type CourseToPreRequisiteCreateManyPreRequisiteInputEnvelope = {
    data: CourseToPreRequisiteCreateManyPreRequisiteInput | CourseToPreRequisiteCreateManyPreRequisiteInput[]
    skipDuplicates?: boolean
  }

  export type CourseFacultyCreateWithoutCourseInput = {
    faculty: FacultyCreateNestedOneWithoutCoursesInput
  }

  export type CourseFacultyUncheckedCreateWithoutCourseInput = {
    facultyId: string
  }

  export type CourseFacultyCreateOrConnectWithoutCourseInput = {
    where: CourseFacultyWhereUniqueInput
    create: XOR<CourseFacultyCreateWithoutCourseInput, CourseFacultyUncheckedCreateWithoutCourseInput>
  }

  export type CourseFacultyCreateManyCourseInputEnvelope = {
    data: CourseFacultyCreateManyCourseInput | CourseFacultyCreateManyCourseInput[]
    skipDuplicates?: boolean
  }

  export type OfferedCourseCreateWithoutCourseInput = {
    id?: string
    academicDepartment: AcademicDepartmentCreateNestedOneWithoutOfferedCoursesInput
    semesterRegistration: SemesterRegistrationCreateNestedOneWithoutOfferedCoursesInput
    offeredCourseSections?: OfferedCourseSectionCreateNestedManyWithoutOfferedCourseInput
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseCreateNestedManyWithoutOfferedCourseInput
  }

  export type OfferedCourseUncheckedCreateWithoutCourseInput = {
    id?: string
    academicDepartmentId: string
    semesterRegistrationId: string
    offeredCourseSections?: OfferedCourseSectionUncheckedCreateNestedManyWithoutOfferedCourseInput
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseUncheckedCreateNestedManyWithoutOfferedCourseInput
  }

  export type OfferedCourseCreateOrConnectWithoutCourseInput = {
    where: OfferedCourseWhereUniqueInput
    create: XOR<OfferedCourseCreateWithoutCourseInput, OfferedCourseUncheckedCreateWithoutCourseInput>
  }

  export type OfferedCourseCreateManyCourseInputEnvelope = {
    data: OfferedCourseCreateManyCourseInput | OfferedCourseCreateManyCourseInput[]
    skipDuplicates?: boolean
  }

  export type StudentEnrolledCourseCreateWithoutCourseInput = {
    id?: string
    grade?: string | null
    point?: number | null
    totalMarks?: number | null
    status?: $Enums.StudentEnrolledCourseStatus | null
    createdAt?: Date | string
    updatedAt?: Date | string
    student: StudentCreateNestedOneWithoutStudentEnrolledCoursesInput
    academicSemester: AcademicSemesterCreateNestedOneWithoutStudentEnrolledCoursesInput
    studentEnrolledCourseMarks?: StudentEnrolledCourseMarkCreateNestedManyWithoutStudentEnrolledCourseInput
  }

  export type StudentEnrolledCourseUncheckedCreateWithoutCourseInput = {
    id?: string
    grade?: string | null
    point?: number | null
    totalMarks?: number | null
    status?: $Enums.StudentEnrolledCourseStatus | null
    createdAt?: Date | string
    updatedAt?: Date | string
    studentId: string
    academicSemesterId: string
    studentEnrolledCourseMarks?: StudentEnrolledCourseMarkUncheckedCreateNestedManyWithoutStudentEnrolledCourseInput
  }

  export type StudentEnrolledCourseCreateOrConnectWithoutCourseInput = {
    where: StudentEnrolledCourseWhereUniqueInput
    create: XOR<StudentEnrolledCourseCreateWithoutCourseInput, StudentEnrolledCourseUncheckedCreateWithoutCourseInput>
  }

  export type StudentEnrolledCourseCreateManyCourseInputEnvelope = {
    data: StudentEnrolledCourseCreateManyCourseInput | StudentEnrolledCourseCreateManyCourseInput[]
    skipDuplicates?: boolean
  }

  export type CourseToPreRequisiteUpsertWithWhereUniqueWithoutCourseInput = {
    where: CourseToPreRequisiteWhereUniqueInput
    update: XOR<CourseToPreRequisiteUpdateWithoutCourseInput, CourseToPreRequisiteUncheckedUpdateWithoutCourseInput>
    create: XOR<CourseToPreRequisiteCreateWithoutCourseInput, CourseToPreRequisiteUncheckedCreateWithoutCourseInput>
  }

  export type CourseToPreRequisiteUpdateWithWhereUniqueWithoutCourseInput = {
    where: CourseToPreRequisiteWhereUniqueInput
    data: XOR<CourseToPreRequisiteUpdateWithoutCourseInput, CourseToPreRequisiteUncheckedUpdateWithoutCourseInput>
  }

  export type CourseToPreRequisiteUpdateManyWithWhereWithoutCourseInput = {
    where: CourseToPreRequisiteScalarWhereInput
    data: XOR<CourseToPreRequisiteUpdateManyMutationInput, CourseToPreRequisiteUncheckedUpdateManyWithoutCourseInput>
  }

  export type CourseToPreRequisiteScalarWhereInput = {
    AND?: CourseToPreRequisiteScalarWhereInput | CourseToPreRequisiteScalarWhereInput[]
    OR?: CourseToPreRequisiteScalarWhereInput[]
    NOT?: CourseToPreRequisiteScalarWhereInput | CourseToPreRequisiteScalarWhereInput[]
    courseId?: StringFilter<"CourseToPreRequisite"> | string
    preRequisiteId?: StringFilter<"CourseToPreRequisite"> | string
  }

  export type CourseToPreRequisiteUpsertWithWhereUniqueWithoutPreRequisiteInput = {
    where: CourseToPreRequisiteWhereUniqueInput
    update: XOR<CourseToPreRequisiteUpdateWithoutPreRequisiteInput, CourseToPreRequisiteUncheckedUpdateWithoutPreRequisiteInput>
    create: XOR<CourseToPreRequisiteCreateWithoutPreRequisiteInput, CourseToPreRequisiteUncheckedCreateWithoutPreRequisiteInput>
  }

  export type CourseToPreRequisiteUpdateWithWhereUniqueWithoutPreRequisiteInput = {
    where: CourseToPreRequisiteWhereUniqueInput
    data: XOR<CourseToPreRequisiteUpdateWithoutPreRequisiteInput, CourseToPreRequisiteUncheckedUpdateWithoutPreRequisiteInput>
  }

  export type CourseToPreRequisiteUpdateManyWithWhereWithoutPreRequisiteInput = {
    where: CourseToPreRequisiteScalarWhereInput
    data: XOR<CourseToPreRequisiteUpdateManyMutationInput, CourseToPreRequisiteUncheckedUpdateManyWithoutPreRequisiteInput>
  }

  export type CourseFacultyUpsertWithWhereUniqueWithoutCourseInput = {
    where: CourseFacultyWhereUniqueInput
    update: XOR<CourseFacultyUpdateWithoutCourseInput, CourseFacultyUncheckedUpdateWithoutCourseInput>
    create: XOR<CourseFacultyCreateWithoutCourseInput, CourseFacultyUncheckedCreateWithoutCourseInput>
  }

  export type CourseFacultyUpdateWithWhereUniqueWithoutCourseInput = {
    where: CourseFacultyWhereUniqueInput
    data: XOR<CourseFacultyUpdateWithoutCourseInput, CourseFacultyUncheckedUpdateWithoutCourseInput>
  }

  export type CourseFacultyUpdateManyWithWhereWithoutCourseInput = {
    where: CourseFacultyScalarWhereInput
    data: XOR<CourseFacultyUpdateManyMutationInput, CourseFacultyUncheckedUpdateManyWithoutCourseInput>
  }

  export type OfferedCourseUpsertWithWhereUniqueWithoutCourseInput = {
    where: OfferedCourseWhereUniqueInput
    update: XOR<OfferedCourseUpdateWithoutCourseInput, OfferedCourseUncheckedUpdateWithoutCourseInput>
    create: XOR<OfferedCourseCreateWithoutCourseInput, OfferedCourseUncheckedCreateWithoutCourseInput>
  }

  export type OfferedCourseUpdateWithWhereUniqueWithoutCourseInput = {
    where: OfferedCourseWhereUniqueInput
    data: XOR<OfferedCourseUpdateWithoutCourseInput, OfferedCourseUncheckedUpdateWithoutCourseInput>
  }

  export type OfferedCourseUpdateManyWithWhereWithoutCourseInput = {
    where: OfferedCourseScalarWhereInput
    data: XOR<OfferedCourseUpdateManyMutationInput, OfferedCourseUncheckedUpdateManyWithoutCourseInput>
  }

  export type StudentEnrolledCourseUpsertWithWhereUniqueWithoutCourseInput = {
    where: StudentEnrolledCourseWhereUniqueInput
    update: XOR<StudentEnrolledCourseUpdateWithoutCourseInput, StudentEnrolledCourseUncheckedUpdateWithoutCourseInput>
    create: XOR<StudentEnrolledCourseCreateWithoutCourseInput, StudentEnrolledCourseUncheckedCreateWithoutCourseInput>
  }

  export type StudentEnrolledCourseUpdateWithWhereUniqueWithoutCourseInput = {
    where: StudentEnrolledCourseWhereUniqueInput
    data: XOR<StudentEnrolledCourseUpdateWithoutCourseInput, StudentEnrolledCourseUncheckedUpdateWithoutCourseInput>
  }

  export type StudentEnrolledCourseUpdateManyWithWhereWithoutCourseInput = {
    where: StudentEnrolledCourseScalarWhereInput
    data: XOR<StudentEnrolledCourseUpdateManyMutationInput, StudentEnrolledCourseUncheckedUpdateManyWithoutCourseInput>
  }

  export type CourseCreateWithoutPreRequisiteInput = {
    id?: string
    title: string
    code: string
    credits?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    preRequisiteFor?: CourseToPreRequisiteCreateNestedManyWithoutPreRequisiteInput
    faculties?: CourseFacultyCreateNestedManyWithoutCourseInput
    offeredCourses?: OfferedCourseCreateNestedManyWithoutCourseInput
    studentEnrolledCourses?: StudentEnrolledCourseCreateNestedManyWithoutCourseInput
  }

  export type CourseUncheckedCreateWithoutPreRequisiteInput = {
    id?: string
    title: string
    code: string
    credits?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    preRequisiteFor?: CourseToPreRequisiteUncheckedCreateNestedManyWithoutPreRequisiteInput
    faculties?: CourseFacultyUncheckedCreateNestedManyWithoutCourseInput
    offeredCourses?: OfferedCourseUncheckedCreateNestedManyWithoutCourseInput
    studentEnrolledCourses?: StudentEnrolledCourseUncheckedCreateNestedManyWithoutCourseInput
  }

  export type CourseCreateOrConnectWithoutPreRequisiteInput = {
    where: CourseWhereUniqueInput
    create: XOR<CourseCreateWithoutPreRequisiteInput, CourseUncheckedCreateWithoutPreRequisiteInput>
  }

  export type CourseCreateWithoutPreRequisiteForInput = {
    id?: string
    title: string
    code: string
    credits?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    preRequisite?: CourseToPreRequisiteCreateNestedManyWithoutCourseInput
    faculties?: CourseFacultyCreateNestedManyWithoutCourseInput
    offeredCourses?: OfferedCourseCreateNestedManyWithoutCourseInput
    studentEnrolledCourses?: StudentEnrolledCourseCreateNestedManyWithoutCourseInput
  }

  export type CourseUncheckedCreateWithoutPreRequisiteForInput = {
    id?: string
    title: string
    code: string
    credits?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    preRequisite?: CourseToPreRequisiteUncheckedCreateNestedManyWithoutCourseInput
    faculties?: CourseFacultyUncheckedCreateNestedManyWithoutCourseInput
    offeredCourses?: OfferedCourseUncheckedCreateNestedManyWithoutCourseInput
    studentEnrolledCourses?: StudentEnrolledCourseUncheckedCreateNestedManyWithoutCourseInput
  }

  export type CourseCreateOrConnectWithoutPreRequisiteForInput = {
    where: CourseWhereUniqueInput
    create: XOR<CourseCreateWithoutPreRequisiteForInput, CourseUncheckedCreateWithoutPreRequisiteForInput>
  }

  export type CourseUpsertWithoutPreRequisiteInput = {
    update: XOR<CourseUpdateWithoutPreRequisiteInput, CourseUncheckedUpdateWithoutPreRequisiteInput>
    create: XOR<CourseCreateWithoutPreRequisiteInput, CourseUncheckedCreateWithoutPreRequisiteInput>
    where?: CourseWhereInput
  }

  export type CourseUpdateToOneWithWhereWithoutPreRequisiteInput = {
    where?: CourseWhereInput
    data: XOR<CourseUpdateWithoutPreRequisiteInput, CourseUncheckedUpdateWithoutPreRequisiteInput>
  }

  export type CourseUpdateWithoutPreRequisiteInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    credits?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    preRequisiteFor?: CourseToPreRequisiteUpdateManyWithoutPreRequisiteNestedInput
    faculties?: CourseFacultyUpdateManyWithoutCourseNestedInput
    offeredCourses?: OfferedCourseUpdateManyWithoutCourseNestedInput
    studentEnrolledCourses?: StudentEnrolledCourseUpdateManyWithoutCourseNestedInput
  }

  export type CourseUncheckedUpdateWithoutPreRequisiteInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    credits?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    preRequisiteFor?: CourseToPreRequisiteUncheckedUpdateManyWithoutPreRequisiteNestedInput
    faculties?: CourseFacultyUncheckedUpdateManyWithoutCourseNestedInput
    offeredCourses?: OfferedCourseUncheckedUpdateManyWithoutCourseNestedInput
    studentEnrolledCourses?: StudentEnrolledCourseUncheckedUpdateManyWithoutCourseNestedInput
  }

  export type CourseUpsertWithoutPreRequisiteForInput = {
    update: XOR<CourseUpdateWithoutPreRequisiteForInput, CourseUncheckedUpdateWithoutPreRequisiteForInput>
    create: XOR<CourseCreateWithoutPreRequisiteForInput, CourseUncheckedCreateWithoutPreRequisiteForInput>
    where?: CourseWhereInput
  }

  export type CourseUpdateToOneWithWhereWithoutPreRequisiteForInput = {
    where?: CourseWhereInput
    data: XOR<CourseUpdateWithoutPreRequisiteForInput, CourseUncheckedUpdateWithoutPreRequisiteForInput>
  }

  export type CourseUpdateWithoutPreRequisiteForInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    credits?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    preRequisite?: CourseToPreRequisiteUpdateManyWithoutCourseNestedInput
    faculties?: CourseFacultyUpdateManyWithoutCourseNestedInput
    offeredCourses?: OfferedCourseUpdateManyWithoutCourseNestedInput
    studentEnrolledCourses?: StudentEnrolledCourseUpdateManyWithoutCourseNestedInput
  }

  export type CourseUncheckedUpdateWithoutPreRequisiteForInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    credits?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    preRequisite?: CourseToPreRequisiteUncheckedUpdateManyWithoutCourseNestedInput
    faculties?: CourseFacultyUncheckedUpdateManyWithoutCourseNestedInput
    offeredCourses?: OfferedCourseUncheckedUpdateManyWithoutCourseNestedInput
    studentEnrolledCourses?: StudentEnrolledCourseUncheckedUpdateManyWithoutCourseNestedInput
  }

  export type CourseCreateWithoutFacultiesInput = {
    id?: string
    title: string
    code: string
    credits?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    preRequisite?: CourseToPreRequisiteCreateNestedManyWithoutCourseInput
    preRequisiteFor?: CourseToPreRequisiteCreateNestedManyWithoutPreRequisiteInput
    offeredCourses?: OfferedCourseCreateNestedManyWithoutCourseInput
    studentEnrolledCourses?: StudentEnrolledCourseCreateNestedManyWithoutCourseInput
  }

  export type CourseUncheckedCreateWithoutFacultiesInput = {
    id?: string
    title: string
    code: string
    credits?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    preRequisite?: CourseToPreRequisiteUncheckedCreateNestedManyWithoutCourseInput
    preRequisiteFor?: CourseToPreRequisiteUncheckedCreateNestedManyWithoutPreRequisiteInput
    offeredCourses?: OfferedCourseUncheckedCreateNestedManyWithoutCourseInput
    studentEnrolledCourses?: StudentEnrolledCourseUncheckedCreateNestedManyWithoutCourseInput
  }

  export type CourseCreateOrConnectWithoutFacultiesInput = {
    where: CourseWhereUniqueInput
    create: XOR<CourseCreateWithoutFacultiesInput, CourseUncheckedCreateWithoutFacultiesInput>
  }

  export type FacultyCreateWithoutCoursesInput = {
    id?: string
    facultyId: string
    firstName: string
    middleName?: string | null
    lastName: string
    profileImage?: string | null
    email?: string | null
    contactNo?: string | null
    gender: string
    designation: string
    password: string
    createdAt?: Date | string
    updatedAt?: Date | string
    academicDepartment: AcademicDepartmentCreateNestedOneWithoutFacultiesInput
    academicFaculty: AcademicFacultyCreateNestedOneWithoutFacultiesInput
    offeredCourseClassSchedules?: OfferedCourseClassScheduleCreateNestedManyWithoutFacultyInput
  }

  export type FacultyUncheckedCreateWithoutCoursesInput = {
    id?: string
    facultyId: string
    firstName: string
    middleName?: string | null
    lastName: string
    profileImage?: string | null
    email?: string | null
    contactNo?: string | null
    gender: string
    designation: string
    password: string
    academicFacultyId: string
    academicDepartmentId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    offeredCourseClassSchedules?: OfferedCourseClassScheduleUncheckedCreateNestedManyWithoutFacultyInput
  }

  export type FacultyCreateOrConnectWithoutCoursesInput = {
    where: FacultyWhereUniqueInput
    create: XOR<FacultyCreateWithoutCoursesInput, FacultyUncheckedCreateWithoutCoursesInput>
  }

  export type CourseUpsertWithoutFacultiesInput = {
    update: XOR<CourseUpdateWithoutFacultiesInput, CourseUncheckedUpdateWithoutFacultiesInput>
    create: XOR<CourseCreateWithoutFacultiesInput, CourseUncheckedCreateWithoutFacultiesInput>
    where?: CourseWhereInput
  }

  export type CourseUpdateToOneWithWhereWithoutFacultiesInput = {
    where?: CourseWhereInput
    data: XOR<CourseUpdateWithoutFacultiesInput, CourseUncheckedUpdateWithoutFacultiesInput>
  }

  export type CourseUpdateWithoutFacultiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    credits?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    preRequisite?: CourseToPreRequisiteUpdateManyWithoutCourseNestedInput
    preRequisiteFor?: CourseToPreRequisiteUpdateManyWithoutPreRequisiteNestedInput
    offeredCourses?: OfferedCourseUpdateManyWithoutCourseNestedInput
    studentEnrolledCourses?: StudentEnrolledCourseUpdateManyWithoutCourseNestedInput
  }

  export type CourseUncheckedUpdateWithoutFacultiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    credits?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    preRequisite?: CourseToPreRequisiteUncheckedUpdateManyWithoutCourseNestedInput
    preRequisiteFor?: CourseToPreRequisiteUncheckedUpdateManyWithoutPreRequisiteNestedInput
    offeredCourses?: OfferedCourseUncheckedUpdateManyWithoutCourseNestedInput
    studentEnrolledCourses?: StudentEnrolledCourseUncheckedUpdateManyWithoutCourseNestedInput
  }

  export type FacultyUpsertWithoutCoursesInput = {
    update: XOR<FacultyUpdateWithoutCoursesInput, FacultyUncheckedUpdateWithoutCoursesInput>
    create: XOR<FacultyCreateWithoutCoursesInput, FacultyUncheckedCreateWithoutCoursesInput>
    where?: FacultyWhereInput
  }

  export type FacultyUpdateToOneWithWhereWithoutCoursesInput = {
    where?: FacultyWhereInput
    data: XOR<FacultyUpdateWithoutCoursesInput, FacultyUncheckedUpdateWithoutCoursesInput>
  }

  export type FacultyUpdateWithoutCoursesInput = {
    id?: StringFieldUpdateOperationsInput | string
    facultyId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    contactNo?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: StringFieldUpdateOperationsInput | string
    designation?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    academicDepartment?: AcademicDepartmentUpdateOneRequiredWithoutFacultiesNestedInput
    academicFaculty?: AcademicFacultyUpdateOneRequiredWithoutFacultiesNestedInput
    offeredCourseClassSchedules?: OfferedCourseClassScheduleUpdateManyWithoutFacultyNestedInput
  }

  export type FacultyUncheckedUpdateWithoutCoursesInput = {
    id?: StringFieldUpdateOperationsInput | string
    facultyId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    contactNo?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: StringFieldUpdateOperationsInput | string
    designation?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    academicFacultyId?: StringFieldUpdateOperationsInput | string
    academicDepartmentId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    offeredCourseClassSchedules?: OfferedCourseClassScheduleUncheckedUpdateManyWithoutFacultyNestedInput
  }

  export type AcademicSemesterCreateWithoutSemesterRegistrationsInput = {
    id?: string
    title: string
    year: string
    code: string
    startMonth: string
    endMonth: string
    isCurrent?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    students?: StudentCreateNestedOneWithoutAcademicSemesterInput
    studentEnrolledCourses?: StudentEnrolledCourseCreateNestedManyWithoutAcademicSemesterInput
    studentEnrolledCourseMarks?: StudentEnrolledCourseMarkCreateNestedManyWithoutAcademicSemesterInput
    studentSemesterPayments?: StudentSemesterPaymentCreateNestedManyWithoutAcademicSemesterInput
  }

  export type AcademicSemesterUncheckedCreateWithoutSemesterRegistrationsInput = {
    id?: string
    title: string
    year: string
    code: string
    startMonth: string
    endMonth: string
    isCurrent?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    students?: StudentUncheckedCreateNestedOneWithoutAcademicSemesterInput
    studentEnrolledCourses?: StudentEnrolledCourseUncheckedCreateNestedManyWithoutAcademicSemesterInput
    studentEnrolledCourseMarks?: StudentEnrolledCourseMarkUncheckedCreateNestedManyWithoutAcademicSemesterInput
    studentSemesterPayments?: StudentSemesterPaymentUncheckedCreateNestedManyWithoutAcademicSemesterInput
  }

  export type AcademicSemesterCreateOrConnectWithoutSemesterRegistrationsInput = {
    where: AcademicSemesterWhereUniqueInput
    create: XOR<AcademicSemesterCreateWithoutSemesterRegistrationsInput, AcademicSemesterUncheckedCreateWithoutSemesterRegistrationsInput>
  }

  export type OfferedCourseCreateWithoutSemesterRegistrationInput = {
    id?: string
    academicDepartment: AcademicDepartmentCreateNestedOneWithoutOfferedCoursesInput
    course: CourseCreateNestedOneWithoutOfferedCoursesInput
    offeredCourseSections?: OfferedCourseSectionCreateNestedManyWithoutOfferedCourseInput
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseCreateNestedManyWithoutOfferedCourseInput
  }

  export type OfferedCourseUncheckedCreateWithoutSemesterRegistrationInput = {
    id?: string
    academicDepartmentId: string
    courseId: string
    offeredCourseSections?: OfferedCourseSectionUncheckedCreateNestedManyWithoutOfferedCourseInput
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseUncheckedCreateNestedManyWithoutOfferedCourseInput
  }

  export type OfferedCourseCreateOrConnectWithoutSemesterRegistrationInput = {
    where: OfferedCourseWhereUniqueInput
    create: XOR<OfferedCourseCreateWithoutSemesterRegistrationInput, OfferedCourseUncheckedCreateWithoutSemesterRegistrationInput>
  }

  export type OfferedCourseCreateManySemesterRegistrationInputEnvelope = {
    data: OfferedCourseCreateManySemesterRegistrationInput | OfferedCourseCreateManySemesterRegistrationInput[]
    skipDuplicates?: boolean
  }

  export type OfferedCourseSectionCreateWithoutSemesterRegistrationInput = {
    id?: string
    title: string
    maxCapacity?: number
    currentlyEnrolledStudent?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    offeredCourse: OfferedCourseCreateNestedOneWithoutOfferedCourseSectionsInput
    offeredCourseClassSchedules?: OfferedCourseClassScheduleCreateNestedManyWithoutOfferedCourseSectionInput
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseCreateNestedManyWithoutOfferedCourseSectionInput
  }

  export type OfferedCourseSectionUncheckedCreateWithoutSemesterRegistrationInput = {
    id?: string
    title: string
    maxCapacity?: number
    currentlyEnrolledStudent?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    offeredCourseId: string
    offeredCourseClassSchedules?: OfferedCourseClassScheduleUncheckedCreateNestedManyWithoutOfferedCourseSectionInput
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseUncheckedCreateNestedManyWithoutOfferedCourseSectionInput
  }

  export type OfferedCourseSectionCreateOrConnectWithoutSemesterRegistrationInput = {
    where: OfferedCourseSectionWhereUniqueInput
    create: XOR<OfferedCourseSectionCreateWithoutSemesterRegistrationInput, OfferedCourseSectionUncheckedCreateWithoutSemesterRegistrationInput>
  }

  export type OfferedCourseSectionCreateManySemesterRegistrationInputEnvelope = {
    data: OfferedCourseSectionCreateManySemesterRegistrationInput | OfferedCourseSectionCreateManySemesterRegistrationInput[]
    skipDuplicates?: boolean
  }

  export type OfferedCourseClassScheduleCreateWithoutSemesterRegistrationInput = {
    id?: string
    startTime: string
    endTime: string
    dayOfWeek?: $Enums.WeekDays
    createdAt?: Date | string
    updatedAt?: Date | string
    offeredCourseSection: OfferedCourseSectionCreateNestedOneWithoutOfferedCourseClassSchedulesInput
    room: RoomCreateNestedOneWithoutOfferedCourseClassSchedulesInput
    faculty: FacultyCreateNestedOneWithoutOfferedCourseClassSchedulesInput
  }

  export type OfferedCourseClassScheduleUncheckedCreateWithoutSemesterRegistrationInput = {
    id?: string
    startTime: string
    endTime: string
    dayOfWeek?: $Enums.WeekDays
    createdAt?: Date | string
    updatedAt?: Date | string
    offeredCourseSectionId: string
    roomId: string
    facultyId: string
  }

  export type OfferedCourseClassScheduleCreateOrConnectWithoutSemesterRegistrationInput = {
    where: OfferedCourseClassScheduleWhereUniqueInput
    create: XOR<OfferedCourseClassScheduleCreateWithoutSemesterRegistrationInput, OfferedCourseClassScheduleUncheckedCreateWithoutSemesterRegistrationInput>
  }

  export type OfferedCourseClassScheduleCreateManySemesterRegistrationInputEnvelope = {
    data: OfferedCourseClassScheduleCreateManySemesterRegistrationInput | OfferedCourseClassScheduleCreateManySemesterRegistrationInput[]
    skipDuplicates?: boolean
  }

  export type StudentSemesterRegistrationCreateWithoutSemesterRegistrationInput = {
    id?: string
    isConfirmed?: boolean | null
    totalCreditsTaken?: number | null
    paymentRecipt?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    student: StudentCreateNestedOneWithoutStudentSemesterRegistrationsInput
  }

  export type StudentSemesterRegistrationUncheckedCreateWithoutSemesterRegistrationInput = {
    id?: string
    isConfirmed?: boolean | null
    totalCreditsTaken?: number | null
    paymentRecipt?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    studentId: string
  }

  export type StudentSemesterRegistrationCreateOrConnectWithoutSemesterRegistrationInput = {
    where: StudentSemesterRegistrationWhereUniqueInput
    create: XOR<StudentSemesterRegistrationCreateWithoutSemesterRegistrationInput, StudentSemesterRegistrationUncheckedCreateWithoutSemesterRegistrationInput>
  }

  export type StudentSemesterRegistrationCreateManySemesterRegistrationInputEnvelope = {
    data: StudentSemesterRegistrationCreateManySemesterRegistrationInput | StudentSemesterRegistrationCreateManySemesterRegistrationInput[]
    skipDuplicates?: boolean
  }

  export type StudentSemesterRegistrationCourseCreateWithoutSemesterRegistrationInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    student: StudentCreateNestedOneWithoutStudentSemesterRegistrationCoursesInput
    offeredCourse: OfferedCourseCreateNestedOneWithoutStudentSemesterRegistrationCoursesInput
    offeredCourseSection: OfferedCourseSectionCreateNestedOneWithoutStudentSemesterRegistrationCoursesInput
  }

  export type StudentSemesterRegistrationCourseUncheckedCreateWithoutSemesterRegistrationInput = {
    studentId: string
    offeredCourseId: string
    offeredCourseSectionId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StudentSemesterRegistrationCourseCreateOrConnectWithoutSemesterRegistrationInput = {
    where: StudentSemesterRegistrationCourseWhereUniqueInput
    create: XOR<StudentSemesterRegistrationCourseCreateWithoutSemesterRegistrationInput, StudentSemesterRegistrationCourseUncheckedCreateWithoutSemesterRegistrationInput>
  }

  export type StudentSemesterRegistrationCourseCreateManySemesterRegistrationInputEnvelope = {
    data: StudentSemesterRegistrationCourseCreateManySemesterRegistrationInput | StudentSemesterRegistrationCourseCreateManySemesterRegistrationInput[]
    skipDuplicates?: boolean
  }

  export type AcademicSemesterUpsertWithoutSemesterRegistrationsInput = {
    update: XOR<AcademicSemesterUpdateWithoutSemesterRegistrationsInput, AcademicSemesterUncheckedUpdateWithoutSemesterRegistrationsInput>
    create: XOR<AcademicSemesterCreateWithoutSemesterRegistrationsInput, AcademicSemesterUncheckedCreateWithoutSemesterRegistrationsInput>
    where?: AcademicSemesterWhereInput
  }

  export type AcademicSemesterUpdateToOneWithWhereWithoutSemesterRegistrationsInput = {
    where?: AcademicSemesterWhereInput
    data: XOR<AcademicSemesterUpdateWithoutSemesterRegistrationsInput, AcademicSemesterUncheckedUpdateWithoutSemesterRegistrationsInput>
  }

  export type AcademicSemesterUpdateWithoutSemesterRegistrationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    year?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    startMonth?: StringFieldUpdateOperationsInput | string
    endMonth?: StringFieldUpdateOperationsInput | string
    isCurrent?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    students?: StudentUpdateOneWithoutAcademicSemesterNestedInput
    studentEnrolledCourses?: StudentEnrolledCourseUpdateManyWithoutAcademicSemesterNestedInput
    studentEnrolledCourseMarks?: StudentEnrolledCourseMarkUpdateManyWithoutAcademicSemesterNestedInput
    studentSemesterPayments?: StudentSemesterPaymentUpdateManyWithoutAcademicSemesterNestedInput
  }

  export type AcademicSemesterUncheckedUpdateWithoutSemesterRegistrationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    year?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    startMonth?: StringFieldUpdateOperationsInput | string
    endMonth?: StringFieldUpdateOperationsInput | string
    isCurrent?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    students?: StudentUncheckedUpdateOneWithoutAcademicSemesterNestedInput
    studentEnrolledCourses?: StudentEnrolledCourseUncheckedUpdateManyWithoutAcademicSemesterNestedInput
    studentEnrolledCourseMarks?: StudentEnrolledCourseMarkUncheckedUpdateManyWithoutAcademicSemesterNestedInput
    studentSemesterPayments?: StudentSemesterPaymentUncheckedUpdateManyWithoutAcademicSemesterNestedInput
  }

  export type OfferedCourseUpsertWithWhereUniqueWithoutSemesterRegistrationInput = {
    where: OfferedCourseWhereUniqueInput
    update: XOR<OfferedCourseUpdateWithoutSemesterRegistrationInput, OfferedCourseUncheckedUpdateWithoutSemesterRegistrationInput>
    create: XOR<OfferedCourseCreateWithoutSemesterRegistrationInput, OfferedCourseUncheckedCreateWithoutSemesterRegistrationInput>
  }

  export type OfferedCourseUpdateWithWhereUniqueWithoutSemesterRegistrationInput = {
    where: OfferedCourseWhereUniqueInput
    data: XOR<OfferedCourseUpdateWithoutSemesterRegistrationInput, OfferedCourseUncheckedUpdateWithoutSemesterRegistrationInput>
  }

  export type OfferedCourseUpdateManyWithWhereWithoutSemesterRegistrationInput = {
    where: OfferedCourseScalarWhereInput
    data: XOR<OfferedCourseUpdateManyMutationInput, OfferedCourseUncheckedUpdateManyWithoutSemesterRegistrationInput>
  }

  export type OfferedCourseSectionUpsertWithWhereUniqueWithoutSemesterRegistrationInput = {
    where: OfferedCourseSectionWhereUniqueInput
    update: XOR<OfferedCourseSectionUpdateWithoutSemesterRegistrationInput, OfferedCourseSectionUncheckedUpdateWithoutSemesterRegistrationInput>
    create: XOR<OfferedCourseSectionCreateWithoutSemesterRegistrationInput, OfferedCourseSectionUncheckedCreateWithoutSemesterRegistrationInput>
  }

  export type OfferedCourseSectionUpdateWithWhereUniqueWithoutSemesterRegistrationInput = {
    where: OfferedCourseSectionWhereUniqueInput
    data: XOR<OfferedCourseSectionUpdateWithoutSemesterRegistrationInput, OfferedCourseSectionUncheckedUpdateWithoutSemesterRegistrationInput>
  }

  export type OfferedCourseSectionUpdateManyWithWhereWithoutSemesterRegistrationInput = {
    where: OfferedCourseSectionScalarWhereInput
    data: XOR<OfferedCourseSectionUpdateManyMutationInput, OfferedCourseSectionUncheckedUpdateManyWithoutSemesterRegistrationInput>
  }

  export type OfferedCourseSectionScalarWhereInput = {
    AND?: OfferedCourseSectionScalarWhereInput | OfferedCourseSectionScalarWhereInput[]
    OR?: OfferedCourseSectionScalarWhereInput[]
    NOT?: OfferedCourseSectionScalarWhereInput | OfferedCourseSectionScalarWhereInput[]
    id?: StringFilter<"OfferedCourseSection"> | string
    title?: StringFilter<"OfferedCourseSection"> | string
    maxCapacity?: IntFilter<"OfferedCourseSection"> | number
    currentlyEnrolledStudent?: IntFilter<"OfferedCourseSection"> | number
    createdAt?: DateTimeFilter<"OfferedCourseSection"> | Date | string
    updatedAt?: DateTimeFilter<"OfferedCourseSection"> | Date | string
    semesterRegistrationId?: StringFilter<"OfferedCourseSection"> | string
    offeredCourseId?: StringFilter<"OfferedCourseSection"> | string
  }

  export type OfferedCourseClassScheduleUpsertWithWhereUniqueWithoutSemesterRegistrationInput = {
    where: OfferedCourseClassScheduleWhereUniqueInput
    update: XOR<OfferedCourseClassScheduleUpdateWithoutSemesterRegistrationInput, OfferedCourseClassScheduleUncheckedUpdateWithoutSemesterRegistrationInput>
    create: XOR<OfferedCourseClassScheduleCreateWithoutSemesterRegistrationInput, OfferedCourseClassScheduleUncheckedCreateWithoutSemesterRegistrationInput>
  }

  export type OfferedCourseClassScheduleUpdateWithWhereUniqueWithoutSemesterRegistrationInput = {
    where: OfferedCourseClassScheduleWhereUniqueInput
    data: XOR<OfferedCourseClassScheduleUpdateWithoutSemesterRegistrationInput, OfferedCourseClassScheduleUncheckedUpdateWithoutSemesterRegistrationInput>
  }

  export type OfferedCourseClassScheduleUpdateManyWithWhereWithoutSemesterRegistrationInput = {
    where: OfferedCourseClassScheduleScalarWhereInput
    data: XOR<OfferedCourseClassScheduleUpdateManyMutationInput, OfferedCourseClassScheduleUncheckedUpdateManyWithoutSemesterRegistrationInput>
  }

  export type StudentSemesterRegistrationUpsertWithWhereUniqueWithoutSemesterRegistrationInput = {
    where: StudentSemesterRegistrationWhereUniqueInput
    update: XOR<StudentSemesterRegistrationUpdateWithoutSemesterRegistrationInput, StudentSemesterRegistrationUncheckedUpdateWithoutSemesterRegistrationInput>
    create: XOR<StudentSemesterRegistrationCreateWithoutSemesterRegistrationInput, StudentSemesterRegistrationUncheckedCreateWithoutSemesterRegistrationInput>
  }

  export type StudentSemesterRegistrationUpdateWithWhereUniqueWithoutSemesterRegistrationInput = {
    where: StudentSemesterRegistrationWhereUniqueInput
    data: XOR<StudentSemesterRegistrationUpdateWithoutSemesterRegistrationInput, StudentSemesterRegistrationUncheckedUpdateWithoutSemesterRegistrationInput>
  }

  export type StudentSemesterRegistrationUpdateManyWithWhereWithoutSemesterRegistrationInput = {
    where: StudentSemesterRegistrationScalarWhereInput
    data: XOR<StudentSemesterRegistrationUpdateManyMutationInput, StudentSemesterRegistrationUncheckedUpdateManyWithoutSemesterRegistrationInput>
  }

  export type StudentSemesterRegistrationCourseUpsertWithWhereUniqueWithoutSemesterRegistrationInput = {
    where: StudentSemesterRegistrationCourseWhereUniqueInput
    update: XOR<StudentSemesterRegistrationCourseUpdateWithoutSemesterRegistrationInput, StudentSemesterRegistrationCourseUncheckedUpdateWithoutSemesterRegistrationInput>
    create: XOR<StudentSemesterRegistrationCourseCreateWithoutSemesterRegistrationInput, StudentSemesterRegistrationCourseUncheckedCreateWithoutSemesterRegistrationInput>
  }

  export type StudentSemesterRegistrationCourseUpdateWithWhereUniqueWithoutSemesterRegistrationInput = {
    where: StudentSemesterRegistrationCourseWhereUniqueInput
    data: XOR<StudentSemesterRegistrationCourseUpdateWithoutSemesterRegistrationInput, StudentSemesterRegistrationCourseUncheckedUpdateWithoutSemesterRegistrationInput>
  }

  export type StudentSemesterRegistrationCourseUpdateManyWithWhereWithoutSemesterRegistrationInput = {
    where: StudentSemesterRegistrationCourseScalarWhereInput
    data: XOR<StudentSemesterRegistrationCourseUpdateManyMutationInput, StudentSemesterRegistrationCourseUncheckedUpdateManyWithoutSemesterRegistrationInput>
  }

  export type AcademicDepartmentCreateWithoutAdmitionExameInput = {
    id?: string
    title: string
    createdAt?: Date | string
    updatedAt?: Date | string
    academicFaculty: AcademicFacultyCreateNestedOneWithoutAcademicDepartmentsInput
    faculties?: FacultyCreateNestedOneWithoutAcademicDepartmentInput
    students?: StudentCreateNestedOneWithoutAcademicDepartmentInput
    departmentHead?: UsersCreateNestedOneWithoutAcademicDepartmentInput
    staffMembers?: UsersCreateNestedManyWithoutStaffDepartmentsInput
    offeredCourses?: OfferedCourseCreateNestedManyWithoutAcademicDepartmentInput
  }

  export type AcademicDepartmentUncheckedCreateWithoutAdmitionExameInput = {
    id?: string
    title: string
    academicFacultyId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    departmentHeadId?: string | null
    faculties?: FacultyUncheckedCreateNestedOneWithoutAcademicDepartmentInput
    students?: StudentUncheckedCreateNestedOneWithoutAcademicDepartmentInput
    staffMembers?: UsersUncheckedCreateNestedManyWithoutStaffDepartmentsInput
    offeredCourses?: OfferedCourseUncheckedCreateNestedManyWithoutAcademicDepartmentInput
  }

  export type AcademicDepartmentCreateOrConnectWithoutAdmitionExameInput = {
    where: AcademicDepartmentWhereUniqueInput
    create: XOR<AcademicDepartmentCreateWithoutAdmitionExameInput, AcademicDepartmentUncheckedCreateWithoutAdmitionExameInput>
  }

  export type StudentCreateWithoutAdmissionRegistrationInput = {
    id?: string
    studentId: string
    firstName: string
    middleName?: string | null
    lastName: string
    profileImage?: string | null
    email?: string | null
    contactNo?: string | null
    gender: string
    isWoker?: boolean
    shift?: $Enums.Shift
    password: string
    gradeDeclarationFile: string
    biFile: string
    presentAddress: string
    permanentAddress?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    academicDepartment: AcademicDepartmentCreateNestedOneWithoutStudentsInput
    academicFaculty: AcademicFacultyCreateNestedOneWithoutStudentsInput
    academicSemester: AcademicSemesterCreateNestedOneWithoutStudentsInput
    studentSemesterRegistrations?: StudentSemesterRegistrationCreateNestedManyWithoutStudentInput
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseCreateNestedManyWithoutStudentInput
    studentEnrolledCourses?: StudentEnrolledCourseCreateNestedManyWithoutStudentInput
    studentEnrolledCourseMarks?: StudentEnrolledCourseMarkCreateNestedManyWithoutStudentInput
    studentSemesterPayments?: StudentSemesterPaymentCreateNestedManyWithoutStudentInput
    studentAcademicInfos?: StudentAcademicInfoCreateNestedManyWithoutStudentInput
  }

  export type StudentUncheckedCreateWithoutAdmissionRegistrationInput = {
    id?: string
    studentId: string
    firstName: string
    middleName?: string | null
    lastName: string
    profileImage?: string | null
    email?: string | null
    contactNo?: string | null
    gender: string
    isWoker?: boolean
    shift?: $Enums.Shift
    password: string
    gradeDeclarationFile: string
    biFile: string
    presentAddress: string
    permanentAddress?: string | null
    academicSemesterId: string
    academicFacultyId: string
    academicDepartmentId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    studentSemesterRegistrations?: StudentSemesterRegistrationUncheckedCreateNestedManyWithoutStudentInput
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseUncheckedCreateNestedManyWithoutStudentInput
    studentEnrolledCourses?: StudentEnrolledCourseUncheckedCreateNestedManyWithoutStudentInput
    studentEnrolledCourseMarks?: StudentEnrolledCourseMarkUncheckedCreateNestedManyWithoutStudentInput
    studentSemesterPayments?: StudentSemesterPaymentUncheckedCreateNestedManyWithoutStudentInput
    studentAcademicInfos?: StudentAcademicInfoUncheckedCreateNestedManyWithoutStudentInput
  }

  export type StudentCreateOrConnectWithoutAdmissionRegistrationInput = {
    where: StudentWhereUniqueInput
    create: XOR<StudentCreateWithoutAdmissionRegistrationInput, StudentUncheckedCreateWithoutAdmissionRegistrationInput>
  }

  export type AcademicDepartmentUpsertWithoutAdmitionExameInput = {
    update: XOR<AcademicDepartmentUpdateWithoutAdmitionExameInput, AcademicDepartmentUncheckedUpdateWithoutAdmitionExameInput>
    create: XOR<AcademicDepartmentCreateWithoutAdmitionExameInput, AcademicDepartmentUncheckedCreateWithoutAdmitionExameInput>
    where?: AcademicDepartmentWhereInput
  }

  export type AcademicDepartmentUpdateToOneWithWhereWithoutAdmitionExameInput = {
    where?: AcademicDepartmentWhereInput
    data: XOR<AcademicDepartmentUpdateWithoutAdmitionExameInput, AcademicDepartmentUncheckedUpdateWithoutAdmitionExameInput>
  }

  export type AcademicDepartmentUpdateWithoutAdmitionExameInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    academicFaculty?: AcademicFacultyUpdateOneRequiredWithoutAcademicDepartmentsNestedInput
    faculties?: FacultyUpdateOneWithoutAcademicDepartmentNestedInput
    students?: StudentUpdateOneWithoutAcademicDepartmentNestedInput
    departmentHead?: UsersUpdateOneWithoutAcademicDepartmentNestedInput
    staffMembers?: UsersUpdateManyWithoutStaffDepartmentsNestedInput
    offeredCourses?: OfferedCourseUpdateManyWithoutAcademicDepartmentNestedInput
  }

  export type AcademicDepartmentUncheckedUpdateWithoutAdmitionExameInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    academicFacultyId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    departmentHeadId?: NullableStringFieldUpdateOperationsInput | string | null
    faculties?: FacultyUncheckedUpdateOneWithoutAcademicDepartmentNestedInput
    students?: StudentUncheckedUpdateOneWithoutAcademicDepartmentNestedInput
    staffMembers?: UsersUncheckedUpdateManyWithoutStaffDepartmentsNestedInput
    offeredCourses?: OfferedCourseUncheckedUpdateManyWithoutAcademicDepartmentNestedInput
  }

  export type StudentUpsertWithoutAdmissionRegistrationInput = {
    update: XOR<StudentUpdateWithoutAdmissionRegistrationInput, StudentUncheckedUpdateWithoutAdmissionRegistrationInput>
    create: XOR<StudentCreateWithoutAdmissionRegistrationInput, StudentUncheckedCreateWithoutAdmissionRegistrationInput>
    where?: StudentWhereInput
  }

  export type StudentUpdateToOneWithWhereWithoutAdmissionRegistrationInput = {
    where?: StudentWhereInput
    data: XOR<StudentUpdateWithoutAdmissionRegistrationInput, StudentUncheckedUpdateWithoutAdmissionRegistrationInput>
  }

  export type StudentUpdateWithoutAdmissionRegistrationInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    contactNo?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: StringFieldUpdateOperationsInput | string
    isWoker?: BoolFieldUpdateOperationsInput | boolean
    shift?: EnumShiftFieldUpdateOperationsInput | $Enums.Shift
    password?: StringFieldUpdateOperationsInput | string
    gradeDeclarationFile?: StringFieldUpdateOperationsInput | string
    biFile?: StringFieldUpdateOperationsInput | string
    presentAddress?: StringFieldUpdateOperationsInput | string
    permanentAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    academicDepartment?: AcademicDepartmentUpdateOneRequiredWithoutStudentsNestedInput
    academicFaculty?: AcademicFacultyUpdateOneRequiredWithoutStudentsNestedInput
    academicSemester?: AcademicSemesterUpdateOneRequiredWithoutStudentsNestedInput
    studentSemesterRegistrations?: StudentSemesterRegistrationUpdateManyWithoutStudentNestedInput
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseUpdateManyWithoutStudentNestedInput
    studentEnrolledCourses?: StudentEnrolledCourseUpdateManyWithoutStudentNestedInput
    studentEnrolledCourseMarks?: StudentEnrolledCourseMarkUpdateManyWithoutStudentNestedInput
    studentSemesterPayments?: StudentSemesterPaymentUpdateManyWithoutStudentNestedInput
    studentAcademicInfos?: StudentAcademicInfoUpdateManyWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateWithoutAdmissionRegistrationInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    contactNo?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: StringFieldUpdateOperationsInput | string
    isWoker?: BoolFieldUpdateOperationsInput | boolean
    shift?: EnumShiftFieldUpdateOperationsInput | $Enums.Shift
    password?: StringFieldUpdateOperationsInput | string
    gradeDeclarationFile?: StringFieldUpdateOperationsInput | string
    biFile?: StringFieldUpdateOperationsInput | string
    presentAddress?: StringFieldUpdateOperationsInput | string
    permanentAddress?: NullableStringFieldUpdateOperationsInput | string | null
    academicSemesterId?: StringFieldUpdateOperationsInput | string
    academicFacultyId?: StringFieldUpdateOperationsInput | string
    academicDepartmentId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    studentSemesterRegistrations?: StudentSemesterRegistrationUncheckedUpdateManyWithoutStudentNestedInput
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseUncheckedUpdateManyWithoutStudentNestedInput
    studentEnrolledCourses?: StudentEnrolledCourseUncheckedUpdateManyWithoutStudentNestedInput
    studentEnrolledCourseMarks?: StudentEnrolledCourseMarkUncheckedUpdateManyWithoutStudentNestedInput
    studentSemesterPayments?: StudentSemesterPaymentUncheckedUpdateManyWithoutStudentNestedInput
    studentAcademicInfos?: StudentAcademicInfoUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type AcademicDepartmentCreateWithoutOfferedCoursesInput = {
    id?: string
    title: string
    createdAt?: Date | string
    updatedAt?: Date | string
    academicFaculty: AcademicFacultyCreateNestedOneWithoutAcademicDepartmentsInput
    faculties?: FacultyCreateNestedOneWithoutAcademicDepartmentInput
    students?: StudentCreateNestedOneWithoutAcademicDepartmentInput
    departmentHead?: UsersCreateNestedOneWithoutAcademicDepartmentInput
    staffMembers?: UsersCreateNestedManyWithoutStaffDepartmentsInput
    admitionExame?: AdmitionExameRegistrationCreateNestedManyWithoutDepartmentInput
  }

  export type AcademicDepartmentUncheckedCreateWithoutOfferedCoursesInput = {
    id?: string
    title: string
    academicFacultyId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    departmentHeadId?: string | null
    faculties?: FacultyUncheckedCreateNestedOneWithoutAcademicDepartmentInput
    students?: StudentUncheckedCreateNestedOneWithoutAcademicDepartmentInput
    staffMembers?: UsersUncheckedCreateNestedManyWithoutStaffDepartmentsInput
    admitionExame?: AdmitionExameRegistrationUncheckedCreateNestedManyWithoutDepartmentInput
  }

  export type AcademicDepartmentCreateOrConnectWithoutOfferedCoursesInput = {
    where: AcademicDepartmentWhereUniqueInput
    create: XOR<AcademicDepartmentCreateWithoutOfferedCoursesInput, AcademicDepartmentUncheckedCreateWithoutOfferedCoursesInput>
  }

  export type SemesterRegistrationCreateWithoutOfferedCoursesInput = {
    id?: string
    startDate: Date | string
    endDate: Date | string
    status?: $Enums.SemesterRegistrationStatus | null
    paymentRecipt: string
    totalPayment?: number
    createdAt?: Date | string
    updateAt?: Date | string
    academicSemester: AcademicSemesterCreateNestedOneWithoutSemesterRegistrationsInput
    offeredCourseSections?: OfferedCourseSectionCreateNestedManyWithoutSemesterRegistrationInput
    offeredCourseClassSchedules?: OfferedCourseClassScheduleCreateNestedManyWithoutSemesterRegistrationInput
    studentSemesterRegistrations?: StudentSemesterRegistrationCreateNestedManyWithoutSemesterRegistrationInput
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseCreateNestedManyWithoutSemesterRegistrationInput
  }

  export type SemesterRegistrationUncheckedCreateWithoutOfferedCoursesInput = {
    id?: string
    startDate: Date | string
    endDate: Date | string
    status?: $Enums.SemesterRegistrationStatus | null
    paymentRecipt: string
    totalPayment?: number
    createdAt?: Date | string
    updateAt?: Date | string
    academicSemesterId: string
    offeredCourseSections?: OfferedCourseSectionUncheckedCreateNestedManyWithoutSemesterRegistrationInput
    offeredCourseClassSchedules?: OfferedCourseClassScheduleUncheckedCreateNestedManyWithoutSemesterRegistrationInput
    studentSemesterRegistrations?: StudentSemesterRegistrationUncheckedCreateNestedManyWithoutSemesterRegistrationInput
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseUncheckedCreateNestedManyWithoutSemesterRegistrationInput
  }

  export type SemesterRegistrationCreateOrConnectWithoutOfferedCoursesInput = {
    where: SemesterRegistrationWhereUniqueInput
    create: XOR<SemesterRegistrationCreateWithoutOfferedCoursesInput, SemesterRegistrationUncheckedCreateWithoutOfferedCoursesInput>
  }

  export type CourseCreateWithoutOfferedCoursesInput = {
    id?: string
    title: string
    code: string
    credits?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    preRequisite?: CourseToPreRequisiteCreateNestedManyWithoutCourseInput
    preRequisiteFor?: CourseToPreRequisiteCreateNestedManyWithoutPreRequisiteInput
    faculties?: CourseFacultyCreateNestedManyWithoutCourseInput
    studentEnrolledCourses?: StudentEnrolledCourseCreateNestedManyWithoutCourseInput
  }

  export type CourseUncheckedCreateWithoutOfferedCoursesInput = {
    id?: string
    title: string
    code: string
    credits?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    preRequisite?: CourseToPreRequisiteUncheckedCreateNestedManyWithoutCourseInput
    preRequisiteFor?: CourseToPreRequisiteUncheckedCreateNestedManyWithoutPreRequisiteInput
    faculties?: CourseFacultyUncheckedCreateNestedManyWithoutCourseInput
    studentEnrolledCourses?: StudentEnrolledCourseUncheckedCreateNestedManyWithoutCourseInput
  }

  export type CourseCreateOrConnectWithoutOfferedCoursesInput = {
    where: CourseWhereUniqueInput
    create: XOR<CourseCreateWithoutOfferedCoursesInput, CourseUncheckedCreateWithoutOfferedCoursesInput>
  }

  export type OfferedCourseSectionCreateWithoutOfferedCourseInput = {
    id?: string
    title: string
    maxCapacity?: number
    currentlyEnrolledStudent?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    semesterRegistration: SemesterRegistrationCreateNestedOneWithoutOfferedCourseSectionsInput
    offeredCourseClassSchedules?: OfferedCourseClassScheduleCreateNestedManyWithoutOfferedCourseSectionInput
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseCreateNestedManyWithoutOfferedCourseSectionInput
  }

  export type OfferedCourseSectionUncheckedCreateWithoutOfferedCourseInput = {
    id?: string
    title: string
    maxCapacity?: number
    currentlyEnrolledStudent?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    semesterRegistrationId: string
    offeredCourseClassSchedules?: OfferedCourseClassScheduleUncheckedCreateNestedManyWithoutOfferedCourseSectionInput
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseUncheckedCreateNestedManyWithoutOfferedCourseSectionInput
  }

  export type OfferedCourseSectionCreateOrConnectWithoutOfferedCourseInput = {
    where: OfferedCourseSectionWhereUniqueInput
    create: XOR<OfferedCourseSectionCreateWithoutOfferedCourseInput, OfferedCourseSectionUncheckedCreateWithoutOfferedCourseInput>
  }

  export type OfferedCourseSectionCreateManyOfferedCourseInputEnvelope = {
    data: OfferedCourseSectionCreateManyOfferedCourseInput | OfferedCourseSectionCreateManyOfferedCourseInput[]
    skipDuplicates?: boolean
  }

  export type StudentSemesterRegistrationCourseCreateWithoutOfferedCourseInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    semesterRegistration: SemesterRegistrationCreateNestedOneWithoutStudentSemesterRegistrationCoursesInput
    student: StudentCreateNestedOneWithoutStudentSemesterRegistrationCoursesInput
    offeredCourseSection: OfferedCourseSectionCreateNestedOneWithoutStudentSemesterRegistrationCoursesInput
  }

  export type StudentSemesterRegistrationCourseUncheckedCreateWithoutOfferedCourseInput = {
    semesterRegistrationId: string
    studentId: string
    offeredCourseSectionId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StudentSemesterRegistrationCourseCreateOrConnectWithoutOfferedCourseInput = {
    where: StudentSemesterRegistrationCourseWhereUniqueInput
    create: XOR<StudentSemesterRegistrationCourseCreateWithoutOfferedCourseInput, StudentSemesterRegistrationCourseUncheckedCreateWithoutOfferedCourseInput>
  }

  export type StudentSemesterRegistrationCourseCreateManyOfferedCourseInputEnvelope = {
    data: StudentSemesterRegistrationCourseCreateManyOfferedCourseInput | StudentSemesterRegistrationCourseCreateManyOfferedCourseInput[]
    skipDuplicates?: boolean
  }

  export type AcademicDepartmentUpsertWithoutOfferedCoursesInput = {
    update: XOR<AcademicDepartmentUpdateWithoutOfferedCoursesInput, AcademicDepartmentUncheckedUpdateWithoutOfferedCoursesInput>
    create: XOR<AcademicDepartmentCreateWithoutOfferedCoursesInput, AcademicDepartmentUncheckedCreateWithoutOfferedCoursesInput>
    where?: AcademicDepartmentWhereInput
  }

  export type AcademicDepartmentUpdateToOneWithWhereWithoutOfferedCoursesInput = {
    where?: AcademicDepartmentWhereInput
    data: XOR<AcademicDepartmentUpdateWithoutOfferedCoursesInput, AcademicDepartmentUncheckedUpdateWithoutOfferedCoursesInput>
  }

  export type AcademicDepartmentUpdateWithoutOfferedCoursesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    academicFaculty?: AcademicFacultyUpdateOneRequiredWithoutAcademicDepartmentsNestedInput
    faculties?: FacultyUpdateOneWithoutAcademicDepartmentNestedInput
    students?: StudentUpdateOneWithoutAcademicDepartmentNestedInput
    departmentHead?: UsersUpdateOneWithoutAcademicDepartmentNestedInput
    staffMembers?: UsersUpdateManyWithoutStaffDepartmentsNestedInput
    admitionExame?: AdmitionExameRegistrationUpdateManyWithoutDepartmentNestedInput
  }

  export type AcademicDepartmentUncheckedUpdateWithoutOfferedCoursesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    academicFacultyId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    departmentHeadId?: NullableStringFieldUpdateOperationsInput | string | null
    faculties?: FacultyUncheckedUpdateOneWithoutAcademicDepartmentNestedInput
    students?: StudentUncheckedUpdateOneWithoutAcademicDepartmentNestedInput
    staffMembers?: UsersUncheckedUpdateManyWithoutStaffDepartmentsNestedInput
    admitionExame?: AdmitionExameRegistrationUncheckedUpdateManyWithoutDepartmentNestedInput
  }

  export type SemesterRegistrationUpsertWithoutOfferedCoursesInput = {
    update: XOR<SemesterRegistrationUpdateWithoutOfferedCoursesInput, SemesterRegistrationUncheckedUpdateWithoutOfferedCoursesInput>
    create: XOR<SemesterRegistrationCreateWithoutOfferedCoursesInput, SemesterRegistrationUncheckedCreateWithoutOfferedCoursesInput>
    where?: SemesterRegistrationWhereInput
  }

  export type SemesterRegistrationUpdateToOneWithWhereWithoutOfferedCoursesInput = {
    where?: SemesterRegistrationWhereInput
    data: XOR<SemesterRegistrationUpdateWithoutOfferedCoursesInput, SemesterRegistrationUncheckedUpdateWithoutOfferedCoursesInput>
  }

  export type SemesterRegistrationUpdateWithoutOfferedCoursesInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: NullableEnumSemesterRegistrationStatusFieldUpdateOperationsInput | $Enums.SemesterRegistrationStatus | null
    paymentRecipt?: StringFieldUpdateOperationsInput | string
    totalPayment?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    academicSemester?: AcademicSemesterUpdateOneRequiredWithoutSemesterRegistrationsNestedInput
    offeredCourseSections?: OfferedCourseSectionUpdateManyWithoutSemesterRegistrationNestedInput
    offeredCourseClassSchedules?: OfferedCourseClassScheduleUpdateManyWithoutSemesterRegistrationNestedInput
    studentSemesterRegistrations?: StudentSemesterRegistrationUpdateManyWithoutSemesterRegistrationNestedInput
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseUpdateManyWithoutSemesterRegistrationNestedInput
  }

  export type SemesterRegistrationUncheckedUpdateWithoutOfferedCoursesInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: NullableEnumSemesterRegistrationStatusFieldUpdateOperationsInput | $Enums.SemesterRegistrationStatus | null
    paymentRecipt?: StringFieldUpdateOperationsInput | string
    totalPayment?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    academicSemesterId?: StringFieldUpdateOperationsInput | string
    offeredCourseSections?: OfferedCourseSectionUncheckedUpdateManyWithoutSemesterRegistrationNestedInput
    offeredCourseClassSchedules?: OfferedCourseClassScheduleUncheckedUpdateManyWithoutSemesterRegistrationNestedInput
    studentSemesterRegistrations?: StudentSemesterRegistrationUncheckedUpdateManyWithoutSemesterRegistrationNestedInput
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseUncheckedUpdateManyWithoutSemesterRegistrationNestedInput
  }

  export type CourseUpsertWithoutOfferedCoursesInput = {
    update: XOR<CourseUpdateWithoutOfferedCoursesInput, CourseUncheckedUpdateWithoutOfferedCoursesInput>
    create: XOR<CourseCreateWithoutOfferedCoursesInput, CourseUncheckedCreateWithoutOfferedCoursesInput>
    where?: CourseWhereInput
  }

  export type CourseUpdateToOneWithWhereWithoutOfferedCoursesInput = {
    where?: CourseWhereInput
    data: XOR<CourseUpdateWithoutOfferedCoursesInput, CourseUncheckedUpdateWithoutOfferedCoursesInput>
  }

  export type CourseUpdateWithoutOfferedCoursesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    credits?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    preRequisite?: CourseToPreRequisiteUpdateManyWithoutCourseNestedInput
    preRequisiteFor?: CourseToPreRequisiteUpdateManyWithoutPreRequisiteNestedInput
    faculties?: CourseFacultyUpdateManyWithoutCourseNestedInput
    studentEnrolledCourses?: StudentEnrolledCourseUpdateManyWithoutCourseNestedInput
  }

  export type CourseUncheckedUpdateWithoutOfferedCoursesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    credits?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    preRequisite?: CourseToPreRequisiteUncheckedUpdateManyWithoutCourseNestedInput
    preRequisiteFor?: CourseToPreRequisiteUncheckedUpdateManyWithoutPreRequisiteNestedInput
    faculties?: CourseFacultyUncheckedUpdateManyWithoutCourseNestedInput
    studentEnrolledCourses?: StudentEnrolledCourseUncheckedUpdateManyWithoutCourseNestedInput
  }

  export type OfferedCourseSectionUpsertWithWhereUniqueWithoutOfferedCourseInput = {
    where: OfferedCourseSectionWhereUniqueInput
    update: XOR<OfferedCourseSectionUpdateWithoutOfferedCourseInput, OfferedCourseSectionUncheckedUpdateWithoutOfferedCourseInput>
    create: XOR<OfferedCourseSectionCreateWithoutOfferedCourseInput, OfferedCourseSectionUncheckedCreateWithoutOfferedCourseInput>
  }

  export type OfferedCourseSectionUpdateWithWhereUniqueWithoutOfferedCourseInput = {
    where: OfferedCourseSectionWhereUniqueInput
    data: XOR<OfferedCourseSectionUpdateWithoutOfferedCourseInput, OfferedCourseSectionUncheckedUpdateWithoutOfferedCourseInput>
  }

  export type OfferedCourseSectionUpdateManyWithWhereWithoutOfferedCourseInput = {
    where: OfferedCourseSectionScalarWhereInput
    data: XOR<OfferedCourseSectionUpdateManyMutationInput, OfferedCourseSectionUncheckedUpdateManyWithoutOfferedCourseInput>
  }

  export type StudentSemesterRegistrationCourseUpsertWithWhereUniqueWithoutOfferedCourseInput = {
    where: StudentSemesterRegistrationCourseWhereUniqueInput
    update: XOR<StudentSemesterRegistrationCourseUpdateWithoutOfferedCourseInput, StudentSemesterRegistrationCourseUncheckedUpdateWithoutOfferedCourseInput>
    create: XOR<StudentSemesterRegistrationCourseCreateWithoutOfferedCourseInput, StudentSemesterRegistrationCourseUncheckedCreateWithoutOfferedCourseInput>
  }

  export type StudentSemesterRegistrationCourseUpdateWithWhereUniqueWithoutOfferedCourseInput = {
    where: StudentSemesterRegistrationCourseWhereUniqueInput
    data: XOR<StudentSemesterRegistrationCourseUpdateWithoutOfferedCourseInput, StudentSemesterRegistrationCourseUncheckedUpdateWithoutOfferedCourseInput>
  }

  export type StudentSemesterRegistrationCourseUpdateManyWithWhereWithoutOfferedCourseInput = {
    where: StudentSemesterRegistrationCourseScalarWhereInput
    data: XOR<StudentSemesterRegistrationCourseUpdateManyMutationInput, StudentSemesterRegistrationCourseUncheckedUpdateManyWithoutOfferedCourseInput>
  }

  export type SemesterRegistrationCreateWithoutOfferedCourseSectionsInput = {
    id?: string
    startDate: Date | string
    endDate: Date | string
    status?: $Enums.SemesterRegistrationStatus | null
    paymentRecipt: string
    totalPayment?: number
    createdAt?: Date | string
    updateAt?: Date | string
    academicSemester: AcademicSemesterCreateNestedOneWithoutSemesterRegistrationsInput
    offeredCourses?: OfferedCourseCreateNestedManyWithoutSemesterRegistrationInput
    offeredCourseClassSchedules?: OfferedCourseClassScheduleCreateNestedManyWithoutSemesterRegistrationInput
    studentSemesterRegistrations?: StudentSemesterRegistrationCreateNestedManyWithoutSemesterRegistrationInput
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseCreateNestedManyWithoutSemesterRegistrationInput
  }

  export type SemesterRegistrationUncheckedCreateWithoutOfferedCourseSectionsInput = {
    id?: string
    startDate: Date | string
    endDate: Date | string
    status?: $Enums.SemesterRegistrationStatus | null
    paymentRecipt: string
    totalPayment?: number
    createdAt?: Date | string
    updateAt?: Date | string
    academicSemesterId: string
    offeredCourses?: OfferedCourseUncheckedCreateNestedManyWithoutSemesterRegistrationInput
    offeredCourseClassSchedules?: OfferedCourseClassScheduleUncheckedCreateNestedManyWithoutSemesterRegistrationInput
    studentSemesterRegistrations?: StudentSemesterRegistrationUncheckedCreateNestedManyWithoutSemesterRegistrationInput
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseUncheckedCreateNestedManyWithoutSemesterRegistrationInput
  }

  export type SemesterRegistrationCreateOrConnectWithoutOfferedCourseSectionsInput = {
    where: SemesterRegistrationWhereUniqueInput
    create: XOR<SemesterRegistrationCreateWithoutOfferedCourseSectionsInput, SemesterRegistrationUncheckedCreateWithoutOfferedCourseSectionsInput>
  }

  export type OfferedCourseCreateWithoutOfferedCourseSectionsInput = {
    id?: string
    academicDepartment: AcademicDepartmentCreateNestedOneWithoutOfferedCoursesInput
    semesterRegistration: SemesterRegistrationCreateNestedOneWithoutOfferedCoursesInput
    course: CourseCreateNestedOneWithoutOfferedCoursesInput
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseCreateNestedManyWithoutOfferedCourseInput
  }

  export type OfferedCourseUncheckedCreateWithoutOfferedCourseSectionsInput = {
    id?: string
    academicDepartmentId: string
    courseId: string
    semesterRegistrationId: string
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseUncheckedCreateNestedManyWithoutOfferedCourseInput
  }

  export type OfferedCourseCreateOrConnectWithoutOfferedCourseSectionsInput = {
    where: OfferedCourseWhereUniqueInput
    create: XOR<OfferedCourseCreateWithoutOfferedCourseSectionsInput, OfferedCourseUncheckedCreateWithoutOfferedCourseSectionsInput>
  }

  export type OfferedCourseClassScheduleCreateWithoutOfferedCourseSectionInput = {
    id?: string
    startTime: string
    endTime: string
    dayOfWeek?: $Enums.WeekDays
    createdAt?: Date | string
    updatedAt?: Date | string
    semesterRegistration: SemesterRegistrationCreateNestedOneWithoutOfferedCourseClassSchedulesInput
    room: RoomCreateNestedOneWithoutOfferedCourseClassSchedulesInput
    faculty: FacultyCreateNestedOneWithoutOfferedCourseClassSchedulesInput
  }

  export type OfferedCourseClassScheduleUncheckedCreateWithoutOfferedCourseSectionInput = {
    id?: string
    startTime: string
    endTime: string
    dayOfWeek?: $Enums.WeekDays
    createdAt?: Date | string
    updatedAt?: Date | string
    semesterRegistrationId: string
    roomId: string
    facultyId: string
  }

  export type OfferedCourseClassScheduleCreateOrConnectWithoutOfferedCourseSectionInput = {
    where: OfferedCourseClassScheduleWhereUniqueInput
    create: XOR<OfferedCourseClassScheduleCreateWithoutOfferedCourseSectionInput, OfferedCourseClassScheduleUncheckedCreateWithoutOfferedCourseSectionInput>
  }

  export type OfferedCourseClassScheduleCreateManyOfferedCourseSectionInputEnvelope = {
    data: OfferedCourseClassScheduleCreateManyOfferedCourseSectionInput | OfferedCourseClassScheduleCreateManyOfferedCourseSectionInput[]
    skipDuplicates?: boolean
  }

  export type StudentSemesterRegistrationCourseCreateWithoutOfferedCourseSectionInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    semesterRegistration: SemesterRegistrationCreateNestedOneWithoutStudentSemesterRegistrationCoursesInput
    student: StudentCreateNestedOneWithoutStudentSemesterRegistrationCoursesInput
    offeredCourse: OfferedCourseCreateNestedOneWithoutStudentSemesterRegistrationCoursesInput
  }

  export type StudentSemesterRegistrationCourseUncheckedCreateWithoutOfferedCourseSectionInput = {
    semesterRegistrationId: string
    studentId: string
    offeredCourseId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StudentSemesterRegistrationCourseCreateOrConnectWithoutOfferedCourseSectionInput = {
    where: StudentSemesterRegistrationCourseWhereUniqueInput
    create: XOR<StudentSemesterRegistrationCourseCreateWithoutOfferedCourseSectionInput, StudentSemesterRegistrationCourseUncheckedCreateWithoutOfferedCourseSectionInput>
  }

  export type StudentSemesterRegistrationCourseCreateManyOfferedCourseSectionInputEnvelope = {
    data: StudentSemesterRegistrationCourseCreateManyOfferedCourseSectionInput | StudentSemesterRegistrationCourseCreateManyOfferedCourseSectionInput[]
    skipDuplicates?: boolean
  }

  export type SemesterRegistrationUpsertWithoutOfferedCourseSectionsInput = {
    update: XOR<SemesterRegistrationUpdateWithoutOfferedCourseSectionsInput, SemesterRegistrationUncheckedUpdateWithoutOfferedCourseSectionsInput>
    create: XOR<SemesterRegistrationCreateWithoutOfferedCourseSectionsInput, SemesterRegistrationUncheckedCreateWithoutOfferedCourseSectionsInput>
    where?: SemesterRegistrationWhereInput
  }

  export type SemesterRegistrationUpdateToOneWithWhereWithoutOfferedCourseSectionsInput = {
    where?: SemesterRegistrationWhereInput
    data: XOR<SemesterRegistrationUpdateWithoutOfferedCourseSectionsInput, SemesterRegistrationUncheckedUpdateWithoutOfferedCourseSectionsInput>
  }

  export type SemesterRegistrationUpdateWithoutOfferedCourseSectionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: NullableEnumSemesterRegistrationStatusFieldUpdateOperationsInput | $Enums.SemesterRegistrationStatus | null
    paymentRecipt?: StringFieldUpdateOperationsInput | string
    totalPayment?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    academicSemester?: AcademicSemesterUpdateOneRequiredWithoutSemesterRegistrationsNestedInput
    offeredCourses?: OfferedCourseUpdateManyWithoutSemesterRegistrationNestedInput
    offeredCourseClassSchedules?: OfferedCourseClassScheduleUpdateManyWithoutSemesterRegistrationNestedInput
    studentSemesterRegistrations?: StudentSemesterRegistrationUpdateManyWithoutSemesterRegistrationNestedInput
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseUpdateManyWithoutSemesterRegistrationNestedInput
  }

  export type SemesterRegistrationUncheckedUpdateWithoutOfferedCourseSectionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: NullableEnumSemesterRegistrationStatusFieldUpdateOperationsInput | $Enums.SemesterRegistrationStatus | null
    paymentRecipt?: StringFieldUpdateOperationsInput | string
    totalPayment?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    academicSemesterId?: StringFieldUpdateOperationsInput | string
    offeredCourses?: OfferedCourseUncheckedUpdateManyWithoutSemesterRegistrationNestedInput
    offeredCourseClassSchedules?: OfferedCourseClassScheduleUncheckedUpdateManyWithoutSemesterRegistrationNestedInput
    studentSemesterRegistrations?: StudentSemesterRegistrationUncheckedUpdateManyWithoutSemesterRegistrationNestedInput
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseUncheckedUpdateManyWithoutSemesterRegistrationNestedInput
  }

  export type OfferedCourseUpsertWithoutOfferedCourseSectionsInput = {
    update: XOR<OfferedCourseUpdateWithoutOfferedCourseSectionsInput, OfferedCourseUncheckedUpdateWithoutOfferedCourseSectionsInput>
    create: XOR<OfferedCourseCreateWithoutOfferedCourseSectionsInput, OfferedCourseUncheckedCreateWithoutOfferedCourseSectionsInput>
    where?: OfferedCourseWhereInput
  }

  export type OfferedCourseUpdateToOneWithWhereWithoutOfferedCourseSectionsInput = {
    where?: OfferedCourseWhereInput
    data: XOR<OfferedCourseUpdateWithoutOfferedCourseSectionsInput, OfferedCourseUncheckedUpdateWithoutOfferedCourseSectionsInput>
  }

  export type OfferedCourseUpdateWithoutOfferedCourseSectionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    academicDepartment?: AcademicDepartmentUpdateOneRequiredWithoutOfferedCoursesNestedInput
    semesterRegistration?: SemesterRegistrationUpdateOneRequiredWithoutOfferedCoursesNestedInput
    course?: CourseUpdateOneRequiredWithoutOfferedCoursesNestedInput
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseUpdateManyWithoutOfferedCourseNestedInput
  }

  export type OfferedCourseUncheckedUpdateWithoutOfferedCourseSectionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    academicDepartmentId?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    semesterRegistrationId?: StringFieldUpdateOperationsInput | string
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseUncheckedUpdateManyWithoutOfferedCourseNestedInput
  }

  export type OfferedCourseClassScheduleUpsertWithWhereUniqueWithoutOfferedCourseSectionInput = {
    where: OfferedCourseClassScheduleWhereUniqueInput
    update: XOR<OfferedCourseClassScheduleUpdateWithoutOfferedCourseSectionInput, OfferedCourseClassScheduleUncheckedUpdateWithoutOfferedCourseSectionInput>
    create: XOR<OfferedCourseClassScheduleCreateWithoutOfferedCourseSectionInput, OfferedCourseClassScheduleUncheckedCreateWithoutOfferedCourseSectionInput>
  }

  export type OfferedCourseClassScheduleUpdateWithWhereUniqueWithoutOfferedCourseSectionInput = {
    where: OfferedCourseClassScheduleWhereUniqueInput
    data: XOR<OfferedCourseClassScheduleUpdateWithoutOfferedCourseSectionInput, OfferedCourseClassScheduleUncheckedUpdateWithoutOfferedCourseSectionInput>
  }

  export type OfferedCourseClassScheduleUpdateManyWithWhereWithoutOfferedCourseSectionInput = {
    where: OfferedCourseClassScheduleScalarWhereInput
    data: XOR<OfferedCourseClassScheduleUpdateManyMutationInput, OfferedCourseClassScheduleUncheckedUpdateManyWithoutOfferedCourseSectionInput>
  }

  export type StudentSemesterRegistrationCourseUpsertWithWhereUniqueWithoutOfferedCourseSectionInput = {
    where: StudentSemesterRegistrationCourseWhereUniqueInput
    update: XOR<StudentSemesterRegistrationCourseUpdateWithoutOfferedCourseSectionInput, StudentSemesterRegistrationCourseUncheckedUpdateWithoutOfferedCourseSectionInput>
    create: XOR<StudentSemesterRegistrationCourseCreateWithoutOfferedCourseSectionInput, StudentSemesterRegistrationCourseUncheckedCreateWithoutOfferedCourseSectionInput>
  }

  export type StudentSemesterRegistrationCourseUpdateWithWhereUniqueWithoutOfferedCourseSectionInput = {
    where: StudentSemesterRegistrationCourseWhereUniqueInput
    data: XOR<StudentSemesterRegistrationCourseUpdateWithoutOfferedCourseSectionInput, StudentSemesterRegistrationCourseUncheckedUpdateWithoutOfferedCourseSectionInput>
  }

  export type StudentSemesterRegistrationCourseUpdateManyWithWhereWithoutOfferedCourseSectionInput = {
    where: StudentSemesterRegistrationCourseScalarWhereInput
    data: XOR<StudentSemesterRegistrationCourseUpdateManyMutationInput, StudentSemesterRegistrationCourseUncheckedUpdateManyWithoutOfferedCourseSectionInput>
  }

  export type OfferedCourseSectionCreateWithoutOfferedCourseClassSchedulesInput = {
    id?: string
    title: string
    maxCapacity?: number
    currentlyEnrolledStudent?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    semesterRegistration: SemesterRegistrationCreateNestedOneWithoutOfferedCourseSectionsInput
    offeredCourse: OfferedCourseCreateNestedOneWithoutOfferedCourseSectionsInput
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseCreateNestedManyWithoutOfferedCourseSectionInput
  }

  export type OfferedCourseSectionUncheckedCreateWithoutOfferedCourseClassSchedulesInput = {
    id?: string
    title: string
    maxCapacity?: number
    currentlyEnrolledStudent?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    semesterRegistrationId: string
    offeredCourseId: string
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseUncheckedCreateNestedManyWithoutOfferedCourseSectionInput
  }

  export type OfferedCourseSectionCreateOrConnectWithoutOfferedCourseClassSchedulesInput = {
    where: OfferedCourseSectionWhereUniqueInput
    create: XOR<OfferedCourseSectionCreateWithoutOfferedCourseClassSchedulesInput, OfferedCourseSectionUncheckedCreateWithoutOfferedCourseClassSchedulesInput>
  }

  export type SemesterRegistrationCreateWithoutOfferedCourseClassSchedulesInput = {
    id?: string
    startDate: Date | string
    endDate: Date | string
    status?: $Enums.SemesterRegistrationStatus | null
    paymentRecipt: string
    totalPayment?: number
    createdAt?: Date | string
    updateAt?: Date | string
    academicSemester: AcademicSemesterCreateNestedOneWithoutSemesterRegistrationsInput
    offeredCourses?: OfferedCourseCreateNestedManyWithoutSemesterRegistrationInput
    offeredCourseSections?: OfferedCourseSectionCreateNestedManyWithoutSemesterRegistrationInput
    studentSemesterRegistrations?: StudentSemesterRegistrationCreateNestedManyWithoutSemesterRegistrationInput
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseCreateNestedManyWithoutSemesterRegistrationInput
  }

  export type SemesterRegistrationUncheckedCreateWithoutOfferedCourseClassSchedulesInput = {
    id?: string
    startDate: Date | string
    endDate: Date | string
    status?: $Enums.SemesterRegistrationStatus | null
    paymentRecipt: string
    totalPayment?: number
    createdAt?: Date | string
    updateAt?: Date | string
    academicSemesterId: string
    offeredCourses?: OfferedCourseUncheckedCreateNestedManyWithoutSemesterRegistrationInput
    offeredCourseSections?: OfferedCourseSectionUncheckedCreateNestedManyWithoutSemesterRegistrationInput
    studentSemesterRegistrations?: StudentSemesterRegistrationUncheckedCreateNestedManyWithoutSemesterRegistrationInput
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseUncheckedCreateNestedManyWithoutSemesterRegistrationInput
  }

  export type SemesterRegistrationCreateOrConnectWithoutOfferedCourseClassSchedulesInput = {
    where: SemesterRegistrationWhereUniqueInput
    create: XOR<SemesterRegistrationCreateWithoutOfferedCourseClassSchedulesInput, SemesterRegistrationUncheckedCreateWithoutOfferedCourseClassSchedulesInput>
  }

  export type RoomCreateWithoutOfferedCourseClassSchedulesInput = {
    id?: string
    roomNumber: string
    floor: string
    createdAt?: Date | string
    updatedAt?: Date | string
    building: BuildingCreateNestedOneWithoutRoomsInput
  }

  export type RoomUncheckedCreateWithoutOfferedCourseClassSchedulesInput = {
    id?: string
    roomNumber: string
    floor: string
    buildingId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RoomCreateOrConnectWithoutOfferedCourseClassSchedulesInput = {
    where: RoomWhereUniqueInput
    create: XOR<RoomCreateWithoutOfferedCourseClassSchedulesInput, RoomUncheckedCreateWithoutOfferedCourseClassSchedulesInput>
  }

  export type FacultyCreateWithoutOfferedCourseClassSchedulesInput = {
    id?: string
    facultyId: string
    firstName: string
    middleName?: string | null
    lastName: string
    profileImage?: string | null
    email?: string | null
    contactNo?: string | null
    gender: string
    designation: string
    password: string
    createdAt?: Date | string
    updatedAt?: Date | string
    courses?: CourseFacultyCreateNestedManyWithoutFacultyInput
    academicDepartment: AcademicDepartmentCreateNestedOneWithoutFacultiesInput
    academicFaculty: AcademicFacultyCreateNestedOneWithoutFacultiesInput
  }

  export type FacultyUncheckedCreateWithoutOfferedCourseClassSchedulesInput = {
    id?: string
    facultyId: string
    firstName: string
    middleName?: string | null
    lastName: string
    profileImage?: string | null
    email?: string | null
    contactNo?: string | null
    gender: string
    designation: string
    password: string
    academicFacultyId: string
    academicDepartmentId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    courses?: CourseFacultyUncheckedCreateNestedManyWithoutFacultyInput
  }

  export type FacultyCreateOrConnectWithoutOfferedCourseClassSchedulesInput = {
    where: FacultyWhereUniqueInput
    create: XOR<FacultyCreateWithoutOfferedCourseClassSchedulesInput, FacultyUncheckedCreateWithoutOfferedCourseClassSchedulesInput>
  }

  export type OfferedCourseSectionUpsertWithoutOfferedCourseClassSchedulesInput = {
    update: XOR<OfferedCourseSectionUpdateWithoutOfferedCourseClassSchedulesInput, OfferedCourseSectionUncheckedUpdateWithoutOfferedCourseClassSchedulesInput>
    create: XOR<OfferedCourseSectionCreateWithoutOfferedCourseClassSchedulesInput, OfferedCourseSectionUncheckedCreateWithoutOfferedCourseClassSchedulesInput>
    where?: OfferedCourseSectionWhereInput
  }

  export type OfferedCourseSectionUpdateToOneWithWhereWithoutOfferedCourseClassSchedulesInput = {
    where?: OfferedCourseSectionWhereInput
    data: XOR<OfferedCourseSectionUpdateWithoutOfferedCourseClassSchedulesInput, OfferedCourseSectionUncheckedUpdateWithoutOfferedCourseClassSchedulesInput>
  }

  export type OfferedCourseSectionUpdateWithoutOfferedCourseClassSchedulesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    maxCapacity?: IntFieldUpdateOperationsInput | number
    currentlyEnrolledStudent?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    semesterRegistration?: SemesterRegistrationUpdateOneRequiredWithoutOfferedCourseSectionsNestedInput
    offeredCourse?: OfferedCourseUpdateOneRequiredWithoutOfferedCourseSectionsNestedInput
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseUpdateManyWithoutOfferedCourseSectionNestedInput
  }

  export type OfferedCourseSectionUncheckedUpdateWithoutOfferedCourseClassSchedulesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    maxCapacity?: IntFieldUpdateOperationsInput | number
    currentlyEnrolledStudent?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    semesterRegistrationId?: StringFieldUpdateOperationsInput | string
    offeredCourseId?: StringFieldUpdateOperationsInput | string
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseUncheckedUpdateManyWithoutOfferedCourseSectionNestedInput
  }

  export type SemesterRegistrationUpsertWithoutOfferedCourseClassSchedulesInput = {
    update: XOR<SemesterRegistrationUpdateWithoutOfferedCourseClassSchedulesInput, SemesterRegistrationUncheckedUpdateWithoutOfferedCourseClassSchedulesInput>
    create: XOR<SemesterRegistrationCreateWithoutOfferedCourseClassSchedulesInput, SemesterRegistrationUncheckedCreateWithoutOfferedCourseClassSchedulesInput>
    where?: SemesterRegistrationWhereInput
  }

  export type SemesterRegistrationUpdateToOneWithWhereWithoutOfferedCourseClassSchedulesInput = {
    where?: SemesterRegistrationWhereInput
    data: XOR<SemesterRegistrationUpdateWithoutOfferedCourseClassSchedulesInput, SemesterRegistrationUncheckedUpdateWithoutOfferedCourseClassSchedulesInput>
  }

  export type SemesterRegistrationUpdateWithoutOfferedCourseClassSchedulesInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: NullableEnumSemesterRegistrationStatusFieldUpdateOperationsInput | $Enums.SemesterRegistrationStatus | null
    paymentRecipt?: StringFieldUpdateOperationsInput | string
    totalPayment?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    academicSemester?: AcademicSemesterUpdateOneRequiredWithoutSemesterRegistrationsNestedInput
    offeredCourses?: OfferedCourseUpdateManyWithoutSemesterRegistrationNestedInput
    offeredCourseSections?: OfferedCourseSectionUpdateManyWithoutSemesterRegistrationNestedInput
    studentSemesterRegistrations?: StudentSemesterRegistrationUpdateManyWithoutSemesterRegistrationNestedInput
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseUpdateManyWithoutSemesterRegistrationNestedInput
  }

  export type SemesterRegistrationUncheckedUpdateWithoutOfferedCourseClassSchedulesInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: NullableEnumSemesterRegistrationStatusFieldUpdateOperationsInput | $Enums.SemesterRegistrationStatus | null
    paymentRecipt?: StringFieldUpdateOperationsInput | string
    totalPayment?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    academicSemesterId?: StringFieldUpdateOperationsInput | string
    offeredCourses?: OfferedCourseUncheckedUpdateManyWithoutSemesterRegistrationNestedInput
    offeredCourseSections?: OfferedCourseSectionUncheckedUpdateManyWithoutSemesterRegistrationNestedInput
    studentSemesterRegistrations?: StudentSemesterRegistrationUncheckedUpdateManyWithoutSemesterRegistrationNestedInput
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseUncheckedUpdateManyWithoutSemesterRegistrationNestedInput
  }

  export type RoomUpsertWithoutOfferedCourseClassSchedulesInput = {
    update: XOR<RoomUpdateWithoutOfferedCourseClassSchedulesInput, RoomUncheckedUpdateWithoutOfferedCourseClassSchedulesInput>
    create: XOR<RoomCreateWithoutOfferedCourseClassSchedulesInput, RoomUncheckedCreateWithoutOfferedCourseClassSchedulesInput>
    where?: RoomWhereInput
  }

  export type RoomUpdateToOneWithWhereWithoutOfferedCourseClassSchedulesInput = {
    where?: RoomWhereInput
    data: XOR<RoomUpdateWithoutOfferedCourseClassSchedulesInput, RoomUncheckedUpdateWithoutOfferedCourseClassSchedulesInput>
  }

  export type RoomUpdateWithoutOfferedCourseClassSchedulesInput = {
    id?: StringFieldUpdateOperationsInput | string
    roomNumber?: StringFieldUpdateOperationsInput | string
    floor?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    building?: BuildingUpdateOneRequiredWithoutRoomsNestedInput
  }

  export type RoomUncheckedUpdateWithoutOfferedCourseClassSchedulesInput = {
    id?: StringFieldUpdateOperationsInput | string
    roomNumber?: StringFieldUpdateOperationsInput | string
    floor?: StringFieldUpdateOperationsInput | string
    buildingId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FacultyUpsertWithoutOfferedCourseClassSchedulesInput = {
    update: XOR<FacultyUpdateWithoutOfferedCourseClassSchedulesInput, FacultyUncheckedUpdateWithoutOfferedCourseClassSchedulesInput>
    create: XOR<FacultyCreateWithoutOfferedCourseClassSchedulesInput, FacultyUncheckedCreateWithoutOfferedCourseClassSchedulesInput>
    where?: FacultyWhereInput
  }

  export type FacultyUpdateToOneWithWhereWithoutOfferedCourseClassSchedulesInput = {
    where?: FacultyWhereInput
    data: XOR<FacultyUpdateWithoutOfferedCourseClassSchedulesInput, FacultyUncheckedUpdateWithoutOfferedCourseClassSchedulesInput>
  }

  export type FacultyUpdateWithoutOfferedCourseClassSchedulesInput = {
    id?: StringFieldUpdateOperationsInput | string
    facultyId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    contactNo?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: StringFieldUpdateOperationsInput | string
    designation?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    courses?: CourseFacultyUpdateManyWithoutFacultyNestedInput
    academicDepartment?: AcademicDepartmentUpdateOneRequiredWithoutFacultiesNestedInput
    academicFaculty?: AcademicFacultyUpdateOneRequiredWithoutFacultiesNestedInput
  }

  export type FacultyUncheckedUpdateWithoutOfferedCourseClassSchedulesInput = {
    id?: StringFieldUpdateOperationsInput | string
    facultyId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    contactNo?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: StringFieldUpdateOperationsInput | string
    designation?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    academicFacultyId?: StringFieldUpdateOperationsInput | string
    academicDepartmentId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    courses?: CourseFacultyUncheckedUpdateManyWithoutFacultyNestedInput
  }

  export type StudentCreateWithoutStudentSemesterRegistrationsInput = {
    id?: string
    studentId: string
    firstName: string
    middleName?: string | null
    lastName: string
    profileImage?: string | null
    email?: string | null
    contactNo?: string | null
    gender: string
    isWoker?: boolean
    shift?: $Enums.Shift
    password: string
    gradeDeclarationFile: string
    biFile: string
    presentAddress: string
    permanentAddress?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    admissionRegistration?: AdmitionExameRegistrationCreateNestedOneWithoutStudentInput
    academicDepartment: AcademicDepartmentCreateNestedOneWithoutStudentsInput
    academicFaculty: AcademicFacultyCreateNestedOneWithoutStudentsInput
    academicSemester: AcademicSemesterCreateNestedOneWithoutStudentsInput
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseCreateNestedManyWithoutStudentInput
    studentEnrolledCourses?: StudentEnrolledCourseCreateNestedManyWithoutStudentInput
    studentEnrolledCourseMarks?: StudentEnrolledCourseMarkCreateNestedManyWithoutStudentInput
    studentSemesterPayments?: StudentSemesterPaymentCreateNestedManyWithoutStudentInput
    studentAcademicInfos?: StudentAcademicInfoCreateNestedManyWithoutStudentInput
  }

  export type StudentUncheckedCreateWithoutStudentSemesterRegistrationsInput = {
    id?: string
    studentId: string
    firstName: string
    middleName?: string | null
    lastName: string
    profileImage?: string | null
    email?: string | null
    contactNo?: string | null
    gender: string
    isWoker?: boolean
    shift?: $Enums.Shift
    password: string
    gradeDeclarationFile: string
    biFile: string
    presentAddress: string
    permanentAddress?: string | null
    academicSemesterId: string
    academicFacultyId: string
    academicDepartmentId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    admissionRegistrationId?: string | null
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseUncheckedCreateNestedManyWithoutStudentInput
    studentEnrolledCourses?: StudentEnrolledCourseUncheckedCreateNestedManyWithoutStudentInput
    studentEnrolledCourseMarks?: StudentEnrolledCourseMarkUncheckedCreateNestedManyWithoutStudentInput
    studentSemesterPayments?: StudentSemesterPaymentUncheckedCreateNestedManyWithoutStudentInput
    studentAcademicInfos?: StudentAcademicInfoUncheckedCreateNestedManyWithoutStudentInput
  }

  export type StudentCreateOrConnectWithoutStudentSemesterRegistrationsInput = {
    where: StudentWhereUniqueInput
    create: XOR<StudentCreateWithoutStudentSemesterRegistrationsInput, StudentUncheckedCreateWithoutStudentSemesterRegistrationsInput>
  }

  export type SemesterRegistrationCreateWithoutStudentSemesterRegistrationsInput = {
    id?: string
    startDate: Date | string
    endDate: Date | string
    status?: $Enums.SemesterRegistrationStatus | null
    paymentRecipt: string
    totalPayment?: number
    createdAt?: Date | string
    updateAt?: Date | string
    academicSemester: AcademicSemesterCreateNestedOneWithoutSemesterRegistrationsInput
    offeredCourses?: OfferedCourseCreateNestedManyWithoutSemesterRegistrationInput
    offeredCourseSections?: OfferedCourseSectionCreateNestedManyWithoutSemesterRegistrationInput
    offeredCourseClassSchedules?: OfferedCourseClassScheduleCreateNestedManyWithoutSemesterRegistrationInput
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseCreateNestedManyWithoutSemesterRegistrationInput
  }

  export type SemesterRegistrationUncheckedCreateWithoutStudentSemesterRegistrationsInput = {
    id?: string
    startDate: Date | string
    endDate: Date | string
    status?: $Enums.SemesterRegistrationStatus | null
    paymentRecipt: string
    totalPayment?: number
    createdAt?: Date | string
    updateAt?: Date | string
    academicSemesterId: string
    offeredCourses?: OfferedCourseUncheckedCreateNestedManyWithoutSemesterRegistrationInput
    offeredCourseSections?: OfferedCourseSectionUncheckedCreateNestedManyWithoutSemesterRegistrationInput
    offeredCourseClassSchedules?: OfferedCourseClassScheduleUncheckedCreateNestedManyWithoutSemesterRegistrationInput
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseUncheckedCreateNestedManyWithoutSemesterRegistrationInput
  }

  export type SemesterRegistrationCreateOrConnectWithoutStudentSemesterRegistrationsInput = {
    where: SemesterRegistrationWhereUniqueInput
    create: XOR<SemesterRegistrationCreateWithoutStudentSemesterRegistrationsInput, SemesterRegistrationUncheckedCreateWithoutStudentSemesterRegistrationsInput>
  }

  export type StudentUpsertWithoutStudentSemesterRegistrationsInput = {
    update: XOR<StudentUpdateWithoutStudentSemesterRegistrationsInput, StudentUncheckedUpdateWithoutStudentSemesterRegistrationsInput>
    create: XOR<StudentCreateWithoutStudentSemesterRegistrationsInput, StudentUncheckedCreateWithoutStudentSemesterRegistrationsInput>
    where?: StudentWhereInput
  }

  export type StudentUpdateToOneWithWhereWithoutStudentSemesterRegistrationsInput = {
    where?: StudentWhereInput
    data: XOR<StudentUpdateWithoutStudentSemesterRegistrationsInput, StudentUncheckedUpdateWithoutStudentSemesterRegistrationsInput>
  }

  export type StudentUpdateWithoutStudentSemesterRegistrationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    contactNo?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: StringFieldUpdateOperationsInput | string
    isWoker?: BoolFieldUpdateOperationsInput | boolean
    shift?: EnumShiftFieldUpdateOperationsInput | $Enums.Shift
    password?: StringFieldUpdateOperationsInput | string
    gradeDeclarationFile?: StringFieldUpdateOperationsInput | string
    biFile?: StringFieldUpdateOperationsInput | string
    presentAddress?: StringFieldUpdateOperationsInput | string
    permanentAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    admissionRegistration?: AdmitionExameRegistrationUpdateOneWithoutStudentNestedInput
    academicDepartment?: AcademicDepartmentUpdateOneRequiredWithoutStudentsNestedInput
    academicFaculty?: AcademicFacultyUpdateOneRequiredWithoutStudentsNestedInput
    academicSemester?: AcademicSemesterUpdateOneRequiredWithoutStudentsNestedInput
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseUpdateManyWithoutStudentNestedInput
    studentEnrolledCourses?: StudentEnrolledCourseUpdateManyWithoutStudentNestedInput
    studentEnrolledCourseMarks?: StudentEnrolledCourseMarkUpdateManyWithoutStudentNestedInput
    studentSemesterPayments?: StudentSemesterPaymentUpdateManyWithoutStudentNestedInput
    studentAcademicInfos?: StudentAcademicInfoUpdateManyWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateWithoutStudentSemesterRegistrationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    contactNo?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: StringFieldUpdateOperationsInput | string
    isWoker?: BoolFieldUpdateOperationsInput | boolean
    shift?: EnumShiftFieldUpdateOperationsInput | $Enums.Shift
    password?: StringFieldUpdateOperationsInput | string
    gradeDeclarationFile?: StringFieldUpdateOperationsInput | string
    biFile?: StringFieldUpdateOperationsInput | string
    presentAddress?: StringFieldUpdateOperationsInput | string
    permanentAddress?: NullableStringFieldUpdateOperationsInput | string | null
    academicSemesterId?: StringFieldUpdateOperationsInput | string
    academicFacultyId?: StringFieldUpdateOperationsInput | string
    academicDepartmentId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    admissionRegistrationId?: NullableStringFieldUpdateOperationsInput | string | null
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseUncheckedUpdateManyWithoutStudentNestedInput
    studentEnrolledCourses?: StudentEnrolledCourseUncheckedUpdateManyWithoutStudentNestedInput
    studentEnrolledCourseMarks?: StudentEnrolledCourseMarkUncheckedUpdateManyWithoutStudentNestedInput
    studentSemesterPayments?: StudentSemesterPaymentUncheckedUpdateManyWithoutStudentNestedInput
    studentAcademicInfos?: StudentAcademicInfoUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type SemesterRegistrationUpsertWithoutStudentSemesterRegistrationsInput = {
    update: XOR<SemesterRegistrationUpdateWithoutStudentSemesterRegistrationsInput, SemesterRegistrationUncheckedUpdateWithoutStudentSemesterRegistrationsInput>
    create: XOR<SemesterRegistrationCreateWithoutStudentSemesterRegistrationsInput, SemesterRegistrationUncheckedCreateWithoutStudentSemesterRegistrationsInput>
    where?: SemesterRegistrationWhereInput
  }

  export type SemesterRegistrationUpdateToOneWithWhereWithoutStudentSemesterRegistrationsInput = {
    where?: SemesterRegistrationWhereInput
    data: XOR<SemesterRegistrationUpdateWithoutStudentSemesterRegistrationsInput, SemesterRegistrationUncheckedUpdateWithoutStudentSemesterRegistrationsInput>
  }

  export type SemesterRegistrationUpdateWithoutStudentSemesterRegistrationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: NullableEnumSemesterRegistrationStatusFieldUpdateOperationsInput | $Enums.SemesterRegistrationStatus | null
    paymentRecipt?: StringFieldUpdateOperationsInput | string
    totalPayment?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    academicSemester?: AcademicSemesterUpdateOneRequiredWithoutSemesterRegistrationsNestedInput
    offeredCourses?: OfferedCourseUpdateManyWithoutSemesterRegistrationNestedInput
    offeredCourseSections?: OfferedCourseSectionUpdateManyWithoutSemesterRegistrationNestedInput
    offeredCourseClassSchedules?: OfferedCourseClassScheduleUpdateManyWithoutSemesterRegistrationNestedInput
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseUpdateManyWithoutSemesterRegistrationNestedInput
  }

  export type SemesterRegistrationUncheckedUpdateWithoutStudentSemesterRegistrationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: NullableEnumSemesterRegistrationStatusFieldUpdateOperationsInput | $Enums.SemesterRegistrationStatus | null
    paymentRecipt?: StringFieldUpdateOperationsInput | string
    totalPayment?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    academicSemesterId?: StringFieldUpdateOperationsInput | string
    offeredCourses?: OfferedCourseUncheckedUpdateManyWithoutSemesterRegistrationNestedInput
    offeredCourseSections?: OfferedCourseSectionUncheckedUpdateManyWithoutSemesterRegistrationNestedInput
    offeredCourseClassSchedules?: OfferedCourseClassScheduleUncheckedUpdateManyWithoutSemesterRegistrationNestedInput
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseUncheckedUpdateManyWithoutSemesterRegistrationNestedInput
  }

  export type SemesterRegistrationCreateWithoutStudentSemesterRegistrationCoursesInput = {
    id?: string
    startDate: Date | string
    endDate: Date | string
    status?: $Enums.SemesterRegistrationStatus | null
    paymentRecipt: string
    totalPayment?: number
    createdAt?: Date | string
    updateAt?: Date | string
    academicSemester: AcademicSemesterCreateNestedOneWithoutSemesterRegistrationsInput
    offeredCourses?: OfferedCourseCreateNestedManyWithoutSemesterRegistrationInput
    offeredCourseSections?: OfferedCourseSectionCreateNestedManyWithoutSemesterRegistrationInput
    offeredCourseClassSchedules?: OfferedCourseClassScheduleCreateNestedManyWithoutSemesterRegistrationInput
    studentSemesterRegistrations?: StudentSemesterRegistrationCreateNestedManyWithoutSemesterRegistrationInput
  }

  export type SemesterRegistrationUncheckedCreateWithoutStudentSemesterRegistrationCoursesInput = {
    id?: string
    startDate: Date | string
    endDate: Date | string
    status?: $Enums.SemesterRegistrationStatus | null
    paymentRecipt: string
    totalPayment?: number
    createdAt?: Date | string
    updateAt?: Date | string
    academicSemesterId: string
    offeredCourses?: OfferedCourseUncheckedCreateNestedManyWithoutSemesterRegistrationInput
    offeredCourseSections?: OfferedCourseSectionUncheckedCreateNestedManyWithoutSemesterRegistrationInput
    offeredCourseClassSchedules?: OfferedCourseClassScheduleUncheckedCreateNestedManyWithoutSemesterRegistrationInput
    studentSemesterRegistrations?: StudentSemesterRegistrationUncheckedCreateNestedManyWithoutSemesterRegistrationInput
  }

  export type SemesterRegistrationCreateOrConnectWithoutStudentSemesterRegistrationCoursesInput = {
    where: SemesterRegistrationWhereUniqueInput
    create: XOR<SemesterRegistrationCreateWithoutStudentSemesterRegistrationCoursesInput, SemesterRegistrationUncheckedCreateWithoutStudentSemesterRegistrationCoursesInput>
  }

  export type StudentCreateWithoutStudentSemesterRegistrationCoursesInput = {
    id?: string
    studentId: string
    firstName: string
    middleName?: string | null
    lastName: string
    profileImage?: string | null
    email?: string | null
    contactNo?: string | null
    gender: string
    isWoker?: boolean
    shift?: $Enums.Shift
    password: string
    gradeDeclarationFile: string
    biFile: string
    presentAddress: string
    permanentAddress?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    admissionRegistration?: AdmitionExameRegistrationCreateNestedOneWithoutStudentInput
    academicDepartment: AcademicDepartmentCreateNestedOneWithoutStudentsInput
    academicFaculty: AcademicFacultyCreateNestedOneWithoutStudentsInput
    academicSemester: AcademicSemesterCreateNestedOneWithoutStudentsInput
    studentSemesterRegistrations?: StudentSemesterRegistrationCreateNestedManyWithoutStudentInput
    studentEnrolledCourses?: StudentEnrolledCourseCreateNestedManyWithoutStudentInput
    studentEnrolledCourseMarks?: StudentEnrolledCourseMarkCreateNestedManyWithoutStudentInput
    studentSemesterPayments?: StudentSemesterPaymentCreateNestedManyWithoutStudentInput
    studentAcademicInfos?: StudentAcademicInfoCreateNestedManyWithoutStudentInput
  }

  export type StudentUncheckedCreateWithoutStudentSemesterRegistrationCoursesInput = {
    id?: string
    studentId: string
    firstName: string
    middleName?: string | null
    lastName: string
    profileImage?: string | null
    email?: string | null
    contactNo?: string | null
    gender: string
    isWoker?: boolean
    shift?: $Enums.Shift
    password: string
    gradeDeclarationFile: string
    biFile: string
    presentAddress: string
    permanentAddress?: string | null
    academicSemesterId: string
    academicFacultyId: string
    academicDepartmentId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    admissionRegistrationId?: string | null
    studentSemesterRegistrations?: StudentSemesterRegistrationUncheckedCreateNestedManyWithoutStudentInput
    studentEnrolledCourses?: StudentEnrolledCourseUncheckedCreateNestedManyWithoutStudentInput
    studentEnrolledCourseMarks?: StudentEnrolledCourseMarkUncheckedCreateNestedManyWithoutStudentInput
    studentSemesterPayments?: StudentSemesterPaymentUncheckedCreateNestedManyWithoutStudentInput
    studentAcademicInfos?: StudentAcademicInfoUncheckedCreateNestedManyWithoutStudentInput
  }

  export type StudentCreateOrConnectWithoutStudentSemesterRegistrationCoursesInput = {
    where: StudentWhereUniqueInput
    create: XOR<StudentCreateWithoutStudentSemesterRegistrationCoursesInput, StudentUncheckedCreateWithoutStudentSemesterRegistrationCoursesInput>
  }

  export type OfferedCourseCreateWithoutStudentSemesterRegistrationCoursesInput = {
    id?: string
    academicDepartment: AcademicDepartmentCreateNestedOneWithoutOfferedCoursesInput
    semesterRegistration: SemesterRegistrationCreateNestedOneWithoutOfferedCoursesInput
    course: CourseCreateNestedOneWithoutOfferedCoursesInput
    offeredCourseSections?: OfferedCourseSectionCreateNestedManyWithoutOfferedCourseInput
  }

  export type OfferedCourseUncheckedCreateWithoutStudentSemesterRegistrationCoursesInput = {
    id?: string
    academicDepartmentId: string
    courseId: string
    semesterRegistrationId: string
    offeredCourseSections?: OfferedCourseSectionUncheckedCreateNestedManyWithoutOfferedCourseInput
  }

  export type OfferedCourseCreateOrConnectWithoutStudentSemesterRegistrationCoursesInput = {
    where: OfferedCourseWhereUniqueInput
    create: XOR<OfferedCourseCreateWithoutStudentSemesterRegistrationCoursesInput, OfferedCourseUncheckedCreateWithoutStudentSemesterRegistrationCoursesInput>
  }

  export type OfferedCourseSectionCreateWithoutStudentSemesterRegistrationCoursesInput = {
    id?: string
    title: string
    maxCapacity?: number
    currentlyEnrolledStudent?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    semesterRegistration: SemesterRegistrationCreateNestedOneWithoutOfferedCourseSectionsInput
    offeredCourse: OfferedCourseCreateNestedOneWithoutOfferedCourseSectionsInput
    offeredCourseClassSchedules?: OfferedCourseClassScheduleCreateNestedManyWithoutOfferedCourseSectionInput
  }

  export type OfferedCourseSectionUncheckedCreateWithoutStudentSemesterRegistrationCoursesInput = {
    id?: string
    title: string
    maxCapacity?: number
    currentlyEnrolledStudent?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    semesterRegistrationId: string
    offeredCourseId: string
    offeredCourseClassSchedules?: OfferedCourseClassScheduleUncheckedCreateNestedManyWithoutOfferedCourseSectionInput
  }

  export type OfferedCourseSectionCreateOrConnectWithoutStudentSemesterRegistrationCoursesInput = {
    where: OfferedCourseSectionWhereUniqueInput
    create: XOR<OfferedCourseSectionCreateWithoutStudentSemesterRegistrationCoursesInput, OfferedCourseSectionUncheckedCreateWithoutStudentSemesterRegistrationCoursesInput>
  }

  export type SemesterRegistrationUpsertWithoutStudentSemesterRegistrationCoursesInput = {
    update: XOR<SemesterRegistrationUpdateWithoutStudentSemesterRegistrationCoursesInput, SemesterRegistrationUncheckedUpdateWithoutStudentSemesterRegistrationCoursesInput>
    create: XOR<SemesterRegistrationCreateWithoutStudentSemesterRegistrationCoursesInput, SemesterRegistrationUncheckedCreateWithoutStudentSemesterRegistrationCoursesInput>
    where?: SemesterRegistrationWhereInput
  }

  export type SemesterRegistrationUpdateToOneWithWhereWithoutStudentSemesterRegistrationCoursesInput = {
    where?: SemesterRegistrationWhereInput
    data: XOR<SemesterRegistrationUpdateWithoutStudentSemesterRegistrationCoursesInput, SemesterRegistrationUncheckedUpdateWithoutStudentSemesterRegistrationCoursesInput>
  }

  export type SemesterRegistrationUpdateWithoutStudentSemesterRegistrationCoursesInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: NullableEnumSemesterRegistrationStatusFieldUpdateOperationsInput | $Enums.SemesterRegistrationStatus | null
    paymentRecipt?: StringFieldUpdateOperationsInput | string
    totalPayment?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    academicSemester?: AcademicSemesterUpdateOneRequiredWithoutSemesterRegistrationsNestedInput
    offeredCourses?: OfferedCourseUpdateManyWithoutSemesterRegistrationNestedInput
    offeredCourseSections?: OfferedCourseSectionUpdateManyWithoutSemesterRegistrationNestedInput
    offeredCourseClassSchedules?: OfferedCourseClassScheduleUpdateManyWithoutSemesterRegistrationNestedInput
    studentSemesterRegistrations?: StudentSemesterRegistrationUpdateManyWithoutSemesterRegistrationNestedInput
  }

  export type SemesterRegistrationUncheckedUpdateWithoutStudentSemesterRegistrationCoursesInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: NullableEnumSemesterRegistrationStatusFieldUpdateOperationsInput | $Enums.SemesterRegistrationStatus | null
    paymentRecipt?: StringFieldUpdateOperationsInput | string
    totalPayment?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    academicSemesterId?: StringFieldUpdateOperationsInput | string
    offeredCourses?: OfferedCourseUncheckedUpdateManyWithoutSemesterRegistrationNestedInput
    offeredCourseSections?: OfferedCourseSectionUncheckedUpdateManyWithoutSemesterRegistrationNestedInput
    offeredCourseClassSchedules?: OfferedCourseClassScheduleUncheckedUpdateManyWithoutSemesterRegistrationNestedInput
    studentSemesterRegistrations?: StudentSemesterRegistrationUncheckedUpdateManyWithoutSemesterRegistrationNestedInput
  }

  export type StudentUpsertWithoutStudentSemesterRegistrationCoursesInput = {
    update: XOR<StudentUpdateWithoutStudentSemesterRegistrationCoursesInput, StudentUncheckedUpdateWithoutStudentSemesterRegistrationCoursesInput>
    create: XOR<StudentCreateWithoutStudentSemesterRegistrationCoursesInput, StudentUncheckedCreateWithoutStudentSemesterRegistrationCoursesInput>
    where?: StudentWhereInput
  }

  export type StudentUpdateToOneWithWhereWithoutStudentSemesterRegistrationCoursesInput = {
    where?: StudentWhereInput
    data: XOR<StudentUpdateWithoutStudentSemesterRegistrationCoursesInput, StudentUncheckedUpdateWithoutStudentSemesterRegistrationCoursesInput>
  }

  export type StudentUpdateWithoutStudentSemesterRegistrationCoursesInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    contactNo?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: StringFieldUpdateOperationsInput | string
    isWoker?: BoolFieldUpdateOperationsInput | boolean
    shift?: EnumShiftFieldUpdateOperationsInput | $Enums.Shift
    password?: StringFieldUpdateOperationsInput | string
    gradeDeclarationFile?: StringFieldUpdateOperationsInput | string
    biFile?: StringFieldUpdateOperationsInput | string
    presentAddress?: StringFieldUpdateOperationsInput | string
    permanentAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    admissionRegistration?: AdmitionExameRegistrationUpdateOneWithoutStudentNestedInput
    academicDepartment?: AcademicDepartmentUpdateOneRequiredWithoutStudentsNestedInput
    academicFaculty?: AcademicFacultyUpdateOneRequiredWithoutStudentsNestedInput
    academicSemester?: AcademicSemesterUpdateOneRequiredWithoutStudentsNestedInput
    studentSemesterRegistrations?: StudentSemesterRegistrationUpdateManyWithoutStudentNestedInput
    studentEnrolledCourses?: StudentEnrolledCourseUpdateManyWithoutStudentNestedInput
    studentEnrolledCourseMarks?: StudentEnrolledCourseMarkUpdateManyWithoutStudentNestedInput
    studentSemesterPayments?: StudentSemesterPaymentUpdateManyWithoutStudentNestedInput
    studentAcademicInfos?: StudentAcademicInfoUpdateManyWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateWithoutStudentSemesterRegistrationCoursesInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    contactNo?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: StringFieldUpdateOperationsInput | string
    isWoker?: BoolFieldUpdateOperationsInput | boolean
    shift?: EnumShiftFieldUpdateOperationsInput | $Enums.Shift
    password?: StringFieldUpdateOperationsInput | string
    gradeDeclarationFile?: StringFieldUpdateOperationsInput | string
    biFile?: StringFieldUpdateOperationsInput | string
    presentAddress?: StringFieldUpdateOperationsInput | string
    permanentAddress?: NullableStringFieldUpdateOperationsInput | string | null
    academicSemesterId?: StringFieldUpdateOperationsInput | string
    academicFacultyId?: StringFieldUpdateOperationsInput | string
    academicDepartmentId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    admissionRegistrationId?: NullableStringFieldUpdateOperationsInput | string | null
    studentSemesterRegistrations?: StudentSemesterRegistrationUncheckedUpdateManyWithoutStudentNestedInput
    studentEnrolledCourses?: StudentEnrolledCourseUncheckedUpdateManyWithoutStudentNestedInput
    studentEnrolledCourseMarks?: StudentEnrolledCourseMarkUncheckedUpdateManyWithoutStudentNestedInput
    studentSemesterPayments?: StudentSemesterPaymentUncheckedUpdateManyWithoutStudentNestedInput
    studentAcademicInfos?: StudentAcademicInfoUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type OfferedCourseUpsertWithoutStudentSemesterRegistrationCoursesInput = {
    update: XOR<OfferedCourseUpdateWithoutStudentSemesterRegistrationCoursesInput, OfferedCourseUncheckedUpdateWithoutStudentSemesterRegistrationCoursesInput>
    create: XOR<OfferedCourseCreateWithoutStudentSemesterRegistrationCoursesInput, OfferedCourseUncheckedCreateWithoutStudentSemesterRegistrationCoursesInput>
    where?: OfferedCourseWhereInput
  }

  export type OfferedCourseUpdateToOneWithWhereWithoutStudentSemesterRegistrationCoursesInput = {
    where?: OfferedCourseWhereInput
    data: XOR<OfferedCourseUpdateWithoutStudentSemesterRegistrationCoursesInput, OfferedCourseUncheckedUpdateWithoutStudentSemesterRegistrationCoursesInput>
  }

  export type OfferedCourseUpdateWithoutStudentSemesterRegistrationCoursesInput = {
    id?: StringFieldUpdateOperationsInput | string
    academicDepartment?: AcademicDepartmentUpdateOneRequiredWithoutOfferedCoursesNestedInput
    semesterRegistration?: SemesterRegistrationUpdateOneRequiredWithoutOfferedCoursesNestedInput
    course?: CourseUpdateOneRequiredWithoutOfferedCoursesNestedInput
    offeredCourseSections?: OfferedCourseSectionUpdateManyWithoutOfferedCourseNestedInput
  }

  export type OfferedCourseUncheckedUpdateWithoutStudentSemesterRegistrationCoursesInput = {
    id?: StringFieldUpdateOperationsInput | string
    academicDepartmentId?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    semesterRegistrationId?: StringFieldUpdateOperationsInput | string
    offeredCourseSections?: OfferedCourseSectionUncheckedUpdateManyWithoutOfferedCourseNestedInput
  }

  export type OfferedCourseSectionUpsertWithoutStudentSemesterRegistrationCoursesInput = {
    update: XOR<OfferedCourseSectionUpdateWithoutStudentSemesterRegistrationCoursesInput, OfferedCourseSectionUncheckedUpdateWithoutStudentSemesterRegistrationCoursesInput>
    create: XOR<OfferedCourseSectionCreateWithoutStudentSemesterRegistrationCoursesInput, OfferedCourseSectionUncheckedCreateWithoutStudentSemesterRegistrationCoursesInput>
    where?: OfferedCourseSectionWhereInput
  }

  export type OfferedCourseSectionUpdateToOneWithWhereWithoutStudentSemesterRegistrationCoursesInput = {
    where?: OfferedCourseSectionWhereInput
    data: XOR<OfferedCourseSectionUpdateWithoutStudentSemesterRegistrationCoursesInput, OfferedCourseSectionUncheckedUpdateWithoutStudentSemesterRegistrationCoursesInput>
  }

  export type OfferedCourseSectionUpdateWithoutStudentSemesterRegistrationCoursesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    maxCapacity?: IntFieldUpdateOperationsInput | number
    currentlyEnrolledStudent?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    semesterRegistration?: SemesterRegistrationUpdateOneRequiredWithoutOfferedCourseSectionsNestedInput
    offeredCourse?: OfferedCourseUpdateOneRequiredWithoutOfferedCourseSectionsNestedInput
    offeredCourseClassSchedules?: OfferedCourseClassScheduleUpdateManyWithoutOfferedCourseSectionNestedInput
  }

  export type OfferedCourseSectionUncheckedUpdateWithoutStudentSemesterRegistrationCoursesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    maxCapacity?: IntFieldUpdateOperationsInput | number
    currentlyEnrolledStudent?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    semesterRegistrationId?: StringFieldUpdateOperationsInput | string
    offeredCourseId?: StringFieldUpdateOperationsInput | string
    offeredCourseClassSchedules?: OfferedCourseClassScheduleUncheckedUpdateManyWithoutOfferedCourseSectionNestedInput
  }

  export type StudentCreateWithoutStudentEnrolledCoursesInput = {
    id?: string
    studentId: string
    firstName: string
    middleName?: string | null
    lastName: string
    profileImage?: string | null
    email?: string | null
    contactNo?: string | null
    gender: string
    isWoker?: boolean
    shift?: $Enums.Shift
    password: string
    gradeDeclarationFile: string
    biFile: string
    presentAddress: string
    permanentAddress?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    admissionRegistration?: AdmitionExameRegistrationCreateNestedOneWithoutStudentInput
    academicDepartment: AcademicDepartmentCreateNestedOneWithoutStudentsInput
    academicFaculty: AcademicFacultyCreateNestedOneWithoutStudentsInput
    academicSemester: AcademicSemesterCreateNestedOneWithoutStudentsInput
    studentSemesterRegistrations?: StudentSemesterRegistrationCreateNestedManyWithoutStudentInput
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseCreateNestedManyWithoutStudentInput
    studentEnrolledCourseMarks?: StudentEnrolledCourseMarkCreateNestedManyWithoutStudentInput
    studentSemesterPayments?: StudentSemesterPaymentCreateNestedManyWithoutStudentInput
    studentAcademicInfos?: StudentAcademicInfoCreateNestedManyWithoutStudentInput
  }

  export type StudentUncheckedCreateWithoutStudentEnrolledCoursesInput = {
    id?: string
    studentId: string
    firstName: string
    middleName?: string | null
    lastName: string
    profileImage?: string | null
    email?: string | null
    contactNo?: string | null
    gender: string
    isWoker?: boolean
    shift?: $Enums.Shift
    password: string
    gradeDeclarationFile: string
    biFile: string
    presentAddress: string
    permanentAddress?: string | null
    academicSemesterId: string
    academicFacultyId: string
    academicDepartmentId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    admissionRegistrationId?: string | null
    studentSemesterRegistrations?: StudentSemesterRegistrationUncheckedCreateNestedManyWithoutStudentInput
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseUncheckedCreateNestedManyWithoutStudentInput
    studentEnrolledCourseMarks?: StudentEnrolledCourseMarkUncheckedCreateNestedManyWithoutStudentInput
    studentSemesterPayments?: StudentSemesterPaymentUncheckedCreateNestedManyWithoutStudentInput
    studentAcademicInfos?: StudentAcademicInfoUncheckedCreateNestedManyWithoutStudentInput
  }

  export type StudentCreateOrConnectWithoutStudentEnrolledCoursesInput = {
    where: StudentWhereUniqueInput
    create: XOR<StudentCreateWithoutStudentEnrolledCoursesInput, StudentUncheckedCreateWithoutStudentEnrolledCoursesInput>
  }

  export type AcademicSemesterCreateWithoutStudentEnrolledCoursesInput = {
    id?: string
    title: string
    year: string
    code: string
    startMonth: string
    endMonth: string
    isCurrent?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    semesterRegistrations?: SemesterRegistrationCreateNestedManyWithoutAcademicSemesterInput
    students?: StudentCreateNestedOneWithoutAcademicSemesterInput
    studentEnrolledCourseMarks?: StudentEnrolledCourseMarkCreateNestedManyWithoutAcademicSemesterInput
    studentSemesterPayments?: StudentSemesterPaymentCreateNestedManyWithoutAcademicSemesterInput
  }

  export type AcademicSemesterUncheckedCreateWithoutStudentEnrolledCoursesInput = {
    id?: string
    title: string
    year: string
    code: string
    startMonth: string
    endMonth: string
    isCurrent?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    semesterRegistrations?: SemesterRegistrationUncheckedCreateNestedManyWithoutAcademicSemesterInput
    students?: StudentUncheckedCreateNestedOneWithoutAcademicSemesterInput
    studentEnrolledCourseMarks?: StudentEnrolledCourseMarkUncheckedCreateNestedManyWithoutAcademicSemesterInput
    studentSemesterPayments?: StudentSemesterPaymentUncheckedCreateNestedManyWithoutAcademicSemesterInput
  }

  export type AcademicSemesterCreateOrConnectWithoutStudentEnrolledCoursesInput = {
    where: AcademicSemesterWhereUniqueInput
    create: XOR<AcademicSemesterCreateWithoutStudentEnrolledCoursesInput, AcademicSemesterUncheckedCreateWithoutStudentEnrolledCoursesInput>
  }

  export type CourseCreateWithoutStudentEnrolledCoursesInput = {
    id?: string
    title: string
    code: string
    credits?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    preRequisite?: CourseToPreRequisiteCreateNestedManyWithoutCourseInput
    preRequisiteFor?: CourseToPreRequisiteCreateNestedManyWithoutPreRequisiteInput
    faculties?: CourseFacultyCreateNestedManyWithoutCourseInput
    offeredCourses?: OfferedCourseCreateNestedManyWithoutCourseInput
  }

  export type CourseUncheckedCreateWithoutStudentEnrolledCoursesInput = {
    id?: string
    title: string
    code: string
    credits?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    preRequisite?: CourseToPreRequisiteUncheckedCreateNestedManyWithoutCourseInput
    preRequisiteFor?: CourseToPreRequisiteUncheckedCreateNestedManyWithoutPreRequisiteInput
    faculties?: CourseFacultyUncheckedCreateNestedManyWithoutCourseInput
    offeredCourses?: OfferedCourseUncheckedCreateNestedManyWithoutCourseInput
  }

  export type CourseCreateOrConnectWithoutStudentEnrolledCoursesInput = {
    where: CourseWhereUniqueInput
    create: XOR<CourseCreateWithoutStudentEnrolledCoursesInput, CourseUncheckedCreateWithoutStudentEnrolledCoursesInput>
  }

  export type StudentEnrolledCourseMarkCreateWithoutStudentEnrolledCourseInput = {
    id?: string
    examType?: $Enums.ExamType | null
    createdAt?: Date | string
    updatedAt?: Date | string
    exam1?: number
    exam2?: number
    exam3?: number
    exam4?: number
    exam5?: number
    exam6?: number
    finalExam?: number
    totalMarks?: number
    grade?: number
    student: StudentCreateNestedOneWithoutStudentEnrolledCourseMarksInput
    academicSemester: AcademicSemesterCreateNestedOneWithoutStudentEnrolledCourseMarksInput
  }

  export type StudentEnrolledCourseMarkUncheckedCreateWithoutStudentEnrolledCourseInput = {
    id?: string
    examType?: $Enums.ExamType | null
    createdAt?: Date | string
    updatedAt?: Date | string
    studentId: string
    academicSemesterId: string
    exam1?: number
    exam2?: number
    exam3?: number
    exam4?: number
    exam5?: number
    exam6?: number
    finalExam?: number
    totalMarks?: number
    grade?: number
  }

  export type StudentEnrolledCourseMarkCreateOrConnectWithoutStudentEnrolledCourseInput = {
    where: StudentEnrolledCourseMarkWhereUniqueInput
    create: XOR<StudentEnrolledCourseMarkCreateWithoutStudentEnrolledCourseInput, StudentEnrolledCourseMarkUncheckedCreateWithoutStudentEnrolledCourseInput>
  }

  export type StudentEnrolledCourseMarkCreateManyStudentEnrolledCourseInputEnvelope = {
    data: StudentEnrolledCourseMarkCreateManyStudentEnrolledCourseInput | StudentEnrolledCourseMarkCreateManyStudentEnrolledCourseInput[]
    skipDuplicates?: boolean
  }

  export type StudentUpsertWithoutStudentEnrolledCoursesInput = {
    update: XOR<StudentUpdateWithoutStudentEnrolledCoursesInput, StudentUncheckedUpdateWithoutStudentEnrolledCoursesInput>
    create: XOR<StudentCreateWithoutStudentEnrolledCoursesInput, StudentUncheckedCreateWithoutStudentEnrolledCoursesInput>
    where?: StudentWhereInput
  }

  export type StudentUpdateToOneWithWhereWithoutStudentEnrolledCoursesInput = {
    where?: StudentWhereInput
    data: XOR<StudentUpdateWithoutStudentEnrolledCoursesInput, StudentUncheckedUpdateWithoutStudentEnrolledCoursesInput>
  }

  export type StudentUpdateWithoutStudentEnrolledCoursesInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    contactNo?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: StringFieldUpdateOperationsInput | string
    isWoker?: BoolFieldUpdateOperationsInput | boolean
    shift?: EnumShiftFieldUpdateOperationsInput | $Enums.Shift
    password?: StringFieldUpdateOperationsInput | string
    gradeDeclarationFile?: StringFieldUpdateOperationsInput | string
    biFile?: StringFieldUpdateOperationsInput | string
    presentAddress?: StringFieldUpdateOperationsInput | string
    permanentAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    admissionRegistration?: AdmitionExameRegistrationUpdateOneWithoutStudentNestedInput
    academicDepartment?: AcademicDepartmentUpdateOneRequiredWithoutStudentsNestedInput
    academicFaculty?: AcademicFacultyUpdateOneRequiredWithoutStudentsNestedInput
    academicSemester?: AcademicSemesterUpdateOneRequiredWithoutStudentsNestedInput
    studentSemesterRegistrations?: StudentSemesterRegistrationUpdateManyWithoutStudentNestedInput
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseUpdateManyWithoutStudentNestedInput
    studentEnrolledCourseMarks?: StudentEnrolledCourseMarkUpdateManyWithoutStudentNestedInput
    studentSemesterPayments?: StudentSemesterPaymentUpdateManyWithoutStudentNestedInput
    studentAcademicInfos?: StudentAcademicInfoUpdateManyWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateWithoutStudentEnrolledCoursesInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    contactNo?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: StringFieldUpdateOperationsInput | string
    isWoker?: BoolFieldUpdateOperationsInput | boolean
    shift?: EnumShiftFieldUpdateOperationsInput | $Enums.Shift
    password?: StringFieldUpdateOperationsInput | string
    gradeDeclarationFile?: StringFieldUpdateOperationsInput | string
    biFile?: StringFieldUpdateOperationsInput | string
    presentAddress?: StringFieldUpdateOperationsInput | string
    permanentAddress?: NullableStringFieldUpdateOperationsInput | string | null
    academicSemesterId?: StringFieldUpdateOperationsInput | string
    academicFacultyId?: StringFieldUpdateOperationsInput | string
    academicDepartmentId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    admissionRegistrationId?: NullableStringFieldUpdateOperationsInput | string | null
    studentSemesterRegistrations?: StudentSemesterRegistrationUncheckedUpdateManyWithoutStudentNestedInput
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseUncheckedUpdateManyWithoutStudentNestedInput
    studentEnrolledCourseMarks?: StudentEnrolledCourseMarkUncheckedUpdateManyWithoutStudentNestedInput
    studentSemesterPayments?: StudentSemesterPaymentUncheckedUpdateManyWithoutStudentNestedInput
    studentAcademicInfos?: StudentAcademicInfoUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type AcademicSemesterUpsertWithoutStudentEnrolledCoursesInput = {
    update: XOR<AcademicSemesterUpdateWithoutStudentEnrolledCoursesInput, AcademicSemesterUncheckedUpdateWithoutStudentEnrolledCoursesInput>
    create: XOR<AcademicSemesterCreateWithoutStudentEnrolledCoursesInput, AcademicSemesterUncheckedCreateWithoutStudentEnrolledCoursesInput>
    where?: AcademicSemesterWhereInput
  }

  export type AcademicSemesterUpdateToOneWithWhereWithoutStudentEnrolledCoursesInput = {
    where?: AcademicSemesterWhereInput
    data: XOR<AcademicSemesterUpdateWithoutStudentEnrolledCoursesInput, AcademicSemesterUncheckedUpdateWithoutStudentEnrolledCoursesInput>
  }

  export type AcademicSemesterUpdateWithoutStudentEnrolledCoursesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    year?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    startMonth?: StringFieldUpdateOperationsInput | string
    endMonth?: StringFieldUpdateOperationsInput | string
    isCurrent?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    semesterRegistrations?: SemesterRegistrationUpdateManyWithoutAcademicSemesterNestedInput
    students?: StudentUpdateOneWithoutAcademicSemesterNestedInput
    studentEnrolledCourseMarks?: StudentEnrolledCourseMarkUpdateManyWithoutAcademicSemesterNestedInput
    studentSemesterPayments?: StudentSemesterPaymentUpdateManyWithoutAcademicSemesterNestedInput
  }

  export type AcademicSemesterUncheckedUpdateWithoutStudentEnrolledCoursesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    year?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    startMonth?: StringFieldUpdateOperationsInput | string
    endMonth?: StringFieldUpdateOperationsInput | string
    isCurrent?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    semesterRegistrations?: SemesterRegistrationUncheckedUpdateManyWithoutAcademicSemesterNestedInput
    students?: StudentUncheckedUpdateOneWithoutAcademicSemesterNestedInput
    studentEnrolledCourseMarks?: StudentEnrolledCourseMarkUncheckedUpdateManyWithoutAcademicSemesterNestedInput
    studentSemesterPayments?: StudentSemesterPaymentUncheckedUpdateManyWithoutAcademicSemesterNestedInput
  }

  export type CourseUpsertWithoutStudentEnrolledCoursesInput = {
    update: XOR<CourseUpdateWithoutStudentEnrolledCoursesInput, CourseUncheckedUpdateWithoutStudentEnrolledCoursesInput>
    create: XOR<CourseCreateWithoutStudentEnrolledCoursesInput, CourseUncheckedCreateWithoutStudentEnrolledCoursesInput>
    where?: CourseWhereInput
  }

  export type CourseUpdateToOneWithWhereWithoutStudentEnrolledCoursesInput = {
    where?: CourseWhereInput
    data: XOR<CourseUpdateWithoutStudentEnrolledCoursesInput, CourseUncheckedUpdateWithoutStudentEnrolledCoursesInput>
  }

  export type CourseUpdateWithoutStudentEnrolledCoursesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    credits?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    preRequisite?: CourseToPreRequisiteUpdateManyWithoutCourseNestedInput
    preRequisiteFor?: CourseToPreRequisiteUpdateManyWithoutPreRequisiteNestedInput
    faculties?: CourseFacultyUpdateManyWithoutCourseNestedInput
    offeredCourses?: OfferedCourseUpdateManyWithoutCourseNestedInput
  }

  export type CourseUncheckedUpdateWithoutStudentEnrolledCoursesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    credits?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    preRequisite?: CourseToPreRequisiteUncheckedUpdateManyWithoutCourseNestedInput
    preRequisiteFor?: CourseToPreRequisiteUncheckedUpdateManyWithoutPreRequisiteNestedInput
    faculties?: CourseFacultyUncheckedUpdateManyWithoutCourseNestedInput
    offeredCourses?: OfferedCourseUncheckedUpdateManyWithoutCourseNestedInput
  }

  export type StudentEnrolledCourseMarkUpsertWithWhereUniqueWithoutStudentEnrolledCourseInput = {
    where: StudentEnrolledCourseMarkWhereUniqueInput
    update: XOR<StudentEnrolledCourseMarkUpdateWithoutStudentEnrolledCourseInput, StudentEnrolledCourseMarkUncheckedUpdateWithoutStudentEnrolledCourseInput>
    create: XOR<StudentEnrolledCourseMarkCreateWithoutStudentEnrolledCourseInput, StudentEnrolledCourseMarkUncheckedCreateWithoutStudentEnrolledCourseInput>
  }

  export type StudentEnrolledCourseMarkUpdateWithWhereUniqueWithoutStudentEnrolledCourseInput = {
    where: StudentEnrolledCourseMarkWhereUniqueInput
    data: XOR<StudentEnrolledCourseMarkUpdateWithoutStudentEnrolledCourseInput, StudentEnrolledCourseMarkUncheckedUpdateWithoutStudentEnrolledCourseInput>
  }

  export type StudentEnrolledCourseMarkUpdateManyWithWhereWithoutStudentEnrolledCourseInput = {
    where: StudentEnrolledCourseMarkScalarWhereInput
    data: XOR<StudentEnrolledCourseMarkUpdateManyMutationInput, StudentEnrolledCourseMarkUncheckedUpdateManyWithoutStudentEnrolledCourseInput>
  }

  export type StudentCreateWithoutStudentEnrolledCourseMarksInput = {
    id?: string
    studentId: string
    firstName: string
    middleName?: string | null
    lastName: string
    profileImage?: string | null
    email?: string | null
    contactNo?: string | null
    gender: string
    isWoker?: boolean
    shift?: $Enums.Shift
    password: string
    gradeDeclarationFile: string
    biFile: string
    presentAddress: string
    permanentAddress?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    admissionRegistration?: AdmitionExameRegistrationCreateNestedOneWithoutStudentInput
    academicDepartment: AcademicDepartmentCreateNestedOneWithoutStudentsInput
    academicFaculty: AcademicFacultyCreateNestedOneWithoutStudentsInput
    academicSemester: AcademicSemesterCreateNestedOneWithoutStudentsInput
    studentSemesterRegistrations?: StudentSemesterRegistrationCreateNestedManyWithoutStudentInput
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseCreateNestedManyWithoutStudentInput
    studentEnrolledCourses?: StudentEnrolledCourseCreateNestedManyWithoutStudentInput
    studentSemesterPayments?: StudentSemesterPaymentCreateNestedManyWithoutStudentInput
    studentAcademicInfos?: StudentAcademicInfoCreateNestedManyWithoutStudentInput
  }

  export type StudentUncheckedCreateWithoutStudentEnrolledCourseMarksInput = {
    id?: string
    studentId: string
    firstName: string
    middleName?: string | null
    lastName: string
    profileImage?: string | null
    email?: string | null
    contactNo?: string | null
    gender: string
    isWoker?: boolean
    shift?: $Enums.Shift
    password: string
    gradeDeclarationFile: string
    biFile: string
    presentAddress: string
    permanentAddress?: string | null
    academicSemesterId: string
    academicFacultyId: string
    academicDepartmentId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    admissionRegistrationId?: string | null
    studentSemesterRegistrations?: StudentSemesterRegistrationUncheckedCreateNestedManyWithoutStudentInput
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseUncheckedCreateNestedManyWithoutStudentInput
    studentEnrolledCourses?: StudentEnrolledCourseUncheckedCreateNestedManyWithoutStudentInput
    studentSemesterPayments?: StudentSemesterPaymentUncheckedCreateNestedManyWithoutStudentInput
    studentAcademicInfos?: StudentAcademicInfoUncheckedCreateNestedManyWithoutStudentInput
  }

  export type StudentCreateOrConnectWithoutStudentEnrolledCourseMarksInput = {
    where: StudentWhereUniqueInput
    create: XOR<StudentCreateWithoutStudentEnrolledCourseMarksInput, StudentUncheckedCreateWithoutStudentEnrolledCourseMarksInput>
  }

  export type StudentEnrolledCourseCreateWithoutStudentEnrolledCourseMarksInput = {
    id?: string
    grade?: string | null
    point?: number | null
    totalMarks?: number | null
    status?: $Enums.StudentEnrolledCourseStatus | null
    createdAt?: Date | string
    updatedAt?: Date | string
    student: StudentCreateNestedOneWithoutStudentEnrolledCoursesInput
    academicSemester: AcademicSemesterCreateNestedOneWithoutStudentEnrolledCoursesInput
    course: CourseCreateNestedOneWithoutStudentEnrolledCoursesInput
  }

  export type StudentEnrolledCourseUncheckedCreateWithoutStudentEnrolledCourseMarksInput = {
    id?: string
    grade?: string | null
    point?: number | null
    totalMarks?: number | null
    status?: $Enums.StudentEnrolledCourseStatus | null
    createdAt?: Date | string
    updatedAt?: Date | string
    studentId: string
    academicSemesterId: string
    courseId: string
  }

  export type StudentEnrolledCourseCreateOrConnectWithoutStudentEnrolledCourseMarksInput = {
    where: StudentEnrolledCourseWhereUniqueInput
    create: XOR<StudentEnrolledCourseCreateWithoutStudentEnrolledCourseMarksInput, StudentEnrolledCourseUncheckedCreateWithoutStudentEnrolledCourseMarksInput>
  }

  export type AcademicSemesterCreateWithoutStudentEnrolledCourseMarksInput = {
    id?: string
    title: string
    year: string
    code: string
    startMonth: string
    endMonth: string
    isCurrent?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    semesterRegistrations?: SemesterRegistrationCreateNestedManyWithoutAcademicSemesterInput
    students?: StudentCreateNestedOneWithoutAcademicSemesterInput
    studentEnrolledCourses?: StudentEnrolledCourseCreateNestedManyWithoutAcademicSemesterInput
    studentSemesterPayments?: StudentSemesterPaymentCreateNestedManyWithoutAcademicSemesterInput
  }

  export type AcademicSemesterUncheckedCreateWithoutStudentEnrolledCourseMarksInput = {
    id?: string
    title: string
    year: string
    code: string
    startMonth: string
    endMonth: string
    isCurrent?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    semesterRegistrations?: SemesterRegistrationUncheckedCreateNestedManyWithoutAcademicSemesterInput
    students?: StudentUncheckedCreateNestedOneWithoutAcademicSemesterInput
    studentEnrolledCourses?: StudentEnrolledCourseUncheckedCreateNestedManyWithoutAcademicSemesterInput
    studentSemesterPayments?: StudentSemesterPaymentUncheckedCreateNestedManyWithoutAcademicSemesterInput
  }

  export type AcademicSemesterCreateOrConnectWithoutStudentEnrolledCourseMarksInput = {
    where: AcademicSemesterWhereUniqueInput
    create: XOR<AcademicSemesterCreateWithoutStudentEnrolledCourseMarksInput, AcademicSemesterUncheckedCreateWithoutStudentEnrolledCourseMarksInput>
  }

  export type StudentUpsertWithoutStudentEnrolledCourseMarksInput = {
    update: XOR<StudentUpdateWithoutStudentEnrolledCourseMarksInput, StudentUncheckedUpdateWithoutStudentEnrolledCourseMarksInput>
    create: XOR<StudentCreateWithoutStudentEnrolledCourseMarksInput, StudentUncheckedCreateWithoutStudentEnrolledCourseMarksInput>
    where?: StudentWhereInput
  }

  export type StudentUpdateToOneWithWhereWithoutStudentEnrolledCourseMarksInput = {
    where?: StudentWhereInput
    data: XOR<StudentUpdateWithoutStudentEnrolledCourseMarksInput, StudentUncheckedUpdateWithoutStudentEnrolledCourseMarksInput>
  }

  export type StudentUpdateWithoutStudentEnrolledCourseMarksInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    contactNo?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: StringFieldUpdateOperationsInput | string
    isWoker?: BoolFieldUpdateOperationsInput | boolean
    shift?: EnumShiftFieldUpdateOperationsInput | $Enums.Shift
    password?: StringFieldUpdateOperationsInput | string
    gradeDeclarationFile?: StringFieldUpdateOperationsInput | string
    biFile?: StringFieldUpdateOperationsInput | string
    presentAddress?: StringFieldUpdateOperationsInput | string
    permanentAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    admissionRegistration?: AdmitionExameRegistrationUpdateOneWithoutStudentNestedInput
    academicDepartment?: AcademicDepartmentUpdateOneRequiredWithoutStudentsNestedInput
    academicFaculty?: AcademicFacultyUpdateOneRequiredWithoutStudentsNestedInput
    academicSemester?: AcademicSemesterUpdateOneRequiredWithoutStudentsNestedInput
    studentSemesterRegistrations?: StudentSemesterRegistrationUpdateManyWithoutStudentNestedInput
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseUpdateManyWithoutStudentNestedInput
    studentEnrolledCourses?: StudentEnrolledCourseUpdateManyWithoutStudentNestedInput
    studentSemesterPayments?: StudentSemesterPaymentUpdateManyWithoutStudentNestedInput
    studentAcademicInfos?: StudentAcademicInfoUpdateManyWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateWithoutStudentEnrolledCourseMarksInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    contactNo?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: StringFieldUpdateOperationsInput | string
    isWoker?: BoolFieldUpdateOperationsInput | boolean
    shift?: EnumShiftFieldUpdateOperationsInput | $Enums.Shift
    password?: StringFieldUpdateOperationsInput | string
    gradeDeclarationFile?: StringFieldUpdateOperationsInput | string
    biFile?: StringFieldUpdateOperationsInput | string
    presentAddress?: StringFieldUpdateOperationsInput | string
    permanentAddress?: NullableStringFieldUpdateOperationsInput | string | null
    academicSemesterId?: StringFieldUpdateOperationsInput | string
    academicFacultyId?: StringFieldUpdateOperationsInput | string
    academicDepartmentId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    admissionRegistrationId?: NullableStringFieldUpdateOperationsInput | string | null
    studentSemesterRegistrations?: StudentSemesterRegistrationUncheckedUpdateManyWithoutStudentNestedInput
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseUncheckedUpdateManyWithoutStudentNestedInput
    studentEnrolledCourses?: StudentEnrolledCourseUncheckedUpdateManyWithoutStudentNestedInput
    studentSemesterPayments?: StudentSemesterPaymentUncheckedUpdateManyWithoutStudentNestedInput
    studentAcademicInfos?: StudentAcademicInfoUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type StudentEnrolledCourseUpsertWithoutStudentEnrolledCourseMarksInput = {
    update: XOR<StudentEnrolledCourseUpdateWithoutStudentEnrolledCourseMarksInput, StudentEnrolledCourseUncheckedUpdateWithoutStudentEnrolledCourseMarksInput>
    create: XOR<StudentEnrolledCourseCreateWithoutStudentEnrolledCourseMarksInput, StudentEnrolledCourseUncheckedCreateWithoutStudentEnrolledCourseMarksInput>
    where?: StudentEnrolledCourseWhereInput
  }

  export type StudentEnrolledCourseUpdateToOneWithWhereWithoutStudentEnrolledCourseMarksInput = {
    where?: StudentEnrolledCourseWhereInput
    data: XOR<StudentEnrolledCourseUpdateWithoutStudentEnrolledCourseMarksInput, StudentEnrolledCourseUncheckedUpdateWithoutStudentEnrolledCourseMarksInput>
  }

  export type StudentEnrolledCourseUpdateWithoutStudentEnrolledCourseMarksInput = {
    id?: StringFieldUpdateOperationsInput | string
    grade?: NullableStringFieldUpdateOperationsInput | string | null
    point?: NullableFloatFieldUpdateOperationsInput | number | null
    totalMarks?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableEnumStudentEnrolledCourseStatusFieldUpdateOperationsInput | $Enums.StudentEnrolledCourseStatus | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUpdateOneRequiredWithoutStudentEnrolledCoursesNestedInput
    academicSemester?: AcademicSemesterUpdateOneRequiredWithoutStudentEnrolledCoursesNestedInput
    course?: CourseUpdateOneRequiredWithoutStudentEnrolledCoursesNestedInput
  }

  export type StudentEnrolledCourseUncheckedUpdateWithoutStudentEnrolledCourseMarksInput = {
    id?: StringFieldUpdateOperationsInput | string
    grade?: NullableStringFieldUpdateOperationsInput | string | null
    point?: NullableFloatFieldUpdateOperationsInput | number | null
    totalMarks?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableEnumStudentEnrolledCourseStatusFieldUpdateOperationsInput | $Enums.StudentEnrolledCourseStatus | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    studentId?: StringFieldUpdateOperationsInput | string
    academicSemesterId?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
  }

  export type AcademicSemesterUpsertWithoutStudentEnrolledCourseMarksInput = {
    update: XOR<AcademicSemesterUpdateWithoutStudentEnrolledCourseMarksInput, AcademicSemesterUncheckedUpdateWithoutStudentEnrolledCourseMarksInput>
    create: XOR<AcademicSemesterCreateWithoutStudentEnrolledCourseMarksInput, AcademicSemesterUncheckedCreateWithoutStudentEnrolledCourseMarksInput>
    where?: AcademicSemesterWhereInput
  }

  export type AcademicSemesterUpdateToOneWithWhereWithoutStudentEnrolledCourseMarksInput = {
    where?: AcademicSemesterWhereInput
    data: XOR<AcademicSemesterUpdateWithoutStudentEnrolledCourseMarksInput, AcademicSemesterUncheckedUpdateWithoutStudentEnrolledCourseMarksInput>
  }

  export type AcademicSemesterUpdateWithoutStudentEnrolledCourseMarksInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    year?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    startMonth?: StringFieldUpdateOperationsInput | string
    endMonth?: StringFieldUpdateOperationsInput | string
    isCurrent?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    semesterRegistrations?: SemesterRegistrationUpdateManyWithoutAcademicSemesterNestedInput
    students?: StudentUpdateOneWithoutAcademicSemesterNestedInput
    studentEnrolledCourses?: StudentEnrolledCourseUpdateManyWithoutAcademicSemesterNestedInput
    studentSemesterPayments?: StudentSemesterPaymentUpdateManyWithoutAcademicSemesterNestedInput
  }

  export type AcademicSemesterUncheckedUpdateWithoutStudentEnrolledCourseMarksInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    year?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    startMonth?: StringFieldUpdateOperationsInput | string
    endMonth?: StringFieldUpdateOperationsInput | string
    isCurrent?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    semesterRegistrations?: SemesterRegistrationUncheckedUpdateManyWithoutAcademicSemesterNestedInput
    students?: StudentUncheckedUpdateOneWithoutAcademicSemesterNestedInput
    studentEnrolledCourses?: StudentEnrolledCourseUncheckedUpdateManyWithoutAcademicSemesterNestedInput
    studentSemesterPayments?: StudentSemesterPaymentUncheckedUpdateManyWithoutAcademicSemesterNestedInput
  }

  export type StudentCreateWithoutStudentSemesterPaymentsInput = {
    id?: string
    studentId: string
    firstName: string
    middleName?: string | null
    lastName: string
    profileImage?: string | null
    email?: string | null
    contactNo?: string | null
    gender: string
    isWoker?: boolean
    shift?: $Enums.Shift
    password: string
    gradeDeclarationFile: string
    biFile: string
    presentAddress: string
    permanentAddress?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    admissionRegistration?: AdmitionExameRegistrationCreateNestedOneWithoutStudentInput
    academicDepartment: AcademicDepartmentCreateNestedOneWithoutStudentsInput
    academicFaculty: AcademicFacultyCreateNestedOneWithoutStudentsInput
    academicSemester: AcademicSemesterCreateNestedOneWithoutStudentsInput
    studentSemesterRegistrations?: StudentSemesterRegistrationCreateNestedManyWithoutStudentInput
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseCreateNestedManyWithoutStudentInput
    studentEnrolledCourses?: StudentEnrolledCourseCreateNestedManyWithoutStudentInput
    studentEnrolledCourseMarks?: StudentEnrolledCourseMarkCreateNestedManyWithoutStudentInput
    studentAcademicInfos?: StudentAcademicInfoCreateNestedManyWithoutStudentInput
  }

  export type StudentUncheckedCreateWithoutStudentSemesterPaymentsInput = {
    id?: string
    studentId: string
    firstName: string
    middleName?: string | null
    lastName: string
    profileImage?: string | null
    email?: string | null
    contactNo?: string | null
    gender: string
    isWoker?: boolean
    shift?: $Enums.Shift
    password: string
    gradeDeclarationFile: string
    biFile: string
    presentAddress: string
    permanentAddress?: string | null
    academicSemesterId: string
    academicFacultyId: string
    academicDepartmentId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    admissionRegistrationId?: string | null
    studentSemesterRegistrations?: StudentSemesterRegistrationUncheckedCreateNestedManyWithoutStudentInput
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseUncheckedCreateNestedManyWithoutStudentInput
    studentEnrolledCourses?: StudentEnrolledCourseUncheckedCreateNestedManyWithoutStudentInput
    studentEnrolledCourseMarks?: StudentEnrolledCourseMarkUncheckedCreateNestedManyWithoutStudentInput
    studentAcademicInfos?: StudentAcademicInfoUncheckedCreateNestedManyWithoutStudentInput
  }

  export type StudentCreateOrConnectWithoutStudentSemesterPaymentsInput = {
    where: StudentWhereUniqueInput
    create: XOR<StudentCreateWithoutStudentSemesterPaymentsInput, StudentUncheckedCreateWithoutStudentSemesterPaymentsInput>
  }

  export type AcademicSemesterCreateWithoutStudentSemesterPaymentsInput = {
    id?: string
    title: string
    year: string
    code: string
    startMonth: string
    endMonth: string
    isCurrent?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    semesterRegistrations?: SemesterRegistrationCreateNestedManyWithoutAcademicSemesterInput
    students?: StudentCreateNestedOneWithoutAcademicSemesterInput
    studentEnrolledCourses?: StudentEnrolledCourseCreateNestedManyWithoutAcademicSemesterInput
    studentEnrolledCourseMarks?: StudentEnrolledCourseMarkCreateNestedManyWithoutAcademicSemesterInput
  }

  export type AcademicSemesterUncheckedCreateWithoutStudentSemesterPaymentsInput = {
    id?: string
    title: string
    year: string
    code: string
    startMonth: string
    endMonth: string
    isCurrent?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    semesterRegistrations?: SemesterRegistrationUncheckedCreateNestedManyWithoutAcademicSemesterInput
    students?: StudentUncheckedCreateNestedOneWithoutAcademicSemesterInput
    studentEnrolledCourses?: StudentEnrolledCourseUncheckedCreateNestedManyWithoutAcademicSemesterInput
    studentEnrolledCourseMarks?: StudentEnrolledCourseMarkUncheckedCreateNestedManyWithoutAcademicSemesterInput
  }

  export type AcademicSemesterCreateOrConnectWithoutStudentSemesterPaymentsInput = {
    where: AcademicSemesterWhereUniqueInput
    create: XOR<AcademicSemesterCreateWithoutStudentSemesterPaymentsInput, AcademicSemesterUncheckedCreateWithoutStudentSemesterPaymentsInput>
  }

  export type StudentUpsertWithoutStudentSemesterPaymentsInput = {
    update: XOR<StudentUpdateWithoutStudentSemesterPaymentsInput, StudentUncheckedUpdateWithoutStudentSemesterPaymentsInput>
    create: XOR<StudentCreateWithoutStudentSemesterPaymentsInput, StudentUncheckedCreateWithoutStudentSemesterPaymentsInput>
    where?: StudentWhereInput
  }

  export type StudentUpdateToOneWithWhereWithoutStudentSemesterPaymentsInput = {
    where?: StudentWhereInput
    data: XOR<StudentUpdateWithoutStudentSemesterPaymentsInput, StudentUncheckedUpdateWithoutStudentSemesterPaymentsInput>
  }

  export type StudentUpdateWithoutStudentSemesterPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    contactNo?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: StringFieldUpdateOperationsInput | string
    isWoker?: BoolFieldUpdateOperationsInput | boolean
    shift?: EnumShiftFieldUpdateOperationsInput | $Enums.Shift
    password?: StringFieldUpdateOperationsInput | string
    gradeDeclarationFile?: StringFieldUpdateOperationsInput | string
    biFile?: StringFieldUpdateOperationsInput | string
    presentAddress?: StringFieldUpdateOperationsInput | string
    permanentAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    admissionRegistration?: AdmitionExameRegistrationUpdateOneWithoutStudentNestedInput
    academicDepartment?: AcademicDepartmentUpdateOneRequiredWithoutStudentsNestedInput
    academicFaculty?: AcademicFacultyUpdateOneRequiredWithoutStudentsNestedInput
    academicSemester?: AcademicSemesterUpdateOneRequiredWithoutStudentsNestedInput
    studentSemesterRegistrations?: StudentSemesterRegistrationUpdateManyWithoutStudentNestedInput
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseUpdateManyWithoutStudentNestedInput
    studentEnrolledCourses?: StudentEnrolledCourseUpdateManyWithoutStudentNestedInput
    studentEnrolledCourseMarks?: StudentEnrolledCourseMarkUpdateManyWithoutStudentNestedInput
    studentAcademicInfos?: StudentAcademicInfoUpdateManyWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateWithoutStudentSemesterPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    contactNo?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: StringFieldUpdateOperationsInput | string
    isWoker?: BoolFieldUpdateOperationsInput | boolean
    shift?: EnumShiftFieldUpdateOperationsInput | $Enums.Shift
    password?: StringFieldUpdateOperationsInput | string
    gradeDeclarationFile?: StringFieldUpdateOperationsInput | string
    biFile?: StringFieldUpdateOperationsInput | string
    presentAddress?: StringFieldUpdateOperationsInput | string
    permanentAddress?: NullableStringFieldUpdateOperationsInput | string | null
    academicSemesterId?: StringFieldUpdateOperationsInput | string
    academicFacultyId?: StringFieldUpdateOperationsInput | string
    academicDepartmentId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    admissionRegistrationId?: NullableStringFieldUpdateOperationsInput | string | null
    studentSemesterRegistrations?: StudentSemesterRegistrationUncheckedUpdateManyWithoutStudentNestedInput
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseUncheckedUpdateManyWithoutStudentNestedInput
    studentEnrolledCourses?: StudentEnrolledCourseUncheckedUpdateManyWithoutStudentNestedInput
    studentEnrolledCourseMarks?: StudentEnrolledCourseMarkUncheckedUpdateManyWithoutStudentNestedInput
    studentAcademicInfos?: StudentAcademicInfoUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type AcademicSemesterUpsertWithoutStudentSemesterPaymentsInput = {
    update: XOR<AcademicSemesterUpdateWithoutStudentSemesterPaymentsInput, AcademicSemesterUncheckedUpdateWithoutStudentSemesterPaymentsInput>
    create: XOR<AcademicSemesterCreateWithoutStudentSemesterPaymentsInput, AcademicSemesterUncheckedCreateWithoutStudentSemesterPaymentsInput>
    where?: AcademicSemesterWhereInput
  }

  export type AcademicSemesterUpdateToOneWithWhereWithoutStudentSemesterPaymentsInput = {
    where?: AcademicSemesterWhereInput
    data: XOR<AcademicSemesterUpdateWithoutStudentSemesterPaymentsInput, AcademicSemesterUncheckedUpdateWithoutStudentSemesterPaymentsInput>
  }

  export type AcademicSemesterUpdateWithoutStudentSemesterPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    year?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    startMonth?: StringFieldUpdateOperationsInput | string
    endMonth?: StringFieldUpdateOperationsInput | string
    isCurrent?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    semesterRegistrations?: SemesterRegistrationUpdateManyWithoutAcademicSemesterNestedInput
    students?: StudentUpdateOneWithoutAcademicSemesterNestedInput
    studentEnrolledCourses?: StudentEnrolledCourseUpdateManyWithoutAcademicSemesterNestedInput
    studentEnrolledCourseMarks?: StudentEnrolledCourseMarkUpdateManyWithoutAcademicSemesterNestedInput
  }

  export type AcademicSemesterUncheckedUpdateWithoutStudentSemesterPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    year?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    startMonth?: StringFieldUpdateOperationsInput | string
    endMonth?: StringFieldUpdateOperationsInput | string
    isCurrent?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    semesterRegistrations?: SemesterRegistrationUncheckedUpdateManyWithoutAcademicSemesterNestedInput
    students?: StudentUncheckedUpdateOneWithoutAcademicSemesterNestedInput
    studentEnrolledCourses?: StudentEnrolledCourseUncheckedUpdateManyWithoutAcademicSemesterNestedInput
    studentEnrolledCourseMarks?: StudentEnrolledCourseMarkUncheckedUpdateManyWithoutAcademicSemesterNestedInput
  }

  export type StudentCreateWithoutStudentAcademicInfosInput = {
    id?: string
    studentId: string
    firstName: string
    middleName?: string | null
    lastName: string
    profileImage?: string | null
    email?: string | null
    contactNo?: string | null
    gender: string
    isWoker?: boolean
    shift?: $Enums.Shift
    password: string
    gradeDeclarationFile: string
    biFile: string
    presentAddress: string
    permanentAddress?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    admissionRegistration?: AdmitionExameRegistrationCreateNestedOneWithoutStudentInput
    academicDepartment: AcademicDepartmentCreateNestedOneWithoutStudentsInput
    academicFaculty: AcademicFacultyCreateNestedOneWithoutStudentsInput
    academicSemester: AcademicSemesterCreateNestedOneWithoutStudentsInput
    studentSemesterRegistrations?: StudentSemesterRegistrationCreateNestedManyWithoutStudentInput
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseCreateNestedManyWithoutStudentInput
    studentEnrolledCourses?: StudentEnrolledCourseCreateNestedManyWithoutStudentInput
    studentEnrolledCourseMarks?: StudentEnrolledCourseMarkCreateNestedManyWithoutStudentInput
    studentSemesterPayments?: StudentSemesterPaymentCreateNestedManyWithoutStudentInput
  }

  export type StudentUncheckedCreateWithoutStudentAcademicInfosInput = {
    id?: string
    studentId: string
    firstName: string
    middleName?: string | null
    lastName: string
    profileImage?: string | null
    email?: string | null
    contactNo?: string | null
    gender: string
    isWoker?: boolean
    shift?: $Enums.Shift
    password: string
    gradeDeclarationFile: string
    biFile: string
    presentAddress: string
    permanentAddress?: string | null
    academicSemesterId: string
    academicFacultyId: string
    academicDepartmentId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    admissionRegistrationId?: string | null
    studentSemesterRegistrations?: StudentSemesterRegistrationUncheckedCreateNestedManyWithoutStudentInput
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseUncheckedCreateNestedManyWithoutStudentInput
    studentEnrolledCourses?: StudentEnrolledCourseUncheckedCreateNestedManyWithoutStudentInput
    studentEnrolledCourseMarks?: StudentEnrolledCourseMarkUncheckedCreateNestedManyWithoutStudentInput
    studentSemesterPayments?: StudentSemesterPaymentUncheckedCreateNestedManyWithoutStudentInput
  }

  export type StudentCreateOrConnectWithoutStudentAcademicInfosInput = {
    where: StudentWhereUniqueInput
    create: XOR<StudentCreateWithoutStudentAcademicInfosInput, StudentUncheckedCreateWithoutStudentAcademicInfosInput>
  }

  export type StudentUpsertWithoutStudentAcademicInfosInput = {
    update: XOR<StudentUpdateWithoutStudentAcademicInfosInput, StudentUncheckedUpdateWithoutStudentAcademicInfosInput>
    create: XOR<StudentCreateWithoutStudentAcademicInfosInput, StudentUncheckedCreateWithoutStudentAcademicInfosInput>
    where?: StudentWhereInput
  }

  export type StudentUpdateToOneWithWhereWithoutStudentAcademicInfosInput = {
    where?: StudentWhereInput
    data: XOR<StudentUpdateWithoutStudentAcademicInfosInput, StudentUncheckedUpdateWithoutStudentAcademicInfosInput>
  }

  export type StudentUpdateWithoutStudentAcademicInfosInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    contactNo?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: StringFieldUpdateOperationsInput | string
    isWoker?: BoolFieldUpdateOperationsInput | boolean
    shift?: EnumShiftFieldUpdateOperationsInput | $Enums.Shift
    password?: StringFieldUpdateOperationsInput | string
    gradeDeclarationFile?: StringFieldUpdateOperationsInput | string
    biFile?: StringFieldUpdateOperationsInput | string
    presentAddress?: StringFieldUpdateOperationsInput | string
    permanentAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    admissionRegistration?: AdmitionExameRegistrationUpdateOneWithoutStudentNestedInput
    academicDepartment?: AcademicDepartmentUpdateOneRequiredWithoutStudentsNestedInput
    academicFaculty?: AcademicFacultyUpdateOneRequiredWithoutStudentsNestedInput
    academicSemester?: AcademicSemesterUpdateOneRequiredWithoutStudentsNestedInput
    studentSemesterRegistrations?: StudentSemesterRegistrationUpdateManyWithoutStudentNestedInput
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseUpdateManyWithoutStudentNestedInput
    studentEnrolledCourses?: StudentEnrolledCourseUpdateManyWithoutStudentNestedInput
    studentEnrolledCourseMarks?: StudentEnrolledCourseMarkUpdateManyWithoutStudentNestedInput
    studentSemesterPayments?: StudentSemesterPaymentUpdateManyWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateWithoutStudentAcademicInfosInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    contactNo?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: StringFieldUpdateOperationsInput | string
    isWoker?: BoolFieldUpdateOperationsInput | boolean
    shift?: EnumShiftFieldUpdateOperationsInput | $Enums.Shift
    password?: StringFieldUpdateOperationsInput | string
    gradeDeclarationFile?: StringFieldUpdateOperationsInput | string
    biFile?: StringFieldUpdateOperationsInput | string
    presentAddress?: StringFieldUpdateOperationsInput | string
    permanentAddress?: NullableStringFieldUpdateOperationsInput | string | null
    academicSemesterId?: StringFieldUpdateOperationsInput | string
    academicFacultyId?: StringFieldUpdateOperationsInput | string
    academicDepartmentId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    admissionRegistrationId?: NullableStringFieldUpdateOperationsInput | string | null
    studentSemesterRegistrations?: StudentSemesterRegistrationUncheckedUpdateManyWithoutStudentNestedInput
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseUncheckedUpdateManyWithoutStudentNestedInput
    studentEnrolledCourses?: StudentEnrolledCourseUncheckedUpdateManyWithoutStudentNestedInput
    studentEnrolledCourseMarks?: StudentEnrolledCourseMarkUncheckedUpdateManyWithoutStudentNestedInput
    studentSemesterPayments?: StudentSemesterPaymentUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type AcademicDepartmentUpdateWithoutStaffMembersInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    academicFaculty?: AcademicFacultyUpdateOneRequiredWithoutAcademicDepartmentsNestedInput
    faculties?: FacultyUpdateOneWithoutAcademicDepartmentNestedInput
    students?: StudentUpdateOneWithoutAcademicDepartmentNestedInput
    departmentHead?: UsersUpdateOneWithoutAcademicDepartmentNestedInput
    admitionExame?: AdmitionExameRegistrationUpdateManyWithoutDepartmentNestedInput
    offeredCourses?: OfferedCourseUpdateManyWithoutAcademicDepartmentNestedInput
  }

  export type AcademicDepartmentUncheckedUpdateWithoutStaffMembersInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    academicFacultyId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    departmentHeadId?: NullableStringFieldUpdateOperationsInput | string | null
    faculties?: FacultyUncheckedUpdateOneWithoutAcademicDepartmentNestedInput
    students?: StudentUncheckedUpdateOneWithoutAcademicDepartmentNestedInput
    admitionExame?: AdmitionExameRegistrationUncheckedUpdateManyWithoutDepartmentNestedInput
    offeredCourses?: OfferedCourseUncheckedUpdateManyWithoutAcademicDepartmentNestedInput
  }

  export type AcademicDepartmentUncheckedUpdateManyWithoutStaffMembersInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    academicFacultyId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    departmentHeadId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SemesterRegistrationCreateManyAcademicSemesterInput = {
    id?: string
    startDate: Date | string
    endDate: Date | string
    status?: $Enums.SemesterRegistrationStatus | null
    paymentRecipt: string
    totalPayment?: number
    createdAt?: Date | string
    updateAt?: Date | string
  }

  export type StudentEnrolledCourseCreateManyAcademicSemesterInput = {
    id?: string
    grade?: string | null
    point?: number | null
    totalMarks?: number | null
    status?: $Enums.StudentEnrolledCourseStatus | null
    createdAt?: Date | string
    updatedAt?: Date | string
    studentId: string
    courseId: string
  }

  export type StudentEnrolledCourseMarkCreateManyAcademicSemesterInput = {
    id?: string
    examType?: $Enums.ExamType | null
    createdAt?: Date | string
    updatedAt?: Date | string
    studentId: string
    studentEnrolledCourseId: string
    exam1?: number
    exam2?: number
    exam3?: number
    exam4?: number
    exam5?: number
    exam6?: number
    finalExam?: number
    totalMarks?: number
    grade?: number
  }

  export type StudentSemesterPaymentCreateManyAcademicSemesterInput = {
    id?: string
    paymentRecipt?: string | null
    totalPayment?: number
    baseAmount: number
    lateFee?: number
    aprovedPayment?: boolean
    paymentType?: $Enums.PAYMENTTYPE
    paymentStatus?: $Enums.PaymentStatus | null
    paymentMonth: number
    paymentYear: number
    createdAt?: Date | string
    updatedAt?: Date | string
    studentId: string
  }

  export type SemesterRegistrationUpdateWithoutAcademicSemesterInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: NullableEnumSemesterRegistrationStatusFieldUpdateOperationsInput | $Enums.SemesterRegistrationStatus | null
    paymentRecipt?: StringFieldUpdateOperationsInput | string
    totalPayment?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    offeredCourses?: OfferedCourseUpdateManyWithoutSemesterRegistrationNestedInput
    offeredCourseSections?: OfferedCourseSectionUpdateManyWithoutSemesterRegistrationNestedInput
    offeredCourseClassSchedules?: OfferedCourseClassScheduleUpdateManyWithoutSemesterRegistrationNestedInput
    studentSemesterRegistrations?: StudentSemesterRegistrationUpdateManyWithoutSemesterRegistrationNestedInput
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseUpdateManyWithoutSemesterRegistrationNestedInput
  }

  export type SemesterRegistrationUncheckedUpdateWithoutAcademicSemesterInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: NullableEnumSemesterRegistrationStatusFieldUpdateOperationsInput | $Enums.SemesterRegistrationStatus | null
    paymentRecipt?: StringFieldUpdateOperationsInput | string
    totalPayment?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    offeredCourses?: OfferedCourseUncheckedUpdateManyWithoutSemesterRegistrationNestedInput
    offeredCourseSections?: OfferedCourseSectionUncheckedUpdateManyWithoutSemesterRegistrationNestedInput
    offeredCourseClassSchedules?: OfferedCourseClassScheduleUncheckedUpdateManyWithoutSemesterRegistrationNestedInput
    studentSemesterRegistrations?: StudentSemesterRegistrationUncheckedUpdateManyWithoutSemesterRegistrationNestedInput
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseUncheckedUpdateManyWithoutSemesterRegistrationNestedInput
  }

  export type SemesterRegistrationUncheckedUpdateManyWithoutAcademicSemesterInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: NullableEnumSemesterRegistrationStatusFieldUpdateOperationsInput | $Enums.SemesterRegistrationStatus | null
    paymentRecipt?: StringFieldUpdateOperationsInput | string
    totalPayment?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentEnrolledCourseUpdateWithoutAcademicSemesterInput = {
    id?: StringFieldUpdateOperationsInput | string
    grade?: NullableStringFieldUpdateOperationsInput | string | null
    point?: NullableFloatFieldUpdateOperationsInput | number | null
    totalMarks?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableEnumStudentEnrolledCourseStatusFieldUpdateOperationsInput | $Enums.StudentEnrolledCourseStatus | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUpdateOneRequiredWithoutStudentEnrolledCoursesNestedInput
    course?: CourseUpdateOneRequiredWithoutStudentEnrolledCoursesNestedInput
    studentEnrolledCourseMarks?: StudentEnrolledCourseMarkUpdateManyWithoutStudentEnrolledCourseNestedInput
  }

  export type StudentEnrolledCourseUncheckedUpdateWithoutAcademicSemesterInput = {
    id?: StringFieldUpdateOperationsInput | string
    grade?: NullableStringFieldUpdateOperationsInput | string | null
    point?: NullableFloatFieldUpdateOperationsInput | number | null
    totalMarks?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableEnumStudentEnrolledCourseStatusFieldUpdateOperationsInput | $Enums.StudentEnrolledCourseStatus | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    studentId?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    studentEnrolledCourseMarks?: StudentEnrolledCourseMarkUncheckedUpdateManyWithoutStudentEnrolledCourseNestedInput
  }

  export type StudentEnrolledCourseUncheckedUpdateManyWithoutAcademicSemesterInput = {
    id?: StringFieldUpdateOperationsInput | string
    grade?: NullableStringFieldUpdateOperationsInput | string | null
    point?: NullableFloatFieldUpdateOperationsInput | number | null
    totalMarks?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableEnumStudentEnrolledCourseStatusFieldUpdateOperationsInput | $Enums.StudentEnrolledCourseStatus | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    studentId?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
  }

  export type StudentEnrolledCourseMarkUpdateWithoutAcademicSemesterInput = {
    id?: StringFieldUpdateOperationsInput | string
    examType?: NullableEnumExamTypeFieldUpdateOperationsInput | $Enums.ExamType | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    exam1?: FloatFieldUpdateOperationsInput | number
    exam2?: FloatFieldUpdateOperationsInput | number
    exam3?: FloatFieldUpdateOperationsInput | number
    exam4?: FloatFieldUpdateOperationsInput | number
    exam5?: FloatFieldUpdateOperationsInput | number
    exam6?: FloatFieldUpdateOperationsInput | number
    finalExam?: FloatFieldUpdateOperationsInput | number
    totalMarks?: FloatFieldUpdateOperationsInput | number
    grade?: FloatFieldUpdateOperationsInput | number
    student?: StudentUpdateOneRequiredWithoutStudentEnrolledCourseMarksNestedInput
    studentEnrolledCourse?: StudentEnrolledCourseUpdateOneRequiredWithoutStudentEnrolledCourseMarksNestedInput
  }

  export type StudentEnrolledCourseMarkUncheckedUpdateWithoutAcademicSemesterInput = {
    id?: StringFieldUpdateOperationsInput | string
    examType?: NullableEnumExamTypeFieldUpdateOperationsInput | $Enums.ExamType | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    studentId?: StringFieldUpdateOperationsInput | string
    studentEnrolledCourseId?: StringFieldUpdateOperationsInput | string
    exam1?: FloatFieldUpdateOperationsInput | number
    exam2?: FloatFieldUpdateOperationsInput | number
    exam3?: FloatFieldUpdateOperationsInput | number
    exam4?: FloatFieldUpdateOperationsInput | number
    exam5?: FloatFieldUpdateOperationsInput | number
    exam6?: FloatFieldUpdateOperationsInput | number
    finalExam?: FloatFieldUpdateOperationsInput | number
    totalMarks?: FloatFieldUpdateOperationsInput | number
    grade?: FloatFieldUpdateOperationsInput | number
  }

  export type StudentEnrolledCourseMarkUncheckedUpdateManyWithoutAcademicSemesterInput = {
    id?: StringFieldUpdateOperationsInput | string
    examType?: NullableEnumExamTypeFieldUpdateOperationsInput | $Enums.ExamType | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    studentId?: StringFieldUpdateOperationsInput | string
    studentEnrolledCourseId?: StringFieldUpdateOperationsInput | string
    exam1?: FloatFieldUpdateOperationsInput | number
    exam2?: FloatFieldUpdateOperationsInput | number
    exam3?: FloatFieldUpdateOperationsInput | number
    exam4?: FloatFieldUpdateOperationsInput | number
    exam5?: FloatFieldUpdateOperationsInput | number
    exam6?: FloatFieldUpdateOperationsInput | number
    finalExam?: FloatFieldUpdateOperationsInput | number
    totalMarks?: FloatFieldUpdateOperationsInput | number
    grade?: FloatFieldUpdateOperationsInput | number
  }

  export type StudentSemesterPaymentUpdateWithoutAcademicSemesterInput = {
    id?: StringFieldUpdateOperationsInput | string
    paymentRecipt?: NullableStringFieldUpdateOperationsInput | string | null
    totalPayment?: IntFieldUpdateOperationsInput | number
    baseAmount?: IntFieldUpdateOperationsInput | number
    lateFee?: IntFieldUpdateOperationsInput | number
    aprovedPayment?: BoolFieldUpdateOperationsInput | boolean
    paymentType?: EnumPAYMENTTYPEFieldUpdateOperationsInput | $Enums.PAYMENTTYPE
    paymentStatus?: NullableEnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus | null
    paymentMonth?: IntFieldUpdateOperationsInput | number
    paymentYear?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUpdateOneRequiredWithoutStudentSemesterPaymentsNestedInput
  }

  export type StudentSemesterPaymentUncheckedUpdateWithoutAcademicSemesterInput = {
    id?: StringFieldUpdateOperationsInput | string
    paymentRecipt?: NullableStringFieldUpdateOperationsInput | string | null
    totalPayment?: IntFieldUpdateOperationsInput | number
    baseAmount?: IntFieldUpdateOperationsInput | number
    lateFee?: IntFieldUpdateOperationsInput | number
    aprovedPayment?: BoolFieldUpdateOperationsInput | boolean
    paymentType?: EnumPAYMENTTYPEFieldUpdateOperationsInput | $Enums.PAYMENTTYPE
    paymentStatus?: NullableEnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus | null
    paymentMonth?: IntFieldUpdateOperationsInput | number
    paymentYear?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    studentId?: StringFieldUpdateOperationsInput | string
  }

  export type StudentSemesterPaymentUncheckedUpdateManyWithoutAcademicSemesterInput = {
    id?: StringFieldUpdateOperationsInput | string
    paymentRecipt?: NullableStringFieldUpdateOperationsInput | string | null
    totalPayment?: IntFieldUpdateOperationsInput | number
    baseAmount?: IntFieldUpdateOperationsInput | number
    lateFee?: IntFieldUpdateOperationsInput | number
    aprovedPayment?: BoolFieldUpdateOperationsInput | boolean
    paymentType?: EnumPAYMENTTYPEFieldUpdateOperationsInput | $Enums.PAYMENTTYPE
    paymentStatus?: NullableEnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus | null
    paymentMonth?: IntFieldUpdateOperationsInput | number
    paymentYear?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    studentId?: StringFieldUpdateOperationsInput | string
  }

  export type AdmitionExameRegistrationCreateManyDepartmentInput = {
    id?: string
    applicantName: string
    paymentRecipt: string
    document: string
    paymentAmoute?: number | null
    aprovePayment?: boolean | null
    exameResults?: number | null
    passed?: boolean | null
    fase?: number
    exameDate: Date | string
    createdAt?: Date | string
    updateAt?: Date | string
  }

  export type OfferedCourseCreateManyAcademicDepartmentInput = {
    id?: string
    courseId: string
    semesterRegistrationId: string
  }

  export type UsersUpdateWithoutStaffDepartmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    academicDepartment?: AcademicDepartmentUpdateOneWithoutDepartmentHeadNestedInput
  }

  export type UsersUncheckedUpdateWithoutStaffDepartmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    academicDepartment?: AcademicDepartmentUncheckedUpdateOneWithoutDepartmentHeadNestedInput
  }

  export type UsersUncheckedUpdateManyWithoutStaffDepartmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdmitionExameRegistrationUpdateWithoutDepartmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    applicantName?: StringFieldUpdateOperationsInput | string
    paymentRecipt?: StringFieldUpdateOperationsInput | string
    document?: StringFieldUpdateOperationsInput | string
    paymentAmoute?: NullableIntFieldUpdateOperationsInput | number | null
    aprovePayment?: NullableBoolFieldUpdateOperationsInput | boolean | null
    exameResults?: NullableIntFieldUpdateOperationsInput | number | null
    passed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    fase?: IntFieldUpdateOperationsInput | number
    exameDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Student?: StudentUpdateOneWithoutAdmissionRegistrationNestedInput
  }

  export type AdmitionExameRegistrationUncheckedUpdateWithoutDepartmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    applicantName?: StringFieldUpdateOperationsInput | string
    paymentRecipt?: StringFieldUpdateOperationsInput | string
    document?: StringFieldUpdateOperationsInput | string
    paymentAmoute?: NullableIntFieldUpdateOperationsInput | number | null
    aprovePayment?: NullableBoolFieldUpdateOperationsInput | boolean | null
    exameResults?: NullableIntFieldUpdateOperationsInput | number | null
    passed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    fase?: IntFieldUpdateOperationsInput | number
    exameDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Student?: StudentUncheckedUpdateOneWithoutAdmissionRegistrationNestedInput
  }

  export type AdmitionExameRegistrationUncheckedUpdateManyWithoutDepartmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    applicantName?: StringFieldUpdateOperationsInput | string
    paymentRecipt?: StringFieldUpdateOperationsInput | string
    document?: StringFieldUpdateOperationsInput | string
    paymentAmoute?: NullableIntFieldUpdateOperationsInput | number | null
    aprovePayment?: NullableBoolFieldUpdateOperationsInput | boolean | null
    exameResults?: NullableIntFieldUpdateOperationsInput | number | null
    passed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    fase?: IntFieldUpdateOperationsInput | number
    exameDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OfferedCourseUpdateWithoutAcademicDepartmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    semesterRegistration?: SemesterRegistrationUpdateOneRequiredWithoutOfferedCoursesNestedInput
    course?: CourseUpdateOneRequiredWithoutOfferedCoursesNestedInput
    offeredCourseSections?: OfferedCourseSectionUpdateManyWithoutOfferedCourseNestedInput
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseUpdateManyWithoutOfferedCourseNestedInput
  }

  export type OfferedCourseUncheckedUpdateWithoutAcademicDepartmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    semesterRegistrationId?: StringFieldUpdateOperationsInput | string
    offeredCourseSections?: OfferedCourseSectionUncheckedUpdateManyWithoutOfferedCourseNestedInput
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseUncheckedUpdateManyWithoutOfferedCourseNestedInput
  }

  export type OfferedCourseUncheckedUpdateManyWithoutAcademicDepartmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    semesterRegistrationId?: StringFieldUpdateOperationsInput | string
  }

  export type StudentSemesterRegistrationCreateManyStudentInput = {
    id?: string
    isConfirmed?: boolean | null
    totalCreditsTaken?: number | null
    paymentRecipt?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    semesterRegistrationId: string
  }

  export type StudentSemesterRegistrationCourseCreateManyStudentInput = {
    semesterRegistrationId: string
    offeredCourseId: string
    offeredCourseSectionId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StudentEnrolledCourseCreateManyStudentInput = {
    id?: string
    grade?: string | null
    point?: number | null
    totalMarks?: number | null
    status?: $Enums.StudentEnrolledCourseStatus | null
    createdAt?: Date | string
    updatedAt?: Date | string
    academicSemesterId: string
    courseId: string
  }

  export type StudentEnrolledCourseMarkCreateManyStudentInput = {
    id?: string
    examType?: $Enums.ExamType | null
    createdAt?: Date | string
    updatedAt?: Date | string
    studentEnrolledCourseId: string
    academicSemesterId: string
    exam1?: number
    exam2?: number
    exam3?: number
    exam4?: number
    exam5?: number
    exam6?: number
    finalExam?: number
    totalMarks?: number
    grade?: number
  }

  export type StudentSemesterPaymentCreateManyStudentInput = {
    id?: string
    paymentRecipt?: string | null
    totalPayment?: number
    baseAmount: number
    lateFee?: number
    aprovedPayment?: boolean
    paymentType?: $Enums.PAYMENTTYPE
    paymentStatus?: $Enums.PaymentStatus | null
    paymentMonth: number
    paymentYear: number
    createdAt?: Date | string
    updatedAt?: Date | string
    academicSemesterId: string
  }

  export type StudentAcademicInfoCreateManyStudentInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    totalCompletedCredits?: number | null
    cgpa?: number | null
  }

  export type StudentSemesterRegistrationUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    isConfirmed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    totalCreditsTaken?: NullableIntFieldUpdateOperationsInput | number | null
    paymentRecipt?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    semesterRegistration?: SemesterRegistrationUpdateOneRequiredWithoutStudentSemesterRegistrationsNestedInput
  }

  export type StudentSemesterRegistrationUncheckedUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    isConfirmed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    totalCreditsTaken?: NullableIntFieldUpdateOperationsInput | number | null
    paymentRecipt?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    semesterRegistrationId?: StringFieldUpdateOperationsInput | string
  }

  export type StudentSemesterRegistrationUncheckedUpdateManyWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    isConfirmed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    totalCreditsTaken?: NullableIntFieldUpdateOperationsInput | number | null
    paymentRecipt?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    semesterRegistrationId?: StringFieldUpdateOperationsInput | string
  }

  export type StudentSemesterRegistrationCourseUpdateWithoutStudentInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    semesterRegistration?: SemesterRegistrationUpdateOneRequiredWithoutStudentSemesterRegistrationCoursesNestedInput
    offeredCourse?: OfferedCourseUpdateOneRequiredWithoutStudentSemesterRegistrationCoursesNestedInput
    offeredCourseSection?: OfferedCourseSectionUpdateOneRequiredWithoutStudentSemesterRegistrationCoursesNestedInput
  }

  export type StudentSemesterRegistrationCourseUncheckedUpdateWithoutStudentInput = {
    semesterRegistrationId?: StringFieldUpdateOperationsInput | string
    offeredCourseId?: StringFieldUpdateOperationsInput | string
    offeredCourseSectionId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentSemesterRegistrationCourseUncheckedUpdateManyWithoutStudentInput = {
    semesterRegistrationId?: StringFieldUpdateOperationsInput | string
    offeredCourseId?: StringFieldUpdateOperationsInput | string
    offeredCourseSectionId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentEnrolledCourseUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    grade?: NullableStringFieldUpdateOperationsInput | string | null
    point?: NullableFloatFieldUpdateOperationsInput | number | null
    totalMarks?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableEnumStudentEnrolledCourseStatusFieldUpdateOperationsInput | $Enums.StudentEnrolledCourseStatus | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    academicSemester?: AcademicSemesterUpdateOneRequiredWithoutStudentEnrolledCoursesNestedInput
    course?: CourseUpdateOneRequiredWithoutStudentEnrolledCoursesNestedInput
    studentEnrolledCourseMarks?: StudentEnrolledCourseMarkUpdateManyWithoutStudentEnrolledCourseNestedInput
  }

  export type StudentEnrolledCourseUncheckedUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    grade?: NullableStringFieldUpdateOperationsInput | string | null
    point?: NullableFloatFieldUpdateOperationsInput | number | null
    totalMarks?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableEnumStudentEnrolledCourseStatusFieldUpdateOperationsInput | $Enums.StudentEnrolledCourseStatus | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    academicSemesterId?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    studentEnrolledCourseMarks?: StudentEnrolledCourseMarkUncheckedUpdateManyWithoutStudentEnrolledCourseNestedInput
  }

  export type StudentEnrolledCourseUncheckedUpdateManyWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    grade?: NullableStringFieldUpdateOperationsInput | string | null
    point?: NullableFloatFieldUpdateOperationsInput | number | null
    totalMarks?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableEnumStudentEnrolledCourseStatusFieldUpdateOperationsInput | $Enums.StudentEnrolledCourseStatus | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    academicSemesterId?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
  }

  export type StudentEnrolledCourseMarkUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    examType?: NullableEnumExamTypeFieldUpdateOperationsInput | $Enums.ExamType | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    exam1?: FloatFieldUpdateOperationsInput | number
    exam2?: FloatFieldUpdateOperationsInput | number
    exam3?: FloatFieldUpdateOperationsInput | number
    exam4?: FloatFieldUpdateOperationsInput | number
    exam5?: FloatFieldUpdateOperationsInput | number
    exam6?: FloatFieldUpdateOperationsInput | number
    finalExam?: FloatFieldUpdateOperationsInput | number
    totalMarks?: FloatFieldUpdateOperationsInput | number
    grade?: FloatFieldUpdateOperationsInput | number
    studentEnrolledCourse?: StudentEnrolledCourseUpdateOneRequiredWithoutStudentEnrolledCourseMarksNestedInput
    academicSemester?: AcademicSemesterUpdateOneRequiredWithoutStudentEnrolledCourseMarksNestedInput
  }

  export type StudentEnrolledCourseMarkUncheckedUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    examType?: NullableEnumExamTypeFieldUpdateOperationsInput | $Enums.ExamType | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    studentEnrolledCourseId?: StringFieldUpdateOperationsInput | string
    academicSemesterId?: StringFieldUpdateOperationsInput | string
    exam1?: FloatFieldUpdateOperationsInput | number
    exam2?: FloatFieldUpdateOperationsInput | number
    exam3?: FloatFieldUpdateOperationsInput | number
    exam4?: FloatFieldUpdateOperationsInput | number
    exam5?: FloatFieldUpdateOperationsInput | number
    exam6?: FloatFieldUpdateOperationsInput | number
    finalExam?: FloatFieldUpdateOperationsInput | number
    totalMarks?: FloatFieldUpdateOperationsInput | number
    grade?: FloatFieldUpdateOperationsInput | number
  }

  export type StudentEnrolledCourseMarkUncheckedUpdateManyWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    examType?: NullableEnumExamTypeFieldUpdateOperationsInput | $Enums.ExamType | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    studentEnrolledCourseId?: StringFieldUpdateOperationsInput | string
    academicSemesterId?: StringFieldUpdateOperationsInput | string
    exam1?: FloatFieldUpdateOperationsInput | number
    exam2?: FloatFieldUpdateOperationsInput | number
    exam3?: FloatFieldUpdateOperationsInput | number
    exam4?: FloatFieldUpdateOperationsInput | number
    exam5?: FloatFieldUpdateOperationsInput | number
    exam6?: FloatFieldUpdateOperationsInput | number
    finalExam?: FloatFieldUpdateOperationsInput | number
    totalMarks?: FloatFieldUpdateOperationsInput | number
    grade?: FloatFieldUpdateOperationsInput | number
  }

  export type StudentSemesterPaymentUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    paymentRecipt?: NullableStringFieldUpdateOperationsInput | string | null
    totalPayment?: IntFieldUpdateOperationsInput | number
    baseAmount?: IntFieldUpdateOperationsInput | number
    lateFee?: IntFieldUpdateOperationsInput | number
    aprovedPayment?: BoolFieldUpdateOperationsInput | boolean
    paymentType?: EnumPAYMENTTYPEFieldUpdateOperationsInput | $Enums.PAYMENTTYPE
    paymentStatus?: NullableEnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus | null
    paymentMonth?: IntFieldUpdateOperationsInput | number
    paymentYear?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    academicSemester?: AcademicSemesterUpdateOneRequiredWithoutStudentSemesterPaymentsNestedInput
  }

  export type StudentSemesterPaymentUncheckedUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    paymentRecipt?: NullableStringFieldUpdateOperationsInput | string | null
    totalPayment?: IntFieldUpdateOperationsInput | number
    baseAmount?: IntFieldUpdateOperationsInput | number
    lateFee?: IntFieldUpdateOperationsInput | number
    aprovedPayment?: BoolFieldUpdateOperationsInput | boolean
    paymentType?: EnumPAYMENTTYPEFieldUpdateOperationsInput | $Enums.PAYMENTTYPE
    paymentStatus?: NullableEnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus | null
    paymentMonth?: IntFieldUpdateOperationsInput | number
    paymentYear?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    academicSemesterId?: StringFieldUpdateOperationsInput | string
  }

  export type StudentSemesterPaymentUncheckedUpdateManyWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    paymentRecipt?: NullableStringFieldUpdateOperationsInput | string | null
    totalPayment?: IntFieldUpdateOperationsInput | number
    baseAmount?: IntFieldUpdateOperationsInput | number
    lateFee?: IntFieldUpdateOperationsInput | number
    aprovedPayment?: BoolFieldUpdateOperationsInput | boolean
    paymentType?: EnumPAYMENTTYPEFieldUpdateOperationsInput | $Enums.PAYMENTTYPE
    paymentStatus?: NullableEnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus | null
    paymentMonth?: IntFieldUpdateOperationsInput | number
    paymentYear?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    academicSemesterId?: StringFieldUpdateOperationsInput | string
  }

  export type StudentAcademicInfoUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    totalCompletedCredits?: NullableIntFieldUpdateOperationsInput | number | null
    cgpa?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type StudentAcademicInfoUncheckedUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    totalCompletedCredits?: NullableIntFieldUpdateOperationsInput | number | null
    cgpa?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type StudentAcademicInfoUncheckedUpdateManyWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    totalCompletedCredits?: NullableIntFieldUpdateOperationsInput | number | null
    cgpa?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type CourseFacultyCreateManyFacultyInput = {
    courseId: string
  }

  export type OfferedCourseClassScheduleCreateManyFacultyInput = {
    id?: string
    startTime: string
    endTime: string
    dayOfWeek?: $Enums.WeekDays
    createdAt?: Date | string
    updatedAt?: Date | string
    offeredCourseSectionId: string
    semesterRegistrationId: string
    roomId: string
  }

  export type CourseFacultyUpdateWithoutFacultyInput = {
    course?: CourseUpdateOneRequiredWithoutFacultiesNestedInput
  }

  export type CourseFacultyUncheckedUpdateWithoutFacultyInput = {
    courseId?: StringFieldUpdateOperationsInput | string
  }

  export type CourseFacultyUncheckedUpdateManyWithoutFacultyInput = {
    courseId?: StringFieldUpdateOperationsInput | string
  }

  export type OfferedCourseClassScheduleUpdateWithoutFacultyInput = {
    id?: StringFieldUpdateOperationsInput | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    dayOfWeek?: EnumWeekDaysFieldUpdateOperationsInput | $Enums.WeekDays
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    offeredCourseSection?: OfferedCourseSectionUpdateOneRequiredWithoutOfferedCourseClassSchedulesNestedInput
    semesterRegistration?: SemesterRegistrationUpdateOneRequiredWithoutOfferedCourseClassSchedulesNestedInput
    room?: RoomUpdateOneRequiredWithoutOfferedCourseClassSchedulesNestedInput
  }

  export type OfferedCourseClassScheduleUncheckedUpdateWithoutFacultyInput = {
    id?: StringFieldUpdateOperationsInput | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    dayOfWeek?: EnumWeekDaysFieldUpdateOperationsInput | $Enums.WeekDays
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    offeredCourseSectionId?: StringFieldUpdateOperationsInput | string
    semesterRegistrationId?: StringFieldUpdateOperationsInput | string
    roomId?: StringFieldUpdateOperationsInput | string
  }

  export type OfferedCourseClassScheduleUncheckedUpdateManyWithoutFacultyInput = {
    id?: StringFieldUpdateOperationsInput | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    dayOfWeek?: EnumWeekDaysFieldUpdateOperationsInput | $Enums.WeekDays
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    offeredCourseSectionId?: StringFieldUpdateOperationsInput | string
    semesterRegistrationId?: StringFieldUpdateOperationsInput | string
    roomId?: StringFieldUpdateOperationsInput | string
  }

  export type RoomCreateManyBuildingInput = {
    id?: string
    roomNumber: string
    floor: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RoomUpdateWithoutBuildingInput = {
    id?: StringFieldUpdateOperationsInput | string
    roomNumber?: StringFieldUpdateOperationsInput | string
    floor?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    offeredCourseClassSchedules?: OfferedCourseClassScheduleUpdateManyWithoutRoomNestedInput
  }

  export type RoomUncheckedUpdateWithoutBuildingInput = {
    id?: StringFieldUpdateOperationsInput | string
    roomNumber?: StringFieldUpdateOperationsInput | string
    floor?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    offeredCourseClassSchedules?: OfferedCourseClassScheduleUncheckedUpdateManyWithoutRoomNestedInput
  }

  export type RoomUncheckedUpdateManyWithoutBuildingInput = {
    id?: StringFieldUpdateOperationsInput | string
    roomNumber?: StringFieldUpdateOperationsInput | string
    floor?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OfferedCourseClassScheduleCreateManyRoomInput = {
    id?: string
    startTime: string
    endTime: string
    dayOfWeek?: $Enums.WeekDays
    createdAt?: Date | string
    updatedAt?: Date | string
    offeredCourseSectionId: string
    semesterRegistrationId: string
    facultyId: string
  }

  export type OfferedCourseClassScheduleUpdateWithoutRoomInput = {
    id?: StringFieldUpdateOperationsInput | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    dayOfWeek?: EnumWeekDaysFieldUpdateOperationsInput | $Enums.WeekDays
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    offeredCourseSection?: OfferedCourseSectionUpdateOneRequiredWithoutOfferedCourseClassSchedulesNestedInput
    semesterRegistration?: SemesterRegistrationUpdateOneRequiredWithoutOfferedCourseClassSchedulesNestedInput
    faculty?: FacultyUpdateOneRequiredWithoutOfferedCourseClassSchedulesNestedInput
  }

  export type OfferedCourseClassScheduleUncheckedUpdateWithoutRoomInput = {
    id?: StringFieldUpdateOperationsInput | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    dayOfWeek?: EnumWeekDaysFieldUpdateOperationsInput | $Enums.WeekDays
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    offeredCourseSectionId?: StringFieldUpdateOperationsInput | string
    semesterRegistrationId?: StringFieldUpdateOperationsInput | string
    facultyId?: StringFieldUpdateOperationsInput | string
  }

  export type OfferedCourseClassScheduleUncheckedUpdateManyWithoutRoomInput = {
    id?: StringFieldUpdateOperationsInput | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    dayOfWeek?: EnumWeekDaysFieldUpdateOperationsInput | $Enums.WeekDays
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    offeredCourseSectionId?: StringFieldUpdateOperationsInput | string
    semesterRegistrationId?: StringFieldUpdateOperationsInput | string
    facultyId?: StringFieldUpdateOperationsInput | string
  }

  export type CourseToPreRequisiteCreateManyCourseInput = {
    preRequisiteId: string
  }

  export type CourseToPreRequisiteCreateManyPreRequisiteInput = {
    courseId: string
  }

  export type CourseFacultyCreateManyCourseInput = {
    facultyId: string
  }

  export type OfferedCourseCreateManyCourseInput = {
    id?: string
    academicDepartmentId: string
    semesterRegistrationId: string
  }

  export type StudentEnrolledCourseCreateManyCourseInput = {
    id?: string
    grade?: string | null
    point?: number | null
    totalMarks?: number | null
    status?: $Enums.StudentEnrolledCourseStatus | null
    createdAt?: Date | string
    updatedAt?: Date | string
    studentId: string
    academicSemesterId: string
  }

  export type CourseToPreRequisiteUpdateWithoutCourseInput = {
    preRequisite?: CourseUpdateOneRequiredWithoutPreRequisiteForNestedInput
  }

  export type CourseToPreRequisiteUncheckedUpdateWithoutCourseInput = {
    preRequisiteId?: StringFieldUpdateOperationsInput | string
  }

  export type CourseToPreRequisiteUncheckedUpdateManyWithoutCourseInput = {
    preRequisiteId?: StringFieldUpdateOperationsInput | string
  }

  export type CourseToPreRequisiteUpdateWithoutPreRequisiteInput = {
    course?: CourseUpdateOneRequiredWithoutPreRequisiteNestedInput
  }

  export type CourseToPreRequisiteUncheckedUpdateWithoutPreRequisiteInput = {
    courseId?: StringFieldUpdateOperationsInput | string
  }

  export type CourseToPreRequisiteUncheckedUpdateManyWithoutPreRequisiteInput = {
    courseId?: StringFieldUpdateOperationsInput | string
  }

  export type CourseFacultyUpdateWithoutCourseInput = {
    faculty?: FacultyUpdateOneRequiredWithoutCoursesNestedInput
  }

  export type CourseFacultyUncheckedUpdateWithoutCourseInput = {
    facultyId?: StringFieldUpdateOperationsInput | string
  }

  export type CourseFacultyUncheckedUpdateManyWithoutCourseInput = {
    facultyId?: StringFieldUpdateOperationsInput | string
  }

  export type OfferedCourseUpdateWithoutCourseInput = {
    id?: StringFieldUpdateOperationsInput | string
    academicDepartment?: AcademicDepartmentUpdateOneRequiredWithoutOfferedCoursesNestedInput
    semesterRegistration?: SemesterRegistrationUpdateOneRequiredWithoutOfferedCoursesNestedInput
    offeredCourseSections?: OfferedCourseSectionUpdateManyWithoutOfferedCourseNestedInput
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseUpdateManyWithoutOfferedCourseNestedInput
  }

  export type OfferedCourseUncheckedUpdateWithoutCourseInput = {
    id?: StringFieldUpdateOperationsInput | string
    academicDepartmentId?: StringFieldUpdateOperationsInput | string
    semesterRegistrationId?: StringFieldUpdateOperationsInput | string
    offeredCourseSections?: OfferedCourseSectionUncheckedUpdateManyWithoutOfferedCourseNestedInput
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseUncheckedUpdateManyWithoutOfferedCourseNestedInput
  }

  export type OfferedCourseUncheckedUpdateManyWithoutCourseInput = {
    id?: StringFieldUpdateOperationsInput | string
    academicDepartmentId?: StringFieldUpdateOperationsInput | string
    semesterRegistrationId?: StringFieldUpdateOperationsInput | string
  }

  export type StudentEnrolledCourseUpdateWithoutCourseInput = {
    id?: StringFieldUpdateOperationsInput | string
    grade?: NullableStringFieldUpdateOperationsInput | string | null
    point?: NullableFloatFieldUpdateOperationsInput | number | null
    totalMarks?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableEnumStudentEnrolledCourseStatusFieldUpdateOperationsInput | $Enums.StudentEnrolledCourseStatus | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUpdateOneRequiredWithoutStudentEnrolledCoursesNestedInput
    academicSemester?: AcademicSemesterUpdateOneRequiredWithoutStudentEnrolledCoursesNestedInput
    studentEnrolledCourseMarks?: StudentEnrolledCourseMarkUpdateManyWithoutStudentEnrolledCourseNestedInput
  }

  export type StudentEnrolledCourseUncheckedUpdateWithoutCourseInput = {
    id?: StringFieldUpdateOperationsInput | string
    grade?: NullableStringFieldUpdateOperationsInput | string | null
    point?: NullableFloatFieldUpdateOperationsInput | number | null
    totalMarks?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableEnumStudentEnrolledCourseStatusFieldUpdateOperationsInput | $Enums.StudentEnrolledCourseStatus | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    studentId?: StringFieldUpdateOperationsInput | string
    academicSemesterId?: StringFieldUpdateOperationsInput | string
    studentEnrolledCourseMarks?: StudentEnrolledCourseMarkUncheckedUpdateManyWithoutStudentEnrolledCourseNestedInput
  }

  export type StudentEnrolledCourseUncheckedUpdateManyWithoutCourseInput = {
    id?: StringFieldUpdateOperationsInput | string
    grade?: NullableStringFieldUpdateOperationsInput | string | null
    point?: NullableFloatFieldUpdateOperationsInput | number | null
    totalMarks?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableEnumStudentEnrolledCourseStatusFieldUpdateOperationsInput | $Enums.StudentEnrolledCourseStatus | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    studentId?: StringFieldUpdateOperationsInput | string
    academicSemesterId?: StringFieldUpdateOperationsInput | string
  }

  export type OfferedCourseCreateManySemesterRegistrationInput = {
    id?: string
    academicDepartmentId: string
    courseId: string
  }

  export type OfferedCourseSectionCreateManySemesterRegistrationInput = {
    id?: string
    title: string
    maxCapacity?: number
    currentlyEnrolledStudent?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    offeredCourseId: string
  }

  export type OfferedCourseClassScheduleCreateManySemesterRegistrationInput = {
    id?: string
    startTime: string
    endTime: string
    dayOfWeek?: $Enums.WeekDays
    createdAt?: Date | string
    updatedAt?: Date | string
    offeredCourseSectionId: string
    roomId: string
    facultyId: string
  }

  export type StudentSemesterRegistrationCreateManySemesterRegistrationInput = {
    id?: string
    isConfirmed?: boolean | null
    totalCreditsTaken?: number | null
    paymentRecipt?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    studentId: string
  }

  export type StudentSemesterRegistrationCourseCreateManySemesterRegistrationInput = {
    studentId: string
    offeredCourseId: string
    offeredCourseSectionId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OfferedCourseUpdateWithoutSemesterRegistrationInput = {
    id?: StringFieldUpdateOperationsInput | string
    academicDepartment?: AcademicDepartmentUpdateOneRequiredWithoutOfferedCoursesNestedInput
    course?: CourseUpdateOneRequiredWithoutOfferedCoursesNestedInput
    offeredCourseSections?: OfferedCourseSectionUpdateManyWithoutOfferedCourseNestedInput
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseUpdateManyWithoutOfferedCourseNestedInput
  }

  export type OfferedCourseUncheckedUpdateWithoutSemesterRegistrationInput = {
    id?: StringFieldUpdateOperationsInput | string
    academicDepartmentId?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    offeredCourseSections?: OfferedCourseSectionUncheckedUpdateManyWithoutOfferedCourseNestedInput
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseUncheckedUpdateManyWithoutOfferedCourseNestedInput
  }

  export type OfferedCourseUncheckedUpdateManyWithoutSemesterRegistrationInput = {
    id?: StringFieldUpdateOperationsInput | string
    academicDepartmentId?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
  }

  export type OfferedCourseSectionUpdateWithoutSemesterRegistrationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    maxCapacity?: IntFieldUpdateOperationsInput | number
    currentlyEnrolledStudent?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    offeredCourse?: OfferedCourseUpdateOneRequiredWithoutOfferedCourseSectionsNestedInput
    offeredCourseClassSchedules?: OfferedCourseClassScheduleUpdateManyWithoutOfferedCourseSectionNestedInput
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseUpdateManyWithoutOfferedCourseSectionNestedInput
  }

  export type OfferedCourseSectionUncheckedUpdateWithoutSemesterRegistrationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    maxCapacity?: IntFieldUpdateOperationsInput | number
    currentlyEnrolledStudent?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    offeredCourseId?: StringFieldUpdateOperationsInput | string
    offeredCourseClassSchedules?: OfferedCourseClassScheduleUncheckedUpdateManyWithoutOfferedCourseSectionNestedInput
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseUncheckedUpdateManyWithoutOfferedCourseSectionNestedInput
  }

  export type OfferedCourseSectionUncheckedUpdateManyWithoutSemesterRegistrationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    maxCapacity?: IntFieldUpdateOperationsInput | number
    currentlyEnrolledStudent?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    offeredCourseId?: StringFieldUpdateOperationsInput | string
  }

  export type OfferedCourseClassScheduleUpdateWithoutSemesterRegistrationInput = {
    id?: StringFieldUpdateOperationsInput | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    dayOfWeek?: EnumWeekDaysFieldUpdateOperationsInput | $Enums.WeekDays
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    offeredCourseSection?: OfferedCourseSectionUpdateOneRequiredWithoutOfferedCourseClassSchedulesNestedInput
    room?: RoomUpdateOneRequiredWithoutOfferedCourseClassSchedulesNestedInput
    faculty?: FacultyUpdateOneRequiredWithoutOfferedCourseClassSchedulesNestedInput
  }

  export type OfferedCourseClassScheduleUncheckedUpdateWithoutSemesterRegistrationInput = {
    id?: StringFieldUpdateOperationsInput | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    dayOfWeek?: EnumWeekDaysFieldUpdateOperationsInput | $Enums.WeekDays
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    offeredCourseSectionId?: StringFieldUpdateOperationsInput | string
    roomId?: StringFieldUpdateOperationsInput | string
    facultyId?: StringFieldUpdateOperationsInput | string
  }

  export type OfferedCourseClassScheduleUncheckedUpdateManyWithoutSemesterRegistrationInput = {
    id?: StringFieldUpdateOperationsInput | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    dayOfWeek?: EnumWeekDaysFieldUpdateOperationsInput | $Enums.WeekDays
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    offeredCourseSectionId?: StringFieldUpdateOperationsInput | string
    roomId?: StringFieldUpdateOperationsInput | string
    facultyId?: StringFieldUpdateOperationsInput | string
  }

  export type StudentSemesterRegistrationUpdateWithoutSemesterRegistrationInput = {
    id?: StringFieldUpdateOperationsInput | string
    isConfirmed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    totalCreditsTaken?: NullableIntFieldUpdateOperationsInput | number | null
    paymentRecipt?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUpdateOneRequiredWithoutStudentSemesterRegistrationsNestedInput
  }

  export type StudentSemesterRegistrationUncheckedUpdateWithoutSemesterRegistrationInput = {
    id?: StringFieldUpdateOperationsInput | string
    isConfirmed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    totalCreditsTaken?: NullableIntFieldUpdateOperationsInput | number | null
    paymentRecipt?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    studentId?: StringFieldUpdateOperationsInput | string
  }

  export type StudentSemesterRegistrationUncheckedUpdateManyWithoutSemesterRegistrationInput = {
    id?: StringFieldUpdateOperationsInput | string
    isConfirmed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    totalCreditsTaken?: NullableIntFieldUpdateOperationsInput | number | null
    paymentRecipt?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    studentId?: StringFieldUpdateOperationsInput | string
  }

  export type StudentSemesterRegistrationCourseUpdateWithoutSemesterRegistrationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUpdateOneRequiredWithoutStudentSemesterRegistrationCoursesNestedInput
    offeredCourse?: OfferedCourseUpdateOneRequiredWithoutStudentSemesterRegistrationCoursesNestedInput
    offeredCourseSection?: OfferedCourseSectionUpdateOneRequiredWithoutStudentSemesterRegistrationCoursesNestedInput
  }

  export type StudentSemesterRegistrationCourseUncheckedUpdateWithoutSemesterRegistrationInput = {
    studentId?: StringFieldUpdateOperationsInput | string
    offeredCourseId?: StringFieldUpdateOperationsInput | string
    offeredCourseSectionId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentSemesterRegistrationCourseUncheckedUpdateManyWithoutSemesterRegistrationInput = {
    studentId?: StringFieldUpdateOperationsInput | string
    offeredCourseId?: StringFieldUpdateOperationsInput | string
    offeredCourseSectionId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OfferedCourseSectionCreateManyOfferedCourseInput = {
    id?: string
    title: string
    maxCapacity?: number
    currentlyEnrolledStudent?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    semesterRegistrationId: string
  }

  export type StudentSemesterRegistrationCourseCreateManyOfferedCourseInput = {
    semesterRegistrationId: string
    studentId: string
    offeredCourseSectionId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OfferedCourseSectionUpdateWithoutOfferedCourseInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    maxCapacity?: IntFieldUpdateOperationsInput | number
    currentlyEnrolledStudent?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    semesterRegistration?: SemesterRegistrationUpdateOneRequiredWithoutOfferedCourseSectionsNestedInput
    offeredCourseClassSchedules?: OfferedCourseClassScheduleUpdateManyWithoutOfferedCourseSectionNestedInput
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseUpdateManyWithoutOfferedCourseSectionNestedInput
  }

  export type OfferedCourseSectionUncheckedUpdateWithoutOfferedCourseInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    maxCapacity?: IntFieldUpdateOperationsInput | number
    currentlyEnrolledStudent?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    semesterRegistrationId?: StringFieldUpdateOperationsInput | string
    offeredCourseClassSchedules?: OfferedCourseClassScheduleUncheckedUpdateManyWithoutOfferedCourseSectionNestedInput
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseUncheckedUpdateManyWithoutOfferedCourseSectionNestedInput
  }

  export type OfferedCourseSectionUncheckedUpdateManyWithoutOfferedCourseInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    maxCapacity?: IntFieldUpdateOperationsInput | number
    currentlyEnrolledStudent?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    semesterRegistrationId?: StringFieldUpdateOperationsInput | string
  }

  export type StudentSemesterRegistrationCourseUpdateWithoutOfferedCourseInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    semesterRegistration?: SemesterRegistrationUpdateOneRequiredWithoutStudentSemesterRegistrationCoursesNestedInput
    student?: StudentUpdateOneRequiredWithoutStudentSemesterRegistrationCoursesNestedInput
    offeredCourseSection?: OfferedCourseSectionUpdateOneRequiredWithoutStudentSemesterRegistrationCoursesNestedInput
  }

  export type StudentSemesterRegistrationCourseUncheckedUpdateWithoutOfferedCourseInput = {
    semesterRegistrationId?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    offeredCourseSectionId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentSemesterRegistrationCourseUncheckedUpdateManyWithoutOfferedCourseInput = {
    semesterRegistrationId?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    offeredCourseSectionId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OfferedCourseClassScheduleCreateManyOfferedCourseSectionInput = {
    id?: string
    startTime: string
    endTime: string
    dayOfWeek?: $Enums.WeekDays
    createdAt?: Date | string
    updatedAt?: Date | string
    semesterRegistrationId: string
    roomId: string
    facultyId: string
  }

  export type StudentSemesterRegistrationCourseCreateManyOfferedCourseSectionInput = {
    semesterRegistrationId: string
    studentId: string
    offeredCourseId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OfferedCourseClassScheduleUpdateWithoutOfferedCourseSectionInput = {
    id?: StringFieldUpdateOperationsInput | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    dayOfWeek?: EnumWeekDaysFieldUpdateOperationsInput | $Enums.WeekDays
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    semesterRegistration?: SemesterRegistrationUpdateOneRequiredWithoutOfferedCourseClassSchedulesNestedInput
    room?: RoomUpdateOneRequiredWithoutOfferedCourseClassSchedulesNestedInput
    faculty?: FacultyUpdateOneRequiredWithoutOfferedCourseClassSchedulesNestedInput
  }

  export type OfferedCourseClassScheduleUncheckedUpdateWithoutOfferedCourseSectionInput = {
    id?: StringFieldUpdateOperationsInput | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    dayOfWeek?: EnumWeekDaysFieldUpdateOperationsInput | $Enums.WeekDays
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    semesterRegistrationId?: StringFieldUpdateOperationsInput | string
    roomId?: StringFieldUpdateOperationsInput | string
    facultyId?: StringFieldUpdateOperationsInput | string
  }

  export type OfferedCourseClassScheduleUncheckedUpdateManyWithoutOfferedCourseSectionInput = {
    id?: StringFieldUpdateOperationsInput | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    dayOfWeek?: EnumWeekDaysFieldUpdateOperationsInput | $Enums.WeekDays
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    semesterRegistrationId?: StringFieldUpdateOperationsInput | string
    roomId?: StringFieldUpdateOperationsInput | string
    facultyId?: StringFieldUpdateOperationsInput | string
  }

  export type StudentSemesterRegistrationCourseUpdateWithoutOfferedCourseSectionInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    semesterRegistration?: SemesterRegistrationUpdateOneRequiredWithoutStudentSemesterRegistrationCoursesNestedInput
    student?: StudentUpdateOneRequiredWithoutStudentSemesterRegistrationCoursesNestedInput
    offeredCourse?: OfferedCourseUpdateOneRequiredWithoutStudentSemesterRegistrationCoursesNestedInput
  }

  export type StudentSemesterRegistrationCourseUncheckedUpdateWithoutOfferedCourseSectionInput = {
    semesterRegistrationId?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    offeredCourseId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentSemesterRegistrationCourseUncheckedUpdateManyWithoutOfferedCourseSectionInput = {
    semesterRegistrationId?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    offeredCourseId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentEnrolledCourseMarkCreateManyStudentEnrolledCourseInput = {
    id?: string
    examType?: $Enums.ExamType | null
    createdAt?: Date | string
    updatedAt?: Date | string
    studentId: string
    academicSemesterId: string
    exam1?: number
    exam2?: number
    exam3?: number
    exam4?: number
    exam5?: number
    exam6?: number
    finalExam?: number
    totalMarks?: number
    grade?: number
  }

  export type StudentEnrolledCourseMarkUpdateWithoutStudentEnrolledCourseInput = {
    id?: StringFieldUpdateOperationsInput | string
    examType?: NullableEnumExamTypeFieldUpdateOperationsInput | $Enums.ExamType | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    exam1?: FloatFieldUpdateOperationsInput | number
    exam2?: FloatFieldUpdateOperationsInput | number
    exam3?: FloatFieldUpdateOperationsInput | number
    exam4?: FloatFieldUpdateOperationsInput | number
    exam5?: FloatFieldUpdateOperationsInput | number
    exam6?: FloatFieldUpdateOperationsInput | number
    finalExam?: FloatFieldUpdateOperationsInput | number
    totalMarks?: FloatFieldUpdateOperationsInput | number
    grade?: FloatFieldUpdateOperationsInput | number
    student?: StudentUpdateOneRequiredWithoutStudentEnrolledCourseMarksNestedInput
    academicSemester?: AcademicSemesterUpdateOneRequiredWithoutStudentEnrolledCourseMarksNestedInput
  }

  export type StudentEnrolledCourseMarkUncheckedUpdateWithoutStudentEnrolledCourseInput = {
    id?: StringFieldUpdateOperationsInput | string
    examType?: NullableEnumExamTypeFieldUpdateOperationsInput | $Enums.ExamType | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    studentId?: StringFieldUpdateOperationsInput | string
    academicSemesterId?: StringFieldUpdateOperationsInput | string
    exam1?: FloatFieldUpdateOperationsInput | number
    exam2?: FloatFieldUpdateOperationsInput | number
    exam3?: FloatFieldUpdateOperationsInput | number
    exam4?: FloatFieldUpdateOperationsInput | number
    exam5?: FloatFieldUpdateOperationsInput | number
    exam6?: FloatFieldUpdateOperationsInput | number
    finalExam?: FloatFieldUpdateOperationsInput | number
    totalMarks?: FloatFieldUpdateOperationsInput | number
    grade?: FloatFieldUpdateOperationsInput | number
  }

  export type StudentEnrolledCourseMarkUncheckedUpdateManyWithoutStudentEnrolledCourseInput = {
    id?: StringFieldUpdateOperationsInput | string
    examType?: NullableEnumExamTypeFieldUpdateOperationsInput | $Enums.ExamType | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    studentId?: StringFieldUpdateOperationsInput | string
    academicSemesterId?: StringFieldUpdateOperationsInput | string
    exam1?: FloatFieldUpdateOperationsInput | number
    exam2?: FloatFieldUpdateOperationsInput | number
    exam3?: FloatFieldUpdateOperationsInput | number
    exam4?: FloatFieldUpdateOperationsInput | number
    exam5?: FloatFieldUpdateOperationsInput | number
    exam6?: FloatFieldUpdateOperationsInput | number
    finalExam?: FloatFieldUpdateOperationsInput | number
    totalMarks?: FloatFieldUpdateOperationsInput | number
    grade?: FloatFieldUpdateOperationsInput | number
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}